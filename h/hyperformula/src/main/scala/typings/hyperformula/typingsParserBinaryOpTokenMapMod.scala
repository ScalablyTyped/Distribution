package typings.hyperformula

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object typingsParserBinaryOpTokenMapMod {
  
  object binaryOpTokenMap {
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap")
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap.CONCATENATE_OP")
    @js.native
    def CONCATENATE_OP: String = js.native
    inline def CONCATENATE_OP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CONCATENATE_OP")(x.asInstanceOf[js.Any])
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap.DIV_OP")
    @js.native
    def DIV_OP: String = js.native
    inline def DIV_OP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DIV_OP")(x.asInstanceOf[js.Any])
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap.EQUALS_OP")
    @js.native
    def EQUALS_OP: String = js.native
    inline def EQUALS_OP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EQUALS_OP")(x.asInstanceOf[js.Any])
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap.GREATER_THAN_OP")
    @js.native
    def GREATER_THAN_OP: String = js.native
    inline def GREATER_THAN_OP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("GREATER_THAN_OP")(x.asInstanceOf[js.Any])
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap.GREATER_THAN_OR_EQUAL_OP")
    @js.native
    def GREATER_THAN_OR_EQUAL_OP: String = js.native
    inline def GREATER_THAN_OR_EQUAL_OP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("GREATER_THAN_OR_EQUAL_OP")(x.asInstanceOf[js.Any])
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap.LESS_THAN_OP")
    @js.native
    def LESS_THAN_OP: String = js.native
    inline def LESS_THAN_OP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("LESS_THAN_OP")(x.asInstanceOf[js.Any])
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap.LESS_THAN_OR_EQUAL_OP")
    @js.native
    def LESS_THAN_OR_EQUAL_OP: String = js.native
    inline def LESS_THAN_OR_EQUAL_OP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("LESS_THAN_OR_EQUAL_OP")(x.asInstanceOf[js.Any])
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap.MINUS_OP")
    @js.native
    def MINUS_OP: String = js.native
    inline def MINUS_OP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MINUS_OP")(x.asInstanceOf[js.Any])
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap.NOT_EQUAL_OP")
    @js.native
    def NOT_EQUAL_OP: String = js.native
    inline def NOT_EQUAL_OP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NOT_EQUAL_OP")(x.asInstanceOf[js.Any])
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap.PLUS_OP")
    @js.native
    def PLUS_OP: String = js.native
    inline def PLUS_OP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PLUS_OP")(x.asInstanceOf[js.Any])
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap.POWER_OP")
    @js.native
    def POWER_OP: String = js.native
    inline def POWER_OP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("POWER_OP")(x.asInstanceOf[js.Any])
    
    @JSImport("hyperformula/typings/parser/binaryOpTokenMap", "binaryOpTokenMap.TIMES_OP")
    @js.native
    def TIMES_OP: String = js.native
    inline def TIMES_OP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TIMES_OP")(x.asInstanceOf[js.Any])
  }
}
