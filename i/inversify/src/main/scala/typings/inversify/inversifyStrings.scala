package typings.inversify

import typings.inversify.dtsInterfacesInterfacesMod.interfaces.BindingScope
import typings.inversify.dtsInterfacesInterfacesMod.interfaces.BindingType
import typings.inversify.dtsInterfacesInterfacesMod.interfaces.TargetType
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

object inversifyStrings {
  @js.native
  sealed trait `Ambiguous match found for serviceIdentifierColon` extends js.Object
  
  @js.native
  sealed trait `Cannot apply @injectable decorator multiple timesDot` extends js.Object
  
  @js.native
  sealed trait `Cannot apply @postConstruct decorator multiple times in the same class` extends js.Object
  
  @js.native
  sealed trait `Circular dependency foundColon` extends js.Object
  
  @js.native
  sealed trait ClassProperty extends TargetType
  
  @js.native
  sealed trait ConstantValue extends BindingType
  
  @js.native
  sealed trait Constructor extends BindingType
  
  @js.native
  sealed trait ConstructorArgument extends TargetType
  
  @js.native
  sealed trait `Could not unbind serviceIdentifierColon` extends js.Object
  
  @js.native
  sealed trait DynamicValue extends BindingType
  
  @js.native
  sealed trait Factory extends BindingType
  
  @js.native
  sealed trait Function extends BindingType
  
  @js.native
  sealed trait Instance extends BindingType
  
  @js.native
  sealed trait Invalid extends BindingType
  
  @js.native
  sealed trait `Invalid binding typeColon` extends js.Object
  
  @js.native
  sealed trait `Invalid return type in middlewareDot Middleware must returnExclamationmark` extends js.Object
  
  @js.native
  sealed trait `Key Not Found` extends js.Object
  
  @js.native
  sealed trait `Maximum call stack size exceeded` extends js.Object
  
  @js.native
  sealed trait `Metadata key was used more than once in a parameterColon` extends js.Object
  
  @js.native
  sealed trait `Missing required @inject or @multiInject annotation inColon` extends js.Object
  
  @js.native
  sealed trait `Missing required @injectable annotation inColon` extends js.Object
  
  @js.native
  sealed trait `NULL argument` extends js.Object
  
  @js.native
  sealed trait `No matching bindings found for serviceIdentifierColon` extends js.Object
  
  @js.native
  sealed trait `No snapshot available to restoreDot` extends js.Object
  
  @js.native
  sealed trait Provider extends BindingType
  
  @js.native
  sealed trait Request extends BindingScope
  
  @js.native
  sealed trait Singleton extends BindingScope
  
  @js.native
  sealed trait `SorryComma this feature is not fully implemented yetDot` extends js.Object
  
  @js.native
  sealed trait Transient extends BindingScope
  
  @js.native
  sealed trait `Value provided to function binding must be a functionExclamationmark` extends js.Object
  
  @js.native
  sealed trait Variable extends TargetType
  
  @js.native
  sealed trait designColonparamtypes extends js.Object
  
  @js.native
  sealed trait inject extends js.Object
  
  @js.native
  sealed trait inversifyColonparamtypes extends js.Object
  
  @js.native
  sealed trait inversifyColontagged extends js.Object
  
  @js.native
  sealed trait inversifyColontagged_props extends js.Object
  
  @js.native
  sealed trait multi_inject extends js.Object
  
  @js.native
  sealed trait name extends js.Object
  
  @js.native
  sealed trait named extends js.Object
  
  @js.native
  sealed trait optional extends js.Object
  
  @js.native
  sealed trait post_construct extends js.Object
  
  @js.native
  sealed trait unmanaged extends js.Object
  
  @scala.inline
  def `Ambiguous match found for serviceIdentifierColon`: `Ambiguous match found for serviceIdentifierColon` = "Ambiguous match found for serviceIdentifier:".asInstanceOf[`Ambiguous match found for serviceIdentifierColon`]
  @scala.inline
  def `Cannot apply @injectable decorator multiple timesDot`: `Cannot apply @injectable decorator multiple timesDot` = "Cannot apply @injectable decorator multiple times.".asInstanceOf[`Cannot apply @injectable decorator multiple timesDot`]
  @scala.inline
  def `Cannot apply @postConstruct decorator multiple times in the same class`: `Cannot apply @postConstruct decorator multiple times in the same class` = "Cannot apply @postConstruct decorator multiple times in the same class".asInstanceOf[`Cannot apply @postConstruct decorator multiple times in the same class`]
  @scala.inline
  def `Circular dependency foundColon`: `Circular dependency foundColon` = "Circular dependency found:".asInstanceOf[`Circular dependency foundColon`]
  @scala.inline
  def ClassProperty: ClassProperty = "ClassProperty".asInstanceOf[ClassProperty]
  @scala.inline
  def ConstantValue: ConstantValue = "ConstantValue".asInstanceOf[ConstantValue]
  @scala.inline
  def Constructor: Constructor = "Constructor".asInstanceOf[Constructor]
  @scala.inline
  def ConstructorArgument: ConstructorArgument = "ConstructorArgument".asInstanceOf[ConstructorArgument]
  @scala.inline
  def `Could not unbind serviceIdentifierColon`: `Could not unbind serviceIdentifierColon` = "Could not unbind serviceIdentifier:".asInstanceOf[`Could not unbind serviceIdentifierColon`]
  @scala.inline
  def DynamicValue: DynamicValue = "DynamicValue".asInstanceOf[DynamicValue]
  @scala.inline
  def Factory: Factory = "Factory".asInstanceOf[Factory]
  @scala.inline
  def Function: Function = "Function".asInstanceOf[Function]
  @scala.inline
  def Instance: Instance = "Instance".asInstanceOf[Instance]
  @scala.inline
  def Invalid: Invalid = "Invalid".asInstanceOf[Invalid]
  @scala.inline
  def `Invalid binding typeColon`: `Invalid binding typeColon` = "Invalid binding type:".asInstanceOf[`Invalid binding typeColon`]
  @scala.inline
  def `Invalid return type in middlewareDot Middleware must returnExclamationmark`: `Invalid return type in middlewareDot Middleware must returnExclamationmark` = "Invalid return type in middleware. Middleware must return!".asInstanceOf[`Invalid return type in middlewareDot Middleware must returnExclamationmark`]
  @scala.inline
  def `Key Not Found`: `Key Not Found` = "Key Not Found".asInstanceOf[`Key Not Found`]
  @scala.inline
  def `Maximum call stack size exceeded`: `Maximum call stack size exceeded` = "Maximum call stack size exceeded".asInstanceOf[`Maximum call stack size exceeded`]
  @scala.inline
  def `Metadata key was used more than once in a parameterColon`: `Metadata key was used more than once in a parameterColon` = "Metadata key was used more than once in a parameter:".asInstanceOf[`Metadata key was used more than once in a parameterColon`]
  @scala.inline
  def `Missing required @inject or @multiInject annotation inColon`: `Missing required @inject or @multiInject annotation inColon` = "Missing required @inject or @multiInject annotation in:".asInstanceOf[`Missing required @inject or @multiInject annotation inColon`]
  @scala.inline
  def `Missing required @injectable annotation inColon`: `Missing required @injectable annotation inColon` = "Missing required @injectable annotation in:".asInstanceOf[`Missing required @injectable annotation inColon`]
  @scala.inline
  def `NULL argument`: `NULL argument` = "NULL argument".asInstanceOf[`NULL argument`]
  @scala.inline
  def `No matching bindings found for serviceIdentifierColon`: `No matching bindings found for serviceIdentifierColon` = "No matching bindings found for serviceIdentifier:".asInstanceOf[`No matching bindings found for serviceIdentifierColon`]
  @scala.inline
  def `No snapshot available to restoreDot`: `No snapshot available to restoreDot` = "No snapshot available to restore.".asInstanceOf[`No snapshot available to restoreDot`]
  @scala.inline
  def Provider: Provider = "Provider".asInstanceOf[Provider]
  @scala.inline
  def Request: Request = "Request".asInstanceOf[Request]
  @scala.inline
  def Singleton: Singleton = "Singleton".asInstanceOf[Singleton]
  @scala.inline
  def `SorryComma this feature is not fully implemented yetDot`: `SorryComma this feature is not fully implemented yetDot` = "Sorry, this feature is not fully implemented yet.".asInstanceOf[`SorryComma this feature is not fully implemented yetDot`]
  @scala.inline
  def Transient: Transient = "Transient".asInstanceOf[Transient]
  @scala.inline
  def `Value provided to function binding must be a functionExclamationmark`: `Value provided to function binding must be a functionExclamationmark` = "Value provided to function binding must be a function!".asInstanceOf[`Value provided to function binding must be a functionExclamationmark`]
  @scala.inline
  def Variable: Variable = "Variable".asInstanceOf[Variable]
  @scala.inline
  def designColonparamtypes: designColonparamtypes = "design:paramtypes".asInstanceOf[designColonparamtypes]
  @scala.inline
  def inject: inject = "inject".asInstanceOf[inject]
  @scala.inline
  def inversifyColonparamtypes: inversifyColonparamtypes = "inversify:paramtypes".asInstanceOf[inversifyColonparamtypes]
  @scala.inline
  def inversifyColontagged: inversifyColontagged = "inversify:tagged".asInstanceOf[inversifyColontagged]
  @scala.inline
  def inversifyColontagged_props: inversifyColontagged_props = "inversify:tagged_props".asInstanceOf[inversifyColontagged_props]
  @scala.inline
  def multi_inject: multi_inject = "multi_inject".asInstanceOf[multi_inject]
  @scala.inline
  def name: name = "name".asInstanceOf[name]
  @scala.inline
  def named: named = "named".asInstanceOf[named]
  @scala.inline
  def optional: optional = "optional".asInstanceOf[optional]
  @scala.inline
  def post_construct: post_construct = "post_construct".asInstanceOf[post_construct]
  @scala.inline
  def unmanaged: unmanaged = "unmanaged".asInstanceOf[unmanaged]
}

