package typings.intlMessageformat

import typings.intlMessageformat.anon.TypeofDateTimeFormat
import typings.intlMessageformat.anon.TypeofNumberFormat
import typings.intlMessageformat.anon.TypeofPluralRules
import typings.intlMessageformat.intlMessageformatNumbers.`0`
import typings.intlMessageformat.intlMessageformatNumbers.`1`
import typings.intlMessageformatParser.srcTypesMod.MessageFormatElement
import typings.std.ConstructorParameters
import typings.std.Date
import typings.std.Intl.DateTimeFormat
import typings.std.Intl.DateTimeFormatOptions
import typings.std.Intl.NumberFormat
import typings.std.Intl.NumberFormatOptions
import typings.std.Intl.PluralRules
import typings.std.Record
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object formattersMod {
  
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](els: js.Array[MessageFormatElement], locales: String, formatters: Formatters, formats: Formats): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: String,
    formatters: Formatters,
    formats: Formats,
    values: js.UndefOr[scala.Nothing],
    currentPluralValue: js.UndefOr[scala.Nothing],
    originalMessage: String
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: String,
    formatters: Formatters,
    formats: Formats,
    values: js.UndefOr[scala.Nothing],
    currentPluralValue: Double
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: String,
    formatters: Formatters,
    formats: Formats,
    values: js.UndefOr[scala.Nothing],
    currentPluralValue: Double,
    originalMessage: String
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: String,
    formatters: Formatters,
    formats: Formats,
    values: Record[
      String, 
      PrimitiveType | T | (FormatXMLElementFn[T, String | T | (js.Array[String | T])])
    ]
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: String,
    formatters: Formatters,
    formats: Formats,
    values: Record[
      String, 
      PrimitiveType | T | (FormatXMLElementFn[T, String | T | (js.Array[String | T])])
    ],
    currentPluralValue: js.UndefOr[scala.Nothing],
    originalMessage: String
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: String,
    formatters: Formatters,
    formats: Formats,
    values: Record[
      String, 
      PrimitiveType | T | (FormatXMLElementFn[T, String | T | (js.Array[String | T])])
    ],
    currentPluralValue: Double
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: String,
    formatters: Formatters,
    formats: Formats,
    values: Record[
      String, 
      PrimitiveType | T | (FormatXMLElementFn[T, String | T | (js.Array[String | T])])
    ],
    currentPluralValue: Double,
    originalMessage: String
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: js.Array[String],
    formatters: Formatters,
    formats: Formats
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: js.Array[String],
    formatters: Formatters,
    formats: Formats,
    values: js.UndefOr[scala.Nothing],
    currentPluralValue: js.UndefOr[scala.Nothing],
    originalMessage: String
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: js.Array[String],
    formatters: Formatters,
    formats: Formats,
    values: js.UndefOr[scala.Nothing],
    currentPluralValue: Double
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: js.Array[String],
    formatters: Formatters,
    formats: Formats,
    values: js.UndefOr[scala.Nothing],
    currentPluralValue: Double,
    originalMessage: String
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: js.Array[String],
    formatters: Formatters,
    formats: Formats,
    values: Record[
      String, 
      PrimitiveType | T | (FormatXMLElementFn[T, String | T | (js.Array[String | T])])
    ]
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: js.Array[String],
    formatters: Formatters,
    formats: Formats,
    values: Record[
      String, 
      PrimitiveType | T | (FormatXMLElementFn[T, String | T | (js.Array[String | T])])
    ],
    currentPluralValue: js.UndefOr[scala.Nothing],
    originalMessage: String
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: js.Array[String],
    formatters: Formatters,
    formats: Formats,
    values: Record[
      String, 
      PrimitiveType | T | (FormatXMLElementFn[T, String | T | (js.Array[String | T])])
    ],
    currentPluralValue: Double
  ): js.Array[MessageFormatPart[T]] = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "formatToParts")
  @js.native
  def formatToParts[T](
    els: js.Array[MessageFormatElement],
    locales: js.Array[String],
    formatters: Formatters,
    formats: Formats,
    values: Record[
      String, 
      PrimitiveType | T | (FormatXMLElementFn[T, String | T | (js.Array[String | T])])
    ],
    currentPluralValue: Double,
    originalMessage: String
  ): js.Array[MessageFormatPart[T]] = js.native
  
  @JSImport("intl-messageformat/lib/src/formatters", "isFormatXMLElementFn")
  @js.native
  def isFormatXMLElementFn[T](el: T): /* is intl-messageformat.intl-messageformat/lib/src/formatters.FormatXMLElementFn<T, string | T | std.Array<string | T>> */ Boolean = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "isFormatXMLElementFn")
  @js.native
  def isFormatXMLElementFn[T](el: FormatXMLElementFn[T, String | T | (js.Array[String | T])]): /* is intl-messageformat.intl-messageformat/lib/src/formatters.FormatXMLElementFn<T, string | T | std.Array<string | T>> */ Boolean = js.native
  @JSImport("intl-messageformat/lib/src/formatters", "isFormatXMLElementFn")
  @js.native
  def isFormatXMLElementFn[T](el: PrimitiveType): /* is intl-messageformat.intl-messageformat/lib/src/formatters.FormatXMLElementFn<T, string | T | std.Array<string | T>> */ Boolean = js.native
  
  type FormatXMLElementFn[T, R] = js.Function1[/* parts */ js.Array[String | T], R]
  
  @js.native
  trait Formats extends StObject {
    
    var date: Record[String, DateTimeFormatOptions] = js.native
    
    var number: Record[String, NumberFormatOptions] = js.native
    
    var time: Record[String, DateTimeFormatOptions] = js.native
  }
  object Formats {
    
    @scala.inline
    def apply(
      date: Record[String, DateTimeFormatOptions],
      number: Record[String, NumberFormatOptions],
      time: Record[String, DateTimeFormatOptions]
    ): Formats = {
      val __obj = js.Dynamic.literal(date = date.asInstanceOf[js.Any], number = number.asInstanceOf[js.Any], time = time.asInstanceOf[js.Any])
      __obj.asInstanceOf[Formats]
    }
    
    @scala.inline
    implicit class FormatsMutableBuilder[Self <: Formats] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setDate(value: Record[String, DateTimeFormatOptions]): Self = StObject.set(x, "date", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNumber(value: Record[String, NumberFormatOptions]): Self = StObject.set(x, "number", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTime(value: Record[String, DateTimeFormatOptions]): Self = StObject.set(x, "time", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait FormatterCache extends StObject {
    
    var dateTime: Record[String, DateTimeFormat] = js.native
    
    var number: Record[String, NumberFormat] = js.native
    
    var pluralRules: Record[String, PluralRules] = js.native
  }
  object FormatterCache {
    
    @scala.inline
    def apply(
      dateTime: Record[String, DateTimeFormat],
      number: Record[String, NumberFormat],
      pluralRules: Record[String, PluralRules]
    ): FormatterCache = {
      val __obj = js.Dynamic.literal(dateTime = dateTime.asInstanceOf[js.Any], number = number.asInstanceOf[js.Any], pluralRules = pluralRules.asInstanceOf[js.Any])
      __obj.asInstanceOf[FormatterCache]
    }
    
    @scala.inline
    implicit class FormatterCacheMutableBuilder[Self <: FormatterCache] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setDateTime(value: Record[String, DateTimeFormat]): Self = StObject.set(x, "dateTime", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNumber(value: Record[String, NumberFormat]): Self = StObject.set(x, "number", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPluralRules(value: Record[String, PluralRules]): Self = StObject.set(x, "pluralRules", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait Formatters extends StObject {
    
    def getDateTimeFormat(
      /* import warning: parser.TsParser#functionParam Dropping repeated marker of param args because its type ConstructorParameters<typeof Intl.DateTimeFormat> is not an array type */ args: ConstructorParameters[TypeofDateTimeFormat]
    ): DateTimeFormat = js.native
    
    def getNumberFormat(
      /* import warning: parser.TsParser#functionParam Dropping repeated marker of param args because its type ConstructorParameters<typeof Intl.NumberFormat> is not an array type */ args: ConstructorParameters[TypeofNumberFormat]
    ): NumberFormat = js.native
    
    def getPluralRules(
      /* import warning: parser.TsParser#functionParam Dropping repeated marker of param args because its type ConstructorParameters<typeof Intl.PluralRules> is not an array type */ args: ConstructorParameters[TypeofPluralRules]
    ): PluralRules = js.native
  }
  object Formatters {
    
    @scala.inline
    def apply(
      getDateTimeFormat: ConstructorParameters[TypeofDateTimeFormat] => DateTimeFormat,
      getNumberFormat: ConstructorParameters[TypeofNumberFormat] => NumberFormat,
      getPluralRules: ConstructorParameters[TypeofPluralRules] => PluralRules
    ): Formatters = {
      val __obj = js.Dynamic.literal(getDateTimeFormat = js.Any.fromFunction1(getDateTimeFormat), getNumberFormat = js.Any.fromFunction1(getNumberFormat), getPluralRules = js.Any.fromFunction1(getPluralRules))
      __obj.asInstanceOf[Formatters]
    }
    
    @scala.inline
    implicit class FormattersMutableBuilder[Self <: Formatters] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setGetDateTimeFormat(value: ConstructorParameters[TypeofDateTimeFormat] => DateTimeFormat): Self = StObject.set(x, "getDateTimeFormat", js.Any.fromFunction1(value))
      
      @scala.inline
      def setGetNumberFormat(value: ConstructorParameters[TypeofNumberFormat] => NumberFormat): Self = StObject.set(x, "getNumberFormat", js.Any.fromFunction1(value))
      
      @scala.inline
      def setGetPluralRules(value: ConstructorParameters[TypeofPluralRules] => PluralRules): Self = StObject.set(x, "getPluralRules", js.Any.fromFunction1(value))
    }
  }
  
  @js.native
  trait LiteralPart
    extends MessageFormatPart[js.Any] {
    
    var `type`: `0` = js.native
    
    var value: String = js.native
  }
  object LiteralPart {
    
    @scala.inline
    def apply(`type`: `0`, value: String): LiteralPart = {
      val __obj = js.Dynamic.literal(value = value.asInstanceOf[js.Any])
      __obj.updateDynamic("type")(`type`.asInstanceOf[js.Any])
      __obj.asInstanceOf[LiteralPart]
    }
    
    @scala.inline
    implicit class LiteralPartMutableBuilder[Self <: LiteralPart] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setType(value: `0`): Self = StObject.set(x, "type", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setValue(value: String): Self = StObject.set(x, "value", value.asInstanceOf[js.Any])
    }
  }
  
  /* Rewritten from type alias, can be one of: 
    - typings.intlMessageformat.formattersMod.LiteralPart
    - typings.intlMessageformat.formattersMod.ObjectPart[T]
  */
  trait MessageFormatPart[T] extends StObject
  object MessageFormatPart {
    
    @scala.inline
    def LiteralPart(`type`: `0`, value: String): typings.intlMessageformat.formattersMod.LiteralPart = {
      val __obj = js.Dynamic.literal(value = value.asInstanceOf[js.Any])
      __obj.updateDynamic("type")(`type`.asInstanceOf[js.Any])
      __obj.asInstanceOf[typings.intlMessageformat.formattersMod.LiteralPart]
    }
    
    @scala.inline
    def ObjectPart[T](`type`: `1`, value: T): typings.intlMessageformat.formattersMod.ObjectPart[T] = {
      val __obj = js.Dynamic.literal(value = value.asInstanceOf[js.Any])
      __obj.updateDynamic("type")(`type`.asInstanceOf[js.Any])
      __obj.asInstanceOf[typings.intlMessageformat.formattersMod.ObjectPart[T]]
    }
  }
  
  @js.native
  trait ObjectPart[T] extends MessageFormatPart[T] {
    
    var `type`: `1` = js.native
    
    var value: T = js.native
  }
  object ObjectPart {
    
    @scala.inline
    def apply[T](`type`: `1`, value: T): ObjectPart[T] = {
      val __obj = js.Dynamic.literal(value = value.asInstanceOf[js.Any])
      __obj.updateDynamic("type")(`type`.asInstanceOf[js.Any])
      __obj.asInstanceOf[ObjectPart[T]]
    }
    
    @scala.inline
    implicit class ObjectPartMutableBuilder[Self <: ObjectPart[_], T] (val x: Self with ObjectPart[T]) extends AnyVal {
      
      @scala.inline
      def setType(value: `1`): Self = StObject.set(x, "type", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setValue(value: T): Self = StObject.set(x, "value", value.asInstanceOf[js.Any])
    }
  }
  
  /* Rewritten from type alias, can be one of: 
    - typings.intlMessageformat.intlMessageformatNumbers.`0`
    - typings.intlMessageformat.intlMessageformatNumbers.`1`
  */
  trait PART_TYPE extends StObject
  object PART_TYPE {
    
    @scala.inline
    def literal: `0` = 0.asInstanceOf[`0`]
    
    @scala.inline
    def `object`: `1` = 1.asInstanceOf[`1`]
  }
  
  type PrimitiveType = js.UndefOr[String | Double | Boolean | Null | Date]
}
