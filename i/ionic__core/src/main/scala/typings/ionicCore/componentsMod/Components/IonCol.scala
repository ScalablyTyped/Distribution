package typings.ionicCore.componentsMod.Components

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait IonCol extends js.Object {
  /**
    * The amount to offset the column, in terms of how many columns it should shift to the end of the total available.
    */
  var offset: js.UndefOr[String] = js.undefined
  /**
    * The amount to offset the column for lg screens, in terms of how many columns it should shift to the end of the total available.
    */
  var offsetLg: js.UndefOr[String] = js.undefined
  /**
    * The amount to offset the column for md screens, in terms of how many columns it should shift to the end of the total available.
    */
  var offsetMd: js.UndefOr[String] = js.undefined
  /**
    * The amount to offset the column for sm screens, in terms of how many columns it should shift to the end of the total available.
    */
  var offsetSm: js.UndefOr[String] = js.undefined
  /**
    * The amount to offset the column for xl screens, in terms of how many columns it should shift to the end of the total available.
    */
  var offsetXl: js.UndefOr[String] = js.undefined
  /**
    * The amount to offset the column for xs screens, in terms of how many columns it should shift to the end of the total available.
    */
  var offsetXs: js.UndefOr[String] = js.undefined
  /**
    * The amount to pull the column, in terms of how many columns it should shift to the start of the total available.
    */
  var pull: js.UndefOr[String] = js.undefined
  /**
    * The amount to pull the column for lg screens, in terms of how many columns it should shift to the start of the total available.
    */
  var pullLg: js.UndefOr[String] = js.undefined
  /**
    * The amount to pull the column for md screens, in terms of how many columns it should shift to the start of the total available.
    */
  var pullMd: js.UndefOr[String] = js.undefined
  /**
    * The amount to pull the column for sm screens, in terms of how many columns it should shift to the start of the total available.
    */
  var pullSm: js.UndefOr[String] = js.undefined
  /**
    * The amount to pull the column for xl screens, in terms of how many columns it should shift to the start of the total available.
    */
  var pullXl: js.UndefOr[String] = js.undefined
  /**
    * The amount to pull the column for xs screens, in terms of how many columns it should shift to the start of the total available.
    */
  var pullXs: js.UndefOr[String] = js.undefined
  /**
    * The amount to push the column, in terms of how many columns it should shift to the end of the total available.
    */
  var push: js.UndefOr[String] = js.undefined
  /**
    * The amount to push the column for lg screens, in terms of how many columns it should shift to the end of the total available.
    */
  var pushLg: js.UndefOr[String] = js.undefined
  /**
    * The amount to push the column for md screens, in terms of how many columns it should shift to the end of the total available.
    */
  var pushMd: js.UndefOr[String] = js.undefined
  /**
    * The amount to push the column for sm screens, in terms of how many columns it should shift to the end of the total available.
    */
  var pushSm: js.UndefOr[String] = js.undefined
  /**
    * The amount to push the column for xl screens, in terms of how many columns it should shift to the end of the total available.
    */
  var pushXl: js.UndefOr[String] = js.undefined
  /**
    * The amount to push the column for xs screens, in terms of how many columns it should shift to the end of the total available.
    */
  var pushXs: js.UndefOr[String] = js.undefined
  /**
    * The size of the column, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
    */
  var size: js.UndefOr[String] = js.undefined
  /**
    * The size of the column for lg screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
    */
  var sizeLg: js.UndefOr[String] = js.undefined
  /**
    * The size of the column for md screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
    */
  var sizeMd: js.UndefOr[String] = js.undefined
  /**
    * The size of the column for sm screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
    */
  var sizeSm: js.UndefOr[String] = js.undefined
  /**
    * The size of the column for xl screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
    */
  var sizeXl: js.UndefOr[String] = js.undefined
  /**
    * The size of the column for xs screens, in terms of how many columns it should take up out of the total available. If `"auto"` is passed, the column will be the size of its content.
    */
  var sizeXs: js.UndefOr[String] = js.undefined
}

object IonCol {
  @scala.inline
  def apply(
    offset: String = null,
    offsetLg: String = null,
    offsetMd: String = null,
    offsetSm: String = null,
    offsetXl: String = null,
    offsetXs: String = null,
    pull: String = null,
    pullLg: String = null,
    pullMd: String = null,
    pullSm: String = null,
    pullXl: String = null,
    pullXs: String = null,
    push: String = null,
    pushLg: String = null,
    pushMd: String = null,
    pushSm: String = null,
    pushXl: String = null,
    pushXs: String = null,
    size: String = null,
    sizeLg: String = null,
    sizeMd: String = null,
    sizeSm: String = null,
    sizeXl: String = null,
    sizeXs: String = null
  ): IonCol = {
    val __obj = js.Dynamic.literal()
    if (offset != null) __obj.updateDynamic("offset")(offset.asInstanceOf[js.Any])
    if (offsetLg != null) __obj.updateDynamic("offsetLg")(offsetLg.asInstanceOf[js.Any])
    if (offsetMd != null) __obj.updateDynamic("offsetMd")(offsetMd.asInstanceOf[js.Any])
    if (offsetSm != null) __obj.updateDynamic("offsetSm")(offsetSm.asInstanceOf[js.Any])
    if (offsetXl != null) __obj.updateDynamic("offsetXl")(offsetXl.asInstanceOf[js.Any])
    if (offsetXs != null) __obj.updateDynamic("offsetXs")(offsetXs.asInstanceOf[js.Any])
    if (pull != null) __obj.updateDynamic("pull")(pull.asInstanceOf[js.Any])
    if (pullLg != null) __obj.updateDynamic("pullLg")(pullLg.asInstanceOf[js.Any])
    if (pullMd != null) __obj.updateDynamic("pullMd")(pullMd.asInstanceOf[js.Any])
    if (pullSm != null) __obj.updateDynamic("pullSm")(pullSm.asInstanceOf[js.Any])
    if (pullXl != null) __obj.updateDynamic("pullXl")(pullXl.asInstanceOf[js.Any])
    if (pullXs != null) __obj.updateDynamic("pullXs")(pullXs.asInstanceOf[js.Any])
    if (push != null) __obj.updateDynamic("push")(push.asInstanceOf[js.Any])
    if (pushLg != null) __obj.updateDynamic("pushLg")(pushLg.asInstanceOf[js.Any])
    if (pushMd != null) __obj.updateDynamic("pushMd")(pushMd.asInstanceOf[js.Any])
    if (pushSm != null) __obj.updateDynamic("pushSm")(pushSm.asInstanceOf[js.Any])
    if (pushXl != null) __obj.updateDynamic("pushXl")(pushXl.asInstanceOf[js.Any])
    if (pushXs != null) __obj.updateDynamic("pushXs")(pushXs.asInstanceOf[js.Any])
    if (size != null) __obj.updateDynamic("size")(size.asInstanceOf[js.Any])
    if (sizeLg != null) __obj.updateDynamic("sizeLg")(sizeLg.asInstanceOf[js.Any])
    if (sizeMd != null) __obj.updateDynamic("sizeMd")(sizeMd.asInstanceOf[js.Any])
    if (sizeSm != null) __obj.updateDynamic("sizeSm")(sizeSm.asInstanceOf[js.Any])
    if (sizeXl != null) __obj.updateDynamic("sizeXl")(sizeXl.asInstanceOf[js.Any])
    if (sizeXs != null) __obj.updateDynamic("sizeXs")(sizeXs.asInstanceOf[js.Any])
    __obj.asInstanceOf[IonCol]
  }
}

