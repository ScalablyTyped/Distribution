package typings.cesium

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object sourceCoreMathMod {
  
  object default {
    
    @JSImport("cesium/Source/Core/Math", JSImport.Default)
    @js.native
    val ^ : js.Any = js.native
    
    /**
      * The number of degrees in a radian.
      */
    @JSImport("cesium/Source/Core/Math", "default.DEGREES_PER_RADIAN")
    @js.native
    val DEGREES_PER_RADIAN: Double = js.native
    
    /**
      * 0.1
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON1")
    @js.native
    val EPSILON1: /* 0.1 */ Double = js.native
    
    /**
      * 0.0000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON10")
    @js.native
    val EPSILON10: /* 1e-10 */ Double = js.native
    
    /**
      * 0.00000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON11")
    @js.native
    val EPSILON11: /* 1e-11 */ Double = js.native
    
    /**
      * 0.000000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON12")
    @js.native
    val EPSILON12: /* 1e-12 */ Double = js.native
    
    /**
      * 0.0000000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON13")
    @js.native
    val EPSILON13: /* 1e-13 */ Double = js.native
    
    /**
      * 0.00000000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON14")
    @js.native
    val EPSILON14: /* 1e-14 */ Double = js.native
    
    /**
      * 0.000000000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON15")
    @js.native
    val EPSILON15: /* 1e-15 */ Double = js.native
    
    /**
      * 0.0000000000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON16")
    @js.native
    val EPSILON16: /* 1e-16 */ Double = js.native
    
    /**
      * 0.00000000000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON17")
    @js.native
    val EPSILON17: /* 1e-17 */ Double = js.native
    
    /**
      * 0.000000000000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON18")
    @js.native
    val EPSILON18: /* 1e-18 */ Double = js.native
    
    /**
      * 0.0000000000000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON19")
    @js.native
    val EPSILON19: /* 1e-19 */ Double = js.native
    
    /**
      * 0.01
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON2")
    @js.native
    val EPSILON2: /* 0.01 */ Double = js.native
    
    /**
      * 0.00000000000000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON20")
    @js.native
    val EPSILON20: /* 1e-20 */ Double = js.native
    
    /**
      * 0.000000000000000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON21")
    @js.native
    val EPSILON21: /* 1e-21 */ Double = js.native
    
    /**
      * 0.001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON3")
    @js.native
    val EPSILON3: /* 0.001 */ Double = js.native
    
    /**
      * 0.0001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON4")
    @js.native
    val EPSILON4: /* 0.0001 */ Double = js.native
    
    /**
      * 0.00001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON5")
    @js.native
    val EPSILON5: /* 0.00001 */ Double = js.native
    
    /**
      * 0.000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON6")
    @js.native
    val EPSILON6: /* 0.000001 */ Double = js.native
    
    /**
      * 0.0000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON7")
    @js.native
    val EPSILON7: /* 1e-7 */ Double = js.native
    
    /**
      * 0.00000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON8")
    @js.native
    val EPSILON8: /* 1e-8 */ Double = js.native
    
    /**
      * 0.000000001
      */
    @JSImport("cesium/Source/Core/Math", "default.EPSILON9")
    @js.native
    val EPSILON9: /* 1e-9 */ Double = js.native
    
    /**
      * 4 * 1024 * 1024 * 1024
      */
    @JSImport("cesium/Source/Core/Math", "default.FOUR_GIGABYTES")
    @js.native
    val FOUR_GIGABYTES: Double = js.native
    
    /**
      * The gravitational parameter of the Earth in meters cubed
      * per second squared as defined by the WGS84 model: 3.986004418e14
      */
    @JSImport("cesium/Source/Core/Math", "default.GRAVITATIONALPARAMETER")
    @js.native
    val GRAVITATIONALPARAMETER: /* 398600441800000.0 */ Double = js.native
    
    /**
      * The mean radius of the moon, according to the "Report of the IAU/IAG Working Group on
      * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000",
      * Celestial Mechanics 82: 83-110, 2002.
      */
    @JSImport("cesium/Source/Core/Math", "default.LUNAR_RADIUS")
    @js.native
    val LUNAR_RADIUS: /* 1737400 */ Double = js.native
    
    /**
      * 1/pi
      */
    @JSImport("cesium/Source/Core/Math", "default.ONE_OVER_PI")
    @js.native
    val ONE_OVER_PI: Double = js.native
    
    /**
      * 1/2pi
      */
    @JSImport("cesium/Source/Core/Math", "default.ONE_OVER_TWO_PI")
    @js.native
    val ONE_OVER_TWO_PI: Double = js.native
    
    /**
      * pi
      */
    @JSImport("cesium/Source/Core/Math", "default.PI")
    @js.native
    val PI: Double = js.native
    
    /**
      * pi/4
      */
    @JSImport("cesium/Source/Core/Math", "default.PI_OVER_FOUR")
    @js.native
    val PI_OVER_FOUR: Double = js.native
    
    /**
      * pi/6
      */
    @JSImport("cesium/Source/Core/Math", "default.PI_OVER_SIX")
    @js.native
    val PI_OVER_SIX: Double = js.native
    
    /**
      * pi/3
      */
    @JSImport("cesium/Source/Core/Math", "default.PI_OVER_THREE")
    @js.native
    val PI_OVER_THREE: Double = js.native
    
    /**
      * pi/2
      */
    @JSImport("cesium/Source/Core/Math", "default.PI_OVER_TWO")
    @js.native
    val PI_OVER_TWO: Double = js.native
    
    /**
      * The number of radians in an arc second.
      */
    @JSImport("cesium/Source/Core/Math", "default.RADIANS_PER_ARCSECOND")
    @js.native
    val RADIANS_PER_ARCSECOND: Double = js.native
    
    /**
      * The number of radians in a degree.
      */
    @JSImport("cesium/Source/Core/Math", "default.RADIANS_PER_DEGREE")
    @js.native
    val RADIANS_PER_DEGREE: Double = js.native
    
    /**
      * 64 * 1024
      */
    @JSImport("cesium/Source/Core/Math", "default.SIXTY_FOUR_KILOBYTES")
    @js.native
    val SIXTY_FOUR_KILOBYTES: Double = js.native
    
    /**
      * Radius of the sun in meters: 6.955e8
      */
    @JSImport("cesium/Source/Core/Math", "default.SOLAR_RADIUS")
    @js.native
    val SOLAR_RADIUS: /* 695500000 */ Double = js.native
    
    /**
      * 3pi/2
      */
    @JSImport("cesium/Source/Core/Math", "default.THREE_PI_OVER_TWO")
    @js.native
    val THREE_PI_OVER_TWO: Double = js.native
    
    /**
      * 2pi
      */
    @JSImport("cesium/Source/Core/Math", "default.TWO_PI")
    @js.native
    val TWO_PI: Double = js.native
    
    /**
      * Computes <code>Math.acos(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]
      * so that the function will never return NaN.
      * @param value - The value for which to compute acos.
      * @returns The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,
      *          whichever is closer, if the value is outside the range.
      */
    inline def acosClamped(value: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("acosClamped")(value.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Computes <code>Math.asin(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]
      * so that the function will never return NaN.
      * @param value - The value for which to compute asin.
      * @returns The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,
      *          whichever is closer, if the value is outside the range.
      */
    inline def asinClamped(value: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("asinClamped")(value.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Finds the cube root of a number.
      * Returns NaN if <code>number</code> is not provided.
      * @param [number] - The number.
      * @returns The result.
      */
    inline def cbrt(): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("cbrt")().asInstanceOf[Double]
    inline def cbrt(number: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("cbrt")(number.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Finds the chord length between two points given the circle's radius and the angle between the points.
      * @param angle - The angle between the two points.
      * @param radius - The radius of the circle.
      * @returns The chord length.
      */
    inline def chordLength(angle: Double, radius: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("chordLength")(angle.asInstanceOf[js.Any], radius.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    /**
      * Constraint a value to lie between two values.
      * @param value - The value to clamp.
      * @param min - The minimum value.
      * @param max - The maximum value.
      * @returns The clamped value such that min <= result <= max.
      */
    inline def clamp(value: Double, min: Double, max: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("clamp")(value.asInstanceOf[js.Any], min.asInstanceOf[js.Any], max.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    /**
      * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
      * Useful for sanitizing data before use in objects requiring correct range.
      * @example
      * // Clamp 108 degrees latitude to 90 degrees latitude
      * const latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));
      * @param angle - The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
      * @returns The latitude value clamped to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
      */
    inline def clampToLatitudeRange(angle: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("clampToLatitudeRange")(angle.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
      * @example
      * // Convert 270 degrees to -90 degrees longitude
      * const longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));
      * @param angle - The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
      * @returns The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).
      */
    inline def convertLongitudeRange(angle: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("convertLongitudeRange")(angle.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Returns the hyperbolic cosine of a number.
      * The hyperbolic cosine of <strong>value</strong> is defined to be
      * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0
      * where <i>e</i> is Euler's number, approximately 2.71828183.
      *
      * <p>Special cases:
      *   <ul>
      *     <li>If the argument is NaN, then the result is NaN.</li>
      *
      *     <li>If the argument is infinite, then the result is positive infinity.</li>
      *
      *     <li>If the argument is zero, then the result is 1.0.</li>
      *   </ul>
      * </p>
      * @param value - The number whose hyperbolic cosine is to be returned.
      * @returns The hyperbolic cosine of <code>value</code>.
      */
    inline def cosh(value: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("cosh")(value.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Determines if two values are equal using an absolute or relative tolerance test. This is useful
      * to avoid problems due to roundoff error when comparing floating-point values directly. The values are
      * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.
      * Use this test if you are unsure of the magnitudes of left and right.
      * @example
      * const a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true
      * const b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false
      * const c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true
      * const d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false
      * @param left - The first value to compare.
      * @param right - The other value to compare.
      * @param [relativeEpsilon = 0] - The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.
      * @param [absoluteEpsilon = relativeEpsilon] - The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.
      * @returns <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.
      */
    inline def equalsEpsilon(left: Double, right: Double): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("equalsEpsilon")(left.asInstanceOf[js.Any], right.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    inline def equalsEpsilon(left: Double, right: Double, relativeEpsilon: Double): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("equalsEpsilon")(left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], relativeEpsilon.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    inline def equalsEpsilon(left: Double, right: Double, relativeEpsilon: Double, absoluteEpsilon: Double): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("equalsEpsilon")(left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], relativeEpsilon.asInstanceOf[js.Any], absoluteEpsilon.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    inline def equalsEpsilon(left: Double, right: Double, relativeEpsilon: Unit, absoluteEpsilon: Double): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("equalsEpsilon")(left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], relativeEpsilon.asInstanceOf[js.Any], absoluteEpsilon.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    /**
      * Computes the factorial of the provided number.
      * @example
      * //Compute 7!, which is equal to 5040
      * const computedFactorial = Cesium.Math.factorial(7);
      * @param n - The number whose factorial is to be computed.
      * @returns The factorial of the provided number or undefined if the number is less than 0.
      */
    inline def factorial(n: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("factorial")(n.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Computes a fast approximation of Atan for input in the range [-1, 1].
      *
      * Based on Michal Drobot's approximation from ShaderFastLibs,
      * which in turn is based on "Efficient approximations for the arctangent function,"
      * Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.
      * Adapted from ShaderFastLibs under MIT License.
      * @param x - An input number in the range [-1, 1]
      * @returns An approximation of atan(x)
      */
    inline def fastApproximateAtan(x: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("fastApproximateAtan")(x.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Computes a fast approximation of Atan2(x, y) for arbitrary input scalars.
      *
      * Range reduction math based on nvidia's cg reference implementation: http://developer.download.nvidia.com/cg/atan2.html
      * @param x - An input number that isn't zero if y is zero.
      * @param y - An input number that isn't zero if x is zero.
      * @returns An approximation of atan2(x, y)
      */
    inline def fastApproximateAtan2(x: Double, y: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("fastApproximateAtan2")(x.asInstanceOf[js.Any], y.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    /**
      * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].
      * @param value - SNORM value in the range [0, rangeMaximum]
      * @param [rangeMaximum = 255] - The maximum value in the SNORM range, 255 by default.
      * @returns Scalar in the range [-1.0, 1.0].
      */
    inline def fromSNorm(value: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("fromSNorm")(value.asInstanceOf[js.Any]).asInstanceOf[Double]
    inline def fromSNorm(value: Double, rangeMaximum: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("fromSNorm")(value.asInstanceOf[js.Any], rangeMaximum.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    /**
      * Determines if the left value is greater the right value. If the two values are within
      * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.
      * @param left - The first number to compare.
      * @param right - The second number to compare.
      * @param absoluteEpsilon - The absolute epsilon to use in comparison.
      * @returns <code>true</code> if <code>left</code> is greater than <code>right</code> by more than
      *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is less or if the two
      *          values are nearly equal.
      */
    inline def greaterThan(left: Double, right: Double, absoluteEpsilon: Double): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("greaterThan")(left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], absoluteEpsilon.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    /**
      * Determines if the left value is greater than or equal to the right value. If the two values are within
      * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.
      * @param left - The first number to compare.
      * @param right - The second number to compare.
      * @param absoluteEpsilon - The absolute epsilon to use in comparison.
      * @returns <code>true</code> if <code>left</code> is greater than <code>right</code> or if the
      *          the values are nearly equal.
      */
    inline def greaterThanOrEquals(left: Double, right: Double, absoluteEpsilon: Double): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("greaterThanOrEquals")(left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], absoluteEpsilon.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    /**
      * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.
      * @example
      * const n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6
      * const m = Cesium.Math.incrementWrap(10, 10, 0); // returns 0
      * @param [n] - The number to be incremented.
      * @param [maximumValue] - The maximum incremented value before rolling over to the minimum value.
      * @param [minimumValue = 0.0] - The number reset to after the maximum value has been exceeded.
      * @returns The incremented number.
      */
    inline def incrementWrap(): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("incrementWrap")().asInstanceOf[Double]
    inline def incrementWrap(n: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("incrementWrap")(n.asInstanceOf[js.Any]).asInstanceOf[Double]
    inline def incrementWrap(n: Double, maximumValue: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("incrementWrap")(n.asInstanceOf[js.Any], maximumValue.asInstanceOf[js.Any])).asInstanceOf[Double]
    inline def incrementWrap(n: Double, maximumValue: Double, minimumValue: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("incrementWrap")(n.asInstanceOf[js.Any], maximumValue.asInstanceOf[js.Any], minimumValue.asInstanceOf[js.Any])).asInstanceOf[Double]
    inline def incrementWrap(n: Double, maximumValue: Unit, minimumValue: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("incrementWrap")(n.asInstanceOf[js.Any], maximumValue.asInstanceOf[js.Any], minimumValue.asInstanceOf[js.Any])).asInstanceOf[Double]
    inline def incrementWrap(n: Unit, maximumValue: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("incrementWrap")(n.asInstanceOf[js.Any], maximumValue.asInstanceOf[js.Any])).asInstanceOf[Double]
    inline def incrementWrap(n: Unit, maximumValue: Double, minimumValue: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("incrementWrap")(n.asInstanceOf[js.Any], maximumValue.asInstanceOf[js.Any], minimumValue.asInstanceOf[js.Any])).asInstanceOf[Double]
    inline def incrementWrap(n: Unit, maximumValue: Unit, minimumValue: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("incrementWrap")(n.asInstanceOf[js.Any], maximumValue.asInstanceOf[js.Any], minimumValue.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    /**
      * Determines if a non-negative integer is a power of two.
      * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.
      * @example
      * const t = Cesium.Math.isPowerOfTwo(16); // true
      * const f = Cesium.Math.isPowerOfTwo(20); // false
      * @param n - The integer to test in the range [0, (2^32)-1].
      * @returns <code>true</code> if the number if a power of two; otherwise, <code>false</code>.
      */
    inline def isPowerOfTwo(n: Double): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isPowerOfTwo")(n.asInstanceOf[js.Any]).asInstanceOf[Boolean]
    
    /**
      * Computes the linear interpolation of two values.
      * @example
      * const n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0
      * @param p - The start value to interpolate.
      * @param q - The end value to interpolate.
      * @param time - The time of interpolation generally in the range <code>[0.0, 1.0]</code>.
      * @returns The linearly interpolated value.
      */
    inline def lerp(p: Double, q: Double, time: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("lerp")(p.asInstanceOf[js.Any], q.asInstanceOf[js.Any], time.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    /**
      * Determines if the left value is less than the right value. If the two values are within
      * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.
      * @param left - The first number to compare.
      * @param right - The second number to compare.
      * @param absoluteEpsilon - The absolute epsilon to use in comparison.
      * @returns <code>true</code> if <code>left</code> is less than <code>right</code> by more than
      *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is greater or if the two
      *          values are nearly equal.
      */
    inline def lessThan(left: Double, right: Double, absoluteEpsilon: Double): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("lessThan")(left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], absoluteEpsilon.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    /**
      * Determines if the left value is less than or equal to the right value. If the two values are within
      * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.
      * @param left - The first number to compare.
      * @param right - The second number to compare.
      * @param absoluteEpsilon - The absolute epsilon to use in comparison.
      * @returns <code>true</code> if <code>left</code> is less than <code>right</code> or if the
      *          the values are nearly equal.
      */
    inline def lessThanOrEquals(left: Double, right: Double, absoluteEpsilon: Double): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("lessThanOrEquals")(left.asInstanceOf[js.Any], right.asInstanceOf[js.Any], absoluteEpsilon.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    
    /**
      * Finds the base 2 logarithm of a number.
      * @param number - The number.
      * @returns The result.
      */
    inline def log2(number: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("log2")(number.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Finds the logarithm of a number to a base.
      * @param number - The number.
      * @param base - The base.
      * @returns The result.
      */
    inline def logBase(number: Double, base: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("logBase")(number.asInstanceOf[js.Any], base.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    /**
      * The modulo operation that also works for negative dividends.
      * @param m - The dividend.
      * @param n - The divisor.
      * @returns The remainder.
      */
    inline def mod(m: Double, n: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("mod")(m.asInstanceOf[js.Any], n.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    /**
      * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.
      * @param angle - in radians
      * @returns The angle in the range [<code>-Math.PI</code>, <code>Math.PI</code>].
      */
    inline def negativePiToPi(angle: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("negativePiToPi")(angle.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Computes the next power-of-two integer greater than or equal to the provided non-negative integer.
      * The maximum allowed input is 2^31 due to 32-bit bitwise operator limitation in Javascript.
      * @example
      * const n = Cesium.Math.nextPowerOfTwo(29); // 32
      * const m = Cesium.Math.nextPowerOfTwo(32); // 32
      * @param n - The integer to test in the range [0, 2^31].
      * @returns The next power-of-two integer.
      */
    inline def nextPowerOfTwo(n: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("nextPowerOfTwo")(n.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Generates a random floating point number in the range of [0.0, 1.0)
      * using a Mersenne twister.
      * @returns A random number in the range of [0.0, 1.0).
      */
    inline def nextRandomNumber(): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("nextRandomNumber")().asInstanceOf[Double]
    
    /**
      * Converts a scalar value in the range [rangeMinimum, rangeMaximum] to a scalar in the range [0.0, 1.0]
      * @param value - The scalar value in the range [rangeMinimum, rangeMaximum]
      * @param rangeMinimum - The minimum value in the mapped range.
      * @param rangeMaximum - The maximum value in the mapped range.
      * @returns A scalar value, where rangeMinimum maps to 0.0 and rangeMaximum maps to 1.0.
      */
    inline def normalize(value: Double, rangeMinimum: Double, rangeMaximum: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("normalize")(value.asInstanceOf[js.Any], rangeMinimum.asInstanceOf[js.Any], rangeMaximum.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    /**
      * Computes the previous power-of-two integer less than or equal to the provided non-negative integer.
      * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.
      * @example
      * const n = Cesium.Math.previousPowerOfTwo(29); // 16
      * const m = Cesium.Math.previousPowerOfTwo(32); // 32
      * @param n - The integer to test in the range [0, (2^32)-1].
      * @returns The previous power-of-two integer.
      */
    inline def previousPowerOfTwo(n: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("previousPowerOfTwo")(n.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Generates a random number between two numbers.
      * @param min - The minimum value.
      * @param max - The maximum value.
      * @returns A random number between the min and max.
      */
    inline def randomBetween(min: Double, max: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("randomBetween")(min.asInstanceOf[js.Any], max.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    /**
      * Sets the seed used by the random number generator
      * in {@link Math#nextRandomNumber}.
      * @param seed - An integer used as the seed.
      */
    inline def setRandomNumberSeed(seed: Double): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("setRandomNumberSeed")(seed.asInstanceOf[js.Any]).asInstanceOf[Unit]
    
    /**
      * Returns the sign of the value; 1 if the value is positive, -1 if the value is
      * negative, or 0 if the value is 0.
      * @param value - The value to return the sign of.
      * @returns The sign of value.
      */
    inline def sign(value: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("sign")(value.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.
      * This is similar to {@link Math#sign} except that returns 1.0 instead of
      * 0.0 when the input value is 0.0.
      * @param value - The value to return the sign of.
      * @returns The sign of value.
      */
    inline def signNotZero(value: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("signNotZero")(value.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Returns the hyperbolic sine of a number.
      * The hyperbolic sine of <em>value</em> is defined to be
      * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0
      * where <i>e</i> is Euler's number, approximately 2.71828183.
      *
      * <p>Special cases:
      *   <ul>
      *     <li>If the argument is NaN, then the result is NaN.</li>
      *
      *     <li>If the argument is infinite, then the result is an infinity
      *     with the same sign as the argument.</li>
      *
      *     <li>If the argument is zero, then the result is a zero with the
      *     same sign as the argument.</li>
      *   </ul>
      * </p>
      * @param value - The number whose hyperbolic sine is to be returned.
      * @returns The hyperbolic sine of <code>value</code>.
      */
    inline def sinh(value: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("sinh")(value.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Converts radians to degrees.
      * @param radians - The angle to convert in radians.
      * @returns The corresponding angle in degrees.
      */
    inline def toDegrees(radians: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("toDegrees")(radians.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Converts degrees to radians.
      * @param degrees - The angle to convert in degrees.
      * @returns The corresponding angle in radians.
      */
    inline def toRadians(degrees: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("toRadians")(degrees.asInstanceOf[js.Any]).asInstanceOf[Double]
    
    /**
      * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]
      * @param value - The scalar value in the range [-1.0, 1.0]
      * @param [rangeMaximum = 255] - The maximum value in the mapped range, 255 by default.
      * @returns A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.
      */
    inline def toSNorm(value: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("toSNorm")(value.asInstanceOf[js.Any]).asInstanceOf[Double]
    inline def toSNorm(value: Double, rangeMaximum: Double): Double = (^.asInstanceOf[js.Dynamic].applyDynamic("toSNorm")(value.asInstanceOf[js.Any], rangeMaximum.asInstanceOf[js.Any])).asInstanceOf[Double]
    
    /**
      * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.
      * @param angle - in radians
      * @returns The angle in the range [0, <code>Math.TWO_PI</code>].
      */
    inline def zeroToTwoPi(angle: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("zeroToTwoPi")(angle.asInstanceOf[js.Any]).asInstanceOf[Double]
  }
}
