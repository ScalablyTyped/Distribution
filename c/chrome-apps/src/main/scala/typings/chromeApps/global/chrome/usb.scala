package typings.chromeApps.global.chrome

import typings.chromeApps.anon.Filters
import typings.chromeApps.anon.InterfaceId
import typings.chromeApps.anon.Multiple
import typings.chromeApps.anon.ProductId
import typings.chromeApps.chrome.integer
import typings.chromeApps.chrome.usb.ConfigDescriptor
import typings.chromeApps.chrome.usb.ConnectionHandle
import typings.chromeApps.chrome.usb.Device
import typings.chromeApps.chrome.usb.DeviceEvent
import typings.chromeApps.chrome.usb.GenericTransferInfo
import typings.chromeApps.chrome.usb.InterfaceDescriptor
import typings.chromeApps.chrome.usb.IsochronousTransferInfo
import typings.chromeApps.chrome.usb.TransferInfo
import typings.chromeApps.chrome.usb.TransferResultInfo
import typings.chromeApps.chromeAppsStrings.adaptive_
import typings.chromeApps.chromeAppsStrings.asynchronous_
import typings.chromeApps.chromeAppsStrings.bulk_
import typings.chromeApps.chromeAppsStrings.class_
import typings.chromeApps.chromeAppsStrings.control_
import typings.chromeApps.chromeAppsStrings.data_
import typings.chromeApps.chromeAppsStrings.device__
import typings.chromeApps.chromeAppsStrings.endpoint_
import typings.chromeApps.chromeAppsStrings.explicitFeedback
import typings.chromeApps.chromeAppsStrings.feedback_
import typings.chromeApps.chromeAppsStrings.in_
import typings.chromeApps.chromeAppsStrings.interface_
import typings.chromeApps.chromeAppsStrings.interrupt_
import typings.chromeApps.chromeAppsStrings.isochronous_
import typings.chromeApps.chromeAppsStrings.notification_
import typings.chromeApps.chromeAppsStrings.other_
import typings.chromeApps.chromeAppsStrings.out_
import typings.chromeApps.chromeAppsStrings.periodic_
import typings.chromeApps.chromeAppsStrings.reserved_
import typings.chromeApps.chromeAppsStrings.standard_
import typings.chromeApps.chromeAppsStrings.synchronous_
import typings.chromeApps.chromeAppsStrings.vendor_
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

// #endregion
// #region chrome.usb
/////////
// USB //
/////////
/**
  * @requires Permissions: 'usb'
  * @since Chrome 26.
  * Use the chrome.usb API to interact with connected USB devices.
  * This API provides access to USB operations from within the context of an app.
  * Using this API, apps can function as drivers for hardware devices.
  * Errors generated by this API are reported by setting runtime.lastError
  * and executing the function's regular callback. The callback's
  * regular parameters will be undefined in this case.
  * @see[Accessing Hardware Devices]{@link https://developer.chrome.com/apps/app_usb}
  */
object usb {
  
  @JSGlobal("chrome.usb")
  @js.native
  val ^ : js.Any = js.native
  
  /** Direction, Recipient, RequestType, and TransferType all map to their namesakes within the USB specification. */
  object Direction {
    
    @JSGlobal("chrome.usb.Direction")
    @js.native
    val ^ : js.Any = js.native
    
    @JSGlobal("chrome.usb.Direction.IN")
    @js.native
    def IN: in_ = js.native
    @scala.inline
    def IN_=(x: in_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("IN")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.Direction.OUT")
    @js.native
    def OUT: out_ = js.native
    @scala.inline
    def OUT_=(x: out_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("OUT")(x.asInstanceOf[js.Any])
  }
  
  /** Direction, Recipient, RequestType, and TransferType all map to their namesakes within the USB specification. */
  object Recipient {
    
    @JSGlobal("chrome.usb.Recipient")
    @js.native
    val ^ : js.Any = js.native
    
    @JSGlobal("chrome.usb.Recipient.DEVICE")
    @js.native
    def DEVICE: device__ = js.native
    @scala.inline
    def DEVICE_=(x: device__): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DEVICE")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.Recipient.ENDPOINT")
    @js.native
    def ENDPOINT: endpoint_ = js.native
    @scala.inline
    def ENDPOINT_=(x: endpoint_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ENDPOINT")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.Recipient.INTERFACE")
    @js.native
    def INTERFACE: interface_ = js.native
    @scala.inline
    def INTERFACE_=(x: interface_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("INTERFACE")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.Recipient.OTHER")
    @js.native
    def OTHER: other_ = js.native
    @scala.inline
    def OTHER_=(x: other_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("OTHER")(x.asInstanceOf[js.Any])
  }
  
  /** Direction, Recipient, RequestType, and TransferType all map to their namesakes within the USB specification. */
  object RequestType {
    
    @JSGlobal("chrome.usb.RequestType")
    @js.native
    val ^ : js.Any = js.native
    
    @JSGlobal("chrome.usb.RequestType.CLASS")
    @js.native
    def CLASS: class_ = js.native
    @scala.inline
    def CLASS_=(x: class_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLASS")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.RequestType.RESERVED")
    @js.native
    def RESERVED: reserved_ = js.native
    @scala.inline
    def RESERVED_=(x: reserved_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RESERVED")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.RequestType.STANDARD")
    @js.native
    def STANDARD: standard_ = js.native
    @scala.inline
    def STANDARD_=(x: standard_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("STANDARD")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.RequestType.VENDOR")
    @js.native
    def VENDOR: vendor_ = js.native
    @scala.inline
    def VENDOR_=(x: vendor_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("VENDOR")(x.asInstanceOf[js.Any])
  }
  
  object SynchronizationType {
    
    @JSGlobal("chrome.usb.SynchronizationType")
    @js.native
    val ^ : js.Any = js.native
    
    @JSGlobal("chrome.usb.SynchronizationType.ADAPTIVE")
    @js.native
    def ADAPTIVE: adaptive_ = js.native
    @scala.inline
    def ADAPTIVE_=(x: adaptive_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ADAPTIVE")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.SynchronizationType.ASYNCHRONOUS")
    @js.native
    def ASYNCHRONOUS: asynchronous_ = js.native
    @scala.inline
    def ASYNCHRONOUS_=(x: asynchronous_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ASYNCHRONOUS")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.SynchronizationType.SYNCHRONOUS")
    @js.native
    def SYNCHRONOUS: synchronous_ = js.native
    @scala.inline
    def SYNCHRONOUS_=(x: synchronous_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SYNCHRONOUS")(x.asInstanceOf[js.Any])
  }
  
  /** Direction, Recipient, RequestType, and TransferType all map to their namesakes within the USB specification. */
  object TransferType {
    
    @JSGlobal("chrome.usb.TransferType")
    @js.native
    val ^ : js.Any = js.native
    
    @JSGlobal("chrome.usb.TransferType.BULK")
    @js.native
    def BULK: bulk_ = js.native
    @scala.inline
    def BULK_=(x: bulk_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("BULK")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.TransferType.CONTROL")
    @js.native
    def CONTROL: control_ = js.native
    @scala.inline
    def CONTROL_=(x: control_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CONTROL")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.TransferType.INTERRUPT")
    @js.native
    def INTERRUPT: interrupt_ = js.native
    @scala.inline
    def INTERRUPT_=(x: interrupt_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("INTERRUPT")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.TransferType.ISOCHRONOUS")
    @js.native
    def ISOCHRONOUS: isochronous_ = js.native
    @scala.inline
    def ISOCHRONOUS_=(x: isochronous_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ISOCHRONOUS")(x.asInstanceOf[js.Any])
  }
  
  object UsageType {
    
    @JSGlobal("chrome.usb.UsageType")
    @js.native
    val ^ : js.Any = js.native
    
    @JSGlobal("chrome.usb.UsageType.DATA")
    @js.native
    def DATA: data_ = js.native
    @scala.inline
    def DATA_=(x: data_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DATA")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.UsageType.EXPLICIT_FEEDBACK")
    @js.native
    def EXPLICIT_FEEDBACK: explicitFeedback = js.native
    @scala.inline
    def EXPLICIT_FEEDBACK_=(x: explicitFeedback): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXPLICIT_FEEDBACK")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.UsageType.FEEDBACK")
    @js.native
    def FEEDBACK: feedback_ = js.native
    @scala.inline
    def FEEDBACK_=(x: feedback_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FEEDBACK")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.UsageType.NOTIFICATION")
    @js.native
    def NOTIFICATION: notification_ = js.native
    @scala.inline
    def NOTIFICATION_=(x: notification_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NOTIFICATION")(x.asInstanceOf[js.Any])
    
    @JSGlobal("chrome.usb.UsageType.PERIODIC")
    @js.native
    def PERIODIC: periodic_ = js.native
    @scala.inline
    def PERIODIC_=(x: periodic_): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PERIODIC")(x.asInstanceOf[js.Any])
  }
  
  /**
    * @description Performs a bulk transfer on the specified device.
    * @param handle An open connection to the device.
    * @param transferInfo The transfer parameters.
    * @param callback
    */
  @scala.inline
  def bulkTransfer(
    handle: ConnectionHandle,
    transferInfo: GenericTransferInfo,
    callback: js.Function1[/* info */ TransferResultInfo, Unit]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("bulkTransfer")(handle.asInstanceOf[js.Any], transferInfo.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * Claims an interface on a USB device.
    * Before data can be transfered to an interface or associated endpoints the interface must be claimed.
    * Only one connection handle can claim an interface at any given time.
    * If the interface is already claimed, this call will fail.
    *
    * **releaseInterface** should be called when the interface is no longer needed.
    * @param handle An open connection to the device.
    * @param interfaceNumber The interface to be claimed.
    * @param callback
    */
  @scala.inline
  def claimInterface(handle: ConnectionHandle, interfaceNumber: integer, callback: js.Function0[Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("claimInterface")(handle.asInstanceOf[js.Any], interfaceNumber.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * Closes a connection handle.
    * Invoking operations on a handle after it has been closed is a safe operation but causes no action to be taken.
    * @param handle The ConnectionHandle to close.
    * @param [callback]
    */
  @scala.inline
  def closeDevice(handle: ConnectionHandle): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("closeDevice")(handle.asInstanceOf[js.Any]).asInstanceOf[Unit]
  @scala.inline
  def closeDevice(handle: ConnectionHandle, callback: js.Function0[Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("closeDevice")(handle.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * Performs a control transfer on the specified device.
    * Control transfers refer to either the device, an interface or an endpoint.
    * Transfers to an interface or endpoint require the interface to be claimed.
    * @param handle An open connection to the device.
    * @param transferInfo Transfer info
    * @param callback
    */
  @scala.inline
  def controlTransfer(
    handle: ConnectionHandle,
    transferInfo: TransferInfo,
    callback: js.Function1[/* info */ TransferResultInfo, Unit]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("controlTransfer")(handle.asInstanceOf[js.Any], transferInfo.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * Finds USB devices specified by the vendor, product and (optionally) interface IDs and if permissions allow opens them for use.
    * If the access request is rejected or the device fails to be opened a connection handle will not be created or returned.
    * Calling this method is equivalent to calling *getDevices* followed by *openDevice* for each device.
    * @param options The properties to search for on target devices.
    *                  - vendorId: The device vendor ID.
    *                  - productId: The product ID.
    *                  - The interface ID to request access to. Only available on Chrome OS. It has no effect on other platforms.
    * @requires(CrOS) Chrome OS if you specify *interfaceId*
    * @param callback
    */
  @scala.inline
  def findDevices(options: InterfaceId, callback: js.Function1[/* handles */ js.Array[ConnectionHandle], Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findDevices")(options.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  /**
    * Finds USB devices specified by the vendor, product and (optionally) interface IDs and if permissions allow opens them for use.
    * If the access request is rejected or the device fails to be opened a connection handle will not be created or returned.
    * Calling this method is equivalent to calling *getDevices* followed by *openDevice* for each device.
    * @param options The properties to search for on target devices.
    *                  - vendorId: The device vendor ID.
    *                  - productId: The product ID.
    * @param callback
    */
  @scala.inline
  def findDevices(options: ProductId, callback: js.Function1[/* handles */ js.Array[ConnectionHandle], Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("findDevices")(options.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * Gets the configuration descriptor for the currently selected configuration.
    * @since Chrome 39.
    * @param handle An open connection to the device.
    * @param callback
    */
  @scala.inline
  def getConfiguration(handle: ConnectionHandle, callback: js.Function1[/* config */ ConfigDescriptor, Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getConfiguration")(handle.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * Returns the full set of device configuration descriptors.
    * @since Chrome 47.
    * @param device The Device to fetch descriptors from.
    * @param callback
    */
  @scala.inline
  def getConfigurations(device: Device, callback: js.Function1[/* configs */ js.Array[ConfigDescriptor], Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getConfigurations")(device.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * @description Enumerates connected USB devices.
    * @since Chrome 39.
    * @param options The properties to search for on target devices.
    * @param callback
    */
  @scala.inline
  def getDevices(options: Filters, callback: js.Function1[/* devices */ js.Array[Device], Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getDevices")(options.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * Presents a device picker to the user and returns the Devices selected.
    * If the user cancels the picker devices will be empty.
    * A user gesture is required for the dialog to display. Without a user gesture,
    * the callback will run as though the user cancelled.
    * @since Chrome 40.
    * @param options Configuration of the device picker dialog box.
    *               - multiple: Allow the user to select multiple devices.
    *               - filters: Filter the list of devices presented to the user.
    *                   If multiple filters are provided, devices matching any filter will be displayed.
    * @param callback Invoked with a list of chosen Devices.
    */
  @scala.inline
  def getUserSelectedDevices(options: Multiple, callback: js.Function1[/* devices */ js.Array[Device], Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getUserSelectedDevices")(options.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * @description Performs an interrupt transfer on the specified device.
    * @param handle An open connection to the device.
    * @param transferInfo The transfer parameters.
    * @param callback
    */
  @scala.inline
  def interruptTransfer(
    handle: ConnectionHandle,
    transferInfo: GenericTransferInfo,
    callback: js.Function1[/* info */ TransferResultInfo, Unit]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("interruptTransfer")(handle.asInstanceOf[js.Any], transferInfo.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * @description Performs an isochronous transfer on the specific device.
    * @param handle An open connection to the device.
    * @param transferInfo
    * @param callback
    */
  @scala.inline
  def isochronousTransfer(
    handle: ConnectionHandle,
    transferInfo: IsochronousTransferInfo,
    callback: js.Function1[/* info */ TransferResultInfo, Unit]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("isochronousTransfer")(handle.asInstanceOf[js.Any], transferInfo.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * @description Lists all interfaces on a USB device.
    * @param handle An open connection to the device.
    * @param callback
    */
  @scala.inline
  def listInterfaces(
    handle: ConnectionHandle,
    callback: js.Function1[/* descriptors */ js.Array[InterfaceDescriptor], Unit]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("listInterfaces")(handle.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * Event generated when a device is added to the system.
    * Events are only broadcast to apps that have permission to access the device.
    * Permission may have been granted at install time, when the user accepted an optional permission
    * (@see[permissions.request]{https://developer.chrome.com/apps/permissions#method-request}),
    * or through **getUserSelectedDevices**.
    * @since Chrome 42.
    */
  @JSGlobal("chrome.usb.onDeviceAdded")
  @js.native
  val onDeviceAdded: DeviceEvent = js.native
  
  /**
    * Event generated when a device is removed from the system.
    * See **onDeviceAdded** for which events are delivered.
    * @since Chrome 42.
    */
  @JSGlobal("chrome.usb.onDeviceRemoved")
  @js.native
  val onDeviceRemoved: DeviceEvent = js.native
  
  /**
    * Opens a USB device returned by *getDevices*
    * @since Chrome 31.
    * @param device The device to open.
    * @param callback
    */
  @scala.inline
  def openDevice(device: Device, callback: js.Function1[/* handle */ ConnectionHandle, Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("openDevice")(device.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * @description Releases a claimed interface.
    * @param handle An open connection to the device.
    * @param interfaceNumber The interface to be released.
    * @param callback
    */
  @scala.inline
  def releaseInterface(handle: ConnectionHandle, interfaceNumber: integer, callback: js.Function0[Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("releaseInterface")(handle.asInstanceOf[js.Any], interfaceNumber.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * @deprecated Since Chrome 40.
    * @requires(CrOS) Chrome OS specific. This operation is now implicitly performed as a part of *openDevice*.
    */
  @scala.inline
  def requestAccess(device: Device, interfaceId: integer, callback: js.Function1[/* success */ Boolean, Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("requestAccess")(device.asInstanceOf[js.Any], interfaceId.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * Tries to reset the USB device. If the reset fails, the given connection handle will be closed
    * and the USB device will appear to be disconnected then reconnected.
    * In this case **getDevices** or **findDevices** must be called again to acquire the device.
    * @param handle A connection handle to reset.
    * @param callback
    */
  @scala.inline
  def resetDevice(handle: ConnectionHandle, callback: js.Function1[/* success */ Boolean, Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("resetDevice")(handle.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * Select a device configuration.
    * This function effectively resets the device by selecting one of the
    * device's available configurations. Only configuration values greater
    * than 0 are valid however some buggy devices have a working
    * configuration 0 and so this value is allowed.
    * @since Chrome 42.
    * @param handle An open connection to the device.
    * @param configurationValue
    * @param callback
    */
  @scala.inline
  def setConfiguration(handle: ConnectionHandle, configurationValue: integer, callback: js.Function0[Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("setConfiguration")(handle.asInstanceOf[js.Any], configurationValue.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  /**
    * @description Selects an alternate setting on a previously claimed interface.
    * @param handle An open connection to the device where this interface has been claimed.
    * @param interfaceNumber The interface to configure.
    * @param alternateSetting The alternate setting to configure.
    * @param callback
    */
  @scala.inline
  def setInterfaceAlternateSetting(
    handle: ConnectionHandle,
    interfaceNumber: integer,
    alternateSetting: integer,
    callback: js.Function0[Unit]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("setInterfaceAlternateSetting")(handle.asInstanceOf[js.Any], interfaceNumber.asInstanceOf[js.Any], alternateSetting.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
}
