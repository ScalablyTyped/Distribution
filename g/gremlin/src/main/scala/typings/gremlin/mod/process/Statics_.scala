package typings.gremlin.mod.process

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait Statics_[T /* <: GraphTraversal */] extends js.Object {
  def V(args: js.Any*): T = js.native
  def addE(args: js.Any*): T = js.native
  def addV(args: js.Any*): T = js.native
  def aggregate(args: js.Any*): T = js.native
  def and(args: js.Any*): T = js.native
  def as(args: js.Any*): T = js.native
  def barrier(args: js.Any*): T = js.native
  def both(args: js.Any*): T = js.native
  def bothE(args: js.Any*): T = js.native
  def bothV(args: js.Any*): T = js.native
  def branch(args: js.Any*): T = js.native
  def cap(args: js.Any*): T = js.native
  def choose(args: js.Any*): T = js.native
  def coalesce(args: js.Any*): T = js.native
  def coin(args: js.Any*): T = js.native
  def constant(args: js.Any*): T = js.native
  def count(args: js.Any*): T = js.native
  def cyclicPath(args: js.Any*): T = js.native
  def dedup(args: js.Any*): T = js.native
  def drop(args: js.Any*): T = js.native
  def elementMap(args: js.Any*): T = js.native
  def emit(args: js.Any*): T = js.native
  def filter(args: js.Any*): T = js.native
  def flatMap(args: js.Any*): T = js.native
  def fold(args: js.Any*): T = js.native
  def group(args: js.Any*): T = js.native
  def groupCount(args: js.Any*): T = js.native
  def has(args: js.Any*): T = js.native
  def hasId(args: js.Any*): T = js.native
  def hasKey(args: js.Any*): T = js.native
  def hasLabel(args: js.Any*): T = js.native
  def hasNot(args: js.Any*): T = js.native
  def hasValue(args: js.Any*): T = js.native
  def id(args: js.Any*): T = js.native
  def identity(args: js.Any*): T = js.native
  def inE(args: js.Any*): T = js.native
  def inV(args: js.Any*): T = js.native
  def in_(args: js.Any*): T = js.native
  def index(args: js.Any*): T = js.native
  def inject(args: js.Any*): T = js.native
  def is(args: js.Any*): T = js.native
  def key(args: js.Any*): T = js.native
  def label(args: js.Any*): T = js.native
  def limit(args: js.Any*): T = js.native
  def local(args: js.Any*): T = js.native
  def loops(args: js.Any*): T = js.native
  def map(args: js.Any*): T = js.native
  def `match`(args: js.Any*): T = js.native
  def math(args: js.Any*): T = js.native
  def max(args: js.Any*): T = js.native
  def mean(args: js.Any*): T = js.native
  def min(args: js.Any*): T = js.native
  def not(args: js.Any*): T = js.native
  def optional(args: js.Any*): T = js.native
  def or(args: js.Any*): T = js.native
  def order(args: js.Any*): T = js.native
  def otherV(args: js.Any*): T = js.native
  def out(args: js.Any*): T = js.native
  def outE(args: js.Any*): T = js.native
  def outV(args: js.Any*): T = js.native
  def path(args: js.Any*): T = js.native
  def project(args: js.Any*): T = js.native
  def properties(args: js.Any*): T = js.native
  def property(args: js.Any*): T = js.native
  def propertyMap(args: js.Any*): T = js.native
  def range(args: js.Any*): T = js.native
  def repeat(args: js.Any*): T = js.native
  def sack(args: js.Any*): T = js.native
  def sample(args: js.Any*): T = js.native
  def select(args: js.Any*): T = js.native
  def sideEffect(args: js.Any*): T = js.native
  def simplePath(args: js.Any*): T = js.native
  def skip(args: js.Any*): T = js.native
  def store(args: js.Any*): T = js.native
  def subgraph(args: js.Any*): T = js.native
  def sum(args: js.Any*): T = js.native
  def tail(args: js.Any*): T = js.native
  def timeLimit(args: js.Any*): T = js.native
  def times(args: js.Any*): T = js.native
  def to(args: js.Any*): T = js.native
  def toE(args: js.Any*): T = js.native
  def toV(args: js.Any*): T = js.native
  def tree(args: js.Any*): T = js.native
  def unfold(args: js.Any*): T = js.native
  def union(args: js.Any*): T = js.native
  def until(args: js.Any*): T = js.native
  def value(args: js.Any*): T = js.native
  def valueMap(args: js.Any*): T = js.native
  def values(args: js.Any*): T = js.native
  def where(args: js.Any*): T = js.native
}

object Statics_ {
  @scala.inline
  def apply[/* <: typings.gremlin.mod.process.GraphTraversal */ T](
    V: /* repeated */ js.Any => T,
    addE: /* repeated */ js.Any => T,
    addV: /* repeated */ js.Any => T,
    aggregate: /* repeated */ js.Any => T,
    and: /* repeated */ js.Any => T,
    as: /* repeated */ js.Any => T,
    barrier: /* repeated */ js.Any => T,
    both: /* repeated */ js.Any => T,
    bothE: /* repeated */ js.Any => T,
    bothV: /* repeated */ js.Any => T,
    branch: /* repeated */ js.Any => T,
    cap: /* repeated */ js.Any => T,
    choose: /* repeated */ js.Any => T,
    coalesce: /* repeated */ js.Any => T,
    coin: /* repeated */ js.Any => T,
    constant: /* repeated */ js.Any => T,
    count: /* repeated */ js.Any => T,
    cyclicPath: /* repeated */ js.Any => T,
    dedup: /* repeated */ js.Any => T,
    drop: /* repeated */ js.Any => T,
    elementMap: /* repeated */ js.Any => T,
    emit: /* repeated */ js.Any => T,
    filter: /* repeated */ js.Any => T,
    flatMap: /* repeated */ js.Any => T,
    fold: /* repeated */ js.Any => T,
    group: /* repeated */ js.Any => T,
    groupCount: /* repeated */ js.Any => T,
    has: /* repeated */ js.Any => T,
    hasId: /* repeated */ js.Any => T,
    hasKey: /* repeated */ js.Any => T,
    hasLabel: /* repeated */ js.Any => T,
    hasNot: /* repeated */ js.Any => T,
    hasValue: /* repeated */ js.Any => T,
    id: /* repeated */ js.Any => T,
    identity: /* repeated */ js.Any => T,
    inE: /* repeated */ js.Any => T,
    inV: /* repeated */ js.Any => T,
    in_ : /* repeated */ js.Any => T,
    index: /* repeated */ js.Any => T,
    inject: /* repeated */ js.Any => T,
    is: /* repeated */ js.Any => T,
    key: /* repeated */ js.Any => T,
    label: /* repeated */ js.Any => T,
    limit: /* repeated */ js.Any => T,
    local: /* repeated */ js.Any => T,
    loops: /* repeated */ js.Any => T,
    map: /* repeated */ js.Any => T,
    `match`: /* repeated */ js.Any => T,
    math: /* repeated */ js.Any => T,
    max: /* repeated */ js.Any => T,
    mean: /* repeated */ js.Any => T,
    min: /* repeated */ js.Any => T,
    not: /* repeated */ js.Any => T,
    optional: /* repeated */ js.Any => T,
    or: /* repeated */ js.Any => T,
    order: /* repeated */ js.Any => T,
    otherV: /* repeated */ js.Any => T,
    out: /* repeated */ js.Any => T,
    outE: /* repeated */ js.Any => T,
    outV: /* repeated */ js.Any => T,
    path: /* repeated */ js.Any => T,
    project: /* repeated */ js.Any => T,
    properties: /* repeated */ js.Any => T,
    property: /* repeated */ js.Any => T,
    propertyMap: /* repeated */ js.Any => T,
    range: /* repeated */ js.Any => T,
    repeat: /* repeated */ js.Any => T,
    sack: /* repeated */ js.Any => T,
    sample: /* repeated */ js.Any => T,
    select: /* repeated */ js.Any => T,
    sideEffect: /* repeated */ js.Any => T,
    simplePath: /* repeated */ js.Any => T,
    skip: /* repeated */ js.Any => T,
    store: /* repeated */ js.Any => T,
    subgraph: /* repeated */ js.Any => T,
    sum: /* repeated */ js.Any => T,
    tail: /* repeated */ js.Any => T,
    timeLimit: /* repeated */ js.Any => T,
    times: /* repeated */ js.Any => T,
    to: /* repeated */ js.Any => T,
    toE: /* repeated */ js.Any => T,
    toV: /* repeated */ js.Any => T,
    tree: /* repeated */ js.Any => T,
    unfold: /* repeated */ js.Any => T,
    union: /* repeated */ js.Any => T,
    until: /* repeated */ js.Any => T,
    value: /* repeated */ js.Any => T,
    valueMap: /* repeated */ js.Any => T,
    values: /* repeated */ js.Any => T,
    where: /* repeated */ js.Any => T
  ): Statics_[T] = {
    val __obj = js.Dynamic.literal(V = js.Any.fromFunction1(V), addE = js.Any.fromFunction1(addE), addV = js.Any.fromFunction1(addV), aggregate = js.Any.fromFunction1(aggregate), and = js.Any.fromFunction1(and), as = js.Any.fromFunction1(as), barrier = js.Any.fromFunction1(barrier), both = js.Any.fromFunction1(both), bothE = js.Any.fromFunction1(bothE), bothV = js.Any.fromFunction1(bothV), branch = js.Any.fromFunction1(branch), cap = js.Any.fromFunction1(cap), choose = js.Any.fromFunction1(choose), coalesce = js.Any.fromFunction1(coalesce), coin = js.Any.fromFunction1(coin), constant = js.Any.fromFunction1(constant), count = js.Any.fromFunction1(count), cyclicPath = js.Any.fromFunction1(cyclicPath), dedup = js.Any.fromFunction1(dedup), drop = js.Any.fromFunction1(drop), elementMap = js.Any.fromFunction1(elementMap), emit = js.Any.fromFunction1(emit), filter = js.Any.fromFunction1(filter), flatMap = js.Any.fromFunction1(flatMap), fold = js.Any.fromFunction1(fold), group = js.Any.fromFunction1(group), groupCount = js.Any.fromFunction1(groupCount), has = js.Any.fromFunction1(has), hasId = js.Any.fromFunction1(hasId), hasKey = js.Any.fromFunction1(hasKey), hasLabel = js.Any.fromFunction1(hasLabel), hasNot = js.Any.fromFunction1(hasNot), hasValue = js.Any.fromFunction1(hasValue), id = js.Any.fromFunction1(id), identity = js.Any.fromFunction1(identity), inE = js.Any.fromFunction1(inE), inV = js.Any.fromFunction1(inV), in_ = js.Any.fromFunction1(in_), index = js.Any.fromFunction1(index), inject = js.Any.fromFunction1(inject), is = js.Any.fromFunction1(is), key = js.Any.fromFunction1(key), label = js.Any.fromFunction1(label), limit = js.Any.fromFunction1(limit), local = js.Any.fromFunction1(local), loops = js.Any.fromFunction1(loops), map = js.Any.fromFunction1(map), math = js.Any.fromFunction1(math), max = js.Any.fromFunction1(max), mean = js.Any.fromFunction1(mean), min = js.Any.fromFunction1(min), not = js.Any.fromFunction1(not), optional = js.Any.fromFunction1(optional), or = js.Any.fromFunction1(or), order = js.Any.fromFunction1(order), otherV = js.Any.fromFunction1(otherV), out = js.Any.fromFunction1(out), outE = js.Any.fromFunction1(outE), outV = js.Any.fromFunction1(outV), path = js.Any.fromFunction1(path), project = js.Any.fromFunction1(project), properties = js.Any.fromFunction1(properties), property = js.Any.fromFunction1(property), propertyMap = js.Any.fromFunction1(propertyMap), range = js.Any.fromFunction1(range), repeat = js.Any.fromFunction1(repeat), sack = js.Any.fromFunction1(sack), sample = js.Any.fromFunction1(sample), select = js.Any.fromFunction1(select), sideEffect = js.Any.fromFunction1(sideEffect), simplePath = js.Any.fromFunction1(simplePath), skip = js.Any.fromFunction1(skip), store = js.Any.fromFunction1(store), subgraph = js.Any.fromFunction1(subgraph), sum = js.Any.fromFunction1(sum), tail = js.Any.fromFunction1(tail), timeLimit = js.Any.fromFunction1(timeLimit), times = js.Any.fromFunction1(times), to = js.Any.fromFunction1(to), toE = js.Any.fromFunction1(toE), toV = js.Any.fromFunction1(toV), tree = js.Any.fromFunction1(tree), unfold = js.Any.fromFunction1(unfold), union = js.Any.fromFunction1(union), until = js.Any.fromFunction1(until), value = js.Any.fromFunction1(value), valueMap = js.Any.fromFunction1(valueMap), values = js.Any.fromFunction1(values), where = js.Any.fromFunction1(where))
    __obj.updateDynamic("match")(js.Any.fromFunction1(`match`))
    __obj.asInstanceOf[Statics_[T]]
  }
  @scala.inline
  implicit class Statics_Ops[Self <: Statics_[_], /* <: typings.gremlin.mod.process.GraphTraversal */ T] (val x: Self with Statics_[T]) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def set(key: String, value: js.Any): Self = {
        x.asInstanceOf[js.Dynamic].updateDynamic(key)(value)
        x
    }
    @scala.inline
    def setV(value: /* repeated */ js.Any => T): Self = this.set("V", js.Any.fromFunction1(value))
    @scala.inline
    def setAddE(value: /* repeated */ js.Any => T): Self = this.set("addE", js.Any.fromFunction1(value))
    @scala.inline
    def setAddV(value: /* repeated */ js.Any => T): Self = this.set("addV", js.Any.fromFunction1(value))
    @scala.inline
    def setAggregate(value: /* repeated */ js.Any => T): Self = this.set("aggregate", js.Any.fromFunction1(value))
    @scala.inline
    def setAnd(value: /* repeated */ js.Any => T): Self = this.set("and", js.Any.fromFunction1(value))
    @scala.inline
    def setAs(value: /* repeated */ js.Any => T): Self = this.set("as", js.Any.fromFunction1(value))
    @scala.inline
    def setBarrier(value: /* repeated */ js.Any => T): Self = this.set("barrier", js.Any.fromFunction1(value))
    @scala.inline
    def setBoth(value: /* repeated */ js.Any => T): Self = this.set("both", js.Any.fromFunction1(value))
    @scala.inline
    def setBothE(value: /* repeated */ js.Any => T): Self = this.set("bothE", js.Any.fromFunction1(value))
    @scala.inline
    def setBothV(value: /* repeated */ js.Any => T): Self = this.set("bothV", js.Any.fromFunction1(value))
    @scala.inline
    def setBranch(value: /* repeated */ js.Any => T): Self = this.set("branch", js.Any.fromFunction1(value))
    @scala.inline
    def setCap(value: /* repeated */ js.Any => T): Self = this.set("cap", js.Any.fromFunction1(value))
    @scala.inline
    def setChoose(value: /* repeated */ js.Any => T): Self = this.set("choose", js.Any.fromFunction1(value))
    @scala.inline
    def setCoalesce(value: /* repeated */ js.Any => T): Self = this.set("coalesce", js.Any.fromFunction1(value))
    @scala.inline
    def setCoin(value: /* repeated */ js.Any => T): Self = this.set("coin", js.Any.fromFunction1(value))
    @scala.inline
    def setConstant(value: /* repeated */ js.Any => T): Self = this.set("constant", js.Any.fromFunction1(value))
    @scala.inline
    def setCount(value: /* repeated */ js.Any => T): Self = this.set("count", js.Any.fromFunction1(value))
    @scala.inline
    def setCyclicPath(value: /* repeated */ js.Any => T): Self = this.set("cyclicPath", js.Any.fromFunction1(value))
    @scala.inline
    def setDedup(value: /* repeated */ js.Any => T): Self = this.set("dedup", js.Any.fromFunction1(value))
    @scala.inline
    def setDrop(value: /* repeated */ js.Any => T): Self = this.set("drop", js.Any.fromFunction1(value))
    @scala.inline
    def setElementMap(value: /* repeated */ js.Any => T): Self = this.set("elementMap", js.Any.fromFunction1(value))
    @scala.inline
    def setEmit(value: /* repeated */ js.Any => T): Self = this.set("emit", js.Any.fromFunction1(value))
    @scala.inline
    def setFilter(value: /* repeated */ js.Any => T): Self = this.set("filter", js.Any.fromFunction1(value))
    @scala.inline
    def setFlatMap(value: /* repeated */ js.Any => T): Self = this.set("flatMap", js.Any.fromFunction1(value))
    @scala.inline
    def setFold(value: /* repeated */ js.Any => T): Self = this.set("fold", js.Any.fromFunction1(value))
    @scala.inline
    def setGroup(value: /* repeated */ js.Any => T): Self = this.set("group", js.Any.fromFunction1(value))
    @scala.inline
    def setGroupCount(value: /* repeated */ js.Any => T): Self = this.set("groupCount", js.Any.fromFunction1(value))
    @scala.inline
    def setHas(value: /* repeated */ js.Any => T): Self = this.set("has", js.Any.fromFunction1(value))
    @scala.inline
    def setHasId(value: /* repeated */ js.Any => T): Self = this.set("hasId", js.Any.fromFunction1(value))
    @scala.inline
    def setHasKey(value: /* repeated */ js.Any => T): Self = this.set("hasKey", js.Any.fromFunction1(value))
    @scala.inline
    def setHasLabel(value: /* repeated */ js.Any => T): Self = this.set("hasLabel", js.Any.fromFunction1(value))
    @scala.inline
    def setHasNot(value: /* repeated */ js.Any => T): Self = this.set("hasNot", js.Any.fromFunction1(value))
    @scala.inline
    def setHasValue(value: /* repeated */ js.Any => T): Self = this.set("hasValue", js.Any.fromFunction1(value))
    @scala.inline
    def setId(value: /* repeated */ js.Any => T): Self = this.set("id", js.Any.fromFunction1(value))
    @scala.inline
    def setIdentity(value: /* repeated */ js.Any => T): Self = this.set("identity", js.Any.fromFunction1(value))
    @scala.inline
    def setInE(value: /* repeated */ js.Any => T): Self = this.set("inE", js.Any.fromFunction1(value))
    @scala.inline
    def setInV(value: /* repeated */ js.Any => T): Self = this.set("inV", js.Any.fromFunction1(value))
    @scala.inline
    def setIn_(value: /* repeated */ js.Any => T): Self = this.set("in_", js.Any.fromFunction1(value))
    @scala.inline
    def setIndex(value: /* repeated */ js.Any => T): Self = this.set("index", js.Any.fromFunction1(value))
    @scala.inline
    def setInject(value: /* repeated */ js.Any => T): Self = this.set("inject", js.Any.fromFunction1(value))
    @scala.inline
    def setIs(value: /* repeated */ js.Any => T): Self = this.set("is", js.Any.fromFunction1(value))
    @scala.inline
    def setKey(value: /* repeated */ js.Any => T): Self = this.set("key", js.Any.fromFunction1(value))
    @scala.inline
    def setLabel(value: /* repeated */ js.Any => T): Self = this.set("label", js.Any.fromFunction1(value))
    @scala.inline
    def setLimit(value: /* repeated */ js.Any => T): Self = this.set("limit", js.Any.fromFunction1(value))
    @scala.inline
    def setLocal(value: /* repeated */ js.Any => T): Self = this.set("local", js.Any.fromFunction1(value))
    @scala.inline
    def setLoops(value: /* repeated */ js.Any => T): Self = this.set("loops", js.Any.fromFunction1(value))
    @scala.inline
    def setMap(value: /* repeated */ js.Any => T): Self = this.set("map", js.Any.fromFunction1(value))
    @scala.inline
    def setMatch(value: /* repeated */ js.Any => T): Self = this.set("match", js.Any.fromFunction1(value))
    @scala.inline
    def setMath(value: /* repeated */ js.Any => T): Self = this.set("math", js.Any.fromFunction1(value))
    @scala.inline
    def setMax(value: /* repeated */ js.Any => T): Self = this.set("max", js.Any.fromFunction1(value))
    @scala.inline
    def setMean(value: /* repeated */ js.Any => T): Self = this.set("mean", js.Any.fromFunction1(value))
    @scala.inline
    def setMin(value: /* repeated */ js.Any => T): Self = this.set("min", js.Any.fromFunction1(value))
    @scala.inline
    def setNot(value: /* repeated */ js.Any => T): Self = this.set("not", js.Any.fromFunction1(value))
    @scala.inline
    def setOptional(value: /* repeated */ js.Any => T): Self = this.set("optional", js.Any.fromFunction1(value))
    @scala.inline
    def setOr(value: /* repeated */ js.Any => T): Self = this.set("or", js.Any.fromFunction1(value))
    @scala.inline
    def setOrder(value: /* repeated */ js.Any => T): Self = this.set("order", js.Any.fromFunction1(value))
    @scala.inline
    def setOtherV(value: /* repeated */ js.Any => T): Self = this.set("otherV", js.Any.fromFunction1(value))
    @scala.inline
    def setOut(value: /* repeated */ js.Any => T): Self = this.set("out", js.Any.fromFunction1(value))
    @scala.inline
    def setOutE(value: /* repeated */ js.Any => T): Self = this.set("outE", js.Any.fromFunction1(value))
    @scala.inline
    def setOutV(value: /* repeated */ js.Any => T): Self = this.set("outV", js.Any.fromFunction1(value))
    @scala.inline
    def setPath(value: /* repeated */ js.Any => T): Self = this.set("path", js.Any.fromFunction1(value))
    @scala.inline
    def setProject(value: /* repeated */ js.Any => T): Self = this.set("project", js.Any.fromFunction1(value))
    @scala.inline
    def setProperties(value: /* repeated */ js.Any => T): Self = this.set("properties", js.Any.fromFunction1(value))
    @scala.inline
    def setProperty(value: /* repeated */ js.Any => T): Self = this.set("property", js.Any.fromFunction1(value))
    @scala.inline
    def setPropertyMap(value: /* repeated */ js.Any => T): Self = this.set("propertyMap", js.Any.fromFunction1(value))
    @scala.inline
    def setRange(value: /* repeated */ js.Any => T): Self = this.set("range", js.Any.fromFunction1(value))
    @scala.inline
    def setRepeat(value: /* repeated */ js.Any => T): Self = this.set("repeat", js.Any.fromFunction1(value))
    @scala.inline
    def setSack(value: /* repeated */ js.Any => T): Self = this.set("sack", js.Any.fromFunction1(value))
    @scala.inline
    def setSample(value: /* repeated */ js.Any => T): Self = this.set("sample", js.Any.fromFunction1(value))
    @scala.inline
    def setSelect(value: /* repeated */ js.Any => T): Self = this.set("select", js.Any.fromFunction1(value))
    @scala.inline
    def setSideEffect(value: /* repeated */ js.Any => T): Self = this.set("sideEffect", js.Any.fromFunction1(value))
    @scala.inline
    def setSimplePath(value: /* repeated */ js.Any => T): Self = this.set("simplePath", js.Any.fromFunction1(value))
    @scala.inline
    def setSkip(value: /* repeated */ js.Any => T): Self = this.set("skip", js.Any.fromFunction1(value))
    @scala.inline
    def setStore(value: /* repeated */ js.Any => T): Self = this.set("store", js.Any.fromFunction1(value))
    @scala.inline
    def setSubgraph(value: /* repeated */ js.Any => T): Self = this.set("subgraph", js.Any.fromFunction1(value))
    @scala.inline
    def setSum(value: /* repeated */ js.Any => T): Self = this.set("sum", js.Any.fromFunction1(value))
    @scala.inline
    def setTail(value: /* repeated */ js.Any => T): Self = this.set("tail", js.Any.fromFunction1(value))
    @scala.inline
    def setTimeLimit(value: /* repeated */ js.Any => T): Self = this.set("timeLimit", js.Any.fromFunction1(value))
    @scala.inline
    def setTimes(value: /* repeated */ js.Any => T): Self = this.set("times", js.Any.fromFunction1(value))
    @scala.inline
    def setTo(value: /* repeated */ js.Any => T): Self = this.set("to", js.Any.fromFunction1(value))
    @scala.inline
    def setToE(value: /* repeated */ js.Any => T): Self = this.set("toE", js.Any.fromFunction1(value))
    @scala.inline
    def setToV(value: /* repeated */ js.Any => T): Self = this.set("toV", js.Any.fromFunction1(value))
    @scala.inline
    def setTree(value: /* repeated */ js.Any => T): Self = this.set("tree", js.Any.fromFunction1(value))
    @scala.inline
    def setUnfold(value: /* repeated */ js.Any => T): Self = this.set("unfold", js.Any.fromFunction1(value))
    @scala.inline
    def setUnion(value: /* repeated */ js.Any => T): Self = this.set("union", js.Any.fromFunction1(value))
    @scala.inline
    def setUntil(value: /* repeated */ js.Any => T): Self = this.set("until", js.Any.fromFunction1(value))
    @scala.inline
    def setValue(value: /* repeated */ js.Any => T): Self = this.set("value", js.Any.fromFunction1(value))
    @scala.inline
    def setValueMap(value: /* repeated */ js.Any => T): Self = this.set("valueMap", js.Any.fromFunction1(value))
    @scala.inline
    def setValues(value: /* repeated */ js.Any => T): Self = this.set("values", js.Any.fromFunction1(value))
    @scala.inline
    def setWhere(value: /* repeated */ js.Any => T): Self = this.set("where", js.Any.fromFunction1(value))
  }
  
}

