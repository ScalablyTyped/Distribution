package typings.emberRouting

import typings.emberRouting.routeInfoMod.RouteInfo
import typings.emberRouting.routeInfoWithAttributesMod.RouteInfoWithAttributes
import typings.std.Record
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@JSImport("@ember/routing/-private/transition", JSImport.Namespace)
@js.native
object transitionMod extends js.Object {
  
  /* Inlined parent std.Partial<std.Promise<T>> */
  @js.native
  trait Transition[T] extends js.Object {
    
    /**
      * Aborts the Transition. Note you can also implicitly abort a transition
      * by initiating another transition while a previous one is underway.
      */
    def abort(): Transition[T] = js.native
    
    /**
      * Forwards to the internal `promise` property which you can use in situations where you want to pass around a thennable,
      * but not the Transition itself.
      *
      * @param onRejection
      * @param label optional string for labeling the promise. Useful for tooling.
      */
    def `catch`[TResult](): js.Promise[TResult] = js.native
    def `catch`[TResult](onRejected: js.UndefOr[scala.Nothing], label: String): js.Promise[TResult] = js.native
    def `catch`[TResult](onRejected: js.Function1[/* reason */ js.Any, TResult | js.Thenable[TResult]]): js.Promise[TResult] = js.native
    def `catch`[TResult](onRejected: js.Function1[/* reason */ js.Any, TResult | js.Thenable[TResult]], label: String): js.Promise[TResult] = js.native
    @JSName("catch")
    var catch_FTransition: js.UndefOr[js.Function0[js.Promise[T | scala.Nothing]]] = js.native
    
    /**
      * Custom state can be stored on a Transition's `data` object.
      * This can be useful for decorating a Transition within an earlier hook and shared with a later hook.
      * Properties set on `data` will be copied to new transitions generated by calling `retry` on this transition.
      */
    var data: Record[String, _] = js.native
    
    /**
      * Forwards to the internal `promise` property which you can use in situations where you want to pass around a thennable,
      * but not the Transition itself.
      *
      * @param onFinally
      * @param label optional string for labeling the promise. Useful for tooling.
      */
    def `finally`(): js.Promise[T] = js.native
    def `finally`(onFinally: js.UndefOr[scala.Nothing], label: String): js.Promise[T] = js.native
    def `finally`(onFinally: js.Function0[Unit]): js.Promise[T] = js.native
    def `finally`(onFinally: js.Function0[Unit], label: String): js.Promise[T] = js.native
    @JSName("finally")
    var finally_FTransition: js.UndefOr[js.Function0[js.Promise[T]]] = js.native
    
    /**
      * Transitions are aborted and their promises rejected when redirects occur;
      * this method returns a promise that will follow any redirects that occur and
      * fulfill with the value fulfilled by any redirecting transitions that occur.
      *
      * @return a promise that fulfills with the same value that the final redirecting transition fulfills with
      */
    def followRedirects(): js.Promise[T] = js.native
    
    /**
      * This property is a `RouteInfo` object that represents where transition originated from.
      * It's important to note that a `RouteInfo` is a linked list and this property is simply the head node of the list.
      * In the case of an initial render, `from` will be set to `null`.
      */
    val from: RouteInfoWithAttributes | Null = js.native
    
    /**
      * Sets the URL-changing method to be employed at the end of a successful transition.
      * By default, a new Transition will just use `updateURL`,
      * but passing 'replace' to this method will cause the URL to update using 'replaceWith' instead.
      * Omitting a parameter will disable the URL change,
      * allowing for transitions that don't update the URL at completion
      * (this is also used for handleURL, since the URL has already changed before the transition took place).
      *
      * @param  method the type of URL-changing method to use at the end of a transition. Accepted values are 'replace',
      *                falsy values, or any other non-falsy value (which is interpreted as an updateURL transition).
      * @return        This transition
      */
    def method(): Transition[T] = js.native
    def method(method: String): Transition[T] = js.native
    
    /**
      * The Transition's internal promise.
      * Calling `.then` on this property is that same as calling `.then` on the Transition object itself,
      * but this property is exposed for when you want to pass around a Transition's promise,
      * but not the Transition object itself, since Transition object can be externally `abort`ed,
      * while the promise cannot.
      */
    val promise: js.Promise[T] = js.native
    
    /**
      * Retries a previously-aborted transition (making sure to abort the
      * transition if it's still active). Returns a new transition that
      * represents the new attempt to transition.
      */
    def retry(): Transition[T] = js.native
    
    /**
      * Fires an event on the current list of resolved/resolving handlers within this transition.
      * Useful for firing events on route hierarchies that haven't fully been entered yet.
      *
      * @param  ignoreFailure a boolean specifying whether unhandled events throw an error
      * @param  name          the name of the event to fire
      */
    def send(ignoreFailure: Boolean, name: String): Unit = js.native
    
    /**
      * A standard promise hook that resolves if the transition succeeds and rejects if it fails/redirects/aborts.
      *
      * Forwards to the internal `promise` property which you can use in situations where you want to pass around a thennable,
      * but not the Transition itself.
      *
      * @param  onFulfilled
      * @param  onRejected
      * @param  label label optional string for labeling the promise. Useful for tooling.
      */
    def `then`[TResult1, TResult2](): js.Promise[TResult1 | TResult2] = js.native
    def `then`[TResult1, TResult2](onfulfilled: js.UndefOr[scala.Nothing], onrejected: js.UndefOr[scala.Nothing], label: String): js.Promise[TResult1 | TResult2] = js.native
    def `then`[TResult1, TResult2](
      onfulfilled: js.UndefOr[scala.Nothing],
      onrejected: js.Function1[/* reason */ js.Any, TResult2 | js.Thenable[TResult2]]
    ): js.Promise[TResult1 | TResult2] = js.native
    def `then`[TResult1, TResult2](
      onfulfilled: js.UndefOr[scala.Nothing],
      onrejected: js.Function1[/* reason */ js.Any, TResult2 | js.Thenable[TResult2]],
      label: String
    ): js.Promise[TResult1 | TResult2] = js.native
    def `then`[TResult1, TResult2](onfulfilled: js.Function1[/* value */ T, TResult1 | js.Thenable[TResult1]]): js.Promise[TResult1 | TResult2] = js.native
    def `then`[TResult1, TResult2](
      onfulfilled: js.Function1[/* value */ T, TResult1 | js.Thenable[TResult1]],
      onrejected: js.UndefOr[scala.Nothing],
      label: String
    ): js.Promise[TResult1 | TResult2] = js.native
    def `then`[TResult1, TResult2](
      onfulfilled: js.Function1[/* value */ T, TResult1 | js.Thenable[TResult1]],
      onrejected: js.Function1[/* reason */ js.Any, TResult2 | js.Thenable[TResult2]]
    ): js.Promise[TResult1 | TResult2] = js.native
    def `then`[TResult1, TResult2](
      onfulfilled: js.Function1[/* value */ T, TResult1 | js.Thenable[TResult1]],
      onrejected: js.Function1[/* reason */ js.Any, TResult2 | js.Thenable[TResult2]],
      label: String
    ): js.Promise[TResult1 | TResult2] = js.native
    @JSName("then")
    var then_FTransition: js.UndefOr[js.Function0[js.Promise[T | scala.Nothing]]] = js.native
    
    /**
      * This property is a `RouteInfo` object that represents where the router is transitioning to.
      * It's important to note that a `RouteInfo` is a linked list and this property is simply the leafmost route.
      */
    val to: RouteInfo | RouteInfoWithAttributes = js.native
    
    /**
      * Fires an event on the current list of resolved/resolving handlers within this transition.
      * Useful for firing events on route hierarchies that haven't fully been entered yet.
      * Note: This method is also aliased as `send`
      *
      * @alias send
      *
      * @param  ignoreFailure a boolean specifying whether unhandled events throw an error
      * @param  name          the name of the event to fire
      */
    def trigger(ignoreFailure: Boolean, name: String): Unit = js.native
  }
}
