package typings.estree.mod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

trait ExpressionMap extends StObject {
  
  var ArrayExpression: typings.estree.mod.ArrayExpression
  
  var ArrowFunctionExpression: typings.estree.mod.ArrowFunctionExpression
  
  var AssignmentExpression: typings.estree.mod.AssignmentExpression
  
  var AwaitExpression: typings.estree.mod.AwaitExpression
  
  var BinaryExpression: typings.estree.mod.BinaryExpression
  
  var CallExpression: typings.estree.mod.CallExpression
  
  var ChainExpression: typings.estree.mod.ChainExpression
  
  var ClassExpression: typings.estree.mod.ClassExpression
  
  var ConditionalExpression: typings.estree.mod.ConditionalExpression
  
  var FunctionExpression: typings.estree.mod.FunctionExpression
  
  var Identifier: typings.estree.mod.Identifier
  
  var ImportExpression: typings.estree.mod.ImportExpression
  
  var Literal: typings.estree.mod.Literal
  
  var LogicalExpression: typings.estree.mod.LogicalExpression
  
  var MemberExpression: typings.estree.mod.MemberExpression
  
  var MetaProperty: typings.estree.mod.MetaProperty
  
  var NewExpression: typings.estree.mod.NewExpression
  
  var ObjectExpression: typings.estree.mod.ObjectExpression
  
  var SequenceExpression: typings.estree.mod.SequenceExpression
  
  var TaggedTemplateExpression: typings.estree.mod.TaggedTemplateExpression
  
  var TemplateLiteral: typings.estree.mod.TemplateLiteral
  
  var ThisExpression: typings.estree.mod.ThisExpression
  
  var UnaryExpression: typings.estree.mod.UnaryExpression
  
  var UpdateExpression: typings.estree.mod.UpdateExpression
  
  var YieldExpression: typings.estree.mod.YieldExpression
}
object ExpressionMap {
  
  inline def apply(
    ArrayExpression: ArrayExpression,
    ArrowFunctionExpression: ArrowFunctionExpression,
    AssignmentExpression: AssignmentExpression,
    AwaitExpression: AwaitExpression,
    BinaryExpression: BinaryExpression,
    CallExpression: CallExpression,
    ChainExpression: ChainExpression,
    ClassExpression: ClassExpression,
    ConditionalExpression: ConditionalExpression,
    FunctionExpression: FunctionExpression,
    Identifier: Identifier,
    ImportExpression: ImportExpression,
    Literal: Literal,
    LogicalExpression: LogicalExpression,
    MemberExpression: MemberExpression,
    MetaProperty: MetaProperty,
    NewExpression: NewExpression,
    ObjectExpression: ObjectExpression,
    SequenceExpression: SequenceExpression,
    TaggedTemplateExpression: TaggedTemplateExpression,
    TemplateLiteral: TemplateLiteral,
    ThisExpression: ThisExpression,
    UnaryExpression: UnaryExpression,
    UpdateExpression: UpdateExpression,
    YieldExpression: YieldExpression
  ): ExpressionMap = {
    val __obj = js.Dynamic.literal(ArrayExpression = ArrayExpression.asInstanceOf[js.Any], ArrowFunctionExpression = ArrowFunctionExpression.asInstanceOf[js.Any], AssignmentExpression = AssignmentExpression.asInstanceOf[js.Any], AwaitExpression = AwaitExpression.asInstanceOf[js.Any], BinaryExpression = BinaryExpression.asInstanceOf[js.Any], CallExpression = CallExpression.asInstanceOf[js.Any], ChainExpression = ChainExpression.asInstanceOf[js.Any], ClassExpression = ClassExpression.asInstanceOf[js.Any], ConditionalExpression = ConditionalExpression.asInstanceOf[js.Any], FunctionExpression = FunctionExpression.asInstanceOf[js.Any], Identifier = Identifier.asInstanceOf[js.Any], ImportExpression = ImportExpression.asInstanceOf[js.Any], Literal = Literal.asInstanceOf[js.Any], LogicalExpression = LogicalExpression.asInstanceOf[js.Any], MemberExpression = MemberExpression.asInstanceOf[js.Any], MetaProperty = MetaProperty.asInstanceOf[js.Any], NewExpression = NewExpression.asInstanceOf[js.Any], ObjectExpression = ObjectExpression.asInstanceOf[js.Any], SequenceExpression = SequenceExpression.asInstanceOf[js.Any], TaggedTemplateExpression = TaggedTemplateExpression.asInstanceOf[js.Any], TemplateLiteral = TemplateLiteral.asInstanceOf[js.Any], ThisExpression = ThisExpression.asInstanceOf[js.Any], UnaryExpression = UnaryExpression.asInstanceOf[js.Any], UpdateExpression = UpdateExpression.asInstanceOf[js.Any], YieldExpression = YieldExpression.asInstanceOf[js.Any])
    __obj.asInstanceOf[ExpressionMap]
  }
  
  extension [Self <: ExpressionMap](x: Self) {
    
    inline def setArrayExpression(value: ArrayExpression): Self = StObject.set(x, "ArrayExpression", value.asInstanceOf[js.Any])
    
    inline def setArrowFunctionExpression(value: ArrowFunctionExpression): Self = StObject.set(x, "ArrowFunctionExpression", value.asInstanceOf[js.Any])
    
    inline def setAssignmentExpression(value: AssignmentExpression): Self = StObject.set(x, "AssignmentExpression", value.asInstanceOf[js.Any])
    
    inline def setAwaitExpression(value: AwaitExpression): Self = StObject.set(x, "AwaitExpression", value.asInstanceOf[js.Any])
    
    inline def setBinaryExpression(value: BinaryExpression): Self = StObject.set(x, "BinaryExpression", value.asInstanceOf[js.Any])
    
    inline def setCallExpression(value: CallExpression): Self = StObject.set(x, "CallExpression", value.asInstanceOf[js.Any])
    
    inline def setChainExpression(value: ChainExpression): Self = StObject.set(x, "ChainExpression", value.asInstanceOf[js.Any])
    
    inline def setClassExpression(value: ClassExpression): Self = StObject.set(x, "ClassExpression", value.asInstanceOf[js.Any])
    
    inline def setConditionalExpression(value: ConditionalExpression): Self = StObject.set(x, "ConditionalExpression", value.asInstanceOf[js.Any])
    
    inline def setFunctionExpression(value: FunctionExpression): Self = StObject.set(x, "FunctionExpression", value.asInstanceOf[js.Any])
    
    inline def setIdentifier(value: Identifier): Self = StObject.set(x, "Identifier", value.asInstanceOf[js.Any])
    
    inline def setImportExpression(value: ImportExpression): Self = StObject.set(x, "ImportExpression", value.asInstanceOf[js.Any])
    
    inline def setLiteral(value: Literal): Self = StObject.set(x, "Literal", value.asInstanceOf[js.Any])
    
    inline def setLogicalExpression(value: LogicalExpression): Self = StObject.set(x, "LogicalExpression", value.asInstanceOf[js.Any])
    
    inline def setMemberExpression(value: MemberExpression): Self = StObject.set(x, "MemberExpression", value.asInstanceOf[js.Any])
    
    inline def setMetaProperty(value: MetaProperty): Self = StObject.set(x, "MetaProperty", value.asInstanceOf[js.Any])
    
    inline def setNewExpression(value: NewExpression): Self = StObject.set(x, "NewExpression", value.asInstanceOf[js.Any])
    
    inline def setObjectExpression(value: ObjectExpression): Self = StObject.set(x, "ObjectExpression", value.asInstanceOf[js.Any])
    
    inline def setSequenceExpression(value: SequenceExpression): Self = StObject.set(x, "SequenceExpression", value.asInstanceOf[js.Any])
    
    inline def setTaggedTemplateExpression(value: TaggedTemplateExpression): Self = StObject.set(x, "TaggedTemplateExpression", value.asInstanceOf[js.Any])
    
    inline def setTemplateLiteral(value: TemplateLiteral): Self = StObject.set(x, "TemplateLiteral", value.asInstanceOf[js.Any])
    
    inline def setThisExpression(value: ThisExpression): Self = StObject.set(x, "ThisExpression", value.asInstanceOf[js.Any])
    
    inline def setUnaryExpression(value: UnaryExpression): Self = StObject.set(x, "UnaryExpression", value.asInstanceOf[js.Any])
    
    inline def setUpdateExpression(value: UpdateExpression): Self = StObject.set(x, "UpdateExpression", value.asInstanceOf[js.Any])
    
    inline def setYieldExpression(value: YieldExpression): Self = StObject.set(x, "YieldExpression", value.asInstanceOf[js.Any])
  }
}
