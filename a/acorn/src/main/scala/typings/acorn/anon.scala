package typings.acorn

import typings.acorn.mod.Node
import typings.acorn.mod.Options
import typings.acorn.mod.TokContext
import typings.acorn.mod.Token
import typings.acorn.mod.TokenType
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object anon {
  
  trait Arrow extends StObject {
    
    var _break: TokenType
    
    var _case: TokenType
    
    var _catch: TokenType
    
    var _class: TokenType
    
    var _const: TokenType
    
    var _continue: TokenType
    
    var _debugger: TokenType
    
    var _default: TokenType
    
    var _delete: TokenType
    
    var _do: TokenType
    
    var _else: TokenType
    
    var _export: TokenType
    
    var _extends: TokenType
    
    var _false: TokenType
    
    var _finally: TokenType
    
    var _for: TokenType
    
    var _function: TokenType
    
    var _if: TokenType
    
    var _import: TokenType
    
    var _in: TokenType
    
    var _instanceof: TokenType
    
    var _new: TokenType
    
    var _null: TokenType
    
    var _return: TokenType
    
    var _super: TokenType
    
    var _switch: TokenType
    
    var _this: TokenType
    
    var _throw: TokenType
    
    var _true: TokenType
    
    var _try: TokenType
    
    var _typeof: TokenType
    
    var _var: TokenType
    
    var _void: TokenType
    
    var _while: TokenType
    
    var _with: TokenType
    
    var arrow: TokenType
    
    var assign: TokenType
    
    var backQuote: TokenType
    
    var bitShift: TokenType
    
    var bitwiseAND: TokenType
    
    var bitwiseOR: TokenType
    
    var bitwiseXOR: TokenType
    
    var braceL: TokenType
    
    var braceR: TokenType
    
    var bracketL: TokenType
    
    var bracketR: TokenType
    
    var coalesce: TokenType
    
    var colon: TokenType
    
    var comma: TokenType
    
    var dollarBraceL: TokenType
    
    var dot: TokenType
    
    var ellipsis: TokenType
    
    var eof: TokenType
    
    @JSName("eq")
    var eq_FArrow: TokenType
    
    var equality: TokenType
    
    var incDec: TokenType
    
    var invalidTemplate: TokenType
    
    var logicalAND: TokenType
    
    var logicalOR: TokenType
    
    var modulo: TokenType
    
    var name: TokenType
    
    var num: TokenType
    
    var parenL: TokenType
    
    var parenR: TokenType
    
    var plusMin: TokenType
    
    var prefix: TokenType
    
    var privateId: TokenType
    
    var question: TokenType
    
    var questionDot: TokenType
    
    var regexp: TokenType
    
    var relational: TokenType
    
    var semi: TokenType
    
    var slash: TokenType
    
    var star: TokenType
    
    var starstar: TokenType
    
    var string: TokenType
    
    var template: TokenType
  }
  object Arrow {
    
    inline def apply(
      _break: TokenType,
      _case: TokenType,
      _catch: TokenType,
      _class: TokenType,
      _const: TokenType,
      _continue: TokenType,
      _debugger: TokenType,
      _default: TokenType,
      _delete: TokenType,
      _do: TokenType,
      _else: TokenType,
      _export: TokenType,
      _extends: TokenType,
      _false: TokenType,
      _finally: TokenType,
      _for: TokenType,
      _function: TokenType,
      _if: TokenType,
      _import: TokenType,
      _in: TokenType,
      _instanceof: TokenType,
      _new: TokenType,
      _null: TokenType,
      _return: TokenType,
      _super: TokenType,
      _switch: TokenType,
      _this: TokenType,
      _throw: TokenType,
      _true: TokenType,
      _try: TokenType,
      _typeof: TokenType,
      _var: TokenType,
      _void: TokenType,
      _while: TokenType,
      _with: TokenType,
      arrow: TokenType,
      assign: TokenType,
      backQuote: TokenType,
      bitShift: TokenType,
      bitwiseAND: TokenType,
      bitwiseOR: TokenType,
      bitwiseXOR: TokenType,
      braceL: TokenType,
      braceR: TokenType,
      bracketL: TokenType,
      bracketR: TokenType,
      coalesce: TokenType,
      colon: TokenType,
      comma: TokenType,
      dollarBraceL: TokenType,
      dot: TokenType,
      ellipsis: TokenType,
      eof: TokenType,
      eq_ : TokenType,
      equality: TokenType,
      incDec: TokenType,
      invalidTemplate: TokenType,
      logicalAND: TokenType,
      logicalOR: TokenType,
      modulo: TokenType,
      name: TokenType,
      num: TokenType,
      parenL: TokenType,
      parenR: TokenType,
      plusMin: TokenType,
      prefix: TokenType,
      privateId: TokenType,
      question: TokenType,
      questionDot: TokenType,
      regexp: TokenType,
      relational: TokenType,
      semi: TokenType,
      slash: TokenType,
      star: TokenType,
      starstar: TokenType,
      string: TokenType,
      template: TokenType
    ): Arrow = {
      val __obj = js.Dynamic.literal(_break = _break.asInstanceOf[js.Any], _case = _case.asInstanceOf[js.Any], _catch = _catch.asInstanceOf[js.Any], _class = _class.asInstanceOf[js.Any], _const = _const.asInstanceOf[js.Any], _continue = _continue.asInstanceOf[js.Any], _debugger = _debugger.asInstanceOf[js.Any], _default = _default.asInstanceOf[js.Any], _delete = _delete.asInstanceOf[js.Any], _do = _do.asInstanceOf[js.Any], _else = _else.asInstanceOf[js.Any], _export = _export.asInstanceOf[js.Any], _extends = _extends.asInstanceOf[js.Any], _false = _false.asInstanceOf[js.Any], _finally = _finally.asInstanceOf[js.Any], _for = _for.asInstanceOf[js.Any], _function = _function.asInstanceOf[js.Any], _if = _if.asInstanceOf[js.Any], _import = _import.asInstanceOf[js.Any], _in = _in.asInstanceOf[js.Any], _instanceof = _instanceof.asInstanceOf[js.Any], _new = _new.asInstanceOf[js.Any], _null = _null.asInstanceOf[js.Any], _return = _return.asInstanceOf[js.Any], _super = _super.asInstanceOf[js.Any], _switch = _switch.asInstanceOf[js.Any], _this = _this.asInstanceOf[js.Any], _throw = _throw.asInstanceOf[js.Any], _true = _true.asInstanceOf[js.Any], _try = _try.asInstanceOf[js.Any], _typeof = _typeof.asInstanceOf[js.Any], _var = _var.asInstanceOf[js.Any], _void = _void.asInstanceOf[js.Any], _while = _while.asInstanceOf[js.Any], _with = _with.asInstanceOf[js.Any], arrow = arrow.asInstanceOf[js.Any], assign = assign.asInstanceOf[js.Any], backQuote = backQuote.asInstanceOf[js.Any], bitShift = bitShift.asInstanceOf[js.Any], bitwiseAND = bitwiseAND.asInstanceOf[js.Any], bitwiseOR = bitwiseOR.asInstanceOf[js.Any], bitwiseXOR = bitwiseXOR.asInstanceOf[js.Any], braceL = braceL.asInstanceOf[js.Any], braceR = braceR.asInstanceOf[js.Any], bracketL = bracketL.asInstanceOf[js.Any], bracketR = bracketR.asInstanceOf[js.Any], coalesce = coalesce.asInstanceOf[js.Any], colon = colon.asInstanceOf[js.Any], comma = comma.asInstanceOf[js.Any], dollarBraceL = dollarBraceL.asInstanceOf[js.Any], dot = dot.asInstanceOf[js.Any], ellipsis = ellipsis.asInstanceOf[js.Any], eof = eof.asInstanceOf[js.Any], equality = equality.asInstanceOf[js.Any], incDec = incDec.asInstanceOf[js.Any], invalidTemplate = invalidTemplate.asInstanceOf[js.Any], logicalAND = logicalAND.asInstanceOf[js.Any], logicalOR = logicalOR.asInstanceOf[js.Any], modulo = modulo.asInstanceOf[js.Any], name = name.asInstanceOf[js.Any], num = num.asInstanceOf[js.Any], parenL = parenL.asInstanceOf[js.Any], parenR = parenR.asInstanceOf[js.Any], plusMin = plusMin.asInstanceOf[js.Any], prefix = prefix.asInstanceOf[js.Any], privateId = privateId.asInstanceOf[js.Any], question = question.asInstanceOf[js.Any], questionDot = questionDot.asInstanceOf[js.Any], regexp = regexp.asInstanceOf[js.Any], relational = relational.asInstanceOf[js.Any], semi = semi.asInstanceOf[js.Any], slash = slash.asInstanceOf[js.Any], star = star.asInstanceOf[js.Any], starstar = starstar.asInstanceOf[js.Any], string = string.asInstanceOf[js.Any], template = template.asInstanceOf[js.Any])
      __obj.updateDynamic("eq")(eq_.asInstanceOf[js.Any])
      __obj.asInstanceOf[Arrow]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Arrow] (val x: Self) extends AnyVal {
      
      inline def setArrow(value: TokenType): Self = StObject.set(x, "arrow", value.asInstanceOf[js.Any])
      
      inline def setAssign(value: TokenType): Self = StObject.set(x, "assign", value.asInstanceOf[js.Any])
      
      inline def setBackQuote(value: TokenType): Self = StObject.set(x, "backQuote", value.asInstanceOf[js.Any])
      
      inline def setBitShift(value: TokenType): Self = StObject.set(x, "bitShift", value.asInstanceOf[js.Any])
      
      inline def setBitwiseAND(value: TokenType): Self = StObject.set(x, "bitwiseAND", value.asInstanceOf[js.Any])
      
      inline def setBitwiseOR(value: TokenType): Self = StObject.set(x, "bitwiseOR", value.asInstanceOf[js.Any])
      
      inline def setBitwiseXOR(value: TokenType): Self = StObject.set(x, "bitwiseXOR", value.asInstanceOf[js.Any])
      
      inline def setBraceL(value: TokenType): Self = StObject.set(x, "braceL", value.asInstanceOf[js.Any])
      
      inline def setBraceR(value: TokenType): Self = StObject.set(x, "braceR", value.asInstanceOf[js.Any])
      
      inline def setBracketL(value: TokenType): Self = StObject.set(x, "bracketL", value.asInstanceOf[js.Any])
      
      inline def setBracketR(value: TokenType): Self = StObject.set(x, "bracketR", value.asInstanceOf[js.Any])
      
      inline def setCoalesce(value: TokenType): Self = StObject.set(x, "coalesce", value.asInstanceOf[js.Any])
      
      inline def setColon(value: TokenType): Self = StObject.set(x, "colon", value.asInstanceOf[js.Any])
      
      inline def setComma(value: TokenType): Self = StObject.set(x, "comma", value.asInstanceOf[js.Any])
      
      inline def setDollarBraceL(value: TokenType): Self = StObject.set(x, "dollarBraceL", value.asInstanceOf[js.Any])
      
      inline def setDot(value: TokenType): Self = StObject.set(x, "dot", value.asInstanceOf[js.Any])
      
      inline def setEllipsis(value: TokenType): Self = StObject.set(x, "ellipsis", value.asInstanceOf[js.Any])
      
      inline def setEof(value: TokenType): Self = StObject.set(x, "eof", value.asInstanceOf[js.Any])
      
      inline def setEq_(value: TokenType): Self = StObject.set(x, "eq", value.asInstanceOf[js.Any])
      
      inline def setEquality(value: TokenType): Self = StObject.set(x, "equality", value.asInstanceOf[js.Any])
      
      inline def setIncDec(value: TokenType): Self = StObject.set(x, "incDec", value.asInstanceOf[js.Any])
      
      inline def setInvalidTemplate(value: TokenType): Self = StObject.set(x, "invalidTemplate", value.asInstanceOf[js.Any])
      
      inline def setLogicalAND(value: TokenType): Self = StObject.set(x, "logicalAND", value.asInstanceOf[js.Any])
      
      inline def setLogicalOR(value: TokenType): Self = StObject.set(x, "logicalOR", value.asInstanceOf[js.Any])
      
      inline def setModulo(value: TokenType): Self = StObject.set(x, "modulo", value.asInstanceOf[js.Any])
      
      inline def setName(value: TokenType): Self = StObject.set(x, "name", value.asInstanceOf[js.Any])
      
      inline def setNum(value: TokenType): Self = StObject.set(x, "num", value.asInstanceOf[js.Any])
      
      inline def setParenL(value: TokenType): Self = StObject.set(x, "parenL", value.asInstanceOf[js.Any])
      
      inline def setParenR(value: TokenType): Self = StObject.set(x, "parenR", value.asInstanceOf[js.Any])
      
      inline def setPlusMin(value: TokenType): Self = StObject.set(x, "plusMin", value.asInstanceOf[js.Any])
      
      inline def setPrefix(value: TokenType): Self = StObject.set(x, "prefix", value.asInstanceOf[js.Any])
      
      inline def setPrivateId(value: TokenType): Self = StObject.set(x, "privateId", value.asInstanceOf[js.Any])
      
      inline def setQuestion(value: TokenType): Self = StObject.set(x, "question", value.asInstanceOf[js.Any])
      
      inline def setQuestionDot(value: TokenType): Self = StObject.set(x, "questionDot", value.asInstanceOf[js.Any])
      
      inline def setRegexp(value: TokenType): Self = StObject.set(x, "regexp", value.asInstanceOf[js.Any])
      
      inline def setRelational(value: TokenType): Self = StObject.set(x, "relational", value.asInstanceOf[js.Any])
      
      inline def setSemi(value: TokenType): Self = StObject.set(x, "semi", value.asInstanceOf[js.Any])
      
      inline def setSlash(value: TokenType): Self = StObject.set(x, "slash", value.asInstanceOf[js.Any])
      
      inline def setStar(value: TokenType): Self = StObject.set(x, "star", value.asInstanceOf[js.Any])
      
      inline def setStarstar(value: TokenType): Self = StObject.set(x, "starstar", value.asInstanceOf[js.Any])
      
      inline def setString(value: TokenType): Self = StObject.set(x, "string", value.asInstanceOf[js.Any])
      
      inline def setTemplate(value: TokenType): Self = StObject.set(x, "template", value.asInstanceOf[js.Any])
      
      inline def set_break(value: TokenType): Self = StObject.set(x, "_break", value.asInstanceOf[js.Any])
      
      inline def set_case(value: TokenType): Self = StObject.set(x, "_case", value.asInstanceOf[js.Any])
      
      inline def set_catch(value: TokenType): Self = StObject.set(x, "_catch", value.asInstanceOf[js.Any])
      
      inline def set_class(value: TokenType): Self = StObject.set(x, "_class", value.asInstanceOf[js.Any])
      
      inline def set_const(value: TokenType): Self = StObject.set(x, "_const", value.asInstanceOf[js.Any])
      
      inline def set_continue(value: TokenType): Self = StObject.set(x, "_continue", value.asInstanceOf[js.Any])
      
      inline def set_debugger(value: TokenType): Self = StObject.set(x, "_debugger", value.asInstanceOf[js.Any])
      
      inline def set_default(value: TokenType): Self = StObject.set(x, "_default", value.asInstanceOf[js.Any])
      
      inline def set_delete(value: TokenType): Self = StObject.set(x, "_delete", value.asInstanceOf[js.Any])
      
      inline def set_do(value: TokenType): Self = StObject.set(x, "_do", value.asInstanceOf[js.Any])
      
      inline def set_else(value: TokenType): Self = StObject.set(x, "_else", value.asInstanceOf[js.Any])
      
      inline def set_export(value: TokenType): Self = StObject.set(x, "_export", value.asInstanceOf[js.Any])
      
      inline def set_extends(value: TokenType): Self = StObject.set(x, "_extends", value.asInstanceOf[js.Any])
      
      inline def set_false(value: TokenType): Self = StObject.set(x, "_false", value.asInstanceOf[js.Any])
      
      inline def set_finally(value: TokenType): Self = StObject.set(x, "_finally", value.asInstanceOf[js.Any])
      
      inline def set_for(value: TokenType): Self = StObject.set(x, "_for", value.asInstanceOf[js.Any])
      
      inline def set_function(value: TokenType): Self = StObject.set(x, "_function", value.asInstanceOf[js.Any])
      
      inline def set_if(value: TokenType): Self = StObject.set(x, "_if", value.asInstanceOf[js.Any])
      
      inline def set_import(value: TokenType): Self = StObject.set(x, "_import", value.asInstanceOf[js.Any])
      
      inline def set_in(value: TokenType): Self = StObject.set(x, "_in", value.asInstanceOf[js.Any])
      
      inline def set_instanceof(value: TokenType): Self = StObject.set(x, "_instanceof", value.asInstanceOf[js.Any])
      
      inline def set_new(value: TokenType): Self = StObject.set(x, "_new", value.asInstanceOf[js.Any])
      
      inline def set_null(value: TokenType): Self = StObject.set(x, "_null", value.asInstanceOf[js.Any])
      
      inline def set_return(value: TokenType): Self = StObject.set(x, "_return", value.asInstanceOf[js.Any])
      
      inline def set_super(value: TokenType): Self = StObject.set(x, "_super", value.asInstanceOf[js.Any])
      
      inline def set_switch(value: TokenType): Self = StObject.set(x, "_switch", value.asInstanceOf[js.Any])
      
      inline def set_this(value: TokenType): Self = StObject.set(x, "_this", value.asInstanceOf[js.Any])
      
      inline def set_throw(value: TokenType): Self = StObject.set(x, "_throw", value.asInstanceOf[js.Any])
      
      inline def set_true(value: TokenType): Self = StObject.set(x, "_true", value.asInstanceOf[js.Any])
      
      inline def set_try(value: TokenType): Self = StObject.set(x, "_try", value.asInstanceOf[js.Any])
      
      inline def set_typeof(value: TokenType): Self = StObject.set(x, "_typeof", value.asInstanceOf[js.Any])
      
      inline def set_var(value: TokenType): Self = StObject.set(x, "_var", value.asInstanceOf[js.Any])
      
      inline def set_void(value: TokenType): Self = StObject.set(x, "_void", value.asInstanceOf[js.Any])
      
      inline def set_while(value: TokenType): Self = StObject.set(x, "_while", value.asInstanceOf[js.Any])
      
      inline def set_with(value: TokenType): Self = StObject.set(x, "_with", value.asInstanceOf[js.Any])
    }
  }
  
  trait Bexpr extends StObject {
    
    var b_expr: TokContext
    
    var b_stat: TokContext
    
    var b_tmpl: TokContext
    
    var f_expr: TokContext
    
    var f_expr_gen: TokContext
    
    var f_gen: TokContext
    
    var f_stat: TokContext
    
    var p_expr: TokContext
    
    var p_stat: TokContext
    
    var q_tmpl: TokContext
  }
  object Bexpr {
    
    inline def apply(
      b_expr: TokContext,
      b_stat: TokContext,
      b_tmpl: TokContext,
      f_expr: TokContext,
      f_expr_gen: TokContext,
      f_gen: TokContext,
      f_stat: TokContext,
      p_expr: TokContext,
      p_stat: TokContext,
      q_tmpl: TokContext
    ): Bexpr = {
      val __obj = js.Dynamic.literal(b_expr = b_expr.asInstanceOf[js.Any], b_stat = b_stat.asInstanceOf[js.Any], b_tmpl = b_tmpl.asInstanceOf[js.Any], f_expr = f_expr.asInstanceOf[js.Any], f_expr_gen = f_expr_gen.asInstanceOf[js.Any], f_gen = f_gen.asInstanceOf[js.Any], f_stat = f_stat.asInstanceOf[js.Any], p_expr = p_expr.asInstanceOf[js.Any], p_stat = p_stat.asInstanceOf[js.Any], q_tmpl = q_tmpl.asInstanceOf[js.Any])
      __obj.asInstanceOf[Bexpr]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Bexpr] (val x: Self) extends AnyVal {
      
      inline def setB_expr(value: TokContext): Self = StObject.set(x, "b_expr", value.asInstanceOf[js.Any])
      
      inline def setB_stat(value: TokContext): Self = StObject.set(x, "b_stat", value.asInstanceOf[js.Any])
      
      inline def setB_tmpl(value: TokContext): Self = StObject.set(x, "b_tmpl", value.asInstanceOf[js.Any])
      
      inline def setF_expr(value: TokContext): Self = StObject.set(x, "f_expr", value.asInstanceOf[js.Any])
      
      inline def setF_expr_gen(value: TokContext): Self = StObject.set(x, "f_expr_gen", value.asInstanceOf[js.Any])
      
      inline def setF_gen(value: TokContext): Self = StObject.set(x, "f_gen", value.asInstanceOf[js.Any])
      
      inline def setF_stat(value: TokContext): Self = StObject.set(x, "f_stat", value.asInstanceOf[js.Any])
      
      inline def setP_expr(value: TokContext): Self = StObject.set(x, "p_expr", value.asInstanceOf[js.Any])
      
      inline def setP_stat(value: TokContext): Self = StObject.set(x, "p_stat", value.asInstanceOf[js.Any])
      
      inline def setQ_tmpl(value: TokContext): Self = StObject.set(x, "q_tmpl", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait GetToken extends StObject {
    
    def getToken(): Token = js.native
    
    @JSName(js.Symbol.iterator)
    var iterator: js.Function0[js.Iterator[Token]] = js.native
  }
  
  trait TypeofParser extends StObject {
    
    /* static member */
    def extend(
      plugins: (js.Function1[
          /* import warning: importer.ImportType#apply Failed type conversion: typeof Parser */ /* BaseParser */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: typeof Parser */ js.Any
        ])*
    ): /* import warning: importer.ImportType#apply Failed type conversion: typeof Parser */ js.Any
    
    // state.js
    /* static member */
    def parse(input: String, options: Options): Node
    
    /* static member */
    def parseExpressionAt(input: String, pos: Double, options: Options): Node
    
    /* static member */
    def tokenizer(input: String, options: Options): GetToken
  }
  object TypeofParser {
    
    inline def apply(
      extend: /* repeated */ js.Function1[
          /* import warning: importer.ImportType#apply Failed type conversion: typeof Parser */ /* BaseParser */ js.Any, 
          /* import warning: importer.ImportType#apply Failed type conversion: typeof Parser */ js.Any
        ] => /* import warning: importer.ImportType#apply Failed type conversion: typeof Parser */ js.Any,
      parse: (String, Options) => Node,
      parseExpressionAt: (String, Double, Options) => Node,
      tokenizer: (String, Options) => GetToken
    ): TypeofParser = {
      val __obj = js.Dynamic.literal(extend = js.Any.fromFunction1(extend), parse = js.Any.fromFunction2(parse), parseExpressionAt = js.Any.fromFunction3(parseExpressionAt), tokenizer = js.Any.fromFunction2(tokenizer))
      __obj.asInstanceOf[TypeofParser]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: TypeofParser] (val x: Self) extends AnyVal {
      
      inline def setExtend(
        value: /* repeated */ js.Function1[
              /* import warning: importer.ImportType#apply Failed type conversion: typeof Parser */ /* BaseParser */ js.Any, 
              /* import warning: importer.ImportType#apply Failed type conversion: typeof Parser */ js.Any
            ] => /* import warning: importer.ImportType#apply Failed type conversion: typeof Parser */ js.Any
      ): Self = StObject.set(x, "extend", js.Any.fromFunction1(value))
      
      inline def setParse(value: (String, Options) => Node): Self = StObject.set(x, "parse", js.Any.fromFunction2(value))
      
      inline def setParseExpressionAt(value: (String, Double, Options) => Node): Self = StObject.set(x, "parseExpressionAt", js.Any.fromFunction3(value))
      
      inline def setTokenizer(value: (String, Options) => GetToken): Self = StObject.set(x, "tokenizer", js.Any.fromFunction2(value))
    }
  }
}
