package typings.katex

import typings.katex.mod.KatexOptions
import typings.std.HTMLElement
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object contribAutoRenderMod {
  
  @JSImport("katex/contrib/auto-render", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  inline def default(elem: HTMLElement): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("default")(elem.asInstanceOf[js.Any]).asInstanceOf[Unit]
  inline def default(elem: HTMLElement, options: RenderMathInElementOptions): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(elem.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  trait RenderMathInElementOptions
    extends StObject
       with KatexOptions
       with RenderMathInElementSpecificOptions
  object RenderMathInElementOptions {
    
    inline def apply(): RenderMathInElementOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[RenderMathInElementOptions]
    }
  }
  
  trait RenderMathInElementSpecificOptions extends StObject {
    
    /**
      * A list of delimiters to look for math
      *
      * @default [
      *   {left: "$$", right: "$$", display: true},
      *   {left: "\\(", right: "\\)", display: false},
      *   {left: "\\[", right: "\\]", display: true}
      * ]
      */
    var delimiters: js.UndefOr[js.Array[RenderMathInElementSpecificOptionsDelimiters]] = js.undefined
    
    /**
      * A callback method returning a message and an error stack in case of an critical error during rendering
      * @param msg Message generated by KaTeX
      * @param err Caught error
      *
      * @default console.error
      */
    var errorCallback: js.UndefOr[js.Function2[/* msg */ String, /* err */ js.Error, Unit]] = js.undefined
    
    /**
      * A list of DOM node class names to ignore when recursing through
      *
      * @default []
      */
    var ignoredClasses: js.UndefOr[js.Array[String]] = js.undefined
    
    /**
      * A list of DOM node types to ignore when recursing through
      *
      * @default ["script", "noscript", "style", "textarea", "pre", "code"]
      */
    var ignoredTags: js.UndefOr[
        js.Array[
          /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 111, starting with typings.katex.katexStrings.a, typings.katex.katexStrings.abbr, typings.katex.katexStrings.address */ Any
        ]
      ] = js.undefined
  }
  object RenderMathInElementSpecificOptions {
    
    inline def apply(): RenderMathInElementSpecificOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[RenderMathInElementSpecificOptions]
    }
    
    extension [Self <: RenderMathInElementSpecificOptions](x: Self) {
      
      inline def setDelimiters(value: js.Array[RenderMathInElementSpecificOptionsDelimiters]): Self = StObject.set(x, "delimiters", value.asInstanceOf[js.Any])
      
      inline def setDelimitersUndefined: Self = StObject.set(x, "delimiters", js.undefined)
      
      inline def setDelimitersVarargs(value: RenderMathInElementSpecificOptionsDelimiters*): Self = StObject.set(x, "delimiters", js.Array(value*))
      
      inline def setErrorCallback(value: (/* msg */ String, /* err */ js.Error) => Unit): Self = StObject.set(x, "errorCallback", js.Any.fromFunction2(value))
      
      inline def setErrorCallbackUndefined: Self = StObject.set(x, "errorCallback", js.undefined)
      
      inline def setIgnoredClasses(value: js.Array[String]): Self = StObject.set(x, "ignoredClasses", value.asInstanceOf[js.Any])
      
      inline def setIgnoredClassesUndefined: Self = StObject.set(x, "ignoredClasses", js.undefined)
      
      inline def setIgnoredClassesVarargs(value: String*): Self = StObject.set(x, "ignoredClasses", js.Array(value*))
      
      inline def setIgnoredTags(
        value: js.Array[
              /* import warning: LimitUnionLength.leaveTypeRef Was union type with length 111, starting with typings.katex.katexStrings.a, typings.katex.katexStrings.abbr, typings.katex.katexStrings.address */ Any
            ]
      ): Self = StObject.set(x, "ignoredTags", value.asInstanceOf[js.Any])
      
      inline def setIgnoredTagsUndefined: Self = StObject.set(x, "ignoredTags", js.undefined)
      
      inline def setIgnoredTagsVarargs(
        value: (/* import warning: LimitUnionLength.leaveTypeRef Was union type with length 111, starting with typings.katex.katexStrings.a, typings.katex.katexStrings.abbr, typings.katex.katexStrings.address */ Any)*
      ): Self = StObject.set(x, "ignoredTags", js.Array(value*))
    }
  }
  
  trait RenderMathInElementSpecificOptionsDelimiters extends StObject {
    
    /**
      * A boolean of whether the math in the expression should be rendered in display mode or not
      */
    var display: Boolean
    
    /**
      * A string which starts the math expression (i.e. the left delimiter)
      */
    var left: String
    
    /**
      * A string which ends the math expression (i.e. the right delimiter)
      */
    var right: String
  }
  object RenderMathInElementSpecificOptionsDelimiters {
    
    inline def apply(display: Boolean, left: String, right: String): RenderMathInElementSpecificOptionsDelimiters = {
      val __obj = js.Dynamic.literal(display = display.asInstanceOf[js.Any], left = left.asInstanceOf[js.Any], right = right.asInstanceOf[js.Any])
      __obj.asInstanceOf[RenderMathInElementSpecificOptionsDelimiters]
    }
    
    extension [Self <: RenderMathInElementSpecificOptionsDelimiters](x: Self) {
      
      inline def setDisplay(value: Boolean): Self = StObject.set(x, "display", value.asInstanceOf[js.Any])
      
      inline def setLeft(value: String): Self = StObject.set(x, "left", value.asInstanceOf[js.Any])
      
      inline def setRight(value: String): Self = StObject.set(x, "right", value.asInstanceOf[js.Any])
    }
  }
}
