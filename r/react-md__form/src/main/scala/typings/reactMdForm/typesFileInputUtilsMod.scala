package typings.reactMdForm

import typings.react.mod.ChangeEvent
import typings.react.mod.ChangeEventHandler
import typings.react.mod.DragEvent
import typings.react.mod.DragEventHandler
import typings.reactMdForm.reactMdFormStrings.complete
import typings.reactMdForm.reactMdFormStrings.max
import typings.reactMdForm.reactMdFormStrings.min
import typings.reactMdForm.reactMdFormStrings.pending
import typings.reactMdForm.reactMdFormStrings.total
import typings.reactMdForm.reactMdFormStrings.uploading
import typings.std.Error
import typings.std.File
import typings.std.HTMLElement
import typings.std.HTMLInputElement
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object typesFileInputUtilsMod {
  
  @JSImport("@react-md/form/types/file-input/utils", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  @JSImport("@react-md/form/types/file-input/utils", "FileAccessError")
  @js.native
  /**
    *
    * @param message - An optional message for the error.
    */
  open class FileAccessError ()
    extends StObject
       with Error
       with _FileValidationError[Any] {
    def this(message: String) = this()
    
    /**
      * A unique key generated by `nanoid` that can be used as a `React` key
      */
    var key: String = js.native
    
    /* standard es5 */
    /* CompleteClass */
    var message: String = js.native
    
    /* standard es5 */
    /* CompleteClass */
    var name: String = js.native
  }
  
  @JSImport("@react-md/form/types/file-input/utils", "FileExtensionError")
  @js.native
  open class FileExtensionError protected ()
    extends GenericFileError
       with _FileValidationError[Any] {
    /**
      *
      * @param files - The file that caused the error
      * @param extensions - The allowed list of file extensions
      */
    def this(files: js.Array[File], extensions: js.Array[String]) = this()
    
    var extensions: js.Array[String] = js.native
  }
  
  @JSImport("@react-md/form/types/file-input/utils", "FileSizeError")
  @js.native
  open class FileSizeError protected ()
    extends GenericFileError
       with _FileValidationError[Any] {
    /**
      *
      * @param files - The list of files that have the file size error
      * @param type - The file size error type
      * @param limit - The number of bytes allowed based on the type
      */
    def this(files: js.Array[File], `type`: min | max | total, limit: Double) = this()
    
    var limit: Double = js.native
    
    var `type`: min | max | total = js.native
  }
  
  @JSImport("@react-md/form/types/file-input/utils", "GenericFileError")
  @js.native
  open class GenericFileError protected ()
    extends StObject
       with Error {
    /**
      *
      * @param files - A list of files that caused the error.
      * @param reason - An optional reason for the error
      */
    def this(files: js.Array[File]) = this()
    def this(files: js.Array[File], reason: String) = this()
    
    var files: js.Array[File] = js.native
    
    /**
      * A unique key generated by `nanoid` that can be used as a `React` key
      */
    var key: String = js.native
    
    /* standard es5 */
    /* CompleteClass */
    var message: String = js.native
    
    /* standard es5 */
    /* CompleteClass */
    var name: String = js.native
    
    var reason: js.UndefOr[String] = js.native
  }
  
  @JSImport("@react-md/form/types/file-input/utils", "TooManyFilesError")
  @js.native
  open class TooManyFilesError protected ()
    extends GenericFileError
       with _FileValidationError[Any] {
    /**
      *
      * @param files - The list of files that could not be uploaded due to the file
      * limit defined.
      * @param limit - The max limit of files allowed.
      */
    def this(files: js.Array[File], limit: Double) = this()
    
    var limit: Double = js.native
  }
  
  @JSImport("@react-md/form/types/file-input/utils", "getFileParser")
  @js.native
  val getFileParser: GetFileParser_ = js.native
  
  inline def getSplitFileUploads(stats: js.Array[FileUploadStats]): SplitFileUploads = ^.asInstanceOf[js.Dynamic].applyDynamic("getSplitFileUploads")(stats.asInstanceOf[js.Any]).asInstanceOf[SplitFileUploads]
  
  inline def isAudioFile(file: File): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isAudioFile")(file.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isFileAccessError[CustomError](error: FileValidationError[CustomError]): /* is @react-md/form.@react-md/form/types/file-input/utils.FileAccessError */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isFileAccessError")(error.asInstanceOf[js.Any]).asInstanceOf[/* is @react-md/form.@react-md/form/types/file-input/utils.FileAccessError */ Boolean]
  
  inline def isFileExtensionError[CustomError](error: FileValidationError[CustomError]): /* is @react-md/form.@react-md/form/types/file-input/utils.FileExtensionError */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isFileExtensionError")(error.asInstanceOf[js.Any]).asInstanceOf[/* is @react-md/form.@react-md/form/types/file-input/utils.FileExtensionError */ Boolean]
  
  inline def isFileSizeError[CustomError](error: FileValidationError[CustomError]): /* is @react-md/form.@react-md/form/types/file-input/utils.FileSizeError */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isFileSizeError")(error.asInstanceOf[js.Any]).asInstanceOf[/* is @react-md/form.@react-md/form/types/file-input/utils.FileSizeError */ Boolean]
  
  inline def isGenericFileError[CustomError](error: FileValidationError[CustomError]): /* is @react-md/form.@react-md/form/types/file-input/utils.GenericFileError */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isGenericFileError")(error.asInstanceOf[js.Any]).asInstanceOf[/* is @react-md/form.@react-md/form/types/file-input/utils.GenericFileError */ Boolean]
  
  inline def isImageFile(file: File): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isImageFile")(file.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isMediaFile(file: File): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isMediaFile")(file.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isTextFile(file: File): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isTextFile")(file.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isTooManyFilesError[CustomError](error: FileValidationError[CustomError]): /* is @react-md/form.@react-md/form/types/file-input/utils.TooManyFilesError */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isTooManyFilesError")(error.asInstanceOf[js.Any]).asInstanceOf[/* is @react-md/form.@react-md/form/types/file-input/utils.TooManyFilesError */ Boolean]
  
  @JSImport("@react-md/form/types/file-input/utils", "isValidFileName")
  @js.native
  val isValidFileName: IsValidFileName_ = js.native
  
  inline def isVideoFile(file: File): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isVideoFile")(file.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def validateFiles[CustomError](files: js.Array[File], param1: FilesValidationOptions): ValidatedFilesResult[CustomError] = (^.asInstanceOf[js.Dynamic].applyDynamic("validateFiles")(files.asInstanceOf[js.Any], param1.asInstanceOf[js.Any])).asInstanceOf[ValidatedFilesResult[CustomError]]
  
  trait BaseFileUploadStats extends StObject {
    
    /**
      * The file instance that is being uploaded.
      */
    var file: File
    
    /**
      * A unique key associated with each upload generated by `nanoid`.
      */
    var key: String
    
    /**
      * The current upload progress as a percentage from 0 - 100 percent.
      */
    var progress: Double
  }
  object BaseFileUploadStats {
    
    inline def apply(file: File, key: String, progress: Double): BaseFileUploadStats = {
      val __obj = js.Dynamic.literal(file = file.asInstanceOf[js.Any], key = key.asInstanceOf[js.Any], progress = progress.asInstanceOf[js.Any])
      __obj.asInstanceOf[BaseFileUploadStats]
    }
    
    extension [Self <: BaseFileUploadStats](x: Self) {
      
      inline def setFile(value: File): Self = StObject.set(x, "file", value.asInstanceOf[js.Any])
      
      inline def setKey(value: String): Self = StObject.set(x, "key", value.asInstanceOf[js.Any])
      
      inline def setProgress(value: Double): Self = StObject.set(x, "progress", value.asInstanceOf[js.Any])
    }
  }
  
  trait CompletedFileUploadStats
    extends StObject
       with BaseFileUploadStats
       with FileUploadStats {
    
    /**
      * The result after a `FileReader` has read a file completely.
      *
      * Note: This _should_ be an `ArrayBuffer` if the next step is to upload to a
      * server.
      *
      * @see {@link FileReaderParser}
      * @see {@link getFileParser}
      * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/FileReader | FileReader}
      */
    var result: FileReaderResult
    
    var status: complete
  }
  object CompletedFileUploadStats {
    
    inline def apply(file: File, key: String, progress: Double): CompletedFileUploadStats = {
      val __obj = js.Dynamic.literal(file = file.asInstanceOf[js.Any], key = key.asInstanceOf[js.Any], progress = progress.asInstanceOf[js.Any], status = "complete", result = null)
      __obj.asInstanceOf[CompletedFileUploadStats]
    }
    
    extension [Self <: CompletedFileUploadStats](x: Self) {
      
      inline def setResult(value: FileReaderResult): Self = StObject.set(x, "result", value.asInstanceOf[js.Any])
      
      inline def setResultNull: Self = StObject.set(x, "result", null)
      
      inline def setStatus(value: complete): Self = StObject.set(x, "status", value.asInstanceOf[js.Any])
    }
  }
  
  /* Rewritten from type alias, can be one of: 
    - typings.reactMdForm.reactMdFormStrings.readAsText
    - typings.reactMdForm.reactMdFormStrings.readAsDataURL
    - typings.reactMdForm.reactMdFormStrings.readAsBinaryString
    - typings.reactMdForm.reactMdFormStrings.readAsArrayBuffer
  */
  trait FileReaderParser extends StObject
  object FileReaderParser {
    
    inline def readAsArrayBuffer: typings.reactMdForm.reactMdFormStrings.readAsArrayBuffer = "readAsArrayBuffer".asInstanceOf[typings.reactMdForm.reactMdFormStrings.readAsArrayBuffer]
    
    inline def readAsBinaryString: typings.reactMdForm.reactMdFormStrings.readAsBinaryString = "readAsBinaryString".asInstanceOf[typings.reactMdForm.reactMdFormStrings.readAsBinaryString]
    
    inline def readAsDataURL: typings.reactMdForm.reactMdFormStrings.readAsDataURL = "readAsDataURL".asInstanceOf[typings.reactMdForm.reactMdFormStrings.readAsDataURL]
    
    inline def readAsText: typings.reactMdForm.reactMdFormStrings.readAsText = "readAsText".asInstanceOf[typings.reactMdForm.reactMdFormStrings.readAsText]
  }
  
  type FileReaderResult = String | js.typedarray.ArrayBuffer | Null
  
  trait FileUploadHandlers[E /* <: HTMLElement */] extends StObject {
    
    var onChange: js.UndefOr[ChangeEventHandler[HTMLInputElement]] = js.undefined
    
    var onDrop: js.UndefOr[DragEventHandler[E]] = js.undefined
  }
  object FileUploadHandlers {
    
    inline def apply[E /* <: HTMLElement */](): FileUploadHandlers[E] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[FileUploadHandlers[E]]
    }
    
    extension [Self <: FileUploadHandlers[?], E /* <: HTMLElement */](x: Self & FileUploadHandlers[E]) {
      
      inline def setOnChange(value: ChangeEvent[HTMLInputElement] => Unit): Self = StObject.set(x, "onChange", js.Any.fromFunction1(value))
      
      inline def setOnChangeUndefined: Self = StObject.set(x, "onChange", js.undefined)
      
      inline def setOnDrop(value: DragEvent[E] => Unit): Self = StObject.set(x, "onDrop", js.Any.fromFunction1(value))
      
      inline def setOnDropUndefined: Self = StObject.set(x, "onDrop", js.undefined)
    }
  }
  
  /* Rewritten from type alias, can be one of: 
    - typings.reactMdForm.typesFileInputUtilsMod.ProcessingFileUploadStats
    - typings.reactMdForm.typesFileInputUtilsMod.CompletedFileUploadStats
  */
  trait FileUploadStats extends StObject
  object FileUploadStats {
    
    inline def CompletedFileUploadStats(file: File, key: String, progress: Double): typings.reactMdForm.typesFileInputUtilsMod.CompletedFileUploadStats = {
      val __obj = js.Dynamic.literal(file = file.asInstanceOf[js.Any], key = key.asInstanceOf[js.Any], progress = progress.asInstanceOf[js.Any], status = "complete", result = null)
      __obj.asInstanceOf[typings.reactMdForm.typesFileInputUtilsMod.CompletedFileUploadStats]
    }
    
    inline def ProcessingFileUploadStats(file: File, key: String, progress: Double, status: pending | uploading): typings.reactMdForm.typesFileInputUtilsMod.ProcessingFileUploadStats = {
      val __obj = js.Dynamic.literal(file = file.asInstanceOf[js.Any], key = key.asInstanceOf[js.Any], progress = progress.asInstanceOf[js.Any], status = status.asInstanceOf[js.Any])
      __obj.asInstanceOf[typings.reactMdForm.typesFileInputUtilsMod.ProcessingFileUploadStats]
    }
  }
  
  /* Inlined @react-md/form.@react-md/form/types/file-input/utils.FileUploadStats['status'] */
  /* Rewritten from type alias, can be one of: 
    - typings.reactMdForm.reactMdFormStrings.pending
    - typings.reactMdForm.reactMdFormStrings.uploading
    - typings.reactMdForm.reactMdFormStrings.complete
  */
  trait FileUploadStatus extends StObject
  object FileUploadStatus {
    
    inline def complete: typings.reactMdForm.reactMdFormStrings.complete = "complete".asInstanceOf[typings.reactMdForm.reactMdFormStrings.complete]
    
    inline def pending: typings.reactMdForm.reactMdFormStrings.pending = "pending".asInstanceOf[typings.reactMdForm.reactMdFormStrings.pending]
    
    inline def uploading: typings.reactMdForm.reactMdFormStrings.uploading = "uploading".asInstanceOf[typings.reactMdForm.reactMdFormStrings.uploading]
  }
  
  /* Rewritten from type alias, can be one of: 
    - typings.reactMdForm.typesFileInputUtilsMod.FileAccessError
    - typings.reactMdForm.typesFileInputUtilsMod.TooManyFilesError
    - typings.reactMdForm.typesFileInputUtilsMod.FileSizeError
    - typings.reactMdForm.typesFileInputUtilsMod.FileExtensionError
    - E
  */
  type FileValidationError[E] = _FileValidationError[E] | E
  
  trait FileValidationOptions extends StObject {
    
    /**
      * An optional list of extensions to enforce when uploading files.
      *
      * Note: The extensions and file names will be compared ignoring case.
      *
      * @example
      * Only Allow Images
      * ```ts
      * const extensions = ["png", "jpeg", "jpg", "gif"];
      * ```
      */
    var extensions: js.UndefOr[js.Array[String]] = js.undefined
    
    /** {@inheritDoc IsValidFileName} */
    var isValidFileName: js.UndefOr[IsValidFileName_] = js.undefined
    
    /**
      * An optional maximum file size to enforce for each file. This will only be
      * used when it is greater than `0`.
      *
      * @defaultValue `-1`
      */
    var maxFileSize: js.UndefOr[Double] = js.undefined
    
    /**
      * If the number of files should be limited, set this value to a number
      * greater than `0`.
      *
      * Note: This still allows "infinite" files when set to `0` since the
      * `<input>` element should normally be set to `disabled` if files should not
      * be able to be uploaded.
      *
      * @defaultValue `-1`
      */
    var maxFiles: js.UndefOr[Double] = js.undefined
    
    /**
      * An optional minimum file size to enforce for each file. This will only be
      * used when it is greater than `0`.
      *
      * @defaultValue `-1`
      */
    var minFileSize: js.UndefOr[Double] = js.undefined
    
    /**
      * An optional total file size to enforce when the {@link maxFiles} option is
      * not set to `1`.
      *
      * @defaultValue `-1`
      */
    var totalFileSize: js.UndefOr[Double] = js.undefined
  }
  object FileValidationOptions {
    
    inline def apply(): FileValidationOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[FileValidationOptions]
    }
    
    extension [Self <: FileValidationOptions](x: Self) {
      
      inline def setExtensions(value: js.Array[String]): Self = StObject.set(x, "extensions", value.asInstanceOf[js.Any])
      
      inline def setExtensionsUndefined: Self = StObject.set(x, "extensions", js.undefined)
      
      inline def setExtensionsVarargs(value: String*): Self = StObject.set(x, "extensions", js.Array(value*))
      
      inline def setIsValidFileName(
        value: (/* file */ File, /* extensionRegExp */ js.UndefOr[js.RegExp], /* extensions */ js.Array[String]) => Boolean
      ): Self = StObject.set(x, "isValidFileName", js.Any.fromFunction3(value))
      
      inline def setIsValidFileNameUndefined: Self = StObject.set(x, "isValidFileName", js.undefined)
      
      inline def setMaxFileSize(value: Double): Self = StObject.set(x, "maxFileSize", value.asInstanceOf[js.Any])
      
      inline def setMaxFileSizeUndefined: Self = StObject.set(x, "maxFileSize", js.undefined)
      
      inline def setMaxFiles(value: Double): Self = StObject.set(x, "maxFiles", value.asInstanceOf[js.Any])
      
      inline def setMaxFilesUndefined: Self = StObject.set(x, "maxFiles", js.undefined)
      
      inline def setMinFileSize(value: Double): Self = StObject.set(x, "minFileSize", value.asInstanceOf[js.Any])
      
      inline def setMinFileSizeUndefined: Self = StObject.set(x, "minFileSize", js.undefined)
      
      inline def setTotalFileSize(value: Double): Self = StObject.set(x, "totalFileSize", value.asInstanceOf[js.Any])
      
      inline def setTotalFileSizeUndefined: Self = StObject.set(x, "totalFileSize", js.undefined)
    }
  }
  
  /* Inlined parent std.Required<@react-md/form.@react-md/form/types/file-input/utils.FileValidationOptions> */
  trait FilesValidationOptions extends StObject {
    
    var extensions: js.Array[String]
    
    var isValidFileName: IsValidFileName_
    
    var maxFileSize: Double
    
    var maxFiles: Double
    
    var minFileSize: Double
    
    /**
      * The total number of bytes in the {@link FileUploadHookReturnValue.stats}
      * list. This is really just:
      *
      * ```ts
      * const totalBytes = stats.reduce((total, stat) => total + stat.file.size, 0);
      * ```
      */
    var totalBytes: Double
    
    var totalFileSize: Double
    
    /**
      * The total number of files in the {@link FileUploadHookReturnValue.stats}.
      */
    var totalFiles: Double
  }
  object FilesValidationOptions {
    
    inline def apply(
      extensions: js.Array[String],
      isValidFileName: (/* file */ File, /* extensionRegExp */ js.UndefOr[js.RegExp], /* extensions */ js.Array[String]) => Boolean,
      maxFileSize: Double,
      maxFiles: Double,
      minFileSize: Double,
      totalBytes: Double,
      totalFileSize: Double,
      totalFiles: Double
    ): FilesValidationOptions = {
      val __obj = js.Dynamic.literal(extensions = extensions.asInstanceOf[js.Any], isValidFileName = js.Any.fromFunction3(isValidFileName), maxFileSize = maxFileSize.asInstanceOf[js.Any], maxFiles = maxFiles.asInstanceOf[js.Any], minFileSize = minFileSize.asInstanceOf[js.Any], totalBytes = totalBytes.asInstanceOf[js.Any], totalFileSize = totalFileSize.asInstanceOf[js.Any], totalFiles = totalFiles.asInstanceOf[js.Any])
      __obj.asInstanceOf[FilesValidationOptions]
    }
    
    extension [Self <: FilesValidationOptions](x: Self) {
      
      inline def setExtensions(value: js.Array[String]): Self = StObject.set(x, "extensions", value.asInstanceOf[js.Any])
      
      inline def setExtensionsVarargs(value: String*): Self = StObject.set(x, "extensions", js.Array(value*))
      
      inline def setIsValidFileName(
        value: (/* file */ File, /* extensionRegExp */ js.UndefOr[js.RegExp], /* extensions */ js.Array[String]) => Boolean
      ): Self = StObject.set(x, "isValidFileName", js.Any.fromFunction3(value))
      
      inline def setMaxFileSize(value: Double): Self = StObject.set(x, "maxFileSize", value.asInstanceOf[js.Any])
      
      inline def setMaxFiles(value: Double): Self = StObject.set(x, "maxFiles", value.asInstanceOf[js.Any])
      
      inline def setMinFileSize(value: Double): Self = StObject.set(x, "minFileSize", value.asInstanceOf[js.Any])
      
      inline def setTotalBytes(value: Double): Self = StObject.set(x, "totalBytes", value.asInstanceOf[js.Any])
      
      inline def setTotalFileSize(value: Double): Self = StObject.set(x, "totalFileSize", value.asInstanceOf[js.Any])
      
      inline def setTotalFiles(value: Double): Self = StObject.set(x, "totalFiles", value.asInstanceOf[js.Any])
    }
  }
  
  type FilesValidator[CustomError] = js.Function2[
    /* files */ js.Array[File], 
    /* options */ FilesValidationOptions, 
    ValidatedFilesResult[CustomError]
  ]
  
  type GetFileParser_ = js.Function1[/* file */ File, FileReaderParser]
  
  type IsValidFileName_ = js.Function3[
    /* file */ File, 
    /* extensionRegExp */ js.UndefOr[js.RegExp], 
    /* extensions */ js.Array[String], 
    Boolean
  ]
  
  trait ProcessingFileUploadStats
    extends StObject
       with BaseFileUploadStats
       with FileUploadStats {
    
    var status: pending | uploading
  }
  object ProcessingFileUploadStats {
    
    inline def apply(file: File, key: String, progress: Double, status: pending | uploading): ProcessingFileUploadStats = {
      val __obj = js.Dynamic.literal(file = file.asInstanceOf[js.Any], key = key.asInstanceOf[js.Any], progress = progress.asInstanceOf[js.Any], status = status.asInstanceOf[js.Any])
      __obj.asInstanceOf[ProcessingFileUploadStats]
    }
    
    extension [Self <: ProcessingFileUploadStats](x: Self) {
      
      inline def setStatus(value: pending | uploading): Self = StObject.set(x, "status", value.asInstanceOf[js.Any])
    }
  }
  
  trait SplitFileUploads extends StObject {
    
    val complete: js.Array[CompletedFileUploadStats]
    
    val pending: js.Array[ProcessingFileUploadStats]
    
    val uploading: js.Array[ProcessingFileUploadStats]
  }
  object SplitFileUploads {
    
    inline def apply(
      complete: js.Array[CompletedFileUploadStats],
      pending: js.Array[ProcessingFileUploadStats],
      uploading: js.Array[ProcessingFileUploadStats]
    ): SplitFileUploads = {
      val __obj = js.Dynamic.literal(complete = complete.asInstanceOf[js.Any], pending = pending.asInstanceOf[js.Any], uploading = uploading.asInstanceOf[js.Any])
      __obj.asInstanceOf[SplitFileUploads]
    }
    
    extension [Self <: SplitFileUploads](x: Self) {
      
      inline def setComplete(value: js.Array[CompletedFileUploadStats]): Self = StObject.set(x, "complete", value.asInstanceOf[js.Any])
      
      inline def setCompleteVarargs(value: CompletedFileUploadStats*): Self = StObject.set(x, "complete", js.Array(value*))
      
      inline def setPending(value: js.Array[ProcessingFileUploadStats]): Self = StObject.set(x, "pending", value.asInstanceOf[js.Any])
      
      inline def setPendingVarargs(value: ProcessingFileUploadStats*): Self = StObject.set(x, "pending", js.Array(value*))
      
      inline def setUploading(value: js.Array[ProcessingFileUploadStats]): Self = StObject.set(x, "uploading", value.asInstanceOf[js.Any])
      
      inline def setUploadingVarargs(value: ProcessingFileUploadStats*): Self = StObject.set(x, "uploading", js.Array(value*))
    }
  }
  
  trait ValidatedFilesResult[CustomError] extends StObject {
    
    /**
      * A list of {@link FileValidationError} that occurred during the validation
      * step.
      *
      * Note: If an error has occurred, the file **should not** be added to the
      * {@link pending} list of files.
      */
    var errors: js.Array[FileValidationError[CustomError]]
    
    /**
      * A filtered list of files that have been validated and can be queued for the
      * upload process.
      */
    var pending: js.Array[File]
  }
  object ValidatedFilesResult {
    
    inline def apply[CustomError](errors: js.Array[FileValidationError[CustomError]], pending: js.Array[File]): ValidatedFilesResult[CustomError] = {
      val __obj = js.Dynamic.literal(errors = errors.asInstanceOf[js.Any], pending = pending.asInstanceOf[js.Any])
      __obj.asInstanceOf[ValidatedFilesResult[CustomError]]
    }
    
    extension [Self <: ValidatedFilesResult[?], CustomError](x: Self & ValidatedFilesResult[CustomError]) {
      
      inline def setErrors(value: js.Array[FileValidationError[CustomError]]): Self = StObject.set(x, "errors", value.asInstanceOf[js.Any])
      
      inline def setErrorsVarargs(value: FileValidationError[CustomError]*): Self = StObject.set(x, "errors", js.Array(value*))
      
      inline def setPending(value: js.Array[File]): Self = StObject.set(x, "pending", value.asInstanceOf[js.Any])
      
      inline def setPendingVarargs(value: File*): Self = StObject.set(x, "pending", js.Array(value*))
    }
  }
  
  trait _FileValidationError[E] extends StObject
}
