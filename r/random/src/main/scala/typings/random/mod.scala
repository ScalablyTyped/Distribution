package typings.random

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  @JSImport("random", "bates")
  @js.native
  def bates(): js.Function0[Double] = js.native
  @JSImport("random", "bates")
  @js.native
  def bates(n: Double): js.Function0[Double] = js.native
  
  @JSImport("random", "bernoulli")
  @js.native
  def bernoulli(): js.Function0[Double] = js.native
  @JSImport("random", "bernoulli")
  @js.native
  def bernoulli(p: Double): js.Function0[Double] = js.native
  
  @JSImport("random", "binomial")
  @js.native
  def binomial(): js.Function0[Double] = js.native
  @JSImport("random", "binomial")
  @js.native
  def binomial(n: js.UndefOr[scala.Nothing], p: Double): js.Function0[Double] = js.native
  @JSImport("random", "binomial")
  @js.native
  def binomial(n: Double): js.Function0[Double] = js.native
  @JSImport("random", "binomial")
  @js.native
  def binomial(n: Double, p: Double): js.Function0[Double] = js.native
  
  @JSImport("random", "bool")
  @js.native
  def bool(): Boolean = js.native
  
  @JSImport("random", "boolean")
  @js.native
  def boolean(): Boolean = js.native
  
  @JSImport("random", "exponential")
  @js.native
  def exponential(): js.Function0[Double] = js.native
  @JSImport("random", "exponential")
  @js.native
  def exponential(lambda: Double): js.Function0[Double] = js.native
  
  @JSImport("random", "float")
  @js.native
  def float(): Double = js.native
  @JSImport("random", "float")
  @js.native
  def float(min: js.UndefOr[scala.Nothing], max: Double): Double = js.native
  @JSImport("random", "float")
  @js.native
  def float(min: Double): Double = js.native
  @JSImport("random", "float")
  @js.native
  def float(min: Double, max: Double): Double = js.native
  
  @JSImport("random", "geometric")
  @js.native
  def geometric(): js.Function0[Double] = js.native
  @JSImport("random", "geometric")
  @js.native
  def geometric(p: Double): js.Function0[Double] = js.native
  
  @JSImport("random", "int")
  @js.native
  def int(): Double = js.native
  @JSImport("random", "int")
  @js.native
  def int(min: js.UndefOr[scala.Nothing], max: Double): Double = js.native
  @JSImport("random", "int")
  @js.native
  def int(min: Double): Double = js.native
  @JSImport("random", "int")
  @js.native
  def int(min: Double, max: Double): Double = js.native
  
  @JSImport("random", "irwinHall")
  @js.native
  def irwinHall(): js.Function0[Double] = js.native
  @JSImport("random", "irwinHall")
  @js.native
  def irwinHall(n: Double): js.Function0[Double] = js.native
  
  @JSImport("random", "logNormal")
  @js.native
  def logNormal(): js.Function0[Double] = js.native
  @JSImport("random", "logNormal")
  @js.native
  def logNormal(mu: js.UndefOr[scala.Nothing], sigma: Double): js.Function0[Double] = js.native
  @JSImport("random", "logNormal")
  @js.native
  def logNormal(mu: Double): js.Function0[Double] = js.native
  @JSImport("random", "logNormal")
  @js.native
  def logNormal(mu: Double, sigma: Double): js.Function0[Double] = js.native
  
  @JSImport("random", "normal")
  @js.native
  def normal(): js.Function0[Double] = js.native
  @JSImport("random", "normal")
  @js.native
  def normal(mu: js.UndefOr[scala.Nothing], sigma: Double): js.Function0[Double] = js.native
  @JSImport("random", "normal")
  @js.native
  def normal(mu: Double): js.Function0[Double] = js.native
  @JSImport("random", "normal")
  @js.native
  def normal(mu: Double, sigma: Double): js.Function0[Double] = js.native
  
  @JSImport("random", "pareto")
  @js.native
  def pareto(): js.Function0[Double] = js.native
  @JSImport("random", "pareto")
  @js.native
  def pareto(alpha: Double): js.Function0[Double] = js.native
  
  @JSImport("random", "patch")
  @js.native
  def patch(): Unit = js.native
  
  @JSImport("random", "poisson")
  @js.native
  def poisson(): js.Function0[Double] = js.native
  @JSImport("random", "poisson")
  @js.native
  def poisson(lambda: Double): js.Function0[Double] = js.native
  
  @JSImport("random", "uniform")
  @js.native
  def uniform(): js.Function0[Double] = js.native
  @JSImport("random", "uniform")
  @js.native
  def uniform(min: js.UndefOr[scala.Nothing], max: Double): js.Function0[Double] = js.native
  @JSImport("random", "uniform")
  @js.native
  def uniform(min: Double): js.Function0[Double] = js.native
  @JSImport("random", "uniform")
  @js.native
  def uniform(min: Double, max: Double): js.Function0[Double] = js.native
  
  @JSImport("random", "uniformBoolean")
  @js.native
  def uniformBoolean(): js.Function0[Boolean] = js.native
  
  @JSImport("random", "uniformInt")
  @js.native
  def uniformInt(): js.Function0[Double] = js.native
  @JSImport("random", "uniformInt")
  @js.native
  def uniformInt(min: js.UndefOr[scala.Nothing], max: Double): js.Function0[Double] = js.native
  @JSImport("random", "uniformInt")
  @js.native
  def uniformInt(min: Double): js.Function0[Double] = js.native
  @JSImport("random", "uniformInt")
  @js.native
  def uniformInt(min: Double, max: Double): js.Function0[Double] = js.native
  
  @JSImport("random", "unpatch")
  @js.native
  def unpatch(): Unit = js.native
  
  @JSImport("random", "use")
  @js.native
  def use(n: String): Unit = js.native
  @JSImport("random", "use")
  @js.native
  def use(n: js.Function0[Double]): Unit = js.native
  @JSImport("random", "use")
  @js.native
  def use(n: Double): Unit = js.native
  @JSImport("random", "use")
  @js.native
  def use(n: RNG): Unit = js.native
  
  @js.native
  trait RNG extends StObject {
    
    def clone(seed: Double, opts: js.Object): RNG = js.native
    
    var name: String = js.native
    
    def next(): Double = js.native
    
    def seed(seed: Double, opts: js.Object): Unit = js.native
  }
  object RNG {
    
    @scala.inline
    def apply(
      clone_ : (Double, js.Object) => RNG,
      name: String,
      next: () => Double,
      seed: (Double, js.Object) => Unit
    ): RNG = {
      val __obj = js.Dynamic.literal(name = name.asInstanceOf[js.Any], next = js.Any.fromFunction0(next), seed = js.Any.fromFunction2(seed))
      __obj.updateDynamic("clone")(js.Any.fromFunction2(clone_))
      __obj.asInstanceOf[RNG]
    }
    
    @scala.inline
    implicit class RNGMutableBuilder[Self <: RNG] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setClone_(value: (Double, js.Object) => RNG): Self = StObject.set(x, "clone", js.Any.fromFunction2(value))
      
      @scala.inline
      def setName(value: String): Self = StObject.set(x, "name", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNext(value: () => Double): Self = StObject.set(x, "next", js.Any.fromFunction0(value))
      
      @scala.inline
      def setSeed(value: (Double, js.Object) => Unit): Self = StObject.set(x, "seed", js.Any.fromFunction2(value))
    }
  }
}
