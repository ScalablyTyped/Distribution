package typings.pixiJs.PIXI

import typings.std.Uint16Array
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

/**
  * Renderer dedicated to drawing and batching sprites.
  *
  * This is the default batch renderer. It buffers objects
  * with texture-based geometries and renders them in
  * batches. It uploads multiple textures to the GPU to
  * reduce to the number of draw calls.
  *
  * @class
  * @protected
  * @memberof PIXI
  * @extends PIXI.ObjectRenderer
  */
@JSGlobal("PIXI.AbstractBatchRenderer")
@js.native
class AbstractBatchRenderer protected () extends ObjectRenderer {
  def this(renderer: Renderer) = this()
  /**
    * Maximum number of textures that can be uploaded to
    * the GPU under the current context. It is initialized
    * properly in `this.contextChange`.
    *
    * @member {number} PIXI.AbstractBatchRenderer#MAX_TEXTURES
    * @see PIXI.AbstractBatchRenderer#contextChange
    * @readonly
    */
  val MAX_TEXTURES: Double = js.native
  /**
    * This shader is generated by `this.shaderGenerator`.
    *
    * It is generated specifically to handle the required
    * number of textures being batched together.
    *
    * @member {PIXI.Shader} PIXI.AbstractBatchRenderer#_shader
    * @protected
    */
  var _shader: Shader = js.native
  /**
    * The class that represents the geometry of objects
    * that are going to be batched with this.
    *
    * @member {object} PIXI.AbstractBatchRenderer#geometryClass
    * @default PIXI.BatchGeometry
    * @protected
    */
  var geometryClass: js.Any = js.native
  /**
    * This is used to generate a shader that can
    * color each vertex based on a `aTextureId`
    * attribute that points to an texture in `uSampler`.
    *
    * This enables the objects with different textures
    * to be drawn in the same draw call.
    *
    * You can customize your shader by creating your
    * custom shader generator.
    *
    * @member {PIXI.BatchShaderGenerator} PIXI.AbstractBatchRenderer#shaderGenerator
    * @protected
    */
  var shaderGenerator: BatchShaderGenerator = js.native
  /**
    * The number of bufferable objects before a flush
    * occurs automatically.
    *
    * @member {number} PIXI.AbstractBatchRenderer#size
    * @default settings.SPRITE_BATCH_SIZE * 4
    */
  var size: Double = js.native
  /**
    * The WebGL state in which this renderer will work.
    *
    * @member {PIXI.State} PIXI.AbstractBatchRenderer#state
    * @readonly
    */
  val state: State = js.native
  /**
    * Size of data being buffered per vertex in the
    * attribute buffers (in floats). By default, the
    * batch-renderer plugin uses 6:
    *
    * | aVertexPosition | 2 |
    * |-----------------|---|
    * | aTextureCoords  | 2 |
    * | aColor          | 1 |
    * | aTextureId      | 1 |
    *
    * @member {number} PIXI.AbstractBatchRenderer#vertexSize
    * @readonly
    */
  val vertexSize: Double = js.native
  /**
    * Bind textures for current rendering
    *
    * @param {PIXI.BatchTextureArray} texArray
    */
  def bindAndClearTexArray(texArray: BatchTextureArray): Unit = js.native
  /**
    * Populating drawcalls for rendering
    *
    * @param {PIXI.BatchTextureArray} texArray
    * @param {number} start
    * @param {number} finish
    */
  def buildDrawCalls(texArray: BatchTextureArray, start: Double, finish: Double): Unit = js.native
  /**
    * Handles the `contextChange` signal.
    *
    * It calculates `this.MAX_TEXTURES` and allocating the
    * packed-geometry object pool.
    */
  def contextChange(): Unit = js.native
  /**
    * Makes sure that static and dynamic flush pooled objects have correct dimensions
    */
  def initFlushBuffers(): Unit = js.native
  /**
    * Handles the `prerender` signal.
    *
    * It ensures that flushes start from the first geometry
    * object again.
    */
  def onPrerender(): Unit = js.native
  /**
    * Takes the four batching parameters of `element`, interleaves
    * and pushes them into the batching attribute/index buffers given.
    *
    * It uses these properties: `vertexData` `uvs`, `textureId` and
    * `indicies`. It also uses the "tint" of the base-texture, if
    * present.
    *
    * @param {PIXI.Sprite} element - element being rendered
    * @param {PIXI.ViewableBuffer} attributeBuffer - attribute buffer.
    * @param {Uint16Array} indexBuffer - index buffer
    * @param {number} aIndex - number of floats already in the attribute buffer
    * @param {number} iIndex - number of indices already in `indexBuffer`
    */
  def packInterleavedGeometry(
    element: Sprite,
    attributeBuffer: ViewableBuffer,
    indexBuffer: Uint16Array,
    aIndex: Double,
    iIndex: Double
  ): Unit = js.native
}

/* static members */
@JSGlobal("PIXI.AbstractBatchRenderer")
@js.native
object AbstractBatchRenderer extends js.Object {
  /**
    * Pool of `BatchDrawCall` objects that `flush` used
    * to create "batches" of the objects being rendered.
    *
    * These are never re-allocated again.
    * Shared between all batch renderers because it can be only one "flush" working at the moment.
    *
    * @static
    * @member {PIXI.BatchDrawCall[]}
    */
  var _drawCallPool: js.Array[BatchDrawCall] = js.native
  /**
    * Pool of `BatchDrawCall` objects that `flush` used
    * to create "batches" of the objects being rendered.
    *
    * These are never re-allocated again.
    * Shared between all batch renderers because it can be only one "flush" working at the moment.
    *
    * @static
    * @member {PIXI.BatchTextureArray[]}
    */
  var _textureArrayPool: js.Array[BatchTextureArray] = js.native
}

