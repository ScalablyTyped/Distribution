package typings
package puppeteerLib.puppeteerMod

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait JSHandle extends SerializableOrJSHandle {
  /**
    * Returns a ElementHandle
    */
  def asElement(): ElementHandle[stdLib.Element] | scala.Null
  /**
    * Stops referencing the element handle.
    */
  def dispose(): js.Promise[scala.Unit]
  /**
    * Gets the execution context.
    */
  def executionContext(): ExecutionContext
  /**
    * Returns a map with property names as keys and JSHandle instances for the property values.
    */
  def getProperties(): js.Promise[stdLib.Map[java.lang.String, JSHandle]]
  /**
    * Fetches a single property from the objectHandle.
    * @param propertyName The property to get.
    */
  def getProperty(propertyName: java.lang.String): js.Promise[JSHandle]
  /**
    * Returns a JSON representation of the object.
    * The JSON is generated by running JSON.stringify on the object in page and consequent JSON.parse in puppeteer.
    * @throws The method will throw if the referenced object is not stringifiable.
    */
  def jsonValue(): js.Promise[_]
}

object JSHandle {
  @scala.inline
  def apply(
    asElement: js.Function0[ElementHandle[stdLib.Element] | scala.Null],
    dispose: js.Function0[js.Promise[scala.Unit]],
    executionContext: js.Function0[ExecutionContext],
    getProperties: js.Function0[js.Promise[stdLib.Map[java.lang.String, JSHandle]]],
    getProperty: js.Function1[java.lang.String, js.Promise[JSHandle]],
    jsonValue: js.Function0[js.Promise[_]]
  ): JSHandle = {
    val __obj = js.Dynamic.literal()
    __obj.updateDynamic("asElement")(asElement)
    __obj.updateDynamic("dispose")(dispose)
    __obj.updateDynamic("executionContext")(executionContext)
    __obj.updateDynamic("getProperties")(getProperties)
    __obj.updateDynamic("getProperty")(getProperty)
    __obj.updateDynamic("jsonValue")(jsonValue)
    __obj.asInstanceOf[JSHandle]
  }
}

