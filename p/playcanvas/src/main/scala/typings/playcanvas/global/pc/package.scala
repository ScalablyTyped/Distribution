package typings.playcanvas.global.pc

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}


/**
  * Clamps texture coordinate to the range 0 to 1.
  */
@scala.inline
def ADDRESS_CLAMP_TO_EDGE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ADDRESS_CLAMP_TO_EDGE").asInstanceOf[scala.Double]

/**
  * Texture coordinate to be set to the fractional part if the integer part is even. If the integer part is odd,
  * then the texture coordinate is set to 1 minus the fractional part.
  */
@scala.inline
def ADDRESS_MIRRORED_REPEAT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ADDRESS_MIRRORED_REPEAT").asInstanceOf[scala.Double]

/**
  * Ignores the integer part of texture coordinates, using only the fractional part.
  */
@scala.inline
def ADDRESS_REPEAT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ADDRESS_REPEAT").asInstanceOf[scala.Double]

/**
  * Automatically set aspect ratio to current render target's width divided by height.
  */
@scala.inline
def ASPECT_AUTO: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASPECT_AUTO").asInstanceOf[scala.Double]

/**
  * Use the manual aspect ratio value.
  */
@scala.inline
def ASPECT_MANUAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASPECT_MANUAL").asInstanceOf[scala.Double]

/**
  * Asset type name for animation.
  */
@scala.inline
def ASSET_ANIMATION: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_ANIMATION").asInstanceOf[java.lang.String]

/**
  * Asset type name for audio.
  */
@scala.inline
def ASSET_AUDIO: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_AUDIO").asInstanceOf[java.lang.String]

/**
  * Asset type name for a container.
  */
@scala.inline
def ASSET_CONTAINER: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_CONTAINER").asInstanceOf[java.lang.String]

/**
  * Asset type name for CSS.
  */
@scala.inline
def ASSET_CSS: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_CSS").asInstanceOf[java.lang.String]

/**
  * Asset type name for cubemap.
  */
@scala.inline
def ASSET_CUBEMAP: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_CUBEMAP").asInstanceOf[java.lang.String]

/**
  * Asset type name for HTML.
  */
@scala.inline
def ASSET_HTML: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_HTML").asInstanceOf[java.lang.String]

/**
  * Asset type name for image.
  */
@scala.inline
def ASSET_IMAGE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_IMAGE").asInstanceOf[java.lang.String]

/**
  * Asset type name for json.
  */
@scala.inline
def ASSET_JSON: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_JSON").asInstanceOf[java.lang.String]

/**
  * Asset type name for material.
  */
@scala.inline
def ASSET_MATERIAL: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_MATERIAL").asInstanceOf[java.lang.String]

/**
  * Asset type name for model.
  */
@scala.inline
def ASSET_MODEL: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_MODEL").asInstanceOf[java.lang.String]

/**
  * Asset type name for script.
  */
@scala.inline
def ASSET_SCRIPT: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_SCRIPT").asInstanceOf[java.lang.String]

/**
  * Asset type name for shader.
  */
@scala.inline
def ASSET_SHADER: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_SHADER").asInstanceOf[java.lang.String]

/**
  * Asset type name for text.
  */
@scala.inline
def ASSET_TEXT: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_TEXT").asInstanceOf[java.lang.String]

/**
  * Asset type name for texture.
  */
@scala.inline
def ASSET_TEXTURE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ASSET_TEXTURE").asInstanceOf[java.lang.String]

/**
  * Single color lightmap.
  */
@scala.inline
def BAKE_COLOR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BAKE_COLOR").asInstanceOf[scala.Double]

/**
  * Single color lightmap + dominant light direction (used for bump/specular).
  */
@scala.inline
def BAKE_COLORDIR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BAKE_COLORDIR").asInstanceOf[scala.Double]

/**
  * Add the results of the source and destination fragment multiplies.
  */
@scala.inline
def BLENDEQUATION_ADD: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDEQUATION_ADD").asInstanceOf[scala.Double]

/**
  * Use the largest value. Check app.graphicsDevice.extBlendMinmax for support.
  */
@scala.inline
def BLENDEQUATION_MAX: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDEQUATION_MAX").asInstanceOf[scala.Double]

/**
  * Use the smallest value. Check app.graphicsDevice.extBlendMinmax for support.
  */
@scala.inline
def BLENDEQUATION_MIN: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDEQUATION_MIN").asInstanceOf[scala.Double]

/**
  * Reverse and subtract the results of the source and destination fragment multiplies.
  */
@scala.inline
def BLENDEQUATION_REVERSE_SUBTRACT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDEQUATION_REVERSE_SUBTRACT").asInstanceOf[scala.Double]

/**
  * Subtract the results of the source and destination fragment multiplies.
  */
@scala.inline
def BLENDEQUATION_SUBTRACT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDEQUATION_SUBTRACT").asInstanceOf[scala.Double]

/**
  * Multiply all fragment components by the alpha value of the destination fragment.
  */
@scala.inline
def BLENDMODE_DST_ALPHA: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_DST_ALPHA").asInstanceOf[scala.Double]

/**
  * Multiply all fragment components by the components of the destination fragment.
  */
@scala.inline
def BLENDMODE_DST_COLOR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_DST_COLOR").asInstanceOf[scala.Double]

/**
  * Multiply all fragment components by one.
  */
@scala.inline
def BLENDMODE_ONE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_ONE").asInstanceOf[scala.Double]

/**
  * Multiply all fragment components by one minus the alpha value of the destination fragment.
  */
@scala.inline
def BLENDMODE_ONE_MINUS_DST_ALPHA: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_ONE_MINUS_DST_ALPHA").asInstanceOf[scala.Double]

/**
  * Multiply all fragment components by one minus the components of the destination fragment.
  */
@scala.inline
def BLENDMODE_ONE_MINUS_DST_COLOR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_ONE_MINUS_DST_COLOR").asInstanceOf[scala.Double]

/**
  * Multiply all fragment components by one minus the alpha value of the source fragment.
  */
@scala.inline
def BLENDMODE_ONE_MINUS_SRC_ALPHA: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_ONE_MINUS_SRC_ALPHA").asInstanceOf[scala.Double]

/**
  * Multiply all fragment components by one minus the components of the source fragment.
  */
@scala.inline
def BLENDMODE_ONE_MINUS_SRC_COLOR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_ONE_MINUS_SRC_COLOR").asInstanceOf[scala.Double]

/**
  * Multiply all fragment components by the alpha value of the source fragment.
  */
@scala.inline
def BLENDMODE_SRC_ALPHA: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_SRC_ALPHA").asInstanceOf[scala.Double]

/**
  * Multiply all fragment components by the alpha value of the source fragment.
  */
@scala.inline
def BLENDMODE_SRC_ALPHA_SATURATE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_SRC_ALPHA_SATURATE").asInstanceOf[scala.Double]

/**
  * Multiply all fragment components by the components of the source fragment.
  */
@scala.inline
def BLENDMODE_SRC_COLOR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_SRC_COLOR").asInstanceOf[scala.Double]

/**
  * Multiply all fragment components by zero.
  */
@scala.inline
def BLENDMODE_ZERO: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLENDMODE_ZERO").asInstanceOf[scala.Double]

/**
  * Add the color of the source fragment to the destination fragment
  * and write the result to the frame buffer.
  */
@scala.inline
def BLEND_ADDITIVE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_ADDITIVE").asInstanceOf[scala.Double]

/**
  * Same as pc.BLEND_ADDITIVE except the source RGB is multiplied by the source alpha.
  */
@scala.inline
def BLEND_ADDITIVEALPHA: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_ADDITIVEALPHA").asInstanceOf[scala.Double]

/**
  * Maximum color. Check app.graphicsDevice.extBlendMinmax for support.
  */
@scala.inline
def BLEND_MAX: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_MAX").asInstanceOf[scala.Double]

/**
  * Minimum color. Check app.graphicsDevice.extBlendMinmax for support.
  */
@scala.inline
def BLEND_MIN: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_MIN").asInstanceOf[scala.Double]

/**
  * Multiply the color of the source fragment by the color of the destination
  * fragment and write the result to the frame buffer.
  */
@scala.inline
def BLEND_MULTIPLICATIVE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_MULTIPLICATIVE").asInstanceOf[scala.Double]

/**
  * Multiplies colors and doubles the result.
  */
@scala.inline
def BLEND_MULTIPLICATIVE2X: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_MULTIPLICATIVE2X").asInstanceOf[scala.Double]

/**
  * Disable blending.
  */
@scala.inline
def BLEND_NONE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_NONE").asInstanceOf[scala.Double]

/**
  * Enable simple translucency for materials such as glass. This is
  * equivalent to enabling a source blend mode of pc.BLENDMODE_SRC_ALPHA and a destination
  * blend mode of pc.BLENDMODE_ONE_MINUS_SRC_ALPHA.
  */
@scala.inline
def BLEND_NORMAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_NORMAL").asInstanceOf[scala.Double]

/**
  * Similar to pc.BLEND_NORMAL expect the source fragment is assumed to have
  * already been multiplied by the source alpha value.
  */
@scala.inline
def BLEND_PREMULTIPLIED: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_PREMULTIPLIED").asInstanceOf[scala.Double]

/**
  * Softer version of additive.
  */
@scala.inline
def BLEND_SCREEN: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_SCREEN").asInstanceOf[scala.Double]

/**
  * Subtract the color of the source fragment from the destination fragment
  * and write the result to the frame buffer.
  */
@scala.inline
def BLEND_SUBTRACTIVE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLEND_SUBTRACTIVE").asInstanceOf[scala.Double]

/**
  * Box filter.
  */
@scala.inline
def BLUR_BOX: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLUR_BOX").asInstanceOf[scala.Double]

/**
  * Gaussian filter. May look smoother than box, but requires more samples.
  */
@scala.inline
def BLUR_GAUSSIAN: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BLUR_GAUSSIAN").asInstanceOf[scala.Double]

/**
  * Rigid body is simulated according to applied forces.
  */
@scala.inline
def BODYTYPE_DYNAMIC: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BODYTYPE_DYNAMIC").asInstanceOf[java.lang.String]

/**
  * Rigid body has infinite mass and does not respond to forces but can still be moved by setting their velocity or position.
  */
@scala.inline
def BODYTYPE_KINEMATIC: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BODYTYPE_KINEMATIC").asInstanceOf[java.lang.String]

/**
  * Rigid body has infinite mass and cannot move.
  */
@scala.inline
def BODYTYPE_STATIC: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BODYTYPE_STATIC").asInstanceOf[java.lang.String]

/**
  * The data store contents will be modified repeatedly and used many times.
  */
@scala.inline
def BUFFER_DYNAMIC: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BUFFER_DYNAMIC").asInstanceOf[scala.Double]

/**
  * The data store contents will be modified repeatedly on the GPU and used many times. Optimal for transform feedback usage (WebGL2 only).
  */
@scala.inline
def BUFFER_GPUDYNAMIC: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BUFFER_GPUDYNAMIC").asInstanceOf[scala.Double]

/**
  * The data store contents will be modified once and used many times.
  */
@scala.inline
def BUFFER_STATIC: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BUFFER_STATIC").asInstanceOf[scala.Double]

/**
  * The data store contents will be modified once and used at most a few times.
  */
@scala.inline
def BUFFER_STREAM: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BUFFER_STREAM").asInstanceOf[scala.Double]

/**
  * Specifies different sprites for the hover, pressed and inactive states.
  */
@scala.inline
def BUTTON_TRANSITION_MODE_SPRITE_CHANGE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BUTTON_TRANSITION_MODE_SPRITE_CHANGE").asInstanceOf[scala.Double]

/**
  * Specifies different color tints for the hover, pressed and inactive states.
  */
@scala.inline
def BUTTON_TRANSITION_MODE_TINT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("BUTTON_TRANSITION_MODE_TINT").asInstanceOf[scala.Double]

/**
  * Clear the color buffer.
  */
@scala.inline
def CLEARFLAG_COLOR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CLEARFLAG_COLOR").asInstanceOf[scala.Double]

/**
  * Clear the depth buffer.
  */
@scala.inline
def CLEARFLAG_DEPTH: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CLEARFLAG_DEPTH").asInstanceOf[scala.Double]

/**
  * Clear the stencil buffer.
  */
@scala.inline
def CLEARFLAG_STENCIL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CLEARFLAG_STENCIL").asInstanceOf[scala.Double]

/**
  * The negative X face of a cubemap.
  */
@scala.inline
def CUBEFACE_NEGX: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEFACE_NEGX").asInstanceOf[scala.Double]

/**
  * The negative Y face of a cubemap.
  */
@scala.inline
def CUBEFACE_NEGY: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEFACE_NEGY").asInstanceOf[scala.Double]

/**
  * The negative Z face of a cubemap.
  */
@scala.inline
def CUBEFACE_NEGZ: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEFACE_NEGZ").asInstanceOf[scala.Double]

/**
  * The positive X face of a cubemap.
  */
@scala.inline
def CUBEFACE_POSX: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEFACE_POSX").asInstanceOf[scala.Double]

/**
  * The positive Y face of a cubemap.
  */
@scala.inline
def CUBEFACE_POSY: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEFACE_POSY").asInstanceOf[scala.Double]

/**
  * The positive Z face of a cubemap.
  */
@scala.inline
def CUBEFACE_POSZ: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEFACE_POSZ").asInstanceOf[scala.Double]

/**
  * The cube map is box-projected based on a world space axis-aligned bounding box.
  */
@scala.inline
def CUBEPROJ_BOX: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEPROJ_BOX").asInstanceOf[scala.Double]

/**
  * The cube map is treated as if it is infinitely far away.
  */
@scala.inline
def CUBEPROJ_NONE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CUBEPROJ_NONE").asInstanceOf[scala.Double]

/**
  * Triangles facing away from the view direction are culled.
  */
@scala.inline
def CULLFACE_BACK: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CULLFACE_BACK").asInstanceOf[scala.Double]

/**
  * Triangles facing the view direction are culled.
  */
@scala.inline
def CULLFACE_FRONT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CULLFACE_FRONT").asInstanceOf[scala.Double]

/**
  * Triangles are culled regardless of their orientation with respect to the view
  * direction. Note that point or line primitives are unaffected by this render state.
  */
@scala.inline
def CULLFACE_FRONTANDBACK: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CULLFACE_FRONTANDBACK").asInstanceOf[scala.Double]

/**
  * No triangles are culled.
  */
@scala.inline
def CULLFACE_NONE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CULLFACE_NONE").asInstanceOf[scala.Double]

/**
  * A cardinal spline interpolation scheme. This interpolation scheme is deprecated. Use CURVE_SPLINE instead.
  */
@scala.inline
def CURVE_CARDINAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CURVE_CARDINAL").asInstanceOf[scala.Double]

/**
  * A Catmull-Rom spline interpolation scheme. This interpolation scheme is deprecated. Use CURVE_SPLINE instead.
  */
@scala.inline
def CURVE_CATMULL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CURVE_CATMULL").asInstanceOf[scala.Double]

/**
  * A linear interpolation scheme.
  */
@scala.inline
def CURVE_LINEAR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CURVE_LINEAR").asInstanceOf[scala.Double]

/**
  * A smooth step interpolation scheme.
  */
@scala.inline
def CURVE_SMOOTHSTEP: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CURVE_SMOOTHSTEP").asInstanceOf[scala.Double]

/**
  * Cardinal spline interpolation scheme. For Catmull-Rom, specify curve tension 0.5.
  */
@scala.inline
def CURVE_SPLINE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CURVE_SPLINE").asInstanceOf[scala.Double]

/**
  * A stepped interpolator, free from the shackles of blending.
  */
@scala.inline
def CURVE_STEP: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("CURVE_STEP").asInstanceOf[scala.Double]

/**
  * Add together the primary and secondary colors.
  */
@scala.inline
def DETAILMODE_ADD: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DETAILMODE_ADD").asInstanceOf[java.lang.String]

/**
  * Select whichever of the primary and secondary colors is lighter, component-wise.
  */
@scala.inline
def DETAILMODE_MAX: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DETAILMODE_MAX").asInstanceOf[java.lang.String]

/**
  * Select whichever of the primary and secondary colors is darker, component-wise.
  */
@scala.inline
def DETAILMODE_MIN: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DETAILMODE_MIN").asInstanceOf[java.lang.String]

/**
  * Multiply together the primary and secondary colors.
  */
@scala.inline
def DETAILMODE_MUL: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DETAILMODE_MUL").asInstanceOf[java.lang.String]

/**
  * Multiplies or screens the colors, depending on the primary color.
  */
@scala.inline
def DETAILMODE_OVERLAY: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DETAILMODE_OVERLAY").asInstanceOf[java.lang.String]

/**
  * Softer version of {@link pc.DETAILMODE_ADD}.
  */
@scala.inline
def DETAILMODE_SCREEN: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DETAILMODE_SCREEN").asInstanceOf[java.lang.String]

/**
  * Exponential distance model.
  */
@scala.inline
def DISTANCE_EXPONENTIAL: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DISTANCE_EXPONENTIAL").asInstanceOf[java.lang.String]

/**
  * Inverse distance model.
  */
@scala.inline
def DISTANCE_INVERSE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DISTANCE_INVERSE").asInstanceOf[java.lang.String]

/**
  * Linear distance model.
  */
@scala.inline
def DISTANCE_LINEAR: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("DISTANCE_LINEAR").asInstanceOf[java.lang.String]

/**
  * A {@link pc.ElementComponent} that contains child {@link pc.ElementComponent}s.
  */
@scala.inline
def ELEMENTTYPE_GROUP: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ELEMENTTYPE_GROUP").asInstanceOf[java.lang.String]

/**
  * A {@link pc.ElementComponent} that displays an image.
  */
@scala.inline
def ELEMENTTYPE_IMAGE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ELEMENTTYPE_IMAGE").asInstanceOf[java.lang.String]

/**
  * A {@link pc.ElementComponent} that displays text.
  */
@scala.inline
def ELEMENTTYPE_TEXT: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ELEMENTTYPE_TEXT").asInstanceOf[java.lang.String]

/**
  * Box shape parameterized by emitterExtents. Initial velocity is directed towards local Z axis.
  */
@scala.inline
def EMITTERSHAPE_BOX: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EMITTERSHAPE_BOX").asInstanceOf[scala.Double]

/**
  * Sphere shape parameterized by emitterRadius. Initial velocity is directed outwards from the center.
  */
@scala.inline
def EMITTERSHAPE_SPHERE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EMITTERSHAPE_SPHERE").asInstanceOf[scala.Double]

/**
  * Name of event fired when a key is pressed.
  */
@scala.inline
def EVENT_KEYDOWN: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_KEYDOWN").asInstanceOf[java.lang.String]

/**
  * Name of event fired when a key is released.
  */
@scala.inline
def EVENT_KEYUP: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_KEYUP").asInstanceOf[java.lang.String]

/**
  * Name of event fired when a mouse button is pressed.
  */
@scala.inline
def EVENT_MOUSEDOWN: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_MOUSEDOWN").asInstanceOf[java.lang.String]

/**
  * Name of event fired when the mouse is moved.
  */
@scala.inline
def EVENT_MOUSEMOVE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_MOUSEMOVE").asInstanceOf[java.lang.String]

/**
  * Name of event fired when a mouse button is released.
  */
@scala.inline
def EVENT_MOUSEUP: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_MOUSEUP").asInstanceOf[java.lang.String]

/**
  * Name of event fired when the mouse wheel is rotated.
  */
@scala.inline
def EVENT_MOUSEWHEEL: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_MOUSEWHEEL").asInstanceOf[java.lang.String]

/**
  * Name of event fired when a new xr select occurs. For example, primary trigger was pressed.
  */
@scala.inline
def EVENT_SELECT: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_SELECT").asInstanceOf[java.lang.String]

/**
  * Name of event fired when xr select ends. For example, a primary trigger is now released.
  */
@scala.inline
def EVENT_SELECTEND: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_SELECTEND").asInstanceOf[java.lang.String]

/**
  * Name of event fired when a new xr select starts. For example, primary trigger is now pressed.
  */
@scala.inline
def EVENT_SELECTSTART: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_SELECTSTART").asInstanceOf[java.lang.String]

/**
  * Name of event fired when a touch point is interrupted in some way.
  * The exact reasons for canceling a touch can vary from device to device.
  * For example, a modal alert pops up during the interaction; the touch point leaves the document area,
  * or there are more touch points than the device supports, in which case the earliest touch point is canceled.
  */
@scala.inline
def EVENT_TOUCHCANCEL: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_TOUCHCANCEL").asInstanceOf[java.lang.String]

/**
  * Name of event fired when touch ends. For example, a finger is lifted off the device.
  */
@scala.inline
def EVENT_TOUCHEND: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_TOUCHEND").asInstanceOf[java.lang.String]

/**
  * Name of event fired when a touch moves.
  */
@scala.inline
def EVENT_TOUCHMOVE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_TOUCHMOVE").asInstanceOf[java.lang.String]

/**
  * Name of event fired when a new touch occurs. For example, a finger is placed on the device.
  */
@scala.inline
def EVENT_TOUCHSTART: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("EVENT_TOUCHSTART").asInstanceOf[java.lang.String]

/**
  * When resizing the window the size of the canvas will change to fill the window exactly.
  */
@scala.inline
def FILLMODE_FILL_WINDOW: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILLMODE_FILL_WINDOW").asInstanceOf[java.lang.String]

/**
  * When resizing the window the size of the canvas will change to fill the window as best it can, while maintaining the same aspect ratio.
  */
@scala.inline
def FILLMODE_KEEP_ASPECT: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILLMODE_KEEP_ASPECT").asInstanceOf[java.lang.String]

/**
  * When resizing the window the size of the canvas will not change.
  */
@scala.inline
def FILLMODE_NONE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILLMODE_NONE").asInstanceOf[java.lang.String]

/**
  * Bilinear filtering.
  */
@scala.inline
def FILTER_LINEAR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_LINEAR").asInstanceOf[scala.Double]

/**
  * Linearly interpolate both the mipmap levels and between texels.
  */
@scala.inline
def FILTER_LINEAR_MIPMAP_LINEAR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_LINEAR_MIPMAP_LINEAR").asInstanceOf[scala.Double]

/**
  * Use the nearest neighbor after linearly interpolating between mipmap levels.
  */
@scala.inline
def FILTER_LINEAR_MIPMAP_NEAREST: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_LINEAR_MIPMAP_NEAREST").asInstanceOf[scala.Double]

/**
  * Point sample filtering.
  */
@scala.inline
def FILTER_NEAREST: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_NEAREST").asInstanceOf[scala.Double]

/**
  * Linearly interpolate in the nearest mipmap level.
  */
@scala.inline
def FILTER_NEAREST_MIPMAP_LINEAR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_NEAREST_MIPMAP_LINEAR").asInstanceOf[scala.Double]

/**
  * Use the nearest neighbor in the nearest mipmap level.
  */
@scala.inline
def FILTER_NEAREST_MIPMAP_NEAREST: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FILTER_NEAREST_MIPMAP_NEAREST").asInstanceOf[scala.Double]

/**
  * Apply both STRETCH and SHRINK fitting logic where applicable.
  */
@scala.inline
def FITTING_BOTH: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FITTING_BOTH").asInstanceOf[scala.Double]

/**
  * Disable all fitting logic.
  */
@scala.inline
def FITTING_NONE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FITTING_NONE").asInstanceOf[scala.Double]

/**
  * Shrink child elements to fit the parent container.
  */
@scala.inline
def FITTING_SHRINK: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FITTING_SHRINK").asInstanceOf[scala.Double]

/**
  * Stretch child elements to fit the parent container.
  */
@scala.inline
def FITTING_STRETCH: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FITTING_STRETCH").asInstanceOf[scala.Double]

/**
  * Fog rises according to an exponential curve controlled by a density value.
  */
@scala.inline
def FOG_EXP: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FOG_EXP").asInstanceOf[java.lang.String]

/**
  * Fog rises according to an exponential curve controlled by a density value.
  */
@scala.inline
def FOG_EXP2: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FOG_EXP2").asInstanceOf[java.lang.String]

/**
  * Fog rises linearly from zero to 1 between a start and end depth.
  */
@scala.inline
def FOG_LINEAR: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FOG_LINEAR").asInstanceOf[java.lang.String]

/**
  * No fog is applied to the scene.
  */
@scala.inline
def FOG_NONE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FOG_NONE").asInstanceOf[java.lang.String]

/**
  * No Fresnel.
  */
@scala.inline
def FRESNEL_NONE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FRESNEL_NONE").asInstanceOf[scala.Double]

/**
  * Schlick's approximation of Fresnel.
  */
@scala.inline
def FRESNEL_SCHLICK: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FRESNEL_SCHLICK").asInstanceOf[scala.Double]

/**
  * Always pass.
  */
@scala.inline
def FUNC_ALWAYS: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_ALWAYS").asInstanceOf[scala.Double]

/**
  * Pass if (ref & mask) == (stencil & mask).
  */
@scala.inline
def FUNC_EQUAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_EQUAL").asInstanceOf[scala.Double]

/**
  * Pass if (ref & mask) > (stencil & mask).
  */
@scala.inline
def FUNC_GREATER: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_GREATER").asInstanceOf[scala.Double]

/**
  * Pass if (ref & mask) >= (stencil & mask).
  */
@scala.inline
def FUNC_GREATEREQUAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_GREATEREQUAL").asInstanceOf[scala.Double]

/**
  * Pass if (ref & mask) < (stencil & mask).
  */
@scala.inline
def FUNC_LESS: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_LESS").asInstanceOf[scala.Double]

/**
  * Pass if (ref & mask) <= (stencil & mask).
  */
@scala.inline
def FUNC_LESSEQUAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_LESSEQUAL").asInstanceOf[scala.Double]

/**
  * Never pass.
  */
@scala.inline
def FUNC_NEVER: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_NEVER").asInstanceOf[scala.Double]

/**
  * Pass if (ref & mask) != (stencil & mask).
  */
@scala.inline
def FUNC_NOTEQUAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("FUNC_NOTEQUAL").asInstanceOf[scala.Double]

/**
  * No gamma correction.
  */
@scala.inline
def GAMMA_NONE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("GAMMA_NONE").asInstanceOf[scala.Double]

/**
  * Apply sRGB gamma correction.
  */
@scala.inline
def GAMMA_SRGB: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("GAMMA_SRGB").asInstanceOf[scala.Double]

/**
  * Apply sRGB (fast) gamma correction.
  */
@scala.inline
def GAMMA_SRGBFAST: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("GAMMA_SRGBFAST").asInstanceOf[scala.Double]

/**
  * Apply sRGB (HDR) gamma correction.
  */
@scala.inline
def GAMMA_SRGBHDR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("GAMMA_SRGBHDR").asInstanceOf[scala.Double]

/**
  * 16-bit unsigned vertex indices (0 to 65,535).
  */
@scala.inline
def INDEXFORMAT_UINT16: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("INDEXFORMAT_UINT16").asInstanceOf[scala.Double]

/**
  * 32-bit unsigned vertex indices (0 to 4,294,967,295).
  */
@scala.inline
def INDEXFORMAT_UINT32: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("INDEXFORMAT_UINT32").asInstanceOf[scala.Double]

/**
  * 8-bit unsigned vertex indices (0 to 255).
  */
@scala.inline
def INDEXFORMAT_UINT8: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("INDEXFORMAT_UINT8").asInstanceOf[scala.Double]

@scala.inline
def KEY_0: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_0").asInstanceOf[scala.Double]

@scala.inline
def KEY_1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_1").asInstanceOf[scala.Double]

@scala.inline
def KEY_2: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_2").asInstanceOf[scala.Double]

@scala.inline
def KEY_3: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_3").asInstanceOf[scala.Double]

@scala.inline
def KEY_4: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_4").asInstanceOf[scala.Double]

@scala.inline
def KEY_5: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_5").asInstanceOf[scala.Double]

@scala.inline
def KEY_6: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_6").asInstanceOf[scala.Double]

@scala.inline
def KEY_7: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_7").asInstanceOf[scala.Double]

@scala.inline
def KEY_8: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_8").asInstanceOf[scala.Double]

@scala.inline
def KEY_9: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_9").asInstanceOf[scala.Double]

@scala.inline
def KEY_A: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_A").asInstanceOf[scala.Double]

@scala.inline
def KEY_ADD: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_ADD").asInstanceOf[scala.Double]

@scala.inline
def KEY_ALT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_ALT").asInstanceOf[scala.Double]

@scala.inline
def KEY_B: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_B").asInstanceOf[scala.Double]

@scala.inline
def KEY_BACKSPACE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_BACKSPACE").asInstanceOf[scala.Double]

@scala.inline
def KEY_BACK_SLASH: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_BACK_SLASH").asInstanceOf[scala.Double]

@scala.inline
def KEY_C: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_C").asInstanceOf[scala.Double]

@scala.inline
def KEY_CAPS_LOCK: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_CAPS_LOCK").asInstanceOf[scala.Double]

@scala.inline
def KEY_CLOSE_BRACKET: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_CLOSE_BRACKET").asInstanceOf[scala.Double]

@scala.inline
def KEY_COMMA: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_COMMA").asInstanceOf[scala.Double]

@scala.inline
def KEY_CONTEXT_MENU: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_CONTEXT_MENU").asInstanceOf[scala.Double]

@scala.inline
def KEY_CONTROL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_CONTROL").asInstanceOf[scala.Double]

@scala.inline
def KEY_D: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_D").asInstanceOf[scala.Double]

@scala.inline
def KEY_DECIMAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_DECIMAL").asInstanceOf[scala.Double]

@scala.inline
def KEY_DELETE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_DELETE").asInstanceOf[scala.Double]

@scala.inline
def KEY_DIVIDE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_DIVIDE").asInstanceOf[scala.Double]

@scala.inline
def KEY_DOWN: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_DOWN").asInstanceOf[scala.Double]

@scala.inline
def KEY_E: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_E").asInstanceOf[scala.Double]

@scala.inline
def KEY_END: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_END").asInstanceOf[scala.Double]

@scala.inline
def KEY_ENTER: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_ENTER").asInstanceOf[scala.Double]

@scala.inline
def KEY_EQUAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_EQUAL").asInstanceOf[scala.Double]

@scala.inline
def KEY_ESCAPE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_ESCAPE").asInstanceOf[scala.Double]

@scala.inline
def KEY_F: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F").asInstanceOf[scala.Double]

@scala.inline
def KEY_F1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F1").asInstanceOf[scala.Double]

@scala.inline
def KEY_F10: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F10").asInstanceOf[scala.Double]

@scala.inline
def KEY_F11: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F11").asInstanceOf[scala.Double]

@scala.inline
def KEY_F12: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F12").asInstanceOf[scala.Double]

@scala.inline
def KEY_F2: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F2").asInstanceOf[scala.Double]

@scala.inline
def KEY_F3: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F3").asInstanceOf[scala.Double]

@scala.inline
def KEY_F4: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F4").asInstanceOf[scala.Double]

@scala.inline
def KEY_F5: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F5").asInstanceOf[scala.Double]

@scala.inline
def KEY_F6: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F6").asInstanceOf[scala.Double]

@scala.inline
def KEY_F7: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F7").asInstanceOf[scala.Double]

@scala.inline
def KEY_F8: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F8").asInstanceOf[scala.Double]

@scala.inline
def KEY_F9: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_F9").asInstanceOf[scala.Double]

@scala.inline
def KEY_G: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_G").asInstanceOf[scala.Double]

@scala.inline
def KEY_H: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_H").asInstanceOf[scala.Double]

@scala.inline
def KEY_HOME: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_HOME").asInstanceOf[scala.Double]

@scala.inline
def KEY_I: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_I").asInstanceOf[scala.Double]

@scala.inline
def KEY_INSERT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_INSERT").asInstanceOf[scala.Double]

@scala.inline
def KEY_J: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_J").asInstanceOf[scala.Double]

@scala.inline
def KEY_K: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_K").asInstanceOf[scala.Double]

@scala.inline
def KEY_L: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_L").asInstanceOf[scala.Double]

@scala.inline
def KEY_LEFT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_LEFT").asInstanceOf[scala.Double]

@scala.inline
def KEY_M: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_M").asInstanceOf[scala.Double]

@scala.inline
def KEY_META: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_META").asInstanceOf[scala.Double]

@scala.inline
def KEY_MULTIPLY: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_MULTIPLY").asInstanceOf[scala.Double]

@scala.inline
def KEY_N: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_N").asInstanceOf[scala.Double]

@scala.inline
def KEY_NUMPAD_0: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_0").asInstanceOf[scala.Double]

@scala.inline
def KEY_NUMPAD_1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_1").asInstanceOf[scala.Double]

@scala.inline
def KEY_NUMPAD_2: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_2").asInstanceOf[scala.Double]

@scala.inline
def KEY_NUMPAD_3: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_3").asInstanceOf[scala.Double]

@scala.inline
def KEY_NUMPAD_4: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_4").asInstanceOf[scala.Double]

@scala.inline
def KEY_NUMPAD_5: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_5").asInstanceOf[scala.Double]

@scala.inline
def KEY_NUMPAD_6: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_6").asInstanceOf[scala.Double]

@scala.inline
def KEY_NUMPAD_7: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_7").asInstanceOf[scala.Double]

@scala.inline
def KEY_NUMPAD_8: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_8").asInstanceOf[scala.Double]

@scala.inline
def KEY_NUMPAD_9: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_NUMPAD_9").asInstanceOf[scala.Double]

@scala.inline
def KEY_O: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_O").asInstanceOf[scala.Double]

@scala.inline
def KEY_OPEN_BRACKET: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_OPEN_BRACKET").asInstanceOf[scala.Double]

@scala.inline
def KEY_P: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_P").asInstanceOf[scala.Double]

@scala.inline
def KEY_PAGE_DOWN: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_PAGE_DOWN").asInstanceOf[scala.Double]

@scala.inline
def KEY_PAGE_UP: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_PAGE_UP").asInstanceOf[scala.Double]

@scala.inline
def KEY_PAUSE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_PAUSE").asInstanceOf[scala.Double]

@scala.inline
def KEY_PERIOD: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_PERIOD").asInstanceOf[scala.Double]

@scala.inline
def KEY_PRINT_SCREEN: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_PRINT_SCREEN").asInstanceOf[scala.Double]

@scala.inline
def KEY_Q: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_Q").asInstanceOf[scala.Double]

@scala.inline
def KEY_R: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_R").asInstanceOf[scala.Double]

@scala.inline
def KEY_RETURN: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_RETURN").asInstanceOf[scala.Double]

@scala.inline
def KEY_RIGHT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_RIGHT").asInstanceOf[scala.Double]

@scala.inline
def KEY_S: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_S").asInstanceOf[scala.Double]

@scala.inline
def KEY_SEMICOLON: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_SEMICOLON").asInstanceOf[scala.Double]

@scala.inline
def KEY_SEPARATOR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_SEPARATOR").asInstanceOf[scala.Double]

@scala.inline
def KEY_SHIFT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_SHIFT").asInstanceOf[scala.Double]

@scala.inline
def KEY_SLASH: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_SLASH").asInstanceOf[scala.Double]

@scala.inline
def KEY_SPACE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_SPACE").asInstanceOf[scala.Double]

@scala.inline
def KEY_SUBTRACT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_SUBTRACT").asInstanceOf[scala.Double]

@scala.inline
def KEY_T: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_T").asInstanceOf[scala.Double]

@scala.inline
def KEY_TAB: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_TAB").asInstanceOf[scala.Double]

@scala.inline
def KEY_U: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_U").asInstanceOf[scala.Double]

@scala.inline
def KEY_UP: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_UP").asInstanceOf[scala.Double]

@scala.inline
def KEY_V: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_V").asInstanceOf[scala.Double]

@scala.inline
def KEY_W: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_W").asInstanceOf[scala.Double]

@scala.inline
def KEY_WINDOWS: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_WINDOWS").asInstanceOf[scala.Double]

@scala.inline
def KEY_X: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_X").asInstanceOf[scala.Double]

@scala.inline
def KEY_Y: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_Y").asInstanceOf[scala.Double]

@scala.inline
def KEY_Z: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("KEY_Z").asInstanceOf[scala.Double]

/**
  * The depth layer.
  */
@scala.inline
def LAYERID_DEPTH: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LAYERID_DEPTH").asInstanceOf[scala.Double]

/**
  * The immediate layer.
  */
@scala.inline
def LAYERID_IMMEDIATE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LAYERID_IMMEDIATE").asInstanceOf[scala.Double]

/**
  * The skybox layer.
  */
@scala.inline
def LAYERID_SKYBOX: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LAYERID_SKYBOX").asInstanceOf[scala.Double]

/**
  * The UI layer.
  */
@scala.inline
def LAYERID_UI: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LAYERID_UI").asInstanceOf[scala.Double]

/**
  * The world layer.
  */
@scala.inline
def LAYERID_WORLD: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LAYERID_WORLD").asInstanceOf[scala.Double]

/**
  * Inverse squared distance falloff model for light attenuation.
  */
@scala.inline
def LIGHTFALLOFF_INVERSESQUARED: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LIGHTFALLOFF_INVERSESQUARED").asInstanceOf[scala.Double]

/**
  * Linear distance falloff model for light attenuation.
  */
@scala.inline
def LIGHTFALLOFF_LINEAR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LIGHTFALLOFF_LINEAR").asInstanceOf[scala.Double]

/**
  * Directional (global) light source.
  */
@scala.inline
def LIGHTTYPE_DIRECTIONAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LIGHTTYPE_DIRECTIONAL").asInstanceOf[scala.Double]

/**
  * Point (local) light source.
  */
@scala.inline
def LIGHTTYPE_POINT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LIGHTTYPE_POINT").asInstanceOf[scala.Double]

/**
  * Spot (local) light source.
  */
@scala.inline
def LIGHTTYPE_SPOT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("LIGHTTYPE_SPOT").asInstanceOf[scala.Double]

/**
  * The left mouse button.
  */
@scala.inline
def MOUSEBUTTON_LEFT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("MOUSEBUTTON_LEFT").asInstanceOf[scala.Double]

/**
  * The middle mouse button.
  */
@scala.inline
def MOUSEBUTTON_MIDDLE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("MOUSEBUTTON_MIDDLE").asInstanceOf[scala.Double]

/**
  * No mouse buttons pressed.
  */
@scala.inline
def MOUSEBUTTON_NONE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("MOUSEBUTTON_NONE").asInstanceOf[scala.Double]

/**
  * The right mouse button.
  */
@scala.inline
def MOUSEBUTTON_RIGHT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("MOUSEBUTTON_RIGHT").asInstanceOf[scala.Double]

/**
  * Horizontal orientation.
  */
@scala.inline
def ORIENTATION_HORIZONTAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ORIENTATION_HORIZONTAL").asInstanceOf[scala.Double]

/**
  * Vertical orientation.
  */
@scala.inline
def ORIENTATION_VERTICAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("ORIENTATION_VERTICAL").asInstanceOf[scala.Double]

/**
  * Index for pad 1.
  */
@scala.inline
def PAD_1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_1").asInstanceOf[scala.Double]

/**
  * Index for pad 2.
  */
@scala.inline
def PAD_2: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_2").asInstanceOf[scala.Double]

/**
  * Index for pad 3.
  */
@scala.inline
def PAD_3: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_3").asInstanceOf[scala.Double]

/**
  * Index for pad 4.
  */
@scala.inline
def PAD_4: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_4").asInstanceOf[scala.Double]

/**
  * Direction pad down.
  */
@scala.inline
def PAD_DOWN: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_DOWN").asInstanceOf[scala.Double]

/**
  * The first face button, from bottom going clockwise.
  */
@scala.inline
def PAD_FACE_1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_FACE_1").asInstanceOf[scala.Double]

/**
  * The second face button, from bottom going clockwise.
  */
@scala.inline
def PAD_FACE_2: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_FACE_2").asInstanceOf[scala.Double]

/**
  * The third face button, from bottom going clockwise.
  */
@scala.inline
def PAD_FACE_3: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_FACE_3").asInstanceOf[scala.Double]

/**
  * The fourth face button, from bottom going clockwise.
  */
@scala.inline
def PAD_FACE_4: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_FACE_4").asInstanceOf[scala.Double]

/**
  * Direction pad left.
  */
@scala.inline
def PAD_LEFT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_LEFT").asInstanceOf[scala.Double]

/**
  * The first shoulder button on the left.
  */
@scala.inline
def PAD_L_SHOULDER_1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_L_SHOULDER_1").asInstanceOf[scala.Double]

/**
  * The second shoulder button on the left.
  */
@scala.inline
def PAD_L_SHOULDER_2: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_L_SHOULDER_2").asInstanceOf[scala.Double]

/**
  * The button when depressing the left analogue stick.
  */
@scala.inline
def PAD_L_STICK_BUTTON: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_L_STICK_BUTTON").asInstanceOf[scala.Double]

/**
  * Horizontal axis on the left analogue stick.
  */
@scala.inline
def PAD_L_STICK_X: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_L_STICK_X").asInstanceOf[scala.Double]

/**
  * Vertical axis on the left analogue stick.
  */
@scala.inline
def PAD_L_STICK_Y: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_L_STICK_Y").asInstanceOf[scala.Double]

/**
  * Direction pad right.
  */
@scala.inline
def PAD_RIGHT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_RIGHT").asInstanceOf[scala.Double]

/**
  * The first shoulder button on the right.
  */
@scala.inline
def PAD_R_SHOULDER_1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_R_SHOULDER_1").asInstanceOf[scala.Double]

/**
  * The second shoulder button on the right.
  */
@scala.inline
def PAD_R_SHOULDER_2: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_R_SHOULDER_2").asInstanceOf[scala.Double]

/**
  * The button when depressing the right analogue stick.
  */
@scala.inline
def PAD_R_STICK_BUTTON: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_R_STICK_BUTTON").asInstanceOf[scala.Double]

/**
  * Horizontal axis on the right analogue stick.
  */
@scala.inline
def PAD_R_STICK_X: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_R_STICK_X").asInstanceOf[scala.Double]

/**
  * Vertical axis on the right analogue stick.
  */
@scala.inline
def PAD_R_STICK_Y: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_R_STICK_Y").asInstanceOf[scala.Double]

/**
  * The select button.
  */
@scala.inline
def PAD_SELECT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_SELECT").asInstanceOf[scala.Double]

/**
  * The start button.
  */
@scala.inline
def PAD_START: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_START").asInstanceOf[scala.Double]

/**
  * Direction pad up.
  */
@scala.inline
def PAD_UP: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_UP").asInstanceOf[scala.Double]

/**
  * Vendor specific button.
  */
@scala.inline
def PAD_VENDOR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PAD_VENDOR").asInstanceOf[scala.Double]

/**
  * Similar to previous, but the normal is affected by emitter(entity) transformation.
  */
@scala.inline
def PARTICLEORIENTATION_EMITTER: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLEORIENTATION_EMITTER").asInstanceOf[scala.Double]

/**
  * Particles are facing camera.
  */
@scala.inline
def PARTICLEORIENTATION_SCREEN: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLEORIENTATION_SCREEN").asInstanceOf[scala.Double]

/**
  * User defines world space normal (particleNormal) to set planes orientation.
  */
@scala.inline
def PARTICLEORIENTATION_WORLD: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLEORIENTATION_WORLD").asInstanceOf[scala.Double]

/**
  * Sorting based on distance to the camera. CPU only.
  */
@scala.inline
def PARTICLESORT_DISTANCE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLESORT_DISTANCE").asInstanceOf[scala.Double]

/**
  * Newer particles are drawn first. CPU only.
  */
@scala.inline
def PARTICLESORT_NEWER_FIRST: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLESORT_NEWER_FIRST").asInstanceOf[scala.Double]

/**
  * No sorting, particles are drawn in arbitrary order. Can be simulated on GPU.
  */
@scala.inline
def PARTICLESORT_NONE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLESORT_NONE").asInstanceOf[scala.Double]

/**
  * Older particles are drawn first. CPU only.
  */
@scala.inline
def PARTICLESORT_OLDER_FIRST: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PARTICLESORT_OLDER_FIRST").asInstanceOf[scala.Double]

/**
  * ATC compressed format with alpha channel in blocks of 4x4.
  */
@scala.inline
def PIXELFORMATASTC4x4: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_ASTC_4x4").asInstanceOf[scala.Double]

/**
  * A floating-point color-only format with 11 bits for red and green channels and 10 bits for the blue channel (WebGL2 only).
  */
@scala.inline
def PIXELFORMAT_111110F: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_111110F").asInstanceOf[scala.Double]

/**
  * 8-bit alpha.
  */
@scala.inline
def PIXELFORMAT_A8: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_A8").asInstanceOf[scala.Double]

/**
  * ATC compressed format with no alpha channel.
  */
@scala.inline
def PIXELFORMAT_ATC_RGB: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_ATC_RGB").asInstanceOf[scala.Double]

/**
  * ATC compressed format with alpha channel.
  */
@scala.inline
def PIXELFORMAT_ATC_RGBA: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_ATC_RGBA").asInstanceOf[scala.Double]

/**
  * A readable depth buffer format.
  */
@scala.inline
def PIXELFORMAT_DEPTH: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_DEPTH").asInstanceOf[scala.Double]

/**
  * A readable depth/stencil buffer format (WebGL2 only).
  */
@scala.inline
def PIXELFORMAT_DEPTHSTENCIL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_DEPTHSTENCIL").asInstanceOf[scala.Double]

/**
  * Block compressed format storing 16 input pixels in 64 bits of output, consisting of two 16-bit RGB 5:6:5 color values and a 4x4 two bit lookup table.
  */
@scala.inline
def PIXELFORMAT_DXT1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_DXT1").asInstanceOf[scala.Double]

/**
  * Block compressed format storing 16 input pixels (corresponding to a 4x4 pixel block) into 128 bits of output, consisting of 64 bits of alpha channel data (4 bits for each pixel) followed by 64 bits of color data; encoded the same way as DXT1.
  */
@scala.inline
def PIXELFORMAT_DXT3: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_DXT3").asInstanceOf[scala.Double]

/**
  * Block compressed format storing 16 input pixels into 128 bits of output, consisting of 64 bits of alpha channel data (two 8 bit alpha values and a 4x4 3 bit lookup table) followed by 64 bits of color data (encoded the same way as DXT1).
  */
@scala.inline
def PIXELFORMAT_DXT5: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_DXT5").asInstanceOf[scala.Double]

/**
  * ETC1 compressed format.
  */
@scala.inline
def PIXELFORMAT_ETC1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_ETC1").asInstanceOf[scala.Double]

/**
  * ETC2 (RGB) compressed format.
  */
@scala.inline
def PIXELFORMAT_ETC2_RGB: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_ETC2_RGB").asInstanceOf[scala.Double]

/**
  * ETC2 (RGBA) compressed format.
  */
@scala.inline
def PIXELFORMAT_ETC2_RGBA: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_ETC2_RGBA").asInstanceOf[scala.Double]

/**
  * 8-bit luminance.
  */
@scala.inline
def PIXELFORMAT_L8: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_L8").asInstanceOf[scala.Double]

/**
  * 8-bit luminance with 8-bit alpha.
  */
@scala.inline
def PIXELFORMAT_L8_A8: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_L8_A8").asInstanceOf[scala.Double]

/**
  * PVRTC (2BPP RGBA) compressed format.
  */
@scala.inline
def PIXELFORMAT_PVRTC_2BPP_RGBA_1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_PVRTC_2BPP_RGBA_1").asInstanceOf[scala.Double]

/**
  * PVRTC (2BPP RGB) compressed format.
  */
@scala.inline
def PIXELFORMAT_PVRTC_2BPP_RGB_1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_PVRTC_2BPP_RGB_1").asInstanceOf[scala.Double]

/**
  * PVRTC (4BPP RGBA) compressed format.
  */
@scala.inline
def PIXELFORMAT_PVRTC_4BPP_RGBA_1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_PVRTC_4BPP_RGBA_1").asInstanceOf[scala.Double]

/**
  * PVRTC (4BPP RGB) compressed format.
  */
@scala.inline
def PIXELFORMAT_PVRTC_4BPP_RGB_1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_PVRTC_4BPP_RGB_1").asInstanceOf[scala.Double]

/**
  * 32-bit floating point single channel format (WebGL2 only).
  */
@scala.inline
def PIXELFORMAT_R32F: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_R32F").asInstanceOf[scala.Double]

/**
  * 16-bit RGBA (4-bits for red channel, 4 for green, 4 for blue with 4-bit alpha).
  */
@scala.inline
def PIXELFORMAT_R4_G4_B4_A4: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_R4_G4_B4_A4").asInstanceOf[scala.Double]

/**
  * 16-bit RGBA (5-bits for red channel, 5 for green, 5 for blue with 1-bit alpha).
  */
@scala.inline
def PIXELFORMAT_R5_G5_B5_A1: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_R5_G5_B5_A1").asInstanceOf[scala.Double]

/**
  * 16-bit RGB (5-bits for red channel, 6 for green and 5 for blue).
  */
@scala.inline
def PIXELFORMAT_R5_G6_B5: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_R5_G6_B5").asInstanceOf[scala.Double]

/**
  * 24-bit RGB (8-bits for red channel, 8 for green and 8 for blue).
  */
@scala.inline
def PIXELFORMAT_R8_G8_B8: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_R8_G8_B8").asInstanceOf[scala.Double]

/**
  * 32-bit RGBA (8-bits for red channel, 8 for green, 8 for blue with 8-bit alpha).
  */
@scala.inline
def PIXELFORMAT_R8_G8_B8_A8: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_R8_G8_B8_A8").asInstanceOf[scala.Double]

/**
  * 16-bit floating point RGB (16-bit float for each red, green and blue channels).
  */
@scala.inline
def PIXELFORMAT_RGB16F: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_RGB16F").asInstanceOf[scala.Double]

/**
  * 32-bit floating point RGB (32-bit float for each red, green and blue channels).
  */
@scala.inline
def PIXELFORMAT_RGB32F: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_RGB32F").asInstanceOf[scala.Double]

/**
  * 16-bit floating point RGBA (16-bit float for each red, green, blue and alpha channels).
  */
@scala.inline
def PIXELFORMAT_RGBA16F: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_RGBA16F").asInstanceOf[scala.Double]

/**
  * 32-bit floating point RGBA (32-bit float for each red, green, blue and alpha channels).
  */
@scala.inline
def PIXELFORMAT_RGBA32F: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_RGBA32F").asInstanceOf[scala.Double]

/**
  * Color-only sRGB format (WebGL2 only).
  */
@scala.inline
def PIXELFORMAT_SRGB: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_SRGB").asInstanceOf[scala.Double]

/**
  * Color sRGB format with additional alpha channel (WebGL2 only).
  */
@scala.inline
def PIXELFORMAT_SRGBA: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PIXELFORMAT_SRGBA").asInstanceOf[scala.Double]

/**
  * List of points that are linked sequentially by line segments, with a closing line segment between the last and first points.
  */
@scala.inline
def PRIMITIVE_LINELOOP: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_LINELOOP").asInstanceOf[scala.Double]

/**
  * Discrete list of line segments.
  */
@scala.inline
def PRIMITIVE_LINES: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_LINES").asInstanceOf[scala.Double]

/**
  * List of points that are linked sequentially by line segments.
  */
@scala.inline
def PRIMITIVE_LINESTRIP: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_LINESTRIP").asInstanceOf[scala.Double]

/**
  * List of distinct points.
  */
@scala.inline
def PRIMITIVE_POINTS: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_POINTS").asInstanceOf[scala.Double]

/**
  * Discrete list of triangles.
  */
@scala.inline
def PRIMITIVE_TRIANGLES: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_TRIANGLES").asInstanceOf[scala.Double]

/**
  * Connected fan of triangles where the first vertex forms triangles with the following pairs of vertices.
  */
@scala.inline
def PRIMITIVE_TRIFAN: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_TRIFAN").asInstanceOf[scala.Double]

/**
  * Connected strip of triangles where a specified vertex forms a triangle using the previous two.
  */
@scala.inline
def PRIMITIVE_TRISTRIP: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PRIMITIVE_TRISTRIP").asInstanceOf[scala.Double]

/**
  * An orthographic camera projection where the frustum shape is essentially a cuboid.
  */
@scala.inline
def PROJECTION_ORTHOGRAPHIC: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PROJECTION_ORTHOGRAPHIC").asInstanceOf[scala.Double]

/**
  * A perspective camera projection where the frustum shape is essentially pyramidal.
  */
@scala.inline
def PROJECTION_PERSPECTIVE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("PROJECTION_PERSPECTIVE").asInstanceOf[scala.Double]

/**
  * Render mesh instance as points.
  */
@scala.inline
def RENDERSTYLE_POINTS: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("RENDERSTYLE_POINTS").asInstanceOf[scala.Double]

/**
  * Render mesh instance as solid geometry.
  */
@scala.inline
def RENDERSTYLE_SOLID: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("RENDERSTYLE_SOLID").asInstanceOf[scala.Double]

/**
  * Render mesh instance as wireframe.
  */
@scala.inline
def RENDERSTYLE_WIREFRAME: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("RENDERSTYLE_WIREFRAME").asInstanceOf[scala.Double]

/**
  * When the canvas is resized the resolution of the canvas will change to match the size of the canvas.
  */
@scala.inline
def RESOLUTION_AUTO: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("RESOLUTION_AUTO").asInstanceOf[java.lang.String]

/**
  * When the canvas is resized the resolution of the canvas will remain at the same value and the output will just be scaled to fit the canvas.
  */
@scala.inline
def RESOLUTION_FIXED: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("RESOLUTION_FIXED").asInstanceOf[java.lang.String]

/**
  * Scale the {@link pc.ScreenComponent} when the application's resolution is different than the ScreenComponent's referenceResolution.
  */
@scala.inline
def SCALEMODE_BLEND: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCALEMODE_BLEND").asInstanceOf[java.lang.String]

/**
  * Always use the application's resolution as the resolution for the {@link pc.ScreenComponent}.
  */
@scala.inline
def SCALEMODE_NONE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCALEMODE_NONE").asInstanceOf[java.lang.String]

/**
  * The scrollbar will be visible all the time.
  */
@scala.inline
def SCROLLBAR_VISIBILITY_SHOW_ALWAYS: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCROLLBAR_VISIBILITY_SHOW_ALWAYS").asInstanceOf[scala.Double]

/**
  * The scrollbar will be visible only when content exceeds the size of the viewport.
  */
@scala.inline
def SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCROLLBAR_VISIBILITY_SHOW_WHEN_REQUIRED").asInstanceOf[scala.Double]

/**
  * Content scrolls past its bounds and then gently bounces back.
  */
@scala.inline
def SCROLL_MODE_BOUNCE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCROLL_MODE_BOUNCE").asInstanceOf[scala.Double]

/**
  * Content does not scroll any further than its bounds.
  */
@scala.inline
def SCROLL_MODE_CLAMP: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCROLL_MODE_CLAMP").asInstanceOf[scala.Double]

/**
  * Content can scroll forever.
  */
@scala.inline
def SCROLL_MODE_INFINITE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SCROLL_MODE_INFINITE").asInstanceOf[scala.Double]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR0: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR0").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR1: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR1").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR10: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR10").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR11: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR11").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR12: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR12").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR13: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR13").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR14: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR14").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR15: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR15").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR2: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR2").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR3: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR3").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR4: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR4").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR5: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR5").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR6: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR6").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR7: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR7").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR8: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR8").asInstanceOf[java.lang.String]

/**
  * Vertex attribute with a user defined semantic.
  */
@scala.inline
def SEMANTIC_ATTR9: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_ATTR9").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as skin blend indices.
  */
@scala.inline
def SEMANTIC_BLENDINDICES: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_BLENDINDICES").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as skin blend weights.
  */
@scala.inline
def SEMANTIC_BLENDWEIGHT: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_BLENDWEIGHT").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as a color.
  */
@scala.inline
def SEMANTIC_COLOR: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_COLOR").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as a normal.
  */
@scala.inline
def SEMANTIC_NORMAL: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_NORMAL").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as a position.
  */
@scala.inline
def SEMANTIC_POSITION: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_POSITION").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as a tangent.
  */
@scala.inline
def SEMANTIC_TANGENT: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TANGENT").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as a texture coordinate (set 0).
  */
@scala.inline
def SEMANTIC_TEXCOORD0: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD0").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as a texture coordinate (set 1).
  */
@scala.inline
def SEMANTIC_TEXCOORD1: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD1").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as a texture coordinate (set 2).
  */
@scala.inline
def SEMANTIC_TEXCOORD2: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD2").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as a texture coordinate (set 3).
  */
@scala.inline
def SEMANTIC_TEXCOORD3: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD3").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as a texture coordinate (set 4).
  */
@scala.inline
def SEMANTIC_TEXCOORD4: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD4").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as a texture coordinate (set 5).
  */
@scala.inline
def SEMANTIC_TEXCOORD5: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD5").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as a texture coordinate (set 6).
  */
@scala.inline
def SEMANTIC_TEXCOORD6: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD6").asInstanceOf[java.lang.String]

/**
  * Vertex attribute to be treated as a texture coordinate (set 7).
  */
@scala.inline
def SEMANTIC_TEXCOORD7: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SEMANTIC_TEXCOORD7").asInstanceOf[java.lang.String]

/**
  * Render RGBA-encoded depth value.
  */
@scala.inline
def SHADER_DEPTH: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADER_DEPTH").asInstanceOf[scala.Double]

/**
  * Render shaded materials with gamma correction and tonemapping.
  */
@scala.inline
def SHADER_FORWARD: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADER_FORWARD").asInstanceOf[scala.Double]

/**
  * Render shaded materials without gamma correction and tonemapping.
  */
@scala.inline
def SHADER_FORWARDHDR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADER_FORWARDHDR").asInstanceOf[scala.Double]

/**
  * The shadow map is not to be updated.
  */
@scala.inline
def SHADOWUPDATE_NONE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOWUPDATE_NONE").asInstanceOf[scala.Double]

/**
  * The shadow map is regenerated every frame.
  */
@scala.inline
def SHADOWUPDATE_REALTIME: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOWUPDATE_REALTIME").asInstanceOf[scala.Double]

/**
  * The shadow map is regenerated this frame and not on subsequent frames.
  */
@scala.inline
def SHADOWUPDATE_THISFRAME: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOWUPDATE_THISFRAME").asInstanceOf[scala.Double]

/**
  * Render depth (color-packed on WebGL 1.0), can be used for PCF 3x3 sampling.
  */
@scala.inline
def SHADOW_PCF3: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOW_PCF3").asInstanceOf[scala.Double]

/**
  * Render depth buffer only, can be used for hardware-accelerated PCF 5x5 sampling. Requires WebGL2. Falls back to pc.SHADOW_PCF3 on WebGL 1.0.
  */
@scala.inline
def SHADOW_PCF5: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOW_PCF5").asInstanceOf[scala.Double]

/**
  * Render 16-bit exponential variance shadow map. Requires OES_texture_half_float extension. Falls back to pc.SHADOW_VSM8, if not supported.
  */
@scala.inline
def SHADOW_VSM16: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOW_VSM16").asInstanceOf[scala.Double]

/**
  * Render 32-bit exponential variance shadow map. Requires OES_texture_float extension. Falls back to pc.SHADOW_VSM16, if not supported.
  */
@scala.inline
def SHADOW_VSM32: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOW_VSM32").asInstanceOf[scala.Double]

/**
  * Render packed variance shadow map. All shadow receivers must also cast shadows for this mode to work correctly.
  */
@scala.inline
def SHADOW_VSM8: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SHADOW_VSM8").asInstanceOf[scala.Double]

/**
  * Mesh instances are sorted back to front. This is the way to properly render many semi-transparent objects on different depth, one is blended on top of another.
  */
@scala.inline
def SORTMODE_BACK2FRONT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SORTMODE_BACK2FRONT").asInstanceOf[scala.Double]

/**
  * Mesh instances are sorted front to back. Depending on GPU and the scene, this option may give better performance than pc.SORTMODE_MATERIALMESH due to reduced overdraw.
  */
@scala.inline
def SORTMODE_FRONT2BACK: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SORTMODE_FRONT2BACK").asInstanceOf[scala.Double]

/**
  * Mesh instances are sorted based on {@link pc.MeshInstance#drawOrder}.
  */
@scala.inline
def SORTMODE_MANUAL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SORTMODE_MANUAL").asInstanceOf[scala.Double]

/**
  * Mesh instances are sorted to minimize switching between materials and meshes to improve rendering performance.
  */
@scala.inline
def SORTMODE_MATERIALMESH: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SORTMODE_MATERIALMESH").asInstanceOf[scala.Double]

/**
  * No sorting is applied. Mesh instances are rendered in the same order they were added to a layer.
  */
@scala.inline
def SORTMODE_NONE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SORTMODE_NONE").asInstanceOf[scala.Double]

/**
  * Use AO directly to occlude specular.
  */
@scala.inline
def SPECOCC_AO: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPECOCC_AO").asInstanceOf[scala.Double]

/**
  * Modify AO based on material glossiness/view angle to occlude specular.
  */
@scala.inline
def SPECOCC_GLOSSDEPENDENT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPECOCC_GLOSSDEPENDENT").asInstanceOf[scala.Double]

/**
  * No specular occlusion.
  */
@scala.inline
def SPECOCC_NONE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPECOCC_NONE").asInstanceOf[scala.Double]

/**
  * Energy-conserving Blinn-Phong.
  */
@scala.inline
def SPECULAR_BLINN: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPECULAR_BLINN").asInstanceOf[scala.Double]

/**
  * Phong without energy conservation. You should only use it as a backwards compatibility with older projects.
  */
@scala.inline
def SPECULAR_PHONG: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPECULAR_PHONG").asInstanceOf[scala.Double]

/**
  * A {@link pc.SpriteComponent} that renders sprite animations.
  */
@scala.inline
def SPRITETYPE_ANIMATED: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPRITETYPE_ANIMATED").asInstanceOf[java.lang.String]

/**
  * A {@link pc.SpriteComponent} that displays a single frame from a sprite asset.
  */
@scala.inline
def SPRITETYPE_SIMPLE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPRITETYPE_SIMPLE").asInstanceOf[java.lang.String]

/**
  * This mode renders a sprite as a simple quad.
  */
@scala.inline
def SPRITE_RENDERMODE_SIMPLE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPRITE_RENDERMODE_SIMPLE").asInstanceOf[scala.Double]

/**
  * This mode renders a sprite using 9-slicing in 'sliced' mode. Sliced mode stretches the
  * top and bottom regions of the sprite horizontally, the left and right regions vertically and the middle region
  * both horizontally and vertically.
  */
@scala.inline
def SPRITE_RENDERMODE_SLICED: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPRITE_RENDERMODE_SLICED").asInstanceOf[scala.Double]

/**
  * This mode renders a sprite using 9-slicing in 'tiled' mode. Tiled mode tiles the
  * top and bottom regions of the sprite horizontally, the left and right regions vertically and the middle region
  * both horizontally and vertically.
  */
@scala.inline
def SPRITE_RENDERMODE_TILED: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("SPRITE_RENDERMODE_TILED").asInstanceOf[scala.Double]

/**
  * Decrement the value.
  */
@scala.inline
def STENCILOP_DECREMENT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_DECREMENT").asInstanceOf[scala.Double]

/**
  * Decrement the value but wrap it to a maximum representable value if the current value is 0.
  */
@scala.inline
def STENCILOP_DECREMENTWRAP: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_DECREMENTWRAP").asInstanceOf[scala.Double]

/**
  * Increment the value.
  */
@scala.inline
def STENCILOP_INCREMENT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_INCREMENT").asInstanceOf[scala.Double]

/**
  * Increment the value but wrap it to zero when it's larger than a maximum representable value.
  */
@scala.inline
def STENCILOP_INCREMENTWRAP: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_INCREMENTWRAP").asInstanceOf[scala.Double]

/**
  * Invert the value bitwise.
  */
@scala.inline
def STENCILOP_INVERT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_INVERT").asInstanceOf[scala.Double]

/**
  * Don't change the stencil buffer value.
  */
@scala.inline
def STENCILOP_KEEP: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_KEEP").asInstanceOf[scala.Double]

/**
  * Replace value with the reference value (see {@link pc.GraphicsDevice#setStencilFunc}).
  */
@scala.inline
def STENCILOP_REPLACE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_REPLACE").asInstanceOf[scala.Double]

/**
  * Set value to zero.
  */
@scala.inline
def STENCILOP_ZERO: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("STENCILOP_ZERO").asInstanceOf[scala.Double]

/**
  * Read only. Any changes to the locked mip level's pixels will not update the texture.
  */
@scala.inline
def TEXTURELOCK_READ: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TEXTURELOCK_READ").asInstanceOf[scala.Double]

/**
  * Write only. The contents of the specified mip level will be entirely replaced.
  */
@scala.inline
def TEXTURELOCK_WRITE: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TEXTURELOCK_WRITE").asInstanceOf[scala.Double]

/**
  * Texture is a default type.
  */
@scala.inline
def TEXTURETYPE_DEFAULT: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TEXTURETYPE_DEFAULT").asInstanceOf[java.lang.String]

/**
  * Texture stores high dynamic range data in RGBE format
  */
@scala.inline
def TEXTURETYPE_RGBE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TEXTURETYPE_RGBE").asInstanceOf[java.lang.String]

/**
  * Texture stores high dynamic range data in RGBM format
  */
@scala.inline
def TEXTURETYPE_RGBM: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TEXTURETYPE_RGBM").asInstanceOf[java.lang.String]

/**
  * Texture stores normalmap data swizzled in GGGR format. This is used for tangent space normal
  * maps. The R component is stored in alpha and G is stored in RGB. This packing can result in higher quality
  * when the texture data is compressed.
  */
@scala.inline
def TEXTURETYPE_SWIZZLEGGGR: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TEXTURETYPE_SWIZZLEGGGR").asInstanceOf[java.lang.String]

/**
  * ACES filmic tonemapping curve.
  */
@scala.inline
def TONEMAP_ACES: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TONEMAP_ACES").asInstanceOf[scala.Double]

/**
  * ACES v2 filmic tonemapping curve.
  */
@scala.inline
def TONEMAP_ACES2: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TONEMAP_ACES2").asInstanceOf[scala.Double]

/**
  * Filmic tonemapping curve.
  */
@scala.inline
def TONEMAP_FILMIC: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TONEMAP_FILMIC").asInstanceOf[scala.Double]

/**
  * Hejl filmic tonemapping curve.
  */
@scala.inline
def TONEMAP_HEJL: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TONEMAP_HEJL").asInstanceOf[scala.Double]

/**
  * Linear tonemapping.
  */
@scala.inline
def TONEMAP_LINEAR: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TONEMAP_LINEAR").asInstanceOf[scala.Double]

/**
  * Floating point vertex element type.
  */
@scala.inline
def TYPE_FLOAT32: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_FLOAT32").asInstanceOf[scala.Double]

/**
  * Signed short vertex element type.
  */
@scala.inline
def TYPE_INT16: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_INT16").asInstanceOf[scala.Double]

/**
  * Signed integer vertex element type.
  */
@scala.inline
def TYPE_INT32: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_INT32").asInstanceOf[scala.Double]

/**
  * Signed byte vertex element type.
  */
@scala.inline
def TYPE_INT8: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_INT8").asInstanceOf[scala.Double]

/**
  * Unsigned short vertex element type.
  */
@scala.inline
def TYPE_UINT16: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_UINT16").asInstanceOf[scala.Double]

/**
  * Unsigned integer vertex element type.
  */
@scala.inline
def TYPE_UINT32: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_UINT32").asInstanceOf[scala.Double]

/**
  * Unsigned byte vertex element type.
  */
@scala.inline
def TYPE_UINT8: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("TYPE_UINT8").asInstanceOf[scala.Double]

/**
  * Center of view.
  */
@scala.inline
def VIEW_CENTER: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("VIEW_CENTER").asInstanceOf[scala.Double]

/**
  * Left of view. Only used in stereo rendering.
  */
@scala.inline
def VIEW_LEFT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("VIEW_LEFT").asInstanceOf[scala.Double]

/**
  * Right of view. Only used in stereo rendering.
  */
@scala.inline
def VIEW_RIGHT: scala.Double = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("VIEW_RIGHT").asInstanceOf[scala.Double]

/**
  * Left - indicates that input source is meant to be held in left hand.
  */
@scala.inline
def XRHAND_LEFT: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRHAND_LEFT").asInstanceOf[java.lang.String]

/**
  * None - input source is not meant to be held in hands.
  */
@scala.inline
def XRHAND_NONE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRHAND_NONE").asInstanceOf[java.lang.String]

/**
  * Right - indicates that input source is meant to be held in right hand.
  */
@scala.inline
def XRHAND_RIGHT: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRHAND_RIGHT").asInstanceOf[java.lang.String]

/**
  * Bounded Floor - represents a tracking space with its native origin at the floor, where the user
  * is expected to move within a pre-established boundary. Tracking in a bounded-floor reference space is optimized
  * for keeping the native origin and bounds geometry stable relative to the users environment.
  */
@scala.inline
def XRSPACE_BOUNDEDFLOOR: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRSPACE_BOUNDEDFLOOR").asInstanceOf[java.lang.String]

/**
  * Local - represents a tracking space with a native origin near the viewer at the time of creation.
  * The exact position and orientation will be initialized based on the conventions of the underlying platform.
  * When using this reference space the user is not expected to move beyond their initial position much, if at all,
  * and tracking is optimized for that purpose. For devices with 6DoF tracking, local reference spaces should
  * emphasize keeping the origin stable relative to the users environment.
  */
@scala.inline
def XRSPACE_LOCAL: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRSPACE_LOCAL").asInstanceOf[java.lang.String]

/**
  * Local Floor - represents a tracking space with a native origin at the floor in a safe position for
  * the user to stand. The y axis equals 0 at floor level, with the x and z position and orientation initialized
  * based on the conventions of the underlying platform. Floor level value might be estimated by the underlying
  * platform. When using this reference space, the user is not expected to move beyond their initial position much,
  * if at all, and tracking is optimized for that purpose. For devices with 6DoF tracking, local-floor reference
  * spaces should emphasize keeping the origin stable relative to the users environment.
  */
@scala.inline
def XRSPACE_LOCALFLOOR: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRSPACE_LOCALFLOOR").asInstanceOf[java.lang.String]

/**
  * Unbounded - represents a tracking space where the user is expected to move freely around their
  * environment, potentially even long distances from their starting point. Tracking in an unbounded reference space
  * is optimized for stability around the users current position, and as such the native origin may drift over time.
  */
@scala.inline
def XRSPACE_UNBOUNDED: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRSPACE_UNBOUNDED").asInstanceOf[java.lang.String]

/**
  * Viewer - always supported space with some basic tracking capabilities.
  */
@scala.inline
def XRSPACE_VIEWER: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRSPACE_VIEWER").asInstanceOf[java.lang.String]

/**
  * Gaze - indicates the target ray will originate at the viewer and follow the direction it is facing. (This is commonly referred to as a "gaze input" device in the context of head-mounted displays.)
  */
@scala.inline
def XRTARGETRAY_GAZE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTARGETRAY_GAZE").asInstanceOf[java.lang.String]

/**
  * Tracked Pointer - indicates that the target ray originates from either a handheld device or other hand-tracking mechanism and represents that the user is using their hands or the held device for pointing.
  */
@scala.inline
def XRTARGETRAY_POINTER: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTARGETRAY_POINTER").asInstanceOf[java.lang.String]

/**
  * Screen - indicates that the input source was an interaction with the canvas element associated with an inline sessions output context, such as a mouse click or touch event.
  */
@scala.inline
def XRTARGETRAY_SCREEN: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTARGETRAY_SCREEN").asInstanceOf[java.lang.String]

/**
  * Mesh - indicates that the hit test results will be computed based on the meshes detected by the underlying Augmented Reality system.
  */
@scala.inline
def XRTRACKABLE_MESH: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTRACKABLE_MESH").asInstanceOf[java.lang.String]

/**
  * Plane - indicates that the hit test results will be computed based on the planes detected by the underlying Augmented Reality system.
  */
@scala.inline
def XRTRACKABLE_PLANE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTRACKABLE_PLANE").asInstanceOf[java.lang.String]

/**
  * Point - indicates that the hit test results will be computed based on the feature points detected by the underlying Augmented Reality system.
  */
@scala.inline
def XRTRACKABLE_POINT: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTRACKABLE_POINT").asInstanceOf[java.lang.String]

/**
  * Immersive AR - session that provides exclusive access to VR/AR device that is intended to be blended
  * with real-world environment.
  */
@scala.inline
def XRTYPE_AR: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTYPE_AR").asInstanceOf[java.lang.String]

/**
  * Inline - always available type of session. It has limited features availability and is rendered
  * into HTML element.
  */
@scala.inline
def XRTYPE_INLINE: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTYPE_INLINE").asInstanceOf[java.lang.String]

/**
  * Immersive VR - session that provides exclusive access to VR device with best available tracking
  * features.
  */
@scala.inline
def XRTYPE_VR: java.lang.String = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("XRTYPE_VR").asInstanceOf[java.lang.String]

/**
  * Generates normal information from the specified positions and
  * triangle indices. See {@link pc.createMesh}.
  * @example
  * var normals = pc.calculateNormals(positions, indices);
  * var tangents = pc.calculateTangents(positions, normals, uvs, indices);
  * var mesh = pc.createMesh(positions, normals, tangents, uvs, indices);
  * @param positions - An array of 3-dimensional vertex positions.
  * @param indices - An array of triangle indices.
  * @returns An array of 3-dimensional vertex normals.
  */
@scala.inline
def calculateNormals(positions: js.Array[scala.Double], indices: js.Array[scala.Double]): js.Array[scala.Double] = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("calculateNormals")(positions.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Array[scala.Double]]

/**
  * Generates tangent information from the specified positions,
  * normals, texture coordinates and triangle indices. See {@link pc.createMesh}.
  * @example
  * var tangents = pc.calculateTangents(positions, normals, uvs, indices);
  * var mesh = pc.createMesh(positions, normals, tangents, uvs, indices);
  * @param positions - An array of 3-dimensional vertex positions.
  * @param normals - An array of 3-dimensional vertex normals.
  * @param uvs - An array of 2-dimensional vertex texture coordinates.
  * @param indices - An array of triangle indices.
  * @returns An array of 3-dimensional vertex tangents.
  */
@scala.inline
def calculateTangents(
  positions: js.Array[scala.Double],
  normals: js.Array[scala.Double],
  uvs: js.Array[scala.Double],
  indices: js.Array[scala.Double]
): js.Array[scala.Double] = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("calculateTangents")(positions.asInstanceOf[js.Any], normals.asInstanceOf[js.Any], uvs.asInstanceOf[js.Any], indices.asInstanceOf[js.Any])).asInstanceOf[js.Array[scala.Double]]

/**
  * Creates a procedural box-shaped mesh.
  *
  * The size, shape and tesselation properties of the box can be controlled via function parameters. By
  * default, the function will create a box centered on the object space origin with a width, length and
  * height of 1.0 unit and 10 segments in either axis (50 triangles per face).
  *
  * Note that the box is created with UVs in the range of 0 to 1 on each face. Additionally, tangent
  * information is generated into the vertex buffer of the box's mesh.
  * @param device - The graphics device used to manage the mesh.
  * @param [opts] - An object that specifies optional inputs for the function as follows:
  * @param [opts.halfExtents] - The half dimensions of the box in each axis (defaults to [0.5, 0.5, 0.5]).
  * @param [opts.widthSegments] - The number of divisions along the X axis of the box (defaults to 1).
  * @param [opts.lengthSegments] - The number of divisions along the Z axis of the box (defaults to 1).
  * @param [opts.heightSegments] - The number of divisions along the Y axis of the box (defaults to 1).
  * @returns A new box-shaped mesh.
  */
@scala.inline
def createBox(device: typings.playcanvas.pc.GraphicsDevice): typings.playcanvas.pc.Mesh = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createBox")(device.asInstanceOf[js.Any]).asInstanceOf[typings.playcanvas.pc.Mesh]
@scala.inline
def createBox(device: typings.playcanvas.pc.GraphicsDevice, opts: typings.playcanvas.anon.HeightSegments): typings.playcanvas.pc.Mesh = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createBox")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typings.playcanvas.pc.Mesh]

/**
  * Creates a procedural capsule-shaped mesh.
  *
  * The size, shape and tesselation properties of the capsule can be controlled via function
  * parameters. By default, the function will create a capsule standing vertically centered
  * on the XZ-plane with a radius of 0.25, a height of 1.0, 1 height segment and 10 cap
  * segments.
  *
  * Note that the capsule is created with UVs in the range of 0 to 1. Additionally, tangent information
  * is generated into the vertex buffer of the capsule's mesh.
  * @param device - The graphics device used to manage the mesh.
  * @param [opts] - An object that specifies optional inputs for the function as follows:
  * @param [opts.radius] - The radius of the tube forming the body of the capsule (defaults to 0.3).
  * @param [opts.height] - The length of the body of the capsule from tip to tip (defaults to 1.0).
  * @param [opts.heightSegments] - The number of divisions along the tubular length of the capsule (defaults to 1).
  * @param [opts.sides] - The number of divisions around the tubular body of the capsule (defaults to 20).
  * @returns A new cylinder-shaped mesh.
  */
@scala.inline
def createCapsule(device: typings.playcanvas.pc.GraphicsDevice): typings.playcanvas.pc.Mesh = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createCapsule")(device.asInstanceOf[js.Any]).asInstanceOf[typings.playcanvas.pc.Mesh]
@scala.inline
def createCapsule(device: typings.playcanvas.pc.GraphicsDevice, opts: typings.playcanvas.anon.Height): typings.playcanvas.pc.Mesh = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createCapsule")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typings.playcanvas.pc.Mesh]

/**
  * Creates a procedural cone-shaped mesh.
  *
  * The size, shape and tesselation properties of the cone can be controlled via function
  * parameters. By default, the function will create a cone standing vertically centered
  * on the XZ-plane with a base radius of 0.5, a height of 1.0, 5 height segments and 20
  * cap segments.
  *
  * Note that the cone is created with UVs in the range of 0 to 1. Additionally, tangent
  * information is generated into the vertex buffer of the cone's mesh.
  * @param device - The graphics device used to manage the mesh.
  * @param [opts] - An object that specifies optional inputs for the function as follows:
  * @param [opts.baseRadius] - The base radius of the cone (defaults to 0.5).
  * @param [opts.peakRadius] - The peak radius of the cone (defaults to 0.0).
  * @param [opts.height] - The length of the body of the cone (defaults to 1.0).
  * @param [opts.heightSegments] - The number of divisions along the length of the cone (defaults to 5).
  * @param [opts.capSegments] - The number of divisions around the tubular body of the cone (defaults to 18).
  * @returns A new cone-shaped mesh.
  */
@scala.inline
def createCone(device: typings.playcanvas.pc.GraphicsDevice): typings.playcanvas.pc.Mesh = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createCone")(device.asInstanceOf[js.Any]).asInstanceOf[typings.playcanvas.pc.Mesh]
@scala.inline
def createCone(device: typings.playcanvas.pc.GraphicsDevice, opts: typings.playcanvas.anon.BaseRadius): typings.playcanvas.pc.Mesh = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createCone")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typings.playcanvas.pc.Mesh]

/**
  * Creates a procedural cylinder-shaped mesh.
  *
  * The size, shape and tesselation properties of the cylinder can be controlled via function parameters.
  * By default, the function will create a cylinder standing vertically centered on the XZ-plane with a radius
  * of 0.5, a height of 1.0, 1 height segment and 20 cap segments.
  *
  * Note that the cylinder is created with UVs in the range of 0 to 1. Additionally, tangent information
  * is generated into the vertex buffer of the cylinder's mesh.
  * @param device - The graphics device used to manage the mesh.
  * @param [opts] - An object that specifies optional inputs for the function as follows:
  * @param [opts.radius] - The radius of the tube forming the body of the cylinder (defaults to 0.5).
  * @param [opts.height] - The length of the body of the cylinder (defaults to 1.0).
  * @param [opts.heightSegments] - The number of divisions along the length of the cylinder (defaults to 5).
  * @param [opts.capSegments] - The number of divisions around the tubular body of the cylinder (defaults to 20).
  * @returns A new cylinder-shaped mesh.
  */
@scala.inline
def createCylinder(device: typings.playcanvas.pc.GraphicsDevice): typings.playcanvas.pc.Mesh = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createCylinder")(device.asInstanceOf[js.Any]).asInstanceOf[typings.playcanvas.pc.Mesh]
@scala.inline
def createCylinder(device: typings.playcanvas.pc.GraphicsDevice, opts: typings.playcanvas.anon.CapSegments): typings.playcanvas.pc.Mesh = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createCylinder")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typings.playcanvas.pc.Mesh]

/**
  * Creates a new mesh object from the supplied vertex information and topology.
  * @example
  * // Create a simple, indexed triangle (with texture coordinates and vertex normals)
  * var mesh = pc.createMesh(graphicsDevice, [0, 0, 0, 1, 0, 0, 0, 1, 0], {
  *     normals: [0, 0, 1, 0, 0, 1, 0, 0, 1],
  *     uvs: [0, 0, 1, 0, 0, 1],
  *     indices: [0, 1, 2]
  * });
  * @param device - The graphics device used to manage the mesh.
  * @param positions - An array of 3-dimensional vertex positions.
  * @param [opts] - An object that specifies optional inputs for the function as follows:
  * @param [opts.normals] - An array of 3-dimensional vertex normals.
  * @param [opts.tangents] - An array of 3-dimensional vertex tangents.
  * @param [opts.colors] - An array of 4-dimensional vertex colors where each
  * component is an integer in the range 0 to 255.
  * @param [opts.uvs] - An array of 2-dimensional vertex texture coordinates.
  * @param [opts.uvs1] - Same as opts.uvs, but for additional UV set
  * @param [opts.blendIndices] - An array of 4-dimensional bone indices where each
  * component is an integer in the range 0 to 255.
  * @param [opts.blendWeights] - An array of 4-dimensional bone weights where each
  * component is in the range 0 to 1 and the sum of the weights should equal 1.
  * @param [opts.indices] - An array of triangle indices.
  * @returns A new Mesh constructed from the supplied vertex and triangle data.
  */
@scala.inline
def createMesh(device: typings.playcanvas.pc.GraphicsDevice, positions: js.Array[scala.Double]): typings.playcanvas.pc.Mesh = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createMesh")(device.asInstanceOf[js.Any], positions.asInstanceOf[js.Any])).asInstanceOf[typings.playcanvas.pc.Mesh]
@scala.inline
def createMesh(
  device: typings.playcanvas.pc.GraphicsDevice,
  positions: js.Array[scala.Double],
  opts: typings.playcanvas.anon.BlendIndices
): typings.playcanvas.pc.Mesh = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createMesh")(device.asInstanceOf[js.Any], positions.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typings.playcanvas.pc.Mesh]

/**
  * Creates a procedural plane-shaped mesh.
  *
  * The size and tesselation properties of the plane can be controlled via function
  * parameters. By default, the function will create a plane centered on the object
  * space origin with a width and length of 1.0 and 5 segments in either axis (50
  * triangles). The normal vector of the plane is aligned along the positive Y axis.
  *
  * Note that the plane is created with UVs in the range of 0 to 1. Additionally, tangent
  * information is generated into the vertex buffer of the plane's mesh.
  * @param device - The graphics device used to manage the mesh.
  * @param [opts] - An object that specifies optional inputs for the function as follows:
  * @param [opts.halfExtents] - The half dimensions of the plane in the X and Z axes (defaults to [0.5, 0.5]).
  * @param [opts.widthSegments] - The number of divisions along the X axis of the plane (defaults to 5).
  * @param [opts.lengthSegments] - The number of divisions along the Z axis of the plane (defaults to 5).
  * @returns A new plane-shaped mesh.
  */
@scala.inline
def createPlane(device: typings.playcanvas.pc.GraphicsDevice): typings.playcanvas.pc.Mesh = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createPlane")(device.asInstanceOf[js.Any]).asInstanceOf[typings.playcanvas.pc.Mesh]
@scala.inline
def createPlane(device: typings.playcanvas.pc.GraphicsDevice, opts: typings.playcanvas.anon.HalfExtents): typings.playcanvas.pc.Mesh = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createPlane")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typings.playcanvas.pc.Mesh]

/**
  * Create and register a new {@link pc.ScriptType}.
  * It returns new class type (constructor function), which is auto-registered to {@link pc.ScriptRegistry} using it's name.
  * This is the main interface to create Script Types, to define custom logic using JavaScript, that is used to create interaction for entities.
  * @example
  * var Turning = pc.createScript('turn');
  *
  * // define `speed` attribute that is available in Editor UI
  * Turning.attributes.add('speed', {
  *     type: 'number',
  *     default: 180,
  *     placeholder: 'deg/s'
  * });
  *
  * // runs every tick
  * Turning.prototype.update = function (dt) {
  *     this.entity.rotate(0, this.speed * dt, 0);
  * };
  * @param name - Unique Name of a Script Type.
  * If a Script Type with the same name has already been registered and the new one has a `swap` method defined in its prototype,
  * then it will perform hot swapping of existing Script Instances on entities using this new Script Type.
  * Note: There is a reserved list of names that cannot be used, such as list below as well as some starting from `_` (underscore):
  * system, entity, create, destroy, swap, move, scripts, onEnable, onDisable, onPostStateChange, has, on, off, fire, once, hasEvent.
  * @param [app] - Optional application handler, to choose which {@link pc.ScriptRegistry} to add a script to.
  * By default it will use `pc.Application.getApplication()` to get current {@link pc.Application}.
  * @returns A class type (constructor function) that inherits {@link pc.ScriptType},
  * which the developer is meant to further extend by adding attributes and prototype methods.
  */
@scala.inline
def createScript(name: java.lang.String): typings.playcanvas.anon.TypeofScriptType & (org.scalablytyped.runtime.Instantiable1[/* args */ typings.playcanvas.anon.App, typings.playcanvas.pc.ScriptType]) = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createScript")(name.asInstanceOf[js.Any]).asInstanceOf[typings.playcanvas.anon.TypeofScriptType & (org.scalablytyped.runtime.Instantiable1[/* args */ typings.playcanvas.anon.App, typings.playcanvas.pc.ScriptType])]
@scala.inline
def createScript(name: java.lang.String, app: typings.playcanvas.pc.Application): typings.playcanvas.anon.TypeofScriptType & (org.scalablytyped.runtime.Instantiable1[/* args */ typings.playcanvas.anon.App, typings.playcanvas.pc.ScriptType]) = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createScript")(name.asInstanceOf[js.Any], app.asInstanceOf[js.Any])).asInstanceOf[typings.playcanvas.anon.TypeofScriptType & (org.scalablytyped.runtime.Instantiable1[/* args */ typings.playcanvas.anon.App, typings.playcanvas.pc.ScriptType])]

/**
  * Creates a procedural sphere-shaped mesh.
  *
  * The size and tesselation properties of the sphere can be controlled via function
  * parameters. By default, the function will create a sphere centered on the object
  * space origin with a radius of 0.5 and 16 segments in both longitude and latitude.
  *
  * Note that the sphere is created with UVs in the range of 0 to 1. Additionally, tangent
  * information is generated into the vertex buffer of the sphere's mesh.
  * @param device - The graphics device used to manage the mesh.
  * @param [opts] - An object that specifies optional inputs for the function as follows:
  * @param [opts.radius] - The radius of the sphere (defaults to 0.5).
  * @param [opts.segments] - The number of divisions along the longitudinal
  * and latitudinal axes of the sphere (defaults to 16).
  * @returns A new sphere-shaped mesh.
  */
@scala.inline
def createSphere(device: typings.playcanvas.pc.GraphicsDevice): typings.playcanvas.pc.Mesh = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createSphere")(device.asInstanceOf[js.Any]).asInstanceOf[typings.playcanvas.pc.Mesh]
@scala.inline
def createSphere(device: typings.playcanvas.pc.GraphicsDevice, opts: typings.playcanvas.anon.Radius): typings.playcanvas.pc.Mesh = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createSphere")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typings.playcanvas.pc.Mesh]

/**
  * Creates a &lt;style&gt; DOM element from a string that contains CSS.
  * @example
  * var css = 'body {height: 100;}';
  * var style = pc.createStyle(css);
  * document.head.appendChild(style);
  * @param cssString - A string that contains valid CSS.
  * @returns The style DOM element.
  */
@scala.inline
def createStyle(cssString: java.lang.String): typings.std.Element = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createStyle")(cssString.asInstanceOf[js.Any]).asInstanceOf[typings.std.Element]

/**
  * Creates a procedural torus-shaped mesh.
  *
  * The size, shape and tesselation properties of the torus can be controlled via function parameters.
  * By default, the function will create a torus in the XZ-plane with a tube radius of 0.2, a ring radius
  * of 0.3, 20 segments and 30 sides.
  *
  * Note that the torus is created with UVs in the range of 0 to 1. Additionally, tangent information
  * is generated into the vertex buffer of the torus's mesh.
  * @param device - The graphics device used to manage the mesh.
  * @param [opts] - An object that specifies optional inputs for the function as follows:
  * @param [opts.tubeRadius] - The radius of the tube forming the body of the torus (defaults to 0.2).
  * @param [opts.ringRadius] - The radius from the centre of the torus to the centre of the tube (defaults to 0.3).
  * @param [opts.segments] - The number of radial divisions forming cross-sections of the torus ring (defaults to 20).
  * @param [opts.sides] - The number of divisions around the tubular body of the torus ring (defaults to 30).
  * @returns A new torus-shaped mesh.
  */
@scala.inline
def createTorus(device: typings.playcanvas.pc.GraphicsDevice): typings.playcanvas.pc.Mesh = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createTorus")(device.asInstanceOf[js.Any]).asInstanceOf[typings.playcanvas.pc.Mesh]
@scala.inline
def createTorus(device: typings.playcanvas.pc.GraphicsDevice, opts: typings.playcanvas.anon.RingRadius): typings.playcanvas.pc.Mesh = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("createTorus")(device.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[typings.playcanvas.pc.Mesh]

/**
  * Draw a screen-space rectangle in a render target. Primarily meant to be used in custom post effects based on {@link pc.PostEffect}.
  * @param device - The graphics device of the application.
  * @param target - The output render target.
  * @param vertexBuffer - The vertex buffer for the rectangle mesh. When calling from a custom post effect, pass the field {@link pc.PostEffect#vertexBuffer}.
  * @param shader - The shader to be used for drawing the rectangle. When calling from a custom post effect, pass the field {@link pc.PostEffect#shader}.
  * @param [rect] - The normalized screen-space position (rect.x, rect.y) and size (rect.z, rect.w) of the rectangle. Default is [0, 0, 1, 1].
  */
@scala.inline
def drawFullscreenQuad(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: typings.playcanvas.pc.RenderTarget,
  vertexBuffer: typings.playcanvas.pc.VertexBuffer,
  shader: typings.playcanvas.pc.Shader
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawFullscreenQuad")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], vertexBuffer.asInstanceOf[js.Any], shader.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawFullscreenQuad(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: typings.playcanvas.pc.RenderTarget,
  vertexBuffer: typings.playcanvas.pc.VertexBuffer,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawFullscreenQuad")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], vertexBuffer.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: scala.Unit,
  scissorRect: scala.Unit,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: scala.Unit,
  scissorRect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: scala.Unit,
  scissorRect: typings.playcanvas.pc.Vec4,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: scala.Unit,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: typings.playcanvas.pc.Vec4,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
/**
  * Draws a screen-space quad using a specific shader. Mostly used by post-effects.
  * @param device - The graphics device used to draw the quad.
  * @param target - The destination render target. If undefined, target is the frame buffer.
  * @param shader - The shader used for rendering the quad. Vertex shader should contain `attribute vec2 vertex_position`.
  * @param [rect] - The viewport rectangle of the quad, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
  * @param [scissorRect] - The scissor rectangle of the quad, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
  * @param [useBlend] - True to enable blending. Defaults to false, disabling blending.
  */
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: scala.Unit,
  scissorRect: scala.Unit,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: scala.Unit,
  scissorRect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: scala.Unit,
  scissorRect: typings.playcanvas.pc.Vec4,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: scala.Unit,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawQuadWithShader(
  device: typings.playcanvas.pc.GraphicsDevice,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: typings.playcanvas.pc.Vec4,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawQuadWithShader")(device.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

/**
  * Draws a texture in screen-space. Mostly used by post-effects.
  * @param device - The graphics device used to draw the texture.
  * @param texture - The source texture to be drawn. Accessible as `uniform sampler2D source` in shader.
  * @param [target] - The destination render target. Defaults to the frame buffer.
  * @param [shader] - The shader used for rendering the texture. Defaults to `pc.GraphicsDevice#getCopyShader()`.
  * @param [rect] - The viewport rectangle to use for the texture, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
  * @param [scissorRect] - The scissor rectangle to use for the texture, in pixels. Defaults to fullscreen (`0, 0, target.width, target.height`).
  * @param [useBlend] - True to enable blending. Defaults to false, disabling blending.
  */
@scala.inline
def drawTexture(device: typings.playcanvas.pc.GraphicsDevice, texture: typings.playcanvas.pc.Texture): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: scala.Unit,
  rect: scala.Unit,
  scissorRect: scala.Unit,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: scala.Unit,
  rect: scala.Unit,
  scissorRect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: scala.Unit,
  rect: scala.Unit,
  scissorRect: typings.playcanvas.pc.Vec4,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: scala.Unit,
  rect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: scala.Unit,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: scala.Unit,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: scala.Unit,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: scala.Unit,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: typings.playcanvas.pc.Vec4,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: scala.Unit,
  scissorRect: scala.Unit,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: scala.Unit,
  scissorRect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: scala.Unit,
  scissorRect: typings.playcanvas.pc.Vec4,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: scala.Unit,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: scala.Unit,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: typings.playcanvas.pc.Vec4,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: scala.Unit,
  rect: scala.Unit,
  scissorRect: scala.Unit,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: scala.Unit,
  rect: scala.Unit,
  scissorRect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: scala.Unit,
  rect: scala.Unit,
  scissorRect: typings.playcanvas.pc.Vec4,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: scala.Unit,
  rect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: scala.Unit,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: scala.Unit,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: scala.Unit,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: scala.Unit,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: typings.playcanvas.pc.Vec4,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: scala.Unit,
  scissorRect: scala.Unit,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: scala.Unit,
  scissorRect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: scala.Unit,
  scissorRect: typings.playcanvas.pc.Vec4,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: scala.Unit,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: typings.playcanvas.pc.Vec4
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def drawTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  texture: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.RenderTarget,
  shader: typings.playcanvas.pc.Shader,
  rect: typings.playcanvas.pc.Vec4,
  scissorRect: typings.playcanvas.pc.Vec4,
  useBlend: scala.Boolean
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("drawTexture")(device.asInstanceOf[js.Any], texture.asInstanceOf[js.Any], target.asInstanceOf[js.Any], shader.asInstanceOf[js.Any], rect.asInstanceOf[js.Any], scissorRect.asInstanceOf[js.Any], useBlend.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

/**
  * Similar to {@link pc.getTargetCoords} for the MouseEvents.
  * This function takes a browser Touch object and returns the co-ordinates of the
  * touch relative to the target element.
  * @param touch - The browser Touch object.
  * @returns The co-ordinates of the touch relative to the touch.target element. In the format {x, y}.
  */
@scala.inline
def getTouchTargetCoords(touch: typings.playcanvas.pc.Touch): js.Any = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("getTouchTargetCoords")(touch.asInstanceOf[js.Any]).asInstanceOf[js.Any]

/**
  * Prefilter a cubemap for use by a {@link pc.StandardMaterial} as an environment map. Should only be used for cubemaps that can't be prefiltered ahead of time (in the editor).
  * @param options - The options for how the cubemap is prefiltered.
  */
@scala.inline
def prefilterCubemap(options: js.Any): scala.Unit = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("prefilterCubemap")(options.asInstanceOf[js.Any]).asInstanceOf[scala.Unit]

/**
  * Register a existing class type as a Script Type to {@link pc.ScriptRegistry}.
  * Useful when defining a ES6 script class that extends {@link pc.ScriptType} (see example).
  * @example
  * // define a ES6 script class
  * class PlayerController extends pc.ScriptType {
  *
  *     initialize() {
  *         // called once on initialize
  *     }
  *
  *     update(dt) {
  *         // called each tick
  *     }
  * }
  *
  * // register the class as a script
  * pc.registerScript(PlayerController);
  *
  * // declare script attributes (Must be after pc.registerScript())
  * PlayerController.attributes.add('attribute1', {type: 'number'});
  * @param script - The existing class type (constructor function) to be registered as a Script Type.
  * Class must extend {@link pc.ScriptType} (see example). Please note: A class created using {@link pc.createScript} is auto-registered,
  * and should therefore not be pass into {@link pc.registerScript} (which would result in swapping out all related script instances).
  * @param [name] - Optional unique name of the Script Type. By default it will use the same name as the existing class.
  * If a Script Type with the same name has already been registered and the new one has a `swap` method defined in its prototype,
  * then it will perform hot swapping of existing Script Instances on entities using this new Script Type.
  * Note: There is a reserved list of names that cannot be used, such as list below as well as some starting from `_` (underscore):
  * system, entity, create, destroy, swap, move, scripts, onEnable, onDisable, onPostStateChange, has, on, off, fire, once, hasEvent.
  * @param [app] - Optional application handler, to choose which {@link pc.ScriptRegistry} to register the script type to.
  * By default it will use `pc.Application.getApplication()` to get current {@link pc.Application}.
  */
@scala.inline
def registerScript(
  script: typings.playcanvas.anon.TypeofScriptType & (org.scalablytyped.runtime.Instantiable1[/* args */ typings.playcanvas.anon.App, typings.playcanvas.pc.ScriptType])
): scala.Unit = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("registerScript")(script.asInstanceOf[js.Any]).asInstanceOf[scala.Unit]
@scala.inline
def registerScript(
  script: typings.playcanvas.anon.TypeofScriptType & (org.scalablytyped.runtime.Instantiable1[/* args */ typings.playcanvas.anon.App, typings.playcanvas.pc.ScriptType]),
  name: java.lang.String
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("registerScript")(script.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def registerScript(
  script: typings.playcanvas.anon.TypeofScriptType & (org.scalablytyped.runtime.Instantiable1[/* args */ typings.playcanvas.anon.App, typings.playcanvas.pc.ScriptType]),
  name: java.lang.String,
  app: typings.playcanvas.pc.Application
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("registerScript")(script.asInstanceOf[js.Any], name.asInstanceOf[js.Any], app.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def registerScript(
  script: typings.playcanvas.anon.TypeofScriptType & (org.scalablytyped.runtime.Instantiable1[/* args */ typings.playcanvas.anon.App, typings.playcanvas.pc.ScriptType]),
  name: scala.Unit,
  app: typings.playcanvas.pc.Application
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("registerScript")(script.asInstanceOf[js.Any], name.asInstanceOf[js.Any], app.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

/**
  * This function reprojects textures between cubemap and equirectangular formats. The
  * function can read and write textures with pixel data in RGBE, RGBM, linear and sRGB formats. When
  * specularPower is specified it will perform a phong-weighted convolution of the source (for generating
  * a gloss maps).
  * @param device - The graphics device
  * @param source - The source texture
  * @param target - The target texture
  * @param [specularPower] - optional specular power. When specular power is specified,
  * the source is convolved by a phong-weighted kernel raised to the specified power. Otherwise
  * the function performs a standard resample.
  * @param [numSamples] - optional number of samples (default is 1024).
  */
@scala.inline
def reprojectTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  source: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.Texture
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("reprojectTexture")(device.asInstanceOf[js.Any], source.asInstanceOf[js.Any], target.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def reprojectTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  source: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.Texture,
  specularPower: scala.Double
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("reprojectTexture")(device.asInstanceOf[js.Any], source.asInstanceOf[js.Any], target.asInstanceOf[js.Any], specularPower.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def reprojectTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  source: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.Texture,
  specularPower: scala.Double,
  numSamples: scala.Double
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("reprojectTexture")(device.asInstanceOf[js.Any], source.asInstanceOf[js.Any], target.asInstanceOf[js.Any], specularPower.asInstanceOf[js.Any], numSamples.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def reprojectTexture(
  device: typings.playcanvas.pc.GraphicsDevice,
  source: typings.playcanvas.pc.Texture,
  target: typings.playcanvas.pc.Texture,
  specularPower: scala.Unit,
  numSamples: scala.Double
): scala.Unit = (typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].applyDynamic("reprojectTexture")(device.asInstanceOf[js.Any], source.asInstanceOf[js.Any], target.asInstanceOf[js.Any], specularPower.asInstanceOf[js.Any], numSamples.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

/**
  * Object containing all default shader chunks used by shader generators.
  */
@scala.inline
def shaderChunks: js.Any = typings.playcanvas.global.pc.^.asInstanceOf[js.Dynamic].selectDynamic("shaderChunks").asInstanceOf[js.Any]
