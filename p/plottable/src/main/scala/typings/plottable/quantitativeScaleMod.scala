package typings.plottable

import typings.plottable.scaleMod.Scale
import typings.plottable.scalesMod.IPaddingExceptionsProvider
import typings.plottable.scalesMod.ITransformableScale
import typings.plottable.tickGeneratorsMod.ITickGenerator
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object quantitativeScaleMod {
  
  @JSImport("plottable/build/src/scales/quantitativeScale", "QuantitativeScale")
  @js.native
  /**
    * A QuantitativeScale is a Scale that maps number-like values to numbers.
    * It is invertible and continuous.
    *
    * @constructor
    */
  open class QuantitativeScale[D] ()
    extends Scale[D, Double]
       with ITransformableScale {
    
    /* protected */ def _defaultExtent(): js.Array[D] = js.native
    
    /* private */ var _domainMax: Any = js.native
    
    /* private */ var _domainMin: Any = js.native
    
    /* protected */ def _expandSingleValueDomain(singleValueDomain: js.Array[D]): js.Array[D] = js.native
    
    /* protected */ def _getUnboundedExtent(): js.Array[D] = js.native
    /* protected */ def _getUnboundedExtent(ignoreAttachState: Boolean): js.Array[D] = js.native
    
    /**
      * Given a domain, expands its domain onto "nice" values, e.g. whole
      * numbers.
      */
    /* protected */ def _niceDomain(domain: js.Array[D]): js.Array[D] = js.native
    /* protected */ def _niceDomain(domain: js.Array[D], count: Double): js.Array[D] = js.native
    
    /* private */ var _padDomain: Any = js.native
    
    /* private */ var _padProportion: Any = js.native
    
    /* private */ var _paddingExceptionsProviders: Any = js.native
    
    /* private */ var _snappingDomainEnabled: Any = js.native
    
    /* private */ var _tickGenerator: Any = js.native
    
    /**
      * Adds a padding exception provider.
      * If one end of the domain is set to an excepted value as a result of autoDomain()-ing,
      * that end of the domain will not be padded.
      *
      * @param {Scales.PaddingExceptionProvider<D>} provider The provider function.
      * @returns {QuantitativeScale} The calling QuantitativeScale.
      */
    def addPaddingExceptionsProvider(provider: IPaddingExceptionsProvider[D]): this.type = js.native
    
    /**
      * Gets the array of tick values generated by the default algorithm.
      */
    def defaultTicks(): js.Array[D] = js.native
    
    /**
      * Gets the upper end of the domain.
      *
      * @return {D}
      */
    def domainMax(): D = js.native
    /**
      * Sets the upper end of the domain.
      *
      * @return {QuantitativeScale} The calling QuantitativeScale.
      */
    def domainMax(domainMax: D): this.type = js.native
    
    /**
      * Gets the lower end of the domain.
      *
      * @return {D}
      */
    def domainMin(): D = js.native
    /**
      * Sets the lower end of the domain.
      *
      * @return {QuantitativeScale} The calling QuantitativeScale.
      */
    def domainMin(domainMin: D): this.type = js.native
    
    /**
      * Returns the current transformed domain of the scale. This must be a
      * numerical range in the same coordinate space used for
      * `scaleTransformation`.
      */
    /* CompleteClass */
    override def getTransformationDomain(): js.Tuple2[Double, Double] = js.native
    
    /**
      * Gets the full extent of the transformation domain.
      */
    /* CompleteClass */
    override def getTransformationExtent(): js.Tuple2[Double, Double] = js.native
    
    /**
      * Computes the domain value corresponding to a supplied range value.
      *
      * @param {number} value: A value from the Scale's range.
      * @returns {D} The domain value corresponding to the supplied range value.
      */
    def invert(value: Double): D = js.native
    
    /**
      * Returns value in *Transformation Space* for the provided *screen space*.
      */
    /* CompleteClass */
    override def invertedTransformation(value: Double): Double = js.native
    
    /**
      * Gets the padding proportion.
      */
    def padProportion(): Double = js.native
    /**
      * Sets the padding porportion.
      * When autoDomain()-ing, the computed domain will be expanded by this proportion,
      * then rounded to human-readable values.
      *
      * @param {number} padProportion The padding proportion. Passing 0 disables padding.
      * @returns {QuantitativeScale} The calling QuantitativeScale.
      */
    def padProportion(padProportion: Double): this.type = js.native
    
    /**
      * Translates the scale by a number of pixels.
      *
      * @param {number} [translateAmount] The translation amount in screen space
      */
    /* CompleteClass */
    override def pan(translateAmount: Double): Unit = js.native
    
    /**
      * Removes the padding exception provider.
      *
      * @param {Scales.PaddingExceptionProvider<D>} provider The provider function.
      * @returns {QuantitativeScale} The calling QuantitativeScale.
      */
    def removePaddingExceptionsProvider(provider: IPaddingExceptionsProvider[D]): this.type = js.native
    
    /**
      * Returns value in *screen space* for the given domain value.
      */
    /* CompleteClass */
    override def scaleTransformation(value: Double): Double = js.native
    
    /**
      * Directly set the transformation domain. Instead of calling `.zoom` or
      * `.pan` perform calculations relative to the current domain, this can but
      * used to pan/zoom to an exact domain interval (in transformation space).
      */
    /* CompleteClass */
    override def setTransformationDomain(domain: js.Tuple2[Double, Double]): Unit = js.native
    
    /**
      * Gets whether or not the scale snaps its domain to nice values.
      */
    def snappingDomainEnabled(): Boolean = js.native
    /**
      * Sets whether or not the scale snaps its domain to nice values.
      */
    def snappingDomainEnabled(snappingDomainEnabled: Boolean): this.type = js.native
    
    /**
      * Gets the TickGenerator.
      */
    def tickGenerator(): ITickGenerator[D] = js.native
    /**
      * Sets the TickGenerator
      *
      * @param {TickGenerator} generator
      * @return {QuantitativeScale} The calling QuantitativeScale.
      */
    def tickGenerator(generator: ITickGenerator[D]): this.type = js.native
    
    /**
      * Apply the magnification with the floating point `magnifyAmount` centered
      * at the `centerValue` coordinate.
      *
      * @param {number} [magnifyAmount] The floating point zoom amount. `1.0` is
      * no zoom change.
      * @param {number} [centerValue] The coordinate of the mouse in screen
      * space.
      */
    /* CompleteClass */
    override def zoom(magnifyAmount: Double, centerValue: Double): Unit = js.native
  }
  /* static members */
  object QuantitativeScale {
    
    @JSImport("plottable/build/src/scales/quantitativeScale", "QuantitativeScale")
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("plottable/build/src/scales/quantitativeScale", "QuantitativeScale._DEFAULT_NUM_TICKS")
    @js.native
    def _DEFAULT_NUM_TICKS: Double = js.native
    inline def _DEFAULT_NUM_TICKS_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("_DEFAULT_NUM_TICKS")(x.asInstanceOf[js.Any])
  }
}
