package typings.peerjs

import typings.peerjs.peerjsStrings.call
import typings.peerjs.peerjsStrings.close
import typings.peerjs.peerjsStrings.connection
import typings.peerjs.peerjsStrings.data
import typings.peerjs.peerjsStrings.disconnected
import typings.peerjs.peerjsStrings.error
import typings.peerjs.peerjsStrings.open
import typings.peerjs.peerjsStrings.stream
import typings.std.MediaStream
import typings.std.RTCConfiguration
import typings.std.RTCDataChannel
import typings.std.RTCPeerConnection
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  @JSImport("peerjs", JSImport.Namespace)
  @js.native
  /**
    * A peer can connect to other peers and listen for connections.
    * @param id Other peers can connect to this peer using the provided ID.
    *     If no ID is given, one will be generated by the brokering server.
    * @param options for specifying details about PeerServer
    */
  class ^ () extends Peer {
    def this(id: String) = this()
    /**
      * A peer can connect to other peers and listen for connections.
      * @param options for specifying details about PeerServer
      */
    def this(options: PeerJSOption) = this()
    def this(id: js.UndefOr[scala.Nothing], options: PeerJSOption) = this()
    def this(id: String, options: PeerJSOption) = this()
  }
  
  @js.native
  trait AnswerOption extends StObject {
    
    var sdpTransform: js.UndefOr[js.Function] = js.native
  }
  object AnswerOption {
    
    @scala.inline
    def apply(): AnswerOption = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[AnswerOption]
    }
    
    @scala.inline
    implicit class AnswerOptionMutableBuilder[Self <: AnswerOption] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setSdpTransform(value: js.Function): Self = StObject.set(x, "sdpTransform", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSdpTransformUndefined: Self = StObject.set(x, "sdpTransform", js.undefined)
    }
  }
  
  @js.native
  trait CallOption extends StObject {
    
    var metadata: js.UndefOr[js.Any] = js.native
    
    var sdpTransform: js.UndefOr[js.Function] = js.native
  }
  object CallOption {
    
    @scala.inline
    def apply(): CallOption = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[CallOption]
    }
    
    @scala.inline
    implicit class CallOptionMutableBuilder[Self <: CallOption] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setMetadata(value: js.Any): Self = StObject.set(x, "metadata", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMetadataUndefined: Self = StObject.set(x, "metadata", js.undefined)
      
      @scala.inline
      def setSdpTransform(value: js.Function): Self = StObject.set(x, "sdpTransform", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSdpTransformUndefined: Self = StObject.set(x, "sdpTransform", js.undefined)
    }
  }
  
  @js.native
  trait DataConnection extends StObject {
    
    var bufferSize: Double = js.native
    
    def close(): Unit = js.native
    
    var dataChannel: RTCDataChannel = js.native
    
    var label: String = js.native
    
    var metadata: js.Any = js.native
    
    def off(event: String, fn: js.Function): Unit = js.native
    def off(event: String, fn: js.Function, once: Boolean): Unit = js.native
    
    def on(event: String, cb: js.Function0[Unit]): Unit = js.native
    @JSName("on")
    def on_close(event: close, cb: js.Function0[Unit]): Unit = js.native
    @JSName("on")
    def on_data(event: data, cb: js.Function1[/* data */ js.Any, Unit]): Unit = js.native
    @JSName("on")
    def on_error(event: error, cb: js.Function1[/* err */ js.Any, Unit]): Unit = js.native
    @JSName("on")
    def on_open(event: open, cb: js.Function0[Unit]): Unit = js.native
    
    var open: Boolean = js.native
    
    def parse(data: String): js.Any = js.native
    
    var peer: String = js.native
    
    var peerConnection: RTCPeerConnection = js.native
    
    var reliable: Boolean = js.native
    
    def send(data: js.Any): Unit = js.native
    
    var serialization: String = js.native
    
    def stringify(data: js.Any): String = js.native
    
    var `type`: String = js.native
  }
  
  @js.native
  trait MediaConnection extends StObject {
    
    def answer(): Unit = js.native
    def answer(stream: js.UndefOr[scala.Nothing], options: AnswerOption): Unit = js.native
    def answer(stream: MediaStream): Unit = js.native
    def answer(stream: MediaStream, options: AnswerOption): Unit = js.native
    
    def close(): Unit = js.native
    
    var metadata: js.Any = js.native
    
    def off(event: String, fn: js.Function): Unit = js.native
    def off(event: String, fn: js.Function, once: Boolean): Unit = js.native
    
    def on(event: String, cb: js.Function0[Unit]): Unit = js.native
    @JSName("on")
    def on_close(event: close, cb: js.Function0[Unit]): Unit = js.native
    @JSName("on")
    def on_error(event: error, cb: js.Function1[/* err */ js.Any, Unit]): Unit = js.native
    @JSName("on")
    def on_stream(event: stream, cb: js.Function1[/* stream */ MediaStream, Unit]): Unit = js.native
    
    var open: Boolean = js.native
    
    var peer: String = js.native
    
    var peerConnection: RTCPeerConnection = js.native
    
    var `type`: String = js.native
  }
  
  @js.native
  trait Peer extends StObject {
    
    /**
      * Calls the remote peer specified by id and returns a media connection.
      * @param id The brokering ID of the remote peer (their peer.id).
      * @param stream The caller's media stream
      * @param options Metadata associated with the connection, passed in by whoever initiated the connection.
      */
    def call(id: String, stream: MediaStream): MediaConnection = js.native
    def call(id: String, stream: MediaStream, options: CallOption): MediaConnection = js.native
    
    /**
      * Connects to the remote peer specified by id and returns a data connection.
      * @param id The brokering ID of the remote peer (their peer.id).
      * @param options for specifying details about Peer Connection
      */
    def connect(id: String): DataConnection = js.native
    def connect(id: String, options: PeerConnectOption): DataConnection = js.native
    
    /**
      * A hash of all connections associated with this peer, keyed by the remote peer's ID.
      */
    var connections: js.Any = js.native
    
    /**
      * Close the connection to the server and terminate all existing connections.
      */
    def destroy(): Unit = js.native
    
    /**
      * true if this peer and all of its connections can no longer be used.
      */
    var destroyed: Boolean = js.native
    
    /**
      * Close the connection to the server, leaving all existing data and media connections intact.
      */
    def disconnect(): Unit = js.native
    
    /**
      * false if there is an active connection to the PeerServer.
      */
    var disconnected: Boolean = js.native
    
    /**
      * Retrieve a data/media connection for this peer.
      * @param peerId
      * @param connectionId
      */
    def getConnection(peerId: String, connectionId: String): MediaConnection | DataConnection | Null = js.native
    
    /**
      * The brokering ID of this peer
      */
    var id: String = js.native
    
    /**
      * Get a list of available peer IDs
      * @param callback
      */
    def listAllPeers(callback: js.Function1[/* peerIds */ js.Array[String], Unit]): Unit = js.native
    
    /**
      * Remove event listeners.(EventEmitter3)
      * @param {String} event The event we want to remove.
      * @param {Function} fn The listener that we need to find.
      * @param {Boolean} once Only remove once listeners.
      */
    def off(event: String, fn: js.Function): Unit = js.native
    def off(event: String, fn: js.Function, once: Boolean): Unit = js.native
    
    /**
      * Set listeners for peer events.
      * @param event Event name
      * @param cb Callback Function
      */
    def on(event: String, cb: js.Function0[Unit]): Unit = js.native
    /**
      * Emitted when a remote peer attempts to call you.
      * @param event Event name
      * @param cb Callback Function
      */
    @JSName("on")
    def on_call(event: call, cb: js.Function1[/* mediaConnection */ MediaConnection, Unit]): Unit = js.native
    /**
      * Emitted when the peer is destroyed and can no longer accept or create any new connections.
      * @param event Event name
      * @param cb Callback Function
      */
    @JSName("on")
    def on_close(event: close, cb: js.Function0[Unit]): Unit = js.native
    /**
      * Emitted when a new data connection is established from a remote peer.
      * @param event Event name
      * @param cb Callback Function
      */
    @JSName("on")
    def on_connection(event: connection, cb: js.Function1[/* dataConnection */ DataConnection, Unit]): Unit = js.native
    /**
      * Emitted when the peer is disconnected from the signalling server
      * @param event Event name
      * @param cb Callback Function
      */
    @JSName("on")
    def on_disconnected(event: disconnected, cb: js.Function0[Unit]): Unit = js.native
    /**
      * Errors on the peer are almost always fatal and will destroy the peer.
      * @param event Event name
      * @param cb Callback Function
      */
    @JSName("on")
    def on_error(event: error, cb: js.Function1[/* err */ js.Any, Unit]): Unit = js.native
    /**
      * Emitted when a connection to the PeerServer is established.
      * @param event Event name
      * @param cb id is the brokering ID of the peer
      */
    @JSName("on")
    def on_open(event: open, cb: js.Function1[/* id */ String, Unit]): Unit = js.native
    
    /**
      * Attempt to reconnect to the server with the peer's old ID
      */
    def reconnect(): Unit = js.native
  }
  
  @js.native
  trait PeerConnectOption extends StObject {
    
    var label: js.UndefOr[String] = js.native
    
    var metadata: js.UndefOr[js.Any] = js.native
    
    var reliable: js.UndefOr[Boolean] = js.native
    
    var serialization: js.UndefOr[String] = js.native
  }
  object PeerConnectOption {
    
    @scala.inline
    def apply(): PeerConnectOption = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[PeerConnectOption]
    }
    
    @scala.inline
    implicit class PeerConnectOptionMutableBuilder[Self <: PeerConnectOption] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setLabel(value: String): Self = StObject.set(x, "label", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLabelUndefined: Self = StObject.set(x, "label", js.undefined)
      
      @scala.inline
      def setMetadata(value: js.Any): Self = StObject.set(x, "metadata", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMetadataUndefined: Self = StObject.set(x, "metadata", js.undefined)
      
      @scala.inline
      def setReliable(value: Boolean): Self = StObject.set(x, "reliable", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setReliableUndefined: Self = StObject.set(x, "reliable", js.undefined)
      
      @scala.inline
      def setSerialization(value: String): Self = StObject.set(x, "serialization", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSerializationUndefined: Self = StObject.set(x, "serialization", js.undefined)
    }
  }
  
  @js.native
  trait PeerJSOption extends StObject {
    
    var config: js.UndefOr[RTCConfiguration] = js.native
    
    var debug: js.UndefOr[Double] = js.native
    
    var host: js.UndefOr[String] = js.native
    
    var key: js.UndefOr[String] = js.native
    
    var path: js.UndefOr[String] = js.native
    
    var port: js.UndefOr[Double] = js.native
    
    var secure: js.UndefOr[Boolean] = js.native
  }
  object PeerJSOption {
    
    @scala.inline
    def apply(): PeerJSOption = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[PeerJSOption]
    }
    
    @scala.inline
    implicit class PeerJSOptionMutableBuilder[Self <: PeerJSOption] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setConfig(value: RTCConfiguration): Self = StObject.set(x, "config", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setConfigUndefined: Self = StObject.set(x, "config", js.undefined)
      
      @scala.inline
      def setDebug(value: Double): Self = StObject.set(x, "debug", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDebugUndefined: Self = StObject.set(x, "debug", js.undefined)
      
      @scala.inline
      def setHost(value: String): Self = StObject.set(x, "host", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setHostUndefined: Self = StObject.set(x, "host", js.undefined)
      
      @scala.inline
      def setKey(value: String): Self = StObject.set(x, "key", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setKeyUndefined: Self = StObject.set(x, "key", js.undefined)
      
      @scala.inline
      def setPath(value: String): Self = StObject.set(x, "path", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPathUndefined: Self = StObject.set(x, "path", js.undefined)
      
      @scala.inline
      def setPort(value: Double): Self = StObject.set(x, "port", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPortUndefined: Self = StObject.set(x, "port", js.undefined)
      
      @scala.inline
      def setSecure(value: Boolean): Self = StObject.set(x, "secure", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSecureUndefined: Self = StObject.set(x, "secure", js.undefined)
    }
  }
  
  @js.native
  trait UtilSupportsObj extends StObject {
    
    var audioVideo: Boolean = js.native
    
    var binaryBlob: Boolean = js.native
    
    var browser: Boolean = js.native
    
    var data: Boolean = js.native
    
    var reliable: Boolean = js.native
    
    var webRTC: Boolean = js.native
  }
  object UtilSupportsObj {
    
    @scala.inline
    def apply(
      audioVideo: Boolean,
      binaryBlob: Boolean,
      browser: Boolean,
      data: Boolean,
      reliable: Boolean,
      webRTC: Boolean
    ): UtilSupportsObj = {
      val __obj = js.Dynamic.literal(audioVideo = audioVideo.asInstanceOf[js.Any], binaryBlob = binaryBlob.asInstanceOf[js.Any], browser = browser.asInstanceOf[js.Any], data = data.asInstanceOf[js.Any], reliable = reliable.asInstanceOf[js.Any], webRTC = webRTC.asInstanceOf[js.Any])
      __obj.asInstanceOf[UtilSupportsObj]
    }
    
    @scala.inline
    implicit class UtilSupportsObjMutableBuilder[Self <: UtilSupportsObj] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setAudioVideo(value: Boolean): Self = StObject.set(x, "audioVideo", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBinaryBlob(value: Boolean): Self = StObject.set(x, "binaryBlob", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBrowser(value: Boolean): Self = StObject.set(x, "browser", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setData(value: Boolean): Self = StObject.set(x, "data", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setReliable(value: Boolean): Self = StObject.set(x, "reliable", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setWebRTC(value: Boolean): Self = StObject.set(x, "webRTC", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait util extends StObject {
    
    var browser: String = js.native
    
    var supports: UtilSupportsObj = js.native
  }
  object util {
    
    @scala.inline
    def apply(browser: String, supports: UtilSupportsObj): util = {
      val __obj = js.Dynamic.literal(browser = browser.asInstanceOf[js.Any], supports = supports.asInstanceOf[js.Any])
      __obj.asInstanceOf[util]
    }
    
    @scala.inline
    implicit class utilMutableBuilder[Self <: util] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setBrowser(value: String): Self = StObject.set(x, "browser", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSupports(value: UtilSupportsObj): Self = StObject.set(x, "supports", value.asInstanceOf[js.Any])
    }
  }
}
