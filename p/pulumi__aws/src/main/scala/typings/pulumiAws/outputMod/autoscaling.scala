package typings.pulumiAws.outputMod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object autoscaling {
  
  @js.native
  trait GroupInitialLifecycleHook extends StObject {
    
    var defaultResult: String = js.native
    
    var heartbeatTimeout: js.UndefOr[Double] = js.native
    
    var lifecycleTransition: String = js.native
    
    /**
      * The name of the auto scaling group. By default generated by this provider.
      */
    var name: String = js.native
    
    var notificationMetadata: js.UndefOr[String] = js.native
    
    var notificationTargetArn: js.UndefOr[String] = js.native
    
    var roleArn: js.UndefOr[String] = js.native
  }
  object GroupInitialLifecycleHook {
    
    @scala.inline
    def apply(defaultResult: String, lifecycleTransition: String, name: String): GroupInitialLifecycleHook = {
      val __obj = js.Dynamic.literal(defaultResult = defaultResult.asInstanceOf[js.Any], lifecycleTransition = lifecycleTransition.asInstanceOf[js.Any], name = name.asInstanceOf[js.Any])
      __obj.asInstanceOf[GroupInitialLifecycleHook]
    }
    
    @scala.inline
    implicit class GroupInitialLifecycleHookMutableBuilder[Self <: GroupInitialLifecycleHook] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setDefaultResult(value: String): Self = StObject.set(x, "defaultResult", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setHeartbeatTimeout(value: Double): Self = StObject.set(x, "heartbeatTimeout", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setHeartbeatTimeoutUndefined: Self = StObject.set(x, "heartbeatTimeout", js.undefined)
      
      @scala.inline
      def setLifecycleTransition(value: String): Self = StObject.set(x, "lifecycleTransition", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setName(value: String): Self = StObject.set(x, "name", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNotificationMetadata(value: String): Self = StObject.set(x, "notificationMetadata", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNotificationMetadataUndefined: Self = StObject.set(x, "notificationMetadata", js.undefined)
      
      @scala.inline
      def setNotificationTargetArn(value: String): Self = StObject.set(x, "notificationTargetArn", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNotificationTargetArnUndefined: Self = StObject.set(x, "notificationTargetArn", js.undefined)
      
      @scala.inline
      def setRoleArn(value: String): Self = StObject.set(x, "roleArn", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRoleArnUndefined: Self = StObject.set(x, "roleArn", js.undefined)
    }
  }
  
  @js.native
  trait GroupLaunchTemplate extends StObject {
    
    /**
      * The ID of the launch template. Conflicts with `name`.
      */
    var id: String = js.native
    
    /**
      * The name of the auto scaling group. By default generated by this provider.
      */
    var name: String = js.native
    
    /**
      * Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
      */
    var version: js.UndefOr[String] = js.native
  }
  object GroupLaunchTemplate {
    
    @scala.inline
    def apply(id: String, name: String): GroupLaunchTemplate = {
      val __obj = js.Dynamic.literal(id = id.asInstanceOf[js.Any], name = name.asInstanceOf[js.Any])
      __obj.asInstanceOf[GroupLaunchTemplate]
    }
    
    @scala.inline
    implicit class GroupLaunchTemplateMutableBuilder[Self <: GroupLaunchTemplate] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setId(value: String): Self = StObject.set(x, "id", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setName(value: String): Self = StObject.set(x, "name", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVersion(value: String): Self = StObject.set(x, "version", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVersionUndefined: Self = StObject.set(x, "version", js.undefined)
    }
  }
  
  @js.native
  trait GroupMixedInstancesPolicy extends StObject {
    
    /**
      * Nested argument containing settings on how to mix on-demand and Spot instances in the Auto Scaling group. Defined below.
      */
    var instancesDistribution: GroupMixedInstancesPolicyInstancesDistribution = js.native
    
    /**
      * Nested argument containing launch template settings along with the overrides to specify multiple instance types and weights. Defined below.
      */
    var launchTemplate: GroupMixedInstancesPolicyLaunchTemplate = js.native
  }
  object GroupMixedInstancesPolicy {
    
    @scala.inline
    def apply(
      instancesDistribution: GroupMixedInstancesPolicyInstancesDistribution,
      launchTemplate: GroupMixedInstancesPolicyLaunchTemplate
    ): GroupMixedInstancesPolicy = {
      val __obj = js.Dynamic.literal(instancesDistribution = instancesDistribution.asInstanceOf[js.Any], launchTemplate = launchTemplate.asInstanceOf[js.Any])
      __obj.asInstanceOf[GroupMixedInstancesPolicy]
    }
    
    @scala.inline
    implicit class GroupMixedInstancesPolicyMutableBuilder[Self <: GroupMixedInstancesPolicy] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setInstancesDistribution(value: GroupMixedInstancesPolicyInstancesDistribution): Self = StObject.set(x, "instancesDistribution", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLaunchTemplate(value: GroupMixedInstancesPolicyLaunchTemplate): Self = StObject.set(x, "launchTemplate", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait GroupMixedInstancesPolicyInstancesDistribution extends StObject {
    
    /**
      * Strategy to use when launching on-demand instances. Valid values: `prioritized`. Default: `prioritized`.
      */
    var onDemandAllocationStrategy: String = js.native
    
    /**
      * Absolute minimum amount of desired capacity that must be fulfilled by on-demand instances. Default: `0`.
      */
    var onDemandBaseCapacity: Double = js.native
    
    /**
      * Percentage split between on-demand and Spot instances above the base on-demand capacity. Default: `0`.
      */
    var onDemandPercentageAboveBaseCapacity: Double = js.native
    
    /**
      * How to allocate capacity across the Spot pools. Valid values: `lowest-price`, `capacity-optimized`. Default: `lowest-price`.
      */
    var spotAllocationStrategy: String = js.native
    
    /**
      * Number of Spot pools per availability zone to allocate capacity. EC2 Auto Scaling selects the cheapest Spot pools and evenly allocates Spot capacity across the number of Spot pools that you specify. Default: `2`.
      */
    var spotInstancePools: Double = js.native
    
    /**
      * Maximum price per unit hour that the user is willing to pay for the Spot instances. Default: an empty string which means the on-demand price.
      */
    var spotMaxPrice: js.UndefOr[String] = js.native
  }
  object GroupMixedInstancesPolicyInstancesDistribution {
    
    @scala.inline
    def apply(
      onDemandAllocationStrategy: String,
      onDemandBaseCapacity: Double,
      onDemandPercentageAboveBaseCapacity: Double,
      spotAllocationStrategy: String,
      spotInstancePools: Double
    ): GroupMixedInstancesPolicyInstancesDistribution = {
      val __obj = js.Dynamic.literal(onDemandAllocationStrategy = onDemandAllocationStrategy.asInstanceOf[js.Any], onDemandBaseCapacity = onDemandBaseCapacity.asInstanceOf[js.Any], onDemandPercentageAboveBaseCapacity = onDemandPercentageAboveBaseCapacity.asInstanceOf[js.Any], spotAllocationStrategy = spotAllocationStrategy.asInstanceOf[js.Any], spotInstancePools = spotInstancePools.asInstanceOf[js.Any])
      __obj.asInstanceOf[GroupMixedInstancesPolicyInstancesDistribution]
    }
    
    @scala.inline
    implicit class GroupMixedInstancesPolicyInstancesDistributionMutableBuilder[Self <: GroupMixedInstancesPolicyInstancesDistribution] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setOnDemandAllocationStrategy(value: String): Self = StObject.set(x, "onDemandAllocationStrategy", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnDemandBaseCapacity(value: Double): Self = StObject.set(x, "onDemandBaseCapacity", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOnDemandPercentageAboveBaseCapacity(value: Double): Self = StObject.set(x, "onDemandPercentageAboveBaseCapacity", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSpotAllocationStrategy(value: String): Self = StObject.set(x, "spotAllocationStrategy", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSpotInstancePools(value: Double): Self = StObject.set(x, "spotInstancePools", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSpotMaxPrice(value: String): Self = StObject.set(x, "spotMaxPrice", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSpotMaxPriceUndefined: Self = StObject.set(x, "spotMaxPrice", js.undefined)
    }
  }
  
  @js.native
  trait GroupMixedInstancesPolicyLaunchTemplate extends StObject {
    
    /**
      * Nested argument defines the Launch Template. Defined below.
      */
    var launchTemplateSpecification: GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification = js.native
    
    /**
      * List of nested arguments provides the ability to specify multiple instance types. This will override the same parameter in the launch template. For on-demand instances, Auto Scaling considers the order of preference of instance types to launch based on the order specified in the overrides list. Defined below.
      */
    var overrides: js.UndefOr[js.Array[GroupMixedInstancesPolicyLaunchTemplateOverride]] = js.native
  }
  object GroupMixedInstancesPolicyLaunchTemplate {
    
    @scala.inline
    def apply(launchTemplateSpecification: GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification): GroupMixedInstancesPolicyLaunchTemplate = {
      val __obj = js.Dynamic.literal(launchTemplateSpecification = launchTemplateSpecification.asInstanceOf[js.Any])
      __obj.asInstanceOf[GroupMixedInstancesPolicyLaunchTemplate]
    }
    
    @scala.inline
    implicit class GroupMixedInstancesPolicyLaunchTemplateMutableBuilder[Self <: GroupMixedInstancesPolicyLaunchTemplate] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setLaunchTemplateSpecification(value: GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification): Self = StObject.set(x, "launchTemplateSpecification", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOverrides(value: js.Array[GroupMixedInstancesPolicyLaunchTemplateOverride]): Self = StObject.set(x, "overrides", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOverridesUndefined: Self = StObject.set(x, "overrides", js.undefined)
      
      @scala.inline
      def setOverridesVarargs(value: GroupMixedInstancesPolicyLaunchTemplateOverride*): Self = StObject.set(x, "overrides", js.Array(value :_*))
    }
  }
  
  @js.native
  trait GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification extends StObject {
    
    /**
      * The ID of the launch template. Conflicts with `launchTemplateName`.
      */
    var launchTemplateId: String = js.native
    
    /**
      * The name of the launch template. Conflicts with `launchTemplateId`.
      */
    var launchTemplateName: String = js.native
    
    /**
      * Template version. Can be version number, `$Latest`, or `$Default`. (Default: `$Default`).
      */
    var version: js.UndefOr[String] = js.native
  }
  object GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification {
    
    @scala.inline
    def apply(launchTemplateId: String, launchTemplateName: String): GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification = {
      val __obj = js.Dynamic.literal(launchTemplateId = launchTemplateId.asInstanceOf[js.Any], launchTemplateName = launchTemplateName.asInstanceOf[js.Any])
      __obj.asInstanceOf[GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification]
    }
    
    @scala.inline
    implicit class GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationMutableBuilder[Self <: GroupMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setLaunchTemplateId(value: String): Self = StObject.set(x, "launchTemplateId", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLaunchTemplateName(value: String): Self = StObject.set(x, "launchTemplateName", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVersion(value: String): Self = StObject.set(x, "version", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVersionUndefined: Self = StObject.set(x, "version", js.undefined)
    }
  }
  
  @js.native
  trait GroupMixedInstancesPolicyLaunchTemplateOverride extends StObject {
    
    /**
      * Override the instance type in the Launch Template.
      */
    var instanceType: js.UndefOr[String] = js.native
    
    /**
      * The number of capacity units, which gives the instance type a proportional weight to other instance types.
      */
    var weightedCapacity: js.UndefOr[String] = js.native
  }
  object GroupMixedInstancesPolicyLaunchTemplateOverride {
    
    @scala.inline
    def apply(): GroupMixedInstancesPolicyLaunchTemplateOverride = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[GroupMixedInstancesPolicyLaunchTemplateOverride]
    }
    
    @scala.inline
    implicit class GroupMixedInstancesPolicyLaunchTemplateOverrideMutableBuilder[Self <: GroupMixedInstancesPolicyLaunchTemplateOverride] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setInstanceType(value: String): Self = StObject.set(x, "instanceType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setInstanceTypeUndefined: Self = StObject.set(x, "instanceType", js.undefined)
      
      @scala.inline
      def setWeightedCapacity(value: String): Self = StObject.set(x, "weightedCapacity", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setWeightedCapacityUndefined: Self = StObject.set(x, "weightedCapacity", js.undefined)
    }
  }
  
  @js.native
  trait GroupTag extends StObject {
    
    /**
      * Key
      */
    var key: String = js.native
    
    /**
      * Enables propagation of the tag to
      * Amazon EC2 instances launched via this ASG
      */
    var propagateAtLaunch: Boolean = js.native
    
    /**
      * Value
      */
    var value: String = js.native
  }
  object GroupTag {
    
    @scala.inline
    def apply(key: String, propagateAtLaunch: Boolean, value: String): GroupTag = {
      val __obj = js.Dynamic.literal(key = key.asInstanceOf[js.Any], propagateAtLaunch = propagateAtLaunch.asInstanceOf[js.Any], value = value.asInstanceOf[js.Any])
      __obj.asInstanceOf[GroupTag]
    }
    
    @scala.inline
    implicit class GroupTagMutableBuilder[Self <: GroupTag] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setKey(value: String): Self = StObject.set(x, "key", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPropagateAtLaunch(value: Boolean): Self = StObject.set(x, "propagateAtLaunch", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setValue(value: String): Self = StObject.set(x, "value", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait PolicyStepAdjustment extends StObject {
    
    /**
      * The lower bound for the
      * difference between the alarm threshold and the CloudWatch metric.
      * Without a value, AWS will treat this bound as infinity.
      */
    var metricIntervalLowerBound: js.UndefOr[String] = js.native
    
    /**
      * The upper bound for the
      * difference between the alarm threshold and the CloudWatch metric.
      * Without a value, AWS will treat this bound as infinity. The upper bound
      * must be greater than the lower bound.
      */
    var metricIntervalUpperBound: js.UndefOr[String] = js.native
    
    /**
      * The number of members by which to
      * scale, when the adjustment bounds are breached. A positive value scales
      * up. A negative value scales down.
      */
    var scalingAdjustment: Double = js.native
  }
  object PolicyStepAdjustment {
    
    @scala.inline
    def apply(scalingAdjustment: Double): PolicyStepAdjustment = {
      val __obj = js.Dynamic.literal(scalingAdjustment = scalingAdjustment.asInstanceOf[js.Any])
      __obj.asInstanceOf[PolicyStepAdjustment]
    }
    
    @scala.inline
    implicit class PolicyStepAdjustmentMutableBuilder[Self <: PolicyStepAdjustment] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setMetricIntervalLowerBound(value: String): Self = StObject.set(x, "metricIntervalLowerBound", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMetricIntervalLowerBoundUndefined: Self = StObject.set(x, "metricIntervalLowerBound", js.undefined)
      
      @scala.inline
      def setMetricIntervalUpperBound(value: String): Self = StObject.set(x, "metricIntervalUpperBound", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMetricIntervalUpperBoundUndefined: Self = StObject.set(x, "metricIntervalUpperBound", js.undefined)
      
      @scala.inline
      def setScalingAdjustment(value: Double): Self = StObject.set(x, "scalingAdjustment", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait PolicyTargetTrackingConfiguration extends StObject {
    
    /**
      * A customized metric. Conflicts with `predefinedMetricSpecification`.
      */
    var customizedMetricSpecification: js.UndefOr[PolicyTargetTrackingConfigurationCustomizedMetricSpecification] = js.native
    
    /**
      * Indicates whether scale in by the target tracking policy is disabled.
      */
    var disableScaleIn: js.UndefOr[Boolean] = js.native
    
    /**
      * A predefined metric. Conflicts with `customizedMetricSpecification`.
      */
    var predefinedMetricSpecification: js.UndefOr[PolicyTargetTrackingConfigurationPredefinedMetricSpecification] = js.native
    
    /**
      * The target value for the metric.
      */
    var targetValue: Double = js.native
  }
  object PolicyTargetTrackingConfiguration {
    
    @scala.inline
    def apply(targetValue: Double): PolicyTargetTrackingConfiguration = {
      val __obj = js.Dynamic.literal(targetValue = targetValue.asInstanceOf[js.Any])
      __obj.asInstanceOf[PolicyTargetTrackingConfiguration]
    }
    
    @scala.inline
    implicit class PolicyTargetTrackingConfigurationMutableBuilder[Self <: PolicyTargetTrackingConfiguration] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setCustomizedMetricSpecification(value: PolicyTargetTrackingConfigurationCustomizedMetricSpecification): Self = StObject.set(x, "customizedMetricSpecification", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCustomizedMetricSpecificationUndefined: Self = StObject.set(x, "customizedMetricSpecification", js.undefined)
      
      @scala.inline
      def setDisableScaleIn(value: Boolean): Self = StObject.set(x, "disableScaleIn", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDisableScaleInUndefined: Self = StObject.set(x, "disableScaleIn", js.undefined)
      
      @scala.inline
      def setPredefinedMetricSpecification(value: PolicyTargetTrackingConfigurationPredefinedMetricSpecification): Self = StObject.set(x, "predefinedMetricSpecification", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPredefinedMetricSpecificationUndefined: Self = StObject.set(x, "predefinedMetricSpecification", js.undefined)
      
      @scala.inline
      def setTargetValue(value: Double): Self = StObject.set(x, "targetValue", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait PolicyTargetTrackingConfigurationCustomizedMetricSpecification extends StObject {
    
    /**
      * The dimensions of the metric.
      */
    var metricDimensions: js.UndefOr[
        js.Array[PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension]
      ] = js.native
    
    /**
      * The name of the metric.
      */
    var metricName: String = js.native
    
    /**
      * The namespace of the metric.
      */
    var namespace: String = js.native
    
    /**
      * The statistic of the metric.
      */
    var statistic: String = js.native
    
    /**
      * The unit of the metric.
      */
    var unit: js.UndefOr[String] = js.native
  }
  object PolicyTargetTrackingConfigurationCustomizedMetricSpecification {
    
    @scala.inline
    def apply(metricName: String, namespace: String, statistic: String): PolicyTargetTrackingConfigurationCustomizedMetricSpecification = {
      val __obj = js.Dynamic.literal(metricName = metricName.asInstanceOf[js.Any], namespace = namespace.asInstanceOf[js.Any], statistic = statistic.asInstanceOf[js.Any])
      __obj.asInstanceOf[PolicyTargetTrackingConfigurationCustomizedMetricSpecification]
    }
    
    @scala.inline
    implicit class PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMutableBuilder[Self <: PolicyTargetTrackingConfigurationCustomizedMetricSpecification] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setMetricDimensions(value: js.Array[PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension]): Self = StObject.set(x, "metricDimensions", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMetricDimensionsUndefined: Self = StObject.set(x, "metricDimensions", js.undefined)
      
      @scala.inline
      def setMetricDimensionsVarargs(value: PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension*): Self = StObject.set(x, "metricDimensions", js.Array(value :_*))
      
      @scala.inline
      def setMetricName(value: String): Self = StObject.set(x, "metricName", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNamespace(value: String): Self = StObject.set(x, "namespace", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStatistic(value: String): Self = StObject.set(x, "statistic", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUnit(value: String): Self = StObject.set(x, "unit", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUnitUndefined: Self = StObject.set(x, "unit", js.undefined)
    }
  }
  
  @js.native
  trait PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension extends StObject {
    
    /**
      * The name of the dimension.
      */
    var name: String = js.native
    
    /**
      * The value of the dimension.
      */
    var value: String = js.native
  }
  object PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension {
    
    @scala.inline
    def apply(name: String, value: String): PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension = {
      val __obj = js.Dynamic.literal(name = name.asInstanceOf[js.Any], value = value.asInstanceOf[js.Any])
      __obj.asInstanceOf[PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension]
    }
    
    @scala.inline
    implicit class PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimensionMutableBuilder[Self <: PolicyTargetTrackingConfigurationCustomizedMetricSpecificationMetricDimension] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setName(value: String): Self = StObject.set(x, "name", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setValue(value: String): Self = StObject.set(x, "value", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait PolicyTargetTrackingConfigurationPredefinedMetricSpecification extends StObject {
    
    /**
      * The metric type.
      */
    var predefinedMetricType: String = js.native
    
    /**
      * Identifies the resource associated with the metric type.
      */
    var resourceLabel: js.UndefOr[String] = js.native
  }
  object PolicyTargetTrackingConfigurationPredefinedMetricSpecification {
    
    @scala.inline
    def apply(predefinedMetricType: String): PolicyTargetTrackingConfigurationPredefinedMetricSpecification = {
      val __obj = js.Dynamic.literal(predefinedMetricType = predefinedMetricType.asInstanceOf[js.Any])
      __obj.asInstanceOf[PolicyTargetTrackingConfigurationPredefinedMetricSpecification]
    }
    
    @scala.inline
    implicit class PolicyTargetTrackingConfigurationPredefinedMetricSpecificationMutableBuilder[Self <: PolicyTargetTrackingConfigurationPredefinedMetricSpecification] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setPredefinedMetricType(value: String): Self = StObject.set(x, "predefinedMetricType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setResourceLabel(value: String): Self = StObject.set(x, "resourceLabel", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setResourceLabelUndefined: Self = StObject.set(x, "resourceLabel", js.undefined)
    }
  }
}
