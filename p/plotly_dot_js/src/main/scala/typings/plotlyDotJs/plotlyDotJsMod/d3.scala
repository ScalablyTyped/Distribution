package typings.plotlyDotJs.plotlyDotJsMod

import org.scalablytyped.runtime.NumberDictionary
import org.scalablytyped.runtime.StringDictionary
import typings.d3DashArray.d3DashArrayMod.Bisector
import typings.d3DashArray.d3DashArrayMod.HistogramGeneratorDate
import typings.d3DashArray.d3DashArrayMod.HistogramGeneratorNumber
import typings.d3DashArray.d3DashArrayMod.Numeric
import typings.d3DashArray.d3DashArrayMod.Primitive
import typings.d3DashAxis.d3DashAxisMod.AxisDomain
import typings.d3DashAxis.d3DashAxisMod.AxisScale
import typings.d3DashBrush.d3DashBrushMod.BrushBehavior
import typings.d3DashBrush.d3DashBrushMod.BrushSelection
import typings.d3DashChord.d3DashChordMod.ChordLayout
import typings.d3DashChord.d3DashChordMod.Ribbon
import typings.d3DashChord.d3DashChordMod.RibbonGenerator
import typings.d3DashChord.d3DashChordMod.RibbonSubgroup
import typings.d3DashCollection.Anon_Key
import typings.d3DashCollection.Anon_KeyValue
import typings.d3DashCollection.d3DashCollectionMod.Nest
import typings.d3DashCollection.d3DashCollectionMod.Set
import typings.d3DashCollection.d3DashCollectionMod.Stringifiable
import typings.d3DashColor.d3DashColorMod.ColorCommonInstance
import typings.d3DashColor.d3DashColorMod.ColorFactory
import typings.d3DashColor.d3DashColorMod.ColorSpaceObject
import typings.d3DashColor.d3DashColorMod.CubehelixColor
import typings.d3DashColor.d3DashColorMod.CubehelixColorFactory
import typings.d3DashColor.d3DashColorMod.HCLColor
import typings.d3DashColor.d3DashColorMod.HCLColorFactory
import typings.d3DashColor.d3DashColorMod.HSLColor
import typings.d3DashColor.d3DashColorMod.HSLColorFactory
import typings.d3DashColor.d3DashColorMod.LabColor
import typings.d3DashColor.d3DashColorMod.LabColorFactory
import typings.d3DashColor.d3DashColorMod.RGBColor
import typings.d3DashColor.d3DashColorMod.RGBColorFactory
import typings.d3DashContour.d3DashContourMod.ContourDensity
import typings.d3DashContour.d3DashContourMod.Contours
import typings.d3DashDispatch.d3DashDispatchMod.Dispatch
import typings.d3DashDrag.d3DashDragMod.DragBehavior
import typings.d3DashDrag.d3DashDragMod.DraggedElementBaseType
import typings.d3DashDrag.d3DashDragMod.SubjectPosition
import typings.d3DashDsv.d3DashDsvMod.DSV
import typings.d3DashDsv.d3DashDsvMod.DSVParsedArray
import typings.d3DashDsv.d3DashDsvMod.DSVRowArray
import typings.d3DashDsv.d3DashDsvMod.DSVRowString
import typings.d3DashEase.d3DashEaseMod.BackEasingFactory
import typings.d3DashEase.d3DashEaseMod.ElasticEasingFactory
import typings.d3DashEase.d3DashEaseMod.PolynomialEasingFactory
import typings.d3DashForce.d3DashForceMod.ForceCenter
import typings.d3DashForce.d3DashForceMod.ForceCollide
import typings.d3DashForce.d3DashForceMod.ForceLink
import typings.d3DashForce.d3DashForceMod.ForceManyBody
import typings.d3DashForce.d3DashForceMod.ForceRadial
import typings.d3DashForce.d3DashForceMod.ForceX
import typings.d3DashForce.d3DashForceMod.ForceY
import typings.d3DashForce.d3DashForceMod.Simulation
import typings.d3DashForce.d3DashForceMod.SimulationLinkDatum
import typings.d3DashForce.d3DashForceMod.SimulationNodeDatum
import typings.d3DashFormat.Anon_ValueOf
import typings.d3DashFormat.d3DashFormatMod.FormatLocaleDefinition
import typings.d3DashFormat.d3DashFormatMod.FormatLocaleObject
import typings.d3DashFormat.d3DashFormatMod.FormatSpecifier
import typings.d3DashGeo.Anon_S
import typings.d3DashGeo.d3DashGeoMod.ExtendedFeature
import typings.d3DashGeo.d3DashGeoMod.ExtendedFeatureCollection
import typings.d3DashGeo.d3DashGeoMod.ExtendedGeometryCollection
import typings.d3DashGeo.d3DashGeoMod.GeoCircleGenerator
import typings.d3DashGeo.d3DashGeoMod.GeoConicProjection
import typings.d3DashGeo.d3DashGeoMod.GeoContext
import typings.d3DashGeo.d3DashGeoMod.GeoGeometryObjects
import typings.d3DashGeo.d3DashGeoMod.GeoGraticuleGenerator
import typings.d3DashGeo.d3DashGeoMod.GeoIdentityTransform
import typings.d3DashGeo.d3DashGeoMod.GeoPath
import typings.d3DashGeo.d3DashGeoMod.GeoPermissibleObjects
import typings.d3DashGeo.d3DashGeoMod.GeoProjection
import typings.d3DashGeo.d3DashGeoMod.GeoRawProjection
import typings.d3DashGeo.d3DashGeoMod.GeoRotation
import typings.d3DashGeo.d3DashGeoMod.GeoStream
import typings.d3DashGeo.d3DashGeoMod.GeoStreamWrapper
import typings.d3DashGeo.d3DashGeoMod.GeoTransformPrototype
import typings.d3DashHierarchy.d3DashHierarchyMod.ClusterLayout
import typings.d3DashHierarchy.d3DashHierarchyMod.HierarchyNode
import typings.d3DashHierarchy.d3DashHierarchyMod.HierarchyRectangularNode
import typings.d3DashHierarchy.d3DashHierarchyMod.PackCircle
import typings.d3DashHierarchy.d3DashHierarchyMod.PackLayout
import typings.d3DashHierarchy.d3DashHierarchyMod.PackRadius
import typings.d3DashHierarchy.d3DashHierarchyMod.PartitionLayout
import typings.d3DashHierarchy.d3DashHierarchyMod.RatioSquarifyTilingFactory
import typings.d3DashHierarchy.d3DashHierarchyMod.StratifyOperator
import typings.d3DashHierarchy.d3DashHierarchyMod.TreeLayout
import typings.d3DashHierarchy.d3DashHierarchyMod.TreemapLayout
import typings.d3DashInterpolate.Anon_ToString
import typings.d3DashInterpolate.d3DashInterpolateMod.ArrayInterpolator
import typings.d3DashInterpolate.d3DashInterpolateMod.ColorGammaInterpolationFactory
import typings.d3DashInterpolate.d3DashInterpolateMod.ZoomInterpolator
import typings.d3DashInterpolate.d3DashInterpolateMod.ZoomView
import typings.d3DashPath.d3DashPathMod.Path
import typings.d3DashQuadtree.d3DashQuadtreeMod.Quadtree
import typings.d3DashRandom.d3DashRandomMod.RandomBates
import typings.d3DashRandom.d3DashRandomMod.RandomExponential
import typings.d3DashRandom.d3DashRandomMod.RandomIrwinHall
import typings.d3DashRandom.d3DashRandomMod.RandomLogNormal
import typings.d3DashRandom.d3DashRandomMod.RandomNormal
import typings.d3DashRandom.d3DashRandomMod.RandomUniform
import typings.d3DashScale.d3DashScaleMod.ScaleBand
import typings.d3DashScale.d3DashScaleMod.ScaleDiverging
import typings.d3DashScale.d3DashScaleMod.ScaleIdentity
import typings.d3DashScale.d3DashScaleMod.ScaleLinear
import typings.d3DashScale.d3DashScaleMod.ScaleLogarithmic
import typings.d3DashScale.d3DashScaleMod.ScaleOrdinal
import typings.d3DashScale.d3DashScaleMod.ScalePoint
import typings.d3DashScale.d3DashScaleMod.ScalePower
import typings.d3DashScale.d3DashScaleMod.ScaleQuantile
import typings.d3DashScale.d3DashScaleMod.ScaleQuantize
import typings.d3DashScale.d3DashScaleMod.ScaleSequential
import typings.d3DashScale.d3DashScaleMod.ScaleThreshold
import typings.d3DashScale.d3DashScaleMod.ScaleTime
import typings.d3DashSelection.d3DashSelectionMod.BaseEvent
import typings.d3DashSelection.d3DashSelectionMod.BaseType
import typings.d3DashSelection.d3DashSelectionMod.ClientPointEvent
import typings.d3DashSelection.d3DashSelectionMod.ContainerElement
import typings.d3DashSelection.d3DashSelectionMod.EnterElement
import typings.d3DashSelection.d3DashSelectionMod.Local
import typings.d3DashSelection.d3DashSelectionMod.NamespaceLocalObject
import typings.d3DashSelection.d3DashSelectionMod.NamespaceMap
import typings.d3DashSelection.d3DashSelectionMod.Selection
import typings.d3DashShape.d3DashShapeMod.Arc
import typings.d3DashShape.d3DashShapeMod.Area
import typings.d3DashShape.d3DashShapeMod.AreaRadial
import typings.d3DashShape.d3DashShapeMod.CurveBundleFactory
import typings.d3DashShape.d3DashShapeMod.CurveCardinalFactory
import typings.d3DashShape.d3DashShapeMod.CurveCatmullRomFactory
import typings.d3DashShape.d3DashShapeMod.CurveGenerator
import typings.d3DashShape.d3DashShapeMod.DefaultArcObject
import typings.d3DashShape.d3DashShapeMod.DefaultLinkObject
import typings.d3DashShape.d3DashShapeMod.Line
import typings.d3DashShape.d3DashShapeMod.LineRadial
import typings.d3DashShape.d3DashShapeMod.Link
import typings.d3DashShape.d3DashShapeMod.LinkRadial
import typings.d3DashShape.d3DashShapeMod.Pie
import typings.d3DashShape.d3DashShapeMod.RadialArea
import typings.d3DashShape.d3DashShapeMod.RadialLine
import typings.d3DashShape.d3DashShapeMod.Series
import typings.d3DashShape.d3DashShapeMod.Stack
import typings.d3DashShape.d3DashShapeMod.Symbol
import typings.d3DashShape.d3DashShapeMod.SymbolType
import typings.d3DashShape.d3DashShapeMod._Global_.CanvasRenderingContext2D
import typings.d3DashTime.d3DashTimeMod.CountableTimeInterval
import typings.d3DashTime.d3DashTimeMod.TimeInterval
import typings.d3DashTimeDashFormat.d3DashTimeDashFormatMod.TimeLocaleDefinition
import typings.d3DashTimeDashFormat.d3DashTimeDashFormatMod.TimeLocaleObject
import typings.d3DashTimer.d3DashTimerMod.Timer
import typings.d3DashVoronoi.d3DashVoronoiMod.VoronoiLayout
import typings.d3DashZoom.d3DashZoomMod.ZoomBehavior
import typings.d3DashZoom.d3DashZoomMod.ZoomTransform
import typings.d3DashZoom.d3DashZoomMod.ZoomedElementBaseType
import typings.geojson.geojsonMod.GeoJsonProperties
import typings.geojson.geojsonMod.MultiLineString
import typings.plotlyDotJs.Anon_Implicit
import typings.plotlyDotJs.plotlyDotJsStrings.`object`
import typings.plotlyDotJs.plotlyDotJsStrings.`var`
import typings.plotlyDotJs.plotlyDotJsStrings.a
import typings.plotlyDotJs.plotlyDotJsStrings.abbr
import typings.plotlyDotJs.plotlyDotJsStrings.address
import typings.plotlyDotJs.plotlyDotJsStrings.applet
import typings.plotlyDotJs.plotlyDotJsStrings.area
import typings.plotlyDotJs.plotlyDotJsStrings.article
import typings.plotlyDotJs.plotlyDotJsStrings.aside
import typings.plotlyDotJs.plotlyDotJsStrings.audio
import typings.plotlyDotJs.plotlyDotJsStrings.b
import typings.plotlyDotJs.plotlyDotJsStrings.base
import typings.plotlyDotJs.plotlyDotJsStrings.basefont
import typings.plotlyDotJs.plotlyDotJsStrings.bdi
import typings.plotlyDotJs.plotlyDotJsStrings.bdo
import typings.plotlyDotJs.plotlyDotJsStrings.blockquote
import typings.plotlyDotJs.plotlyDotJsStrings.body
import typings.plotlyDotJs.plotlyDotJsStrings.br
import typings.plotlyDotJs.plotlyDotJsStrings.button
import typings.plotlyDotJs.plotlyDotJsStrings.canvas
import typings.plotlyDotJs.plotlyDotJsStrings.caption
import typings.plotlyDotJs.plotlyDotJsStrings.cite
import typings.plotlyDotJs.plotlyDotJsStrings.code
import typings.plotlyDotJs.plotlyDotJsStrings.col
import typings.plotlyDotJs.plotlyDotJsStrings.colgroup
import typings.plotlyDotJs.plotlyDotJsStrings.data
import typings.plotlyDotJs.plotlyDotJsStrings.datalist
import typings.plotlyDotJs.plotlyDotJsStrings.dd
import typings.plotlyDotJs.plotlyDotJsStrings.del
import typings.plotlyDotJs.plotlyDotJsStrings.details
import typings.plotlyDotJs.plotlyDotJsStrings.dfn
import typings.plotlyDotJs.plotlyDotJsStrings.dialog
import typings.plotlyDotJs.plotlyDotJsStrings.dir
import typings.plotlyDotJs.plotlyDotJsStrings.div
import typings.plotlyDotJs.plotlyDotJsStrings.dl
import typings.plotlyDotJs.plotlyDotJsStrings.dt
import typings.plotlyDotJs.plotlyDotJsStrings.em
import typings.plotlyDotJs.plotlyDotJsStrings.embed
import typings.plotlyDotJs.plotlyDotJsStrings.fieldset
import typings.plotlyDotJs.plotlyDotJsStrings.figcaption
import typings.plotlyDotJs.plotlyDotJsStrings.figure
import typings.plotlyDotJs.plotlyDotJsStrings.font
import typings.plotlyDotJs.plotlyDotJsStrings.footer
import typings.plotlyDotJs.plotlyDotJsStrings.form
import typings.plotlyDotJs.plotlyDotJsStrings.frame
import typings.plotlyDotJs.plotlyDotJsStrings.frameset
import typings.plotlyDotJs.plotlyDotJsStrings.h1
import typings.plotlyDotJs.plotlyDotJsStrings.h2
import typings.plotlyDotJs.plotlyDotJsStrings.h3
import typings.plotlyDotJs.plotlyDotJsStrings.h4
import typings.plotlyDotJs.plotlyDotJsStrings.h5
import typings.plotlyDotJs.plotlyDotJsStrings.h6
import typings.plotlyDotJs.plotlyDotJsStrings.head
import typings.plotlyDotJs.plotlyDotJsStrings.header
import typings.plotlyDotJs.plotlyDotJsStrings.hgroup
import typings.plotlyDotJs.plotlyDotJsStrings.hr
import typings.plotlyDotJs.plotlyDotJsStrings.html
import typings.plotlyDotJs.plotlyDotJsStrings.i
import typings.plotlyDotJs.plotlyDotJsStrings.iframe
import typings.plotlyDotJs.plotlyDotJsStrings.img
import typings.plotlyDotJs.plotlyDotJsStrings.input
import typings.plotlyDotJs.plotlyDotJsStrings.ins
import typings.plotlyDotJs.plotlyDotJsStrings.kbd
import typings.plotlyDotJs.plotlyDotJsStrings.label
import typings.plotlyDotJs.plotlyDotJsStrings.legend
import typings.plotlyDotJs.plotlyDotJsStrings.li
import typings.plotlyDotJs.plotlyDotJsStrings.link
import typings.plotlyDotJs.plotlyDotJsStrings.main
import typings.plotlyDotJs.plotlyDotJsStrings.map
import typings.plotlyDotJs.plotlyDotJsStrings.mark
import typings.plotlyDotJs.plotlyDotJsStrings.marquee
import typings.plotlyDotJs.plotlyDotJsStrings.menu
import typings.plotlyDotJs.plotlyDotJsStrings.meta
import typings.plotlyDotJs.plotlyDotJsStrings.meter
import typings.plotlyDotJs.plotlyDotJsStrings.nav
import typings.plotlyDotJs.plotlyDotJsStrings.noscript
import typings.plotlyDotJs.plotlyDotJsStrings.ol
import typings.plotlyDotJs.plotlyDotJsStrings.optgroup
import typings.plotlyDotJs.plotlyDotJsStrings.option
import typings.plotlyDotJs.plotlyDotJsStrings.output
import typings.plotlyDotJs.plotlyDotJsStrings.p
import typings.plotlyDotJs.plotlyDotJsStrings.param
import typings.plotlyDotJs.plotlyDotJsStrings.picture
import typings.plotlyDotJs.plotlyDotJsStrings.pre
import typings.plotlyDotJs.plotlyDotJsStrings.progress
import typings.plotlyDotJs.plotlyDotJsStrings.q
import typings.plotlyDotJs.plotlyDotJsStrings.rp
import typings.plotlyDotJs.plotlyDotJsStrings.rt
import typings.plotlyDotJs.plotlyDotJsStrings.ruby
import typings.plotlyDotJs.plotlyDotJsStrings.s
import typings.plotlyDotJs.plotlyDotJsStrings.samp
import typings.plotlyDotJs.plotlyDotJsStrings.script
import typings.plotlyDotJs.plotlyDotJsStrings.section
import typings.plotlyDotJs.plotlyDotJsStrings.select
import typings.plotlyDotJs.plotlyDotJsStrings.slot
import typings.plotlyDotJs.plotlyDotJsStrings.small
import typings.plotlyDotJs.plotlyDotJsStrings.source
import typings.plotlyDotJs.plotlyDotJsStrings.span
import typings.plotlyDotJs.plotlyDotJsStrings.strong
import typings.plotlyDotJs.plotlyDotJsStrings.style
import typings.plotlyDotJs.plotlyDotJsStrings.sub
import typings.plotlyDotJs.plotlyDotJsStrings.summary
import typings.plotlyDotJs.plotlyDotJsStrings.sup
import typings.plotlyDotJs.plotlyDotJsStrings.table
import typings.plotlyDotJs.plotlyDotJsStrings.tbody
import typings.plotlyDotJs.plotlyDotJsStrings.td
import typings.plotlyDotJs.plotlyDotJsStrings.template
import typings.plotlyDotJs.plotlyDotJsStrings.textarea
import typings.plotlyDotJs.plotlyDotJsStrings.tfoot
import typings.plotlyDotJs.plotlyDotJsStrings.th
import typings.plotlyDotJs.plotlyDotJsStrings.thead
import typings.plotlyDotJs.plotlyDotJsStrings.time
import typings.plotlyDotJs.plotlyDotJsStrings.title
import typings.plotlyDotJs.plotlyDotJsStrings.tr
import typings.plotlyDotJs.plotlyDotJsStrings.track
import typings.plotlyDotJs.plotlyDotJsStrings.u
import typings.plotlyDotJs.plotlyDotJsStrings.ul
import typings.plotlyDotJs.plotlyDotJsStrings.video
import typings.plotlyDotJs.plotlyDotJsStrings.wbr
import typings.std.ArrayBuffer
import typings.std.ArrayLike
import typings.std.Blob
import typings.std.Date
import typings.std.Document
import typings.std.Element
import typings.std.EventTarget
import typings.std.Float32Array
import typings.std.Float64Array
import typings.std.HTMLAnchorElement
import typings.std.HTMLAppletElement
import typings.std.HTMLAreaElement
import typings.std.HTMLAudioElement
import typings.std.HTMLBRElement
import typings.std.HTMLBaseElement
import typings.std.HTMLBaseFontElement
import typings.std.HTMLBodyElement
import typings.std.HTMLButtonElement
import typings.std.HTMLCanvasElement
import typings.std.HTMLDListElement
import typings.std.HTMLDataElement
import typings.std.HTMLDataListElement
import typings.std.HTMLDetailsElement
import typings.std.HTMLDialogElement
import typings.std.HTMLDirectoryElement
import typings.std.HTMLDivElement
import typings.std.HTMLElement
import typings.std.HTMLEmbedElement
import typings.std.HTMLFieldSetElement
import typings.std.HTMLFontElement
import typings.std.HTMLFormElement
import typings.std.HTMLFrameElement
import typings.std.HTMLFrameSetElement
import typings.std.HTMLHRElement
import typings.std.HTMLHeadElement
import typings.std.HTMLHeadingElement
import typings.std.HTMLHtmlElement
import typings.std.HTMLIFrameElement
import typings.std.HTMLImageElement
import typings.std.HTMLInputElement
import typings.std.HTMLLIElement
import typings.std.HTMLLabelElement
import typings.std.HTMLLegendElement
import typings.std.HTMLLinkElement
import typings.std.HTMLMapElement
import typings.std.HTMLMarqueeElement
import typings.std.HTMLMenuElement
import typings.std.HTMLMetaElement
import typings.std.HTMLMeterElement
import typings.std.HTMLModElement
import typings.std.HTMLOListElement
import typings.std.HTMLObjectElement
import typings.std.HTMLOptGroupElement
import typings.std.HTMLOptionElement
import typings.std.HTMLOutputElement
import typings.std.HTMLParagraphElement
import typings.std.HTMLParamElement
import typings.std.HTMLPictureElement
import typings.std.HTMLPreElement
import typings.std.HTMLProgressElement
import typings.std.HTMLQuoteElement
import typings.std.HTMLScriptElement
import typings.std.HTMLSelectElement
import typings.std.HTMLSlotElement
import typings.std.HTMLSourceElement
import typings.std.HTMLSpanElement
import typings.std.HTMLStyleElement
import typings.std.HTMLTableCaptionElement
import typings.std.HTMLTableColElement
import typings.std.HTMLTableDataCellElement
import typings.std.HTMLTableElement
import typings.std.HTMLTableHeaderCellElement
import typings.std.HTMLTableRowElement
import typings.std.HTMLTableSectionElement
import typings.std.HTMLTemplateElement
import typings.std.HTMLTextAreaElement
import typings.std.HTMLTimeElement
import typings.std.HTMLTitleElement
import typings.std.HTMLTrackElement
import typings.std.HTMLUListElement
import typings.std.HTMLVideoElement
import typings.std.Int16Array
import typings.std.Int32Array
import typings.std.Int8Array
import typings.std.Iterable
import typings.std.Map
import typings.std.NodeListOf
import typings.std.Partial
import typings.std.RequestInit
import typings.std.SVGGElement
import typings.std.TouchList
import typings.std.Uint16Array
import typings.std.Uint32Array
import typings.std.Uint8Array
import typings.std.Uint8ClampedArray
import typings.std.Window
import typings.std.XMLDocument
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@JSImport("plotly.js", "d3")
@js.native
object d3 extends js.Object {
  @JSName("color")
  val color_Original: ColorFactory = js.native
  @JSName("cubehelix")
  val cubehelix_Original: CubehelixColorFactory = js.native
  val curveBundle: CurveBundleFactory = js.native
  val curveCardinal: CurveCardinalFactory = js.native
  val curveCardinalClosed: CurveCardinalFactory = js.native
  val curveCardinalOpen: CurveCardinalFactory = js.native
  val curveCatmullRom: CurveCatmullRomFactory = js.native
  val curveCatmullRomClosed: CurveCatmullRomFactory = js.native
  val curveCatmullRomOpen: CurveCatmullRomFactory = js.native
  @JSName("easeBackInOut")
  val easeBackInOut_Original: BackEasingFactory = js.native
  @JSName("easeBackIn")
  val easeBackIn_Original: BackEasingFactory = js.native
  @JSName("easeBackOut")
  val easeBackOut_Original: BackEasingFactory = js.native
  @JSName("easeBack")
  val easeBack_Original: BackEasingFactory = js.native
  @JSName("easeElasticInOut")
  val easeElasticInOut_Original: ElasticEasingFactory = js.native
  @JSName("easeElasticIn")
  val easeElasticIn_Original: ElasticEasingFactory = js.native
  @JSName("easeElasticOut")
  val easeElasticOut_Original: ElasticEasingFactory = js.native
  @JSName("easeElastic")
  val easeElastic_Original: ElasticEasingFactory = js.native
  @JSName("easePolyInOut")
  val easePolyInOut_Original: PolynomialEasingFactory = js.native
  @JSName("easePolyIn")
  val easePolyIn_Original: PolynomialEasingFactory = js.native
  @JSName("easePolyOut")
  val easePolyOut_Original: PolynomialEasingFactory = js.native
  @JSName("easePoly")
  val easePoly_Original: PolynomialEasingFactory = js.native
  val event: js.Any = js.native
  @JSName("hcl")
  val hcl_Original: HCLColorFactory = js.native
  @JSName("hsl")
  val hsl_Original: HSLColorFactory = js.native
  @JSName("interpolateCubehelixLong")
  val interpolateCubehelixLong_Original: ColorGammaInterpolationFactory = js.native
  @JSName("interpolateCubehelix")
  val interpolateCubehelix_Original: ColorGammaInterpolationFactory = js.native
  @JSName("interpolateRgb")
  val interpolateRgb_Original: ColorGammaInterpolationFactory = js.native
  @JSName("lab")
  val lab_Original: LabColorFactory = js.native
  val namespaces: NamespaceMap = js.native
  @JSName("randomBates")
  val randomBates_Original: RandomBates = js.native
  @JSName("randomExponential")
  val randomExponential_Original: RandomExponential = js.native
  @JSName("randomIrwinHall")
  val randomIrwinHall_Original: RandomIrwinHall = js.native
  @JSName("randomLogNormal")
  val randomLogNormal_Original: RandomLogNormal = js.native
  @JSName("randomNormal")
  val randomNormal_Original: RandomNormal = js.native
  @JSName("randomUniform")
  val randomUniform_Original: RandomUniform = js.native
  @JSName("rgb")
  val rgb_Original: RGBColorFactory = js.native
  val scaleImplicit: Anon_Implicit = js.native
  val schemeAccent: js.Array[String] = js.native
  val schemeBlues: js.Array[js.Array[String]] = js.native
  val schemeBrBG: js.Array[js.Array[String]] = js.native
  val schemeBuGn: js.Array[js.Array[String]] = js.native
  val schemeBuPu: js.Array[js.Array[String]] = js.native
  val schemeCategory10: js.Array[String] = js.native
  val schemeDark2: js.Array[String] = js.native
  val schemeGnBu: js.Array[js.Array[String]] = js.native
  val schemeGreens: js.Array[js.Array[String]] = js.native
  val schemeGreys: js.Array[js.Array[String]] = js.native
  val schemeOrRd: js.Array[js.Array[String]] = js.native
  val schemeOranges: js.Array[js.Array[String]] = js.native
  val schemePRGn: js.Array[js.Array[String]] = js.native
  val schemePaired: js.Array[String] = js.native
  val schemePastel1: js.Array[String] = js.native
  val schemePastel2: js.Array[String] = js.native
  val schemePiYG: js.Array[js.Array[String]] = js.native
  val schemePuBu: js.Array[js.Array[String]] = js.native
  val schemePuBuGn: js.Array[js.Array[String]] = js.native
  val schemePuOr: js.Array[js.Array[String]] = js.native
  val schemePuRd: js.Array[js.Array[String]] = js.native
  val schemePurples: js.Array[js.Array[String]] = js.native
  val schemeRdBu: js.Array[js.Array[String]] = js.native
  val schemeRdGy: js.Array[js.Array[String]] = js.native
  val schemeRdPu: js.Array[js.Array[String]] = js.native
  val schemeRdYlBu: js.Array[js.Array[String]] = js.native
  val schemeRdYlGn: js.Array[js.Array[String]] = js.native
  val schemeReds: js.Array[js.Array[String]] = js.native
  val schemeSet1: js.Array[String] = js.native
  val schemeSet2: js.Array[String] = js.native
  val schemeSet3: js.Array[String] = js.native
  val schemeSpectral: js.Array[js.Array[String]] = js.native
  val schemeYlGn: js.Array[js.Array[String]] = js.native
  val schemeYlGnBu: js.Array[js.Array[String]] = js.native
  val schemeYlOrBr: js.Array[js.Array[String]] = js.native
  val schemeYlOrRd: js.Array[js.Array[String]] = js.native
  val symbolCircle: SymbolType = js.native
  val symbolCross: SymbolType = js.native
  val symbolDiamond: SymbolType = js.native
  val symbolSquare: SymbolType = js.native
  val symbolStar: SymbolType = js.native
  val symbolTriangle: SymbolType = js.native
  val symbolWye: SymbolType = js.native
  val symbols: js.Array[SymbolType] = js.native
  @JSName("timeDay")
  val timeDay_Original: CountableTimeInterval = js.native
  @JSName("timeFriday")
  val timeFriday_Original: CountableTimeInterval = js.native
  @JSName("timeHour")
  val timeHour_Original: CountableTimeInterval = js.native
  @JSName("timeMillisecond")
  val timeMillisecond_Original: CountableTimeInterval = js.native
  @JSName("timeMinute")
  val timeMinute_Original: CountableTimeInterval = js.native
  @JSName("timeMonday")
  val timeMonday_Original: CountableTimeInterval = js.native
  @JSName("timeMonth")
  val timeMonth_Original: CountableTimeInterval = js.native
  @JSName("timeSaturday")
  val timeSaturday_Original: CountableTimeInterval = js.native
  @JSName("timeSecond")
  val timeSecond_Original: CountableTimeInterval = js.native
  @JSName("timeSunday")
  val timeSunday_Original: CountableTimeInterval = js.native
  @JSName("timeThursday")
  val timeThursday_Original: CountableTimeInterval = js.native
  @JSName("timeTuesday")
  val timeTuesday_Original: CountableTimeInterval = js.native
  @JSName("timeWednesday")
  val timeWednesday_Original: CountableTimeInterval = js.native
  @JSName("timeWeek")
  val timeWeek_Original: CountableTimeInterval = js.native
  @JSName("timeYear")
  val timeYear_Original: CountableTimeInterval = js.native
  @JSName("treemapResquarify")
  val treemapResquarify_Original: RatioSquarifyTilingFactory = js.native
  @JSName("treemapSquarify")
  val treemapSquarify_Original: RatioSquarifyTilingFactory = js.native
  @JSName("utcDay")
  val utcDay_Original: CountableTimeInterval = js.native
  @JSName("utcFriday")
  val utcFriday_Original: CountableTimeInterval = js.native
  @JSName("utcHour")
  val utcHour_Original: CountableTimeInterval = js.native
  @JSName("utcMillisecond")
  val utcMillisecond_Original: CountableTimeInterval = js.native
  @JSName("utcMinute")
  val utcMinute_Original: CountableTimeInterval = js.native
  @JSName("utcMonday")
  val utcMonday_Original: CountableTimeInterval = js.native
  @JSName("utcMonth")
  val utcMonth_Original: CountableTimeInterval = js.native
  @JSName("utcSaturday")
  val utcSaturday_Original: CountableTimeInterval = js.native
  @JSName("utcSecond")
  val utcSecond_Original: CountableTimeInterval = js.native
  @JSName("utcSunday")
  val utcSunday_Original: CountableTimeInterval = js.native
  @JSName("utcThursday")
  val utcThursday_Original: CountableTimeInterval = js.native
  @JSName("utcTuesday")
  val utcTuesday_Original: CountableTimeInterval = js.native
  @JSName("utcWednesday")
  val utcWednesday_Original: CountableTimeInterval = js.native
  @JSName("utcWeek")
  val utcWeek_Original: CountableTimeInterval = js.native
  @JSName("utcYear")
  val utcYear_Original: CountableTimeInterval = js.native
  val version: String = js.native
  val zoomIdentity: ZoomTransform = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](): (typings.d3DashTransition.d3DashTransitionMod.Transition[Null, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Null, name: String): (typings.d3DashTransition.d3DashTransitionMod.Transition[Null, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: EnterElement): (typings.d3DashTransition.d3DashTransitionMod.Transition[EnterElement, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: EnterElement, name: String): (typings.d3DashTransition.d3DashTransitionMod.Transition[EnterElement, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Document): (typings.d3DashTransition.d3DashTransitionMod.Transition[Document, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Document, name: String): (typings.d3DashTransition.d3DashTransitionMod.Transition[Document, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Element): (typings.d3DashTransition.d3DashTransitionMod.Transition[Element, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Element, name: String): (typings.d3DashTransition.d3DashTransitionMod.Transition[Element, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Window): (typings.d3DashTransition.d3DashTransitionMod.Transition[Window, Datum, PElement, PDatum]) | Null = js.native
  def active[Datum, PElement /* <: BaseType */, PDatum](node: Window, name: String): (typings.d3DashTransition.d3DashTransitionMod.Transition[Window, Datum, PElement, PDatum]) | Null = js.native
  def arc(): Arc[_, DefaultArcObject] = js.native
  @JSName("arc")
  def arc_Datum[Datum](): Arc[_, Datum] = js.native
  @JSName("arc")
  def arc_ThisDatum[This, Datum](): Arc[This, Datum] = js.native
  def area(): Area[js.Tuple2[Double, Double]] = js.native
  def areaRadial(): AreaRadial[js.Tuple2[Double, Double]] = js.native
  @JSName("areaRadial")
  def areaRadial_Datum[Datum](): AreaRadial[Datum] = js.native
  @JSName("area")
  def area_Datum[Datum](): Area[Datum] = js.native
  def ascending(): Double = js.native
  def ascending(a: js.UndefOr[Primitive], b: Primitive): Double = js.native
  def ascending(a: Primitive): Double = js.native
  def axisBottom[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): typings.d3DashAxis.d3DashAxisMod.Axis[Domain] = js.native
  def axisLeft[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): typings.d3DashAxis.d3DashAxisMod.Axis[Domain] = js.native
  def axisRight[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): typings.d3DashAxis.d3DashAxisMod.Axis[Domain] = js.native
  def axisTop[Domain /* <: AxisDomain */](scale: AxisScale[Domain]): typings.d3DashAxis.d3DashAxisMod.Axis[Domain] = js.native
  def bisect(array: ArrayLike[String], x: String): Double = js.native
  def bisect(array: ArrayLike[String], x: String, lo: Double): Double = js.native
  def bisect(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
  def bisect(array: ArrayLike[Double], x: Double): Double = js.native
  def bisect(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
  def bisect(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
  def bisect(array: ArrayLike[Date], x: Date): Double = js.native
  def bisect(array: ArrayLike[Date], x: Date, lo: Double): Double = js.native
  def bisect(array: ArrayLike[Date], x: Date, lo: Double, hi: Double): Double = js.native
  def bisectLeft(array: ArrayLike[String], x: String): Double = js.native
  def bisectLeft(array: ArrayLike[String], x: String, lo: Double): Double = js.native
  def bisectLeft(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
  def bisectLeft(array: ArrayLike[Double], x: Double): Double = js.native
  def bisectLeft(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
  def bisectLeft(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
  def bisectLeft(array: ArrayLike[Date], x: Date): Double = js.native
  def bisectLeft(array: ArrayLike[Date], x: Date, lo: Double): Double = js.native
  def bisectLeft(array: ArrayLike[Date], x: Date, lo: Double, hi: Double): Double = js.native
  def bisectRight(array: ArrayLike[String], x: String): Double = js.native
  def bisectRight(array: ArrayLike[String], x: String, lo: Double): Double = js.native
  def bisectRight(array: ArrayLike[String], x: String, lo: Double, hi: Double): Double = js.native
  def bisectRight(array: ArrayLike[Double], x: Double): Double = js.native
  def bisectRight(array: ArrayLike[Double], x: Double, lo: Double): Double = js.native
  def bisectRight(array: ArrayLike[Double], x: Double, lo: Double, hi: Double): Double = js.native
  def bisectRight(array: ArrayLike[Date], x: Date): Double = js.native
  def bisectRight(array: ArrayLike[Date], x: Date, lo: Double): Double = js.native
  def bisectRight(array: ArrayLike[Date], x: Date, lo: Double, hi: Double): Double = js.native
  def bisector[T, U](accessor: js.Function1[/* x */ T, U]): Bisector[T, U] = js.native
  def bisector[T, U](comparator: js.Function2[/* a */ T, /* b */ U, Double]): Bisector[T, U] = js.native
  def blob(url: String): js.Promise[Blob] = js.native
  def blob(url: String, init: RequestInit): js.Promise[Blob] = js.native
  def brush[Datum](): BrushBehavior[Datum] = js.native
  def brushSelection(node: SVGGElement): BrushSelection | Null = js.native
  def brushX[Datum](): BrushBehavior[Datum] = js.native
  def brushY[Datum](): BrushBehavior[Datum] = js.native
  def buffer(url: String): js.Promise[ArrayBuffer] = js.native
  def buffer(url: String, init: RequestInit): js.Promise[ArrayBuffer] = js.native
  def chord(): ChordLayout = js.native
  def clientPoint(container: ContainerElement, event: ClientPointEvent): js.Tuple2[Double, Double] = js.native
  def cluster[Datum](): ClusterLayout[Datum] = js.native
  def color(color: ColorCommonInstance): RGBColor | HSLColor = js.native
  /**
    * Converts the provided color instance and returns an RGB or HSL color.
    *
    * @param color A permissible color space instance.
    */
  def color(color: ColorSpaceObject): RGBColor | HSLColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an RGB or HSL color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  def color(cssColorSpecifier: String): RGBColor | HSLColor | Null = js.native
  def contourDensity[Datum](): ContourDensity[Datum] = js.native
  def contours(): Contours = js.native
  def create[NewGElement /* <: Element */](name: String): Selection[NewGElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_a(name: a): Selection[HTMLAnchorElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_abbr(name: abbr): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_address(name: address): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_applet(name: applet): Selection[HTMLAppletElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_area(name: area): Selection[HTMLAreaElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_article(name: article): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_aside(name: aside): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_audio(name: audio): Selection[HTMLAudioElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_b(name: b): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_base(name: base): Selection[HTMLBaseElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_basefont(name: basefont): Selection[HTMLBaseFontElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_bdi(name: bdi): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_bdo(name: bdo): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_blockquote(name: blockquote): Selection[HTMLQuoteElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_body(name: body): Selection[HTMLBodyElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_br(name: br): Selection[HTMLBRElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_button(name: button): Selection[HTMLButtonElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_canvas(name: canvas): Selection[HTMLCanvasElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_caption(name: caption): Selection[HTMLTableCaptionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_cite(name: cite): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_code(name: code): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_col(name: col): Selection[HTMLTableColElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_colgroup(name: colgroup): Selection[HTMLTableColElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_data(name: data): Selection[HTMLDataElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_datalist(name: datalist): Selection[HTMLDataListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_dd(name: dd): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_del(name: del): Selection[HTMLModElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_details(name: details): Selection[HTMLDetailsElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_dfn(name: dfn): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_dialog(name: dialog): Selection[HTMLDialogElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_dir(name: dir): Selection[HTMLDirectoryElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_div(name: div): Selection[HTMLDivElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_dl(name: dl): Selection[HTMLDListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_dt(name: dt): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_em(name: em): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_embed(name: embed): Selection[HTMLEmbedElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_fieldset(name: fieldset): Selection[HTMLFieldSetElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_figcaption(name: figcaption): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_figure(name: figure): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_font(name: font): Selection[HTMLFontElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_footer(name: footer): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_form(name: form): Selection[HTMLFormElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_frame(name: frame): Selection[HTMLFrameElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_frameset(name: frameset): Selection[HTMLFrameSetElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_h1(name: h1): Selection[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_h2(name: h2): Selection[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_h3(name: h3): Selection[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_h4(name: h4): Selection[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_h5(name: h5): Selection[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_h6(name: h6): Selection[HTMLHeadingElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_head(name: head): Selection[HTMLHeadElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_header(name: header): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_hgroup(name: hgroup): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_hr(name: hr): Selection[HTMLHRElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_html(name: html): Selection[HTMLHtmlElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_i(name: i): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_iframe(name: iframe): Selection[HTMLIFrameElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_img(name: img): Selection[HTMLImageElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_input(name: input): Selection[HTMLInputElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_ins(name: ins): Selection[HTMLModElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_kbd(name: kbd): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_label(name: label): Selection[HTMLLabelElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_legend(name: legend): Selection[HTMLLegendElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_li(name: li): Selection[HTMLLIElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_link(name: link): Selection[HTMLLinkElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_main(name: main): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_map(name: map): Selection[HTMLMapElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_mark(name: mark): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_marquee(name: marquee): Selection[HTMLMarqueeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_menu(name: menu): Selection[HTMLMenuElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_meta(name: meta): Selection[HTMLMetaElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_meter(name: meter): Selection[HTMLMeterElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_nav(name: nav): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_noscript(name: noscript): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_object(name: `object`): Selection[HTMLObjectElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_ol(name: ol): Selection[HTMLOListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_optgroup(name: optgroup): Selection[HTMLOptGroupElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_option(name: option): Selection[HTMLOptionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_output(name: output): Selection[HTMLOutputElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_p(name: p): Selection[HTMLParagraphElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_param(name: param): Selection[HTMLParamElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_picture(name: picture): Selection[HTMLPictureElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_pre(name: pre): Selection[HTMLPreElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_progress(name: progress): Selection[HTMLProgressElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_q(name: q): Selection[HTMLQuoteElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_rp(name: rp): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_rt(name: rt): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_ruby(name: ruby): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_s(name: s): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_samp(name: samp): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_script(name: script): Selection[HTMLScriptElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_section(name: section): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_select(name: select): Selection[HTMLSelectElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_slot(name: slot): Selection[HTMLSlotElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_small(name: small): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_source(name: source): Selection[HTMLSourceElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_span(name: span): Selection[HTMLSpanElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_strong(name: strong): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_style(name: style): Selection[HTMLStyleElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_sub(name: sub): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_summary(name: summary): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_sup(name: sup): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_table(name: table): Selection[HTMLTableElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_tbody(name: tbody): Selection[HTMLTableSectionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_td(name: td): Selection[HTMLTableDataCellElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_template(name: template): Selection[HTMLTemplateElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_textarea(name: textarea): Selection[HTMLTextAreaElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_tfoot(name: tfoot): Selection[HTMLTableSectionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_th(name: th): Selection[HTMLTableHeaderCellElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_thead(name: thead): Selection[HTMLTableSectionElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_time(name: time): Selection[HTMLTimeElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_title(name: title): Selection[HTMLTitleElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_tr(name: tr): Selection[HTMLTableRowElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_track(name: track): Selection[HTMLTrackElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_u(name: u): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_ul(name: ul): Selection[HTMLUListElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_var(name: `var`): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_video(name: video): Selection[HTMLVideoElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  @JSName("create")
  def create_wbr(name: wbr): Selection[HTMLElement, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  def creator[NewGElement /* <: Element */](name: String): js.ThisFunction0[/* this */ BaseType, NewGElement] = js.native
  @JSName("creator")
  def creator_a(name: a): js.ThisFunction0[/* this */ BaseType, HTMLAnchorElement] = js.native
  @JSName("creator")
  def creator_abbr(name: abbr): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_address(name: address): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_applet(name: applet): js.ThisFunction0[/* this */ BaseType, HTMLAppletElement] = js.native
  @JSName("creator")
  def creator_area(name: area): js.ThisFunction0[/* this */ BaseType, HTMLAreaElement] = js.native
  @JSName("creator")
  def creator_article(name: article): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_aside(name: aside): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_audio(name: audio): js.ThisFunction0[/* this */ BaseType, HTMLAudioElement] = js.native
  @JSName("creator")
  def creator_b(name: b): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_base(name: base): js.ThisFunction0[/* this */ BaseType, HTMLBaseElement] = js.native
  @JSName("creator")
  def creator_basefont(name: basefont): js.ThisFunction0[/* this */ BaseType, HTMLBaseFontElement] = js.native
  @JSName("creator")
  def creator_bdi(name: bdi): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_bdo(name: bdo): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_blockquote(name: blockquote): js.ThisFunction0[/* this */ BaseType, HTMLQuoteElement] = js.native
  @JSName("creator")
  def creator_body(name: body): js.ThisFunction0[/* this */ BaseType, HTMLBodyElement] = js.native
  @JSName("creator")
  def creator_br(name: br): js.ThisFunction0[/* this */ BaseType, HTMLBRElement] = js.native
  @JSName("creator")
  def creator_button(name: button): js.ThisFunction0[/* this */ BaseType, HTMLButtonElement] = js.native
  @JSName("creator")
  def creator_canvas(name: canvas): js.ThisFunction0[/* this */ BaseType, HTMLCanvasElement] = js.native
  @JSName("creator")
  def creator_caption(name: caption): js.ThisFunction0[/* this */ BaseType, HTMLTableCaptionElement] = js.native
  @JSName("creator")
  def creator_cite(name: cite): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_code(name: code): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_col(name: col): js.ThisFunction0[/* this */ BaseType, HTMLTableColElement] = js.native
  @JSName("creator")
  def creator_colgroup(name: colgroup): js.ThisFunction0[/* this */ BaseType, HTMLTableColElement] = js.native
  @JSName("creator")
  def creator_data(name: data): js.ThisFunction0[/* this */ BaseType, HTMLDataElement] = js.native
  @JSName("creator")
  def creator_datalist(name: datalist): js.ThisFunction0[/* this */ BaseType, HTMLDataListElement] = js.native
  @JSName("creator")
  def creator_dd(name: dd): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_del(name: del): js.ThisFunction0[/* this */ BaseType, HTMLModElement] = js.native
  @JSName("creator")
  def creator_details(name: details): js.ThisFunction0[/* this */ BaseType, HTMLDetailsElement] = js.native
  @JSName("creator")
  def creator_dfn(name: dfn): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_dialog(name: dialog): js.ThisFunction0[/* this */ BaseType, HTMLDialogElement] = js.native
  @JSName("creator")
  def creator_dir(name: dir): js.ThisFunction0[/* this */ BaseType, HTMLDirectoryElement] = js.native
  @JSName("creator")
  def creator_div(name: div): js.ThisFunction0[/* this */ BaseType, HTMLDivElement] = js.native
  @JSName("creator")
  def creator_dl(name: dl): js.ThisFunction0[/* this */ BaseType, HTMLDListElement] = js.native
  @JSName("creator")
  def creator_dt(name: dt): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_em(name: em): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_embed(name: embed): js.ThisFunction0[/* this */ BaseType, HTMLEmbedElement] = js.native
  @JSName("creator")
  def creator_fieldset(name: fieldset): js.ThisFunction0[/* this */ BaseType, HTMLFieldSetElement] = js.native
  @JSName("creator")
  def creator_figcaption(name: figcaption): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_figure(name: figure): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_font(name: font): js.ThisFunction0[/* this */ BaseType, HTMLFontElement] = js.native
  @JSName("creator")
  def creator_footer(name: footer): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_form(name: form): js.ThisFunction0[/* this */ BaseType, HTMLFormElement] = js.native
  @JSName("creator")
  def creator_frame(name: frame): js.ThisFunction0[/* this */ BaseType, HTMLFrameElement] = js.native
  @JSName("creator")
  def creator_frameset(name: frameset): js.ThisFunction0[/* this */ BaseType, HTMLFrameSetElement] = js.native
  @JSName("creator")
  def creator_h1(name: h1): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSName("creator")
  def creator_h2(name: h2): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSName("creator")
  def creator_h3(name: h3): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSName("creator")
  def creator_h4(name: h4): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSName("creator")
  def creator_h5(name: h5): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSName("creator")
  def creator_h6(name: h6): js.ThisFunction0[/* this */ BaseType, HTMLHeadingElement] = js.native
  @JSName("creator")
  def creator_head(name: head): js.ThisFunction0[/* this */ BaseType, HTMLHeadElement] = js.native
  @JSName("creator")
  def creator_header(name: header): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_hgroup(name: hgroup): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_hr(name: hr): js.ThisFunction0[/* this */ BaseType, HTMLHRElement] = js.native
  @JSName("creator")
  def creator_html(name: html): js.ThisFunction0[/* this */ BaseType, HTMLHtmlElement] = js.native
  @JSName("creator")
  def creator_i(name: i): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_iframe(name: iframe): js.ThisFunction0[/* this */ BaseType, HTMLIFrameElement] = js.native
  @JSName("creator")
  def creator_img(name: img): js.ThisFunction0[/* this */ BaseType, HTMLImageElement] = js.native
  @JSName("creator")
  def creator_input(name: input): js.ThisFunction0[/* this */ BaseType, HTMLInputElement] = js.native
  @JSName("creator")
  def creator_ins(name: ins): js.ThisFunction0[/* this */ BaseType, HTMLModElement] = js.native
  @JSName("creator")
  def creator_kbd(name: kbd): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_label(name: label): js.ThisFunction0[/* this */ BaseType, HTMLLabelElement] = js.native
  @JSName("creator")
  def creator_legend(name: legend): js.ThisFunction0[/* this */ BaseType, HTMLLegendElement] = js.native
  @JSName("creator")
  def creator_li(name: li): js.ThisFunction0[/* this */ BaseType, HTMLLIElement] = js.native
  @JSName("creator")
  def creator_link(name: link): js.ThisFunction0[/* this */ BaseType, HTMLLinkElement] = js.native
  @JSName("creator")
  def creator_main(name: main): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_map(name: map): js.ThisFunction0[/* this */ BaseType, HTMLMapElement] = js.native
  @JSName("creator")
  def creator_mark(name: mark): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_marquee(name: marquee): js.ThisFunction0[/* this */ BaseType, HTMLMarqueeElement] = js.native
  @JSName("creator")
  def creator_menu(name: menu): js.ThisFunction0[/* this */ BaseType, HTMLMenuElement] = js.native
  @JSName("creator")
  def creator_meta(name: meta): js.ThisFunction0[/* this */ BaseType, HTMLMetaElement] = js.native
  @JSName("creator")
  def creator_meter(name: meter): js.ThisFunction0[/* this */ BaseType, HTMLMeterElement] = js.native
  @JSName("creator")
  def creator_nav(name: nav): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_noscript(name: noscript): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_object(name: `object`): js.ThisFunction0[/* this */ BaseType, HTMLObjectElement] = js.native
  @JSName("creator")
  def creator_ol(name: ol): js.ThisFunction0[/* this */ BaseType, HTMLOListElement] = js.native
  @JSName("creator")
  def creator_optgroup(name: optgroup): js.ThisFunction0[/* this */ BaseType, HTMLOptGroupElement] = js.native
  @JSName("creator")
  def creator_option(name: option): js.ThisFunction0[/* this */ BaseType, HTMLOptionElement] = js.native
  @JSName("creator")
  def creator_output(name: output): js.ThisFunction0[/* this */ BaseType, HTMLOutputElement] = js.native
  @JSName("creator")
  def creator_p(name: p): js.ThisFunction0[/* this */ BaseType, HTMLParagraphElement] = js.native
  @JSName("creator")
  def creator_param(name: param): js.ThisFunction0[/* this */ BaseType, HTMLParamElement] = js.native
  @JSName("creator")
  def creator_picture(name: picture): js.ThisFunction0[/* this */ BaseType, HTMLPictureElement] = js.native
  @JSName("creator")
  def creator_pre(name: pre): js.ThisFunction0[/* this */ BaseType, HTMLPreElement] = js.native
  @JSName("creator")
  def creator_progress(name: progress): js.ThisFunction0[/* this */ BaseType, HTMLProgressElement] = js.native
  @JSName("creator")
  def creator_q(name: q): js.ThisFunction0[/* this */ BaseType, HTMLQuoteElement] = js.native
  @JSName("creator")
  def creator_rp(name: rp): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_rt(name: rt): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_ruby(name: ruby): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_s(name: s): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_samp(name: samp): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_script(name: script): js.ThisFunction0[/* this */ BaseType, HTMLScriptElement] = js.native
  @JSName("creator")
  def creator_section(name: section): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_select(name: select): js.ThisFunction0[/* this */ BaseType, HTMLSelectElement] = js.native
  @JSName("creator")
  def creator_slot(name: slot): js.ThisFunction0[/* this */ BaseType, HTMLSlotElement] = js.native
  @JSName("creator")
  def creator_small(name: small): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_source(name: source): js.ThisFunction0[/* this */ BaseType, HTMLSourceElement] = js.native
  @JSName("creator")
  def creator_span(name: span): js.ThisFunction0[/* this */ BaseType, HTMLSpanElement] = js.native
  @JSName("creator")
  def creator_strong(name: strong): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_style(name: style): js.ThisFunction0[/* this */ BaseType, HTMLStyleElement] = js.native
  @JSName("creator")
  def creator_sub(name: sub): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_summary(name: summary): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_sup(name: sup): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_table(name: table): js.ThisFunction0[/* this */ BaseType, HTMLTableElement] = js.native
  @JSName("creator")
  def creator_tbody(name: tbody): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = js.native
  @JSName("creator")
  def creator_td(name: td): js.ThisFunction0[/* this */ BaseType, HTMLTableDataCellElement] = js.native
  @JSName("creator")
  def creator_template(name: template): js.ThisFunction0[/* this */ BaseType, HTMLTemplateElement] = js.native
  @JSName("creator")
  def creator_textarea(name: textarea): js.ThisFunction0[/* this */ BaseType, HTMLTextAreaElement] = js.native
  @JSName("creator")
  def creator_tfoot(name: tfoot): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = js.native
  @JSName("creator")
  def creator_th(name: th): js.ThisFunction0[/* this */ BaseType, HTMLTableHeaderCellElement] = js.native
  @JSName("creator")
  def creator_thead(name: thead): js.ThisFunction0[/* this */ BaseType, HTMLTableSectionElement] = js.native
  @JSName("creator")
  def creator_time(name: time): js.ThisFunction0[/* this */ BaseType, HTMLTimeElement] = js.native
  @JSName("creator")
  def creator_title(name: title): js.ThisFunction0[/* this */ BaseType, HTMLTitleElement] = js.native
  @JSName("creator")
  def creator_tr(name: tr): js.ThisFunction0[/* this */ BaseType, HTMLTableRowElement] = js.native
  @JSName("creator")
  def creator_track(name: track): js.ThisFunction0[/* this */ BaseType, HTMLTrackElement] = js.native
  @JSName("creator")
  def creator_u(name: u): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_ul(name: ul): js.ThisFunction0[/* this */ BaseType, HTMLUListElement] = js.native
  @JSName("creator")
  def creator_var(name: `var`): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  @JSName("creator")
  def creator_video(name: video): js.ThisFunction0[/* this */ BaseType, HTMLVideoElement] = js.native
  @JSName("creator")
  def creator_wbr(name: wbr): js.ThisFunction0[/* this */ BaseType, HTMLElement] = js.native
  def cross[S, T](a: Iterable[S], b: Iterable[T]): js.Array[js.Tuple2[S, T]] = js.native
  def cross[S, T, U](a: Iterable[S], b: Iterable[T], reducer: js.Function2[/* a */ S, /* b */ T, U]): js.Array[U] = js.native
  def csv[Columns /* <: String */](url: String): js.Promise[DSVRowArray[Columns]] = js.native
  def csv[Columns /* <: String */](url: String, init: RequestInit): js.Promise[DSVRowArray[Columns]] = js.native
  def csv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    url: String,
    init: RequestInit,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  def csv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    url: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  def csvFormat[T /* <: js.Object */](rows: js.Array[T]): String = js.native
  def csvFormat[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[String]): String = js.native
  def csvFormatRows(rows: js.Array[js.Array[String]]): String = js.native
  def csvParse[Columns /* <: String */](csvString: String): DSVRowArray[Columns] = js.native
  def csvParse[ParsedRow /* <: js.Object */, Columns /* <: String */](
    csvString: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): DSVParsedArray[ParsedRow] = js.native
  def csvParseRows(csvString: String): js.Array[js.Array[String]] = js.native
  def csvParseRows[ParsedRow /* <: js.Object */](
    csvString: String,
    row: js.Function2[/* rawRow */ js.Array[String], /* index */ Double, js.UndefOr[ParsedRow | Null]]
  ): js.Array[ParsedRow] = js.native
  def cubehelix(color: ColorCommonInstance): CubehelixColor = js.native
  /**
    * Converts the provided color instance and returns a Cubehelix color.
    * The color instance is specified, it is converted to the RGB color space using color.rgb and then converted to Cubehelix.
    * (Colors already in the Cubehelix color space skip the conversion to RGB.)
    *
    * @param color A permissible color space instance.
    */
  def cubehelix(color: ColorSpaceObject): CubehelixColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an Cubehelix color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  def cubehelix(cssColorSpecifier: String): CubehelixColor = js.native
  /**
    * Constructs a new Cubehelix color based on the specified channel values and opacity.
    *
    * @param h Hue channel value.
    * @param s Saturation channel value.
    * @param l Lightness channel value.
    * @param opacity Optional opacity value, defaults to 1.
    */
  def cubehelix(h: Double, s: Double, l: Double): CubehelixColor = js.native
  def cubehelix(h: Double, s: Double, l: Double, opacity: Double): CubehelixColor = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveBasis(context: Path): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveBasis(context: CanvasRenderingContext2D): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveBasisClosed(context: Path): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveBasisClosed(context: CanvasRenderingContext2D): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveBasisOpen(context: Path): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveBasisOpen(context: CanvasRenderingContext2D): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveLinear(context: Path): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveLinear(context: CanvasRenderingContext2D): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveLinearClosed(context: Path): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveLinearClosed(context: CanvasRenderingContext2D): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveMonotoneX(context: Path): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveMonotoneX(context: CanvasRenderingContext2D): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveMonotoneY(context: Path): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveMonotoneY(context: CanvasRenderingContext2D): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveNatural(context: Path): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveNatural(context: CanvasRenderingContext2D): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveStep(context: Path): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveStep(context: CanvasRenderingContext2D): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveStepAfter(context: Path): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveStepAfter(context: CanvasRenderingContext2D): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveStepBefore(context: Path): CurveGenerator = js.native
  /**
    * Returns a curve generator which renders to the specified context.
    *
    * @param context A rendering context.
    */
  def curveStepBefore(context: CanvasRenderingContext2D): CurveGenerator = js.native
  def customEvent[Context, Result](
    event: BaseEvent,
    listener: js.ThisFunction1[/* this */ Context, /* repeated */ js.Any, Result],
    that: Context,
    args: js.Any*
  ): Result = js.native
  def descending(): Double = js.native
  def descending(a: js.UndefOr[Primitive], b: Primitive): Double = js.native
  def descending(a: Primitive): Double = js.native
  def deviation[T /* <: Numeric */](array: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
  def deviation[T](
    array: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  def dispatch[T /* <: EventTarget */](types: String*): Dispatch[T] = js.native
  def drag[GElement /* <: DraggedElementBaseType */, Datum](): DragBehavior[GElement, Datum, Datum | SubjectPosition] = js.native
  def dragDisable(window: Window): Unit = js.native
  def dragEnable(window: Window): Unit = js.native
  def dragEnable(window: Window, noClick: Boolean): Unit = js.native
  @JSName("drag")
  def drag_GElement_DraggedElementBaseTypeDatumSubject[GElement /* <: DraggedElementBaseType */, Datum, Subject](): DragBehavior[GElement, Datum, Subject] = js.native
  def dsv[Columns /* <: String */](delimiter: String, url: String): js.Promise[DSVRowArray[Columns]] = js.native
  def dsv[Columns /* <: String */](delimiter: String, url: String, init: RequestInit): js.Promise[DSVRowArray[Columns]] = js.native
  def dsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    delimiter: String,
    url: String,
    init: RequestInit,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  def dsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    delimiter: String,
    url: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  def dsvFormat(delimiter: String): DSV = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeBack(normalizedTime: Double): Double = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeBackIn(normalizedTime: Double): Double = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeBackInOut(normalizedTime: Double): Double = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeBackOut(normalizedTime: Double): Double = js.native
  def easeBounce(normalizedTime: Double): Double = js.native
  def easeBounceIn(normalizedTime: Double): Double = js.native
  def easeBounceInOut(normalizedTime: Double): Double = js.native
  def easeBounceOut(normalizedTime: Double): Double = js.native
  def easeCircle(normalizedTime: Double): Double = js.native
  def easeCircleIn(normalizedTime: Double): Double = js.native
  def easeCircleInOut(normalizedTime: Double): Double = js.native
  def easeCircleOut(normalizedTime: Double): Double = js.native
  def easeCubic(normalizedTime: Double): Double = js.native
  def easeCubicIn(normalizedTime: Double): Double = js.native
  def easeCubicInOut(normalizedTime: Double): Double = js.native
  def easeCubicOut(normalizedTime: Double): Double = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeElastic(normalizedTime: Double): Double = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeElasticIn(normalizedTime: Double): Double = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeElasticInOut(normalizedTime: Double): Double = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easeElasticOut(normalizedTime: Double): Double = js.native
  def easeExp(normalizedTime: Double): Double = js.native
  def easeExpIn(normalizedTime: Double): Double = js.native
  def easeExpInOut(normalizedTime: Double): Double = js.native
  def easeExpOut(normalizedTime: Double): Double = js.native
  def easeLinear(normalizedTime: Double): Double = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easePoly(normalizedTime: Double): Double = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easePolyIn(normalizedTime: Double): Double = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easePolyInOut(normalizedTime: Double): Double = js.native
  /**
    * Calculate eased time.
    * @param normalizedTime Normalized time typically in the range [0, 1]
    */
  def easePolyOut(normalizedTime: Double): Double = js.native
  def easeQuad(normalizedTime: Double): Double = js.native
  def easeQuadIn(normalizedTime: Double): Double = js.native
  def easeQuadInOut(normalizedTime: Double): Double = js.native
  def easeQuadOut(normalizedTime: Double): Double = js.native
  def easeSin(normalizedTime: Double): Double = js.native
  def easeSinIn(normalizedTime: Double): Double = js.native
  def easeSinInOut(normalizedTime: Double): Double = js.native
  def easeSinOut(normalizedTime: Double): Double = js.native
  def entries(obj: js.Object): js.Array[Anon_KeyValue] = js.native
  def entries[T](obj: StringDictionary[T]): js.Array[Anon_Key[T]] = js.native
  def entries[T](obj: ArrayLike[T]): js.Array[Anon_Key[T]] = js.native
  def extent(array: Iterable[String]): js.Tuple2[js.UndefOr[String], js.UndefOr[String]] = js.native
  def extent[T](
    array: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[String | Null]]
  ): js.Tuple2[js.UndefOr[String], js.UndefOr[String]] = js.native
  @JSName("extent")
  def extent_TU_Numeric[T, U /* <: Numeric */](
    array: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[U | Null]]
  ): js.Tuple2[js.UndefOr[U], js.UndefOr[U]] = js.native
  @JSName("extent")
  def extent_T_Numeric[T /* <: Numeric */](array: Iterable[T]): js.Tuple2[js.UndefOr[T], js.UndefOr[T]] = js.native
  def forceCenter[NodeDatum /* <: SimulationNodeDatum */](): ForceCenter[NodeDatum] = js.native
  def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: Double): ForceCenter[NodeDatum] = js.native
  def forceCenter[NodeDatum /* <: SimulationNodeDatum */](x: Double, y: Double): ForceCenter[NodeDatum] = js.native
  def forceCollide[NodeDatum /* <: SimulationNodeDatum */](): ForceCollide[NodeDatum] = js.native
  def forceCollide[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* node */ NodeDatum, /* i */ Double, /* nodes */ js.Array[NodeDatum], Double]
  ): ForceCollide[NodeDatum] = js.native
  def forceCollide[NodeDatum /* <: SimulationNodeDatum */](radius: Double): ForceCollide[NodeDatum] = js.native
  def forceLink[NodeDatum /* <: SimulationNodeDatum */, LinksDatum /* <: SimulationLinkDatum[NodeDatum] */](): ForceLink[NodeDatum, LinksDatum] = js.native
  def forceLink[NodeDatum /* <: SimulationNodeDatum */, LinksDatum /* <: SimulationLinkDatum[NodeDatum] */](links: js.Array[LinksDatum]): ForceLink[NodeDatum, LinksDatum] = js.native
  def forceManyBody[NodeDatum /* <: SimulationNodeDatum */](): ForceManyBody[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    y: Double
  ): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: Double
  ): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: Double,
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    x: Double,
    y: Double
  ): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double],
    y: Double
  ): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: Double): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](
    radius: Double,
    x: Double,
    y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]
  ): ForceRadial[NodeDatum] = js.native
  def forceRadial[NodeDatum /* <: SimulationNodeDatum */](radius: Double, x: Double, y: Double): ForceRadial[NodeDatum] = js.native
  def forceSimulation[NodeDatum /* <: SimulationNodeDatum */](): Simulation[NodeDatum, js.UndefOr[scala.Nothing]] = js.native
  def forceSimulation[NodeDatum /* <: SimulationNodeDatum */](nodesData: js.Array[NodeDatum]): Simulation[NodeDatum, js.UndefOr[scala.Nothing]] = js.native
  @JSName("forceSimulation")
  def forceSimulation_NodeDatum_SimulationNodeDatumLinkDatum_SimulationLinkDatumNodeDatum[NodeDatum /* <: SimulationNodeDatum */, LinkDatum /* <: SimulationLinkDatum[NodeDatum] */](): Simulation[NodeDatum, LinkDatum] = js.native
  @JSName("forceSimulation")
  def forceSimulation_NodeDatum_SimulationNodeDatumLinkDatum_SimulationLinkDatumNodeDatum[NodeDatum /* <: SimulationNodeDatum */, LinkDatum /* <: SimulationLinkDatum[NodeDatum] */](nodesData: js.Array[NodeDatum]): Simulation[NodeDatum, LinkDatum] = js.native
  def forceX[NodeDatum /* <: SimulationNodeDatum */](): ForceX[NodeDatum] = js.native
  def forceX[NodeDatum /* <: SimulationNodeDatum */](x: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceX[NodeDatum] = js.native
  def forceX[NodeDatum /* <: SimulationNodeDatum */](x: Double): ForceX[NodeDatum] = js.native
  def forceY[NodeDatum /* <: SimulationNodeDatum */](): ForceY[NodeDatum] = js.native
  def forceY[NodeDatum /* <: SimulationNodeDatum */](y: js.Function3[/* d */ NodeDatum, /* i */ Double, /* data */ js.Array[NodeDatum], Double]): ForceY[NodeDatum] = js.native
  def forceY[NodeDatum /* <: SimulationNodeDatum */](y: Double): ForceY[NodeDatum] = js.native
  def format(specifier: String): js.Function1[/* n */ Double | Anon_ValueOf, String] = js.native
  def formatDefaultLocale(defaultLocale: FormatLocaleDefinition): FormatLocaleObject = js.native
  def formatLocale(locale: FormatLocaleDefinition): FormatLocaleObject = js.native
  def formatPrefix(specifier: String, value: Double): js.Function1[/* n */ Double | Anon_ValueOf, String] = js.native
  def formatSpecifier(specifier: String): FormatSpecifier = js.native
  def geoAlbers(): GeoConicProjection = js.native
  def geoAlbersUsa(): GeoProjection = js.native
  def geoArea(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): Double = js.native
  def geoArea(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): Double = js.native
  def geoArea(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): Double = js.native
  def geoArea(`object`: GeoGeometryObjects): Double = js.native
  def geoAzimuthalEqualArea(): GeoProjection = js.native
  def geoAzimuthalEqualAreaRaw(): GeoRawProjection = js.native
  def geoAzimuthalEquidistant(): GeoProjection = js.native
  def geoAzimuthalEquidistantRaw(): GeoRawProjection = js.native
  def geoBounds(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
  def geoBounds(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
  def geoBounds(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
  def geoBounds(`object`: GeoGeometryObjects): js.Tuple2[js.Tuple2[Double, Double], js.Tuple2[Double, Double]] = js.native
  def geoCentroid(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): js.Tuple2[Double, Double] = js.native
  def geoCentroid(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): js.Tuple2[Double, Double] = js.native
  def geoCentroid(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): js.Tuple2[Double, Double] = js.native
  def geoCentroid(`object`: GeoGeometryObjects): js.Tuple2[Double, Double] = js.native
  def geoCircle(): GeoCircleGenerator[_, _] = js.native
  @JSName("geoCircle")
  def geoCircle_Datum[Datum](): GeoCircleGenerator[_, Datum] = js.native
  @JSName("geoCircle")
  def geoCircle_ThisDatum[This, Datum](): GeoCircleGenerator[This, Datum] = js.native
  def geoClipAntimeridian(stream: GeoStream): GeoStream = js.native
  def geoClipCircle(angle: Double): js.Function1[/* stream */ GeoStream, GeoStream] = js.native
  def geoClipRectangle(x0: Double, y0: Double, x1: Double, y1: Double): js.Function1[/* stream */ GeoStream, GeoStream] = js.native
  def geoConicConformal(): GeoConicProjection = js.native
  def geoConicConformalRaw(phi0: Double, phi1: Double): GeoRawProjection = js.native
  def geoConicEqualArea(): GeoConicProjection = js.native
  def geoConicEqualAreaRaw(phi0: Double, phi1: Double): GeoRawProjection = js.native
  def geoConicEquidistant(): GeoConicProjection = js.native
  def geoConicEquidistantRaw(phi0: Double, phi1: Double): GeoRawProjection = js.native
  def geoContains(
    `object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]],
    point: js.Tuple2[Double, Double]
  ): Boolean = js.native
  def geoContains(
    `object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties],
    point: js.Tuple2[Double, Double]
  ): Boolean = js.native
  def geoContains(`object`: ExtendedGeometryCollection[GeoGeometryObjects], point: js.Tuple2[Double, Double]): Boolean = js.native
  def geoContains(`object`: GeoGeometryObjects, point: js.Tuple2[Double, Double]): Boolean = js.native
  def geoDistance(a: js.Tuple2[Double, Double], b: js.Tuple2[Double, Double]): Double = js.native
  def geoEqualEarth(): GeoProjection = js.native
  def geoEqualEarthRaw(): GeoRawProjection = js.native
  def geoEquirectangular(): GeoProjection = js.native
  def geoEquirectangularRaw(): GeoRawProjection = js.native
  def geoGnomonic(): GeoProjection = js.native
  def geoGnomonicRaw(): GeoRawProjection = js.native
  def geoGraticule(): GeoGraticuleGenerator = js.native
  def geoGraticule10(): MultiLineString = js.native
  def geoIdentity(): GeoIdentityTransform = js.native
  def geoInterpolate(a: js.Tuple2[Double, Double], b: js.Tuple2[Double, Double]): js.Function1[/* t */ Double, js.Tuple2[Double, Double]] = js.native
  def geoLength(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]): Double = js.native
  def geoLength(`object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]]): Double = js.native
  def geoLength(`object`: ExtendedGeometryCollection[GeoGeometryObjects]): Double = js.native
  def geoLength(`object`: GeoGeometryObjects): Double = js.native
  def geoMercator(): GeoProjection = js.native
  def geoMercatorRaw(): GeoRawProjection = js.native
  def geoNaturalEarth1(): GeoProjection = js.native
  def geoNaturalEarth1Raw(): GeoRawProjection = js.native
  def geoOrthographic(): GeoProjection = js.native
  def geoOrthographicRaw(): GeoRawProjection = js.native
  def geoPath(): GeoPath[_, GeoPermissibleObjects] = js.native
  def geoPath(projection: Null, context: GeoContext): GeoPath[_, GeoPermissibleObjects] = js.native
  def geoPath(projection: GeoProjection): GeoPath[_, GeoPermissibleObjects] = js.native
  def geoPath(projection: GeoProjection, context: GeoContext): GeoPath[_, GeoPermissibleObjects] = js.native
  def geoPath(projection: GeoStreamWrapper): GeoPath[_, GeoPermissibleObjects] = js.native
  def geoPath(projection: GeoStreamWrapper, context: GeoContext): GeoPath[_, GeoPermissibleObjects] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](): GeoPath[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: Null, context: GeoContext): GeoPath[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection): GeoPath[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection, context: GeoContext): GeoPath[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper): GeoPath[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_DatumObject_GeoPermissibleObjects[DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper, context: GeoContext): GeoPath[_, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](): GeoPath[This, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: Null, context: GeoContext): GeoPath[This, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection): GeoPath[This, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoProjection, context: GeoContext): GeoPath[This, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper): GeoPath[This, DatumObject] = js.native
  @JSName("geoPath")
  def geoPath_ThisDatumObject_GeoPermissibleObjects[This, DatumObject /* <: GeoPermissibleObjects */](projection: GeoStreamWrapper, context: GeoContext): GeoPath[This, DatumObject] = js.native
  def geoProjection(project: GeoRawProjection): GeoProjection = js.native
  def geoProjectionMutator(factory: js.Function1[/* repeated */ js.Any, GeoRawProjection]): js.Function0[GeoProjection] = js.native
  def geoRotation(angles: js.Tuple2[Double, Double]): GeoRotation = js.native
  def geoRotation(angles: js.Tuple3[Double, Double, Double]): GeoRotation = js.native
  def geoStereographic(): GeoProjection = js.native
  def geoStereographicRaw(): GeoRawProjection = js.native
  def geoStream(
    `object`: ExtendedFeatureCollection[ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties]],
    stream: GeoStream
  ): Unit = js.native
  def geoStream(`object`: ExtendedFeature[GeoGeometryObjects | Null, GeoJsonProperties], stream: GeoStream): Unit = js.native
  def geoStream(`object`: ExtendedGeometryCollection[GeoGeometryObjects], stream: GeoStream): Unit = js.native
  def geoStream(`object`: GeoGeometryObjects, stream: GeoStream): Unit = js.native
  def geoTransform[T /* <: GeoTransformPrototype */](methods: T): Anon_S[T] = js.native
  def geoTransverseMercator(): GeoProjection = js.native
  def geoTransverseMercatorRaw(): GeoRawProjection = js.native
  /**
    * Constructs a new Lab color with the specified l value and a = b = 0.
    *
    * @param l Lightness typically in the range [0, 100].
    * @param opacity Optional opacity value, defaults to 1.
    */
  def gray(l: Double): LabColor = js.native
  /**
    * Constructs a new Lab color with the specified l value and a = b = 0.
    *
    * @param l Lightness typically in the range [0, 100].
    * @param opacity Optional opacity value, defaults to 1.
    */
  def gray(l: Double, opacity: Double): LabColor = js.native
  def group[TObject, TKey](a: Iterable[TObject], key: js.Function1[/* value */ TObject, TKey]): Map[TKey, js.Array[TObject]] = js.native
  def hcl(color: ColorCommonInstance): HCLColor = js.native
  /**
    * Converts the provided color instance and returns an HCL color.
    * The color instance is converted to the RGB color space using color.rgb and then converted to HCL.
    * (Colors already in the HCL color space skip the conversion to RGB,
    * and colors in the Lab color space are converted directly to HCL.)
    *
    * @param color A permissible color space instance.
    */
  def hcl(color: ColorSpaceObject): HCLColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an HCL color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  def hcl(cssColorSpecifier: String): HCLColor = js.native
  /**
    * Constructs a new HCL color based on the specified channel values and opacity.
    *
    * @param h Hue channel value typically in [0, 360).
    * @param c Chroma channel value typically in [0, 230].
    * @param l Luminance channel value typically in the range [0, 100].
    * @param opacity Optional opacity value, defaults to 1.
    */
  def hcl(h: Double, l: Double, c: Double): HCLColor = js.native
  def hcl(h: Double, l: Double, c: Double, opacity: Double): HCLColor = js.native
  def hierarchy[Datum](data: Datum): HierarchyNode[Datum] = js.native
  def hierarchy[Datum](data: Datum, children: js.Function1[/* d */ Datum, js.UndefOr[js.Array[Datum] | Null]]): HierarchyNode[Datum] = js.native
  def histogram(): HistogramGeneratorNumber[Double, Double] = js.native
  @JSName("histogram")
  def `histogram_DatumValue_UnionDatejs.undefinedNothing_HistogramGeneratorDate`[Datum, Value /* <: js.UndefOr[Date] */](): HistogramGeneratorDate[Datum, Value] = js.native
  @JSName("histogram")
  def `histogram_DatumValue_UnionDoublejs.undefinedNothing`[Datum, Value /* <: js.UndefOr[Double] */](): HistogramGeneratorNumber[Datum, Value] = js.native
  def hsl(color: ColorCommonInstance): HSLColor = js.native
  /**
    * Converts the provided color instance and returns an HSL color.
    * The color instance is converted to the RGB color space using color.rgb and then converted to HSL.
    * (Colors already in the HSL color space skip the conversion to RGB.)
    *
    * @param color A permissible color space instance.
    */
  def hsl(color: ColorSpaceObject): HSLColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an HSL color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  def hsl(cssColorSpecifier: String): HSLColor = js.native
  /**
    * Constructs a new HSL color based on the specified channel values and opacity.
    *
    * @param h Hue channel value.
    * @param s Saturation channel value.
    * @param l Lightness channel value.
    * @param opacity Optional opacity value, defaults to 1.
    */
  def hsl(h: Double, s: Double, l: Double): HSLColor = js.native
  def hsl(h: Double, s: Double, l: Double, opacity: Double): HSLColor = js.native
  def html(url: String): js.Promise[Document] = js.native
  def html(url: String, init: RequestInit): js.Promise[Document] = js.native
  def image(url: String): js.Promise[HTMLImageElement] = js.native
  def image(url: String, init: Partial[HTMLImageElement]): js.Promise[HTMLImageElement] = js.native
  def interpolate(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolate(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolate(a: js.Any): js.Function1[/* t */ Double, Null] = js.native
  def interpolate(a: js.Any, b: Boolean): js.Function1[/* t */ Double, Boolean] = js.native
  def interpolate(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolate(a: Double, b: typings.d3DashInterpolate.Anon_ValueOf): js.Function1[/* t */ Double, Double] = js.native
  def interpolate(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolate(a: Anon_ToString, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolate(a: typings.d3DashInterpolate.Anon_ValueOf, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolate(a: typings.d3DashInterpolate.Anon_ValueOf, b: typings.d3DashInterpolate.Anon_ValueOf): js.Function1[/* t */ Double, Double] = js.native
  def interpolate(a: Date, b: Date): js.Function1[/* t */ Double, Date] = js.native
  def interpolate[U /* <: js.Object */](a: js.Any, b: U): js.Function1[/* t */ Double, U] = js.native
  def interpolate[U /* <: js.Array[_] */](a: js.Array[_], b: U): js.Function1[/* t */ Double, U] = js.native
  def interpolateArray[A /* <: js.Array[_] */](a: js.Array[_], b: A): ArrayInterpolator[A] = js.native
  def interpolateBasis(splineNodes: js.Array[Double]): js.Function1[/* t */ Double, Double] = js.native
  def interpolateBasisClosed(splineNodes: js.Array[Double]): js.Function1[/* t */ Double, Double] = js.native
  def interpolateBlues(t: Double): String = js.native
  def interpolateBrBG(t: Double): String = js.native
  def interpolateBuGn(t: Double): String = js.native
  def interpolateBuPu(t: Double): String = js.native
  def interpolateCool(t: Double): String = js.native
  def interpolateCubehelix(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelix(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelix(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelix(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelixDefault(t: Double): String = js.native
  def interpolateCubehelixLong(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelixLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelixLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateCubehelixLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateDate(a: Date, b: Date): js.Function1[/* t */ Double, Date] = js.native
  def interpolateDiscrete[T](values: js.Array[T]): js.Function1[/* t */ Double, T] = js.native
  def interpolateGnBu(t: Double): String = js.native
  def interpolateGreens(t: Double): String = js.native
  def interpolateGreys(t: Double): String = js.native
  def interpolateHcl(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHcl(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateHcl(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHcl(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateHclLong(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHclLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateHclLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHclLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateHsl(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHsl(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateHsl(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHsl(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateHslLong(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHslLong(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateHslLong(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateHslLong(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateHue(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolateInferno(t: Double): String = js.native
  def interpolateLab(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateLab(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateLab(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateLab(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateMagma(t: Double): String = js.native
  def interpolateNumber(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolateNumber(a: Double, b: typings.d3DashInterpolate.Anon_ValueOf): js.Function1[/* t */ Double, Double] = js.native
  def interpolateNumber(a: typings.d3DashInterpolate.Anon_ValueOf, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolateNumber(a: typings.d3DashInterpolate.Anon_ValueOf, b: typings.d3DashInterpolate.Anon_ValueOf): js.Function1[/* t */ Double, Double] = js.native
  def interpolateObject[U /* <: js.Object */](a: js.Any, b: U): js.Function1[/* t */ Double, U] = js.native
  def interpolateOrRd(t: Double): String = js.native
  def interpolateOranges(t: Double): String = js.native
  def interpolatePRGn(t: Double): String = js.native
  def interpolatePiYG(t: Double): String = js.native
  def interpolatePlasma(t: Double): String = js.native
  def interpolatePuBu(t: Double): String = js.native
  def interpolatePuBuGn(t: Double): String = js.native
  def interpolatePuOr(t: Double): String = js.native
  def interpolatePuRd(t: Double): String = js.native
  def interpolatePurples(t: Double): String = js.native
  def interpolateRainbow(t: Double): String = js.native
  def interpolateRdBu(t: Double): String = js.native
  def interpolateRdGy(t: Double): String = js.native
  def interpolateRdPu(t: Double): String = js.native
  def interpolateRdYlBu(t: Double): String = js.native
  def interpolateRdYlGn(t: Double): String = js.native
  def interpolateReds(t: Double): String = js.native
  def interpolateRgb(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateRgb(a: String, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateRgb(a: ColorCommonInstance, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateRgb(a: ColorCommonInstance, b: ColorCommonInstance): js.Function1[/* t */ Double, String] = js.native
  def interpolateRgbBasis(colors: js.Array[String | ColorCommonInstance]): js.Function1[/* t */ Double, String] = js.native
  def interpolateRgbBasisClosed(colors: js.Array[String | ColorCommonInstance]): js.Function1[/* t */ Double, String] = js.native
  def interpolateRound(a: Double, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolateRound(a: Double, b: typings.d3DashInterpolate.Anon_ValueOf): js.Function1[/* t */ Double, Double] = js.native
  def interpolateRound(a: typings.d3DashInterpolate.Anon_ValueOf, b: Double): js.Function1[/* t */ Double, Double] = js.native
  def interpolateRound(a: typings.d3DashInterpolate.Anon_ValueOf, b: typings.d3DashInterpolate.Anon_ValueOf): js.Function1[/* t */ Double, Double] = js.native
  def interpolateSinebow(t: Double): String = js.native
  def interpolateSpectral(t: Double): String = js.native
  def interpolateString(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateString(a: String, b: Anon_ToString): js.Function1[/* t */ Double, String] = js.native
  def interpolateString(a: Anon_ToString, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateString(a: Anon_ToString, b: Anon_ToString): js.Function1[/* t */ Double, String] = js.native
  def interpolateTransformCss(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateTransformSvg(a: String, b: String): js.Function1[/* t */ Double, String] = js.native
  def interpolateViridis(t: Double): String = js.native
  def interpolateWarm(t: Double): String = js.native
  def interpolateYlGn(t: Double): String = js.native
  def interpolateYlGnBu(t: Double): String = js.native
  def interpolateYlOrBr(t: Double): String = js.native
  def interpolateYlOrRd(t: Double): String = js.native
  def interpolateZoom(a: ZoomView, b: ZoomView): ZoomInterpolator = js.native
  def interrupt(node: BaseType): Unit = js.native
  def interrupt(node: BaseType, name: String): Unit = js.native
  def interval(callback: js.Function1[/* elapsed */ Double, Unit]): Timer = js.native
  def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer = js.native
  def interval(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer = js.native
  def isoFormat(date: Date): String = js.native
  def isoParse(dateString: String): Date | Null = js.native
  def json[ParsedJSONObject /* <: js.Any */](url: String): js.Promise[ParsedJSONObject] = js.native
  def json[ParsedJSONObject /* <: js.Any */](url: String, init: RequestInit): js.Promise[ParsedJSONObject] = js.native
  def keys(obj: js.Object): js.Array[String] = js.native
  def lab(color: ColorCommonInstance): LabColor = js.native
  /**
    * Converts the provided color instance and returns a Lab color.
    * The color instance is converted to the RGB color space using color.rgb and then converted to Lab.
    * (Colors already in the Lab color space skip the conversion to RGB,
    * and colors in the HCL color space are converted directly to Lab.)
    *
    * @param color A permissible color space instance.
    */
  def lab(color: ColorSpaceObject): LabColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning a Lab color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  def lab(cssColorSpecifier: String): LabColor = js.native
  /**
    * Constructs a new Lab color based on the specified channel values and opacity.
    *
    * @param l Lightness typically in the range [0, 100].
    * @param a Position between red/magenta and green typically in [-160, +160].
    * @param b Position between yellow and blue typically in [-160, +160].
    * @param opacity Optional opacity value, defaults to 1.
    */
  def lab(l: Double, a: Double, b: Double): LabColor = js.native
  def lab(l: Double, a: Double, b: Double, opacity: Double): LabColor = js.native
  def lch(color: ColorCommonInstance): HCLColor = js.native
  /**
    * Converts the provided color instance and returns an HCL color.
    * The color instance is converted to the RGB color space using color.rgb and then converted to HCL.
    * (Colors already in the HCL color space skip the conversion to RGB,
    * and colors in the Lab color space are converted directly to HCL.)
    *
    * @param color A permissible color space instance.
    */
  def lch(color: ColorSpaceObject): HCLColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an HCL color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS color Module Level 3 specifier string.
    */
  def lch(cssColorSpecifier: String): HCLColor = js.native
  /**
    * Constructs a new HCL color based on the specified channel values and opacity.
    *
    * @param l Luminance channel value typically in the range [0, 100].
    * @param c Chroma channel value typically in [0, 230].
    * @param h Hue channel value typically in [0, 360).
    * @param opacity Optional opacity value, defaults to 1.
    */
  def lch(l: Double, c: Double, h: Double): HCLColor = js.native
  def lch(l: Double, c: Double, h: Double, opacity: Double): HCLColor = js.native
  def line(): Line[js.Tuple2[Double, Double]] = js.native
  def lineRadial(): LineRadial[js.Tuple2[Double, Double]] = js.native
  @JSName("lineRadial")
  def lineRadial_Datum[Datum](): LineRadial[Datum] = js.native
  @JSName("line")
  def line_Datum[Datum](): Line[Datum] = js.native
  def linkHorizontal(): Link[_, DefaultLinkObject, js.Tuple2[Double, Double]] = js.native
  @JSName("linkHorizontal")
  def linkHorizontal_LinkDatumNodeDatum[LinkDatum, NodeDatum](): Link[_, LinkDatum, NodeDatum] = js.native
  @JSName("linkHorizontal")
  def linkHorizontal_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): Link[This, LinkDatum, NodeDatum] = js.native
  def linkRadial(): LinkRadial[_, DefaultLinkObject, js.Tuple2[Double, Double]] = js.native
  @JSName("linkRadial")
  def linkRadial_LinkDatumNodeDatum[LinkDatum, NodeDatum](): LinkRadial[_, LinkDatum, NodeDatum] = js.native
  @JSName("linkRadial")
  def linkRadial_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): LinkRadial[This, LinkDatum, NodeDatum] = js.native
  def linkVertical(): Link[_, DefaultLinkObject, js.Tuple2[Double, Double]] = js.native
  @JSName("linkVertical")
  def linkVertical_LinkDatumNodeDatum[LinkDatum, NodeDatum](): Link[_, LinkDatum, NodeDatum] = js.native
  @JSName("linkVertical")
  def linkVertical_ThisLinkDatumNodeDatum[This, LinkDatum, NodeDatum](): Link[This, LinkDatum, NodeDatum] = js.native
  def local[T](): Local[T] = js.native
  def map(obj: js.Object): typings.d3DashCollection.d3DashCollectionMod.Map[_] = js.native
  def map[T](): typings.d3DashCollection.d3DashCollectionMod.Map[T] = js.native
  def map[T](array: js.Array[T]): typings.d3DashCollection.d3DashCollectionMod.Map[T] = js.native
  def map[T](
    array: js.Array[T],
    key: js.Function3[/* value */ T, /* i */ js.UndefOr[Double], /* array */ js.UndefOr[js.Array[T]], String]
  ): typings.d3DashCollection.d3DashCollectionMod.Map[T] = js.native
  def map[T](d3Map: typings.d3DashCollection.d3DashCollectionMod.Map[T]): typings.d3DashCollection.d3DashCollectionMod.Map[T] = js.native
  def map[T](obj: NumberDictionary[T]): typings.d3DashCollection.d3DashCollectionMod.Map[T] = js.native
  def map[T](obj: StringDictionary[T]): typings.d3DashCollection.d3DashCollectionMod.Map[T] = js.native
  def matcher(selector: String): js.ThisFunction0[/* this */ BaseType, Boolean] = js.native
  def max(array: Iterable[String]): js.UndefOr[String] = js.native
  def max[T](
    array: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[String | Null]]
  ): js.UndefOr[String] = js.native
  @JSName("max")
  def max_TU_Numeric[T, U /* <: Numeric */](
    array: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[U | Null]]
  ): js.UndefOr[U] = js.native
  @JSName("max")
  def max_T_Numeric[T /* <: Numeric */](array: Iterable[T]): js.UndefOr[T] = js.native
  def mean[T /* <: Numeric */](array: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
  def mean[T](
    array: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  def median[T /* <: Numeric */](array: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
  def median[T](
    array: Iterable[T],
    accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  def merge[T](arrays: Iterable[Iterable[T]]): js.Array[T] = js.native
  def min(array: Iterable[String]): js.UndefOr[String] = js.native
  def min[T](
    array: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[String | Null]]
  ): js.UndefOr[String] = js.native
  @JSName("min")
  def min_TU_Numeric[T, U /* <: Numeric */](
    array: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[U | Null]]
  ): js.UndefOr[U] = js.native
  @JSName("min")
  def min_T_Numeric[T /* <: Numeric */](array: Iterable[T]): js.UndefOr[T] = js.native
  def mouse(container: ContainerElement): js.Tuple2[Double, Double] = js.native
  def namespace(prefixedLocal: String): NamespaceLocalObject | String = js.native
  def nest[Datum, RollupType](): Nest[Datum, RollupType] = js.native
  def now(): Double = js.native
  def pack[Datum](): PackLayout[Datum] = js.native
  def packEnclose[Datum /* <: PackCircle */](circles: js.Array[Datum]): PackCircle = js.native
  def packSiblings[Datum /* <: PackRadius */](circles: js.Array[Datum]): js.Array[Datum with PackCircle] = js.native
  def pairs[T](array: Iterable[T]): js.Array[js.Tuple2[T, T]] = js.native
  def pairs[T, U](array: Iterable[T], reducer: js.Function2[/* a */ T, /* b */ T, U]): js.Array[U] = js.native
  def partition[Datum](): PartitionLayout[Datum] = js.native
  def path(): Path = js.native
  def permute[T](array: NumberDictionary[T], keys: ArrayLike[Double]): js.Array[T] = js.native
  def permute[T, K /* <: String */](`object`: T, keys: ArrayLike[K]): js.Array[/* import warning: ImportType.apply Failed type conversion: T[K] */ js.Any] = js.native
  def pie(): Pie[_, Double | typings.d3DashShape.Anon_ValueOf] = js.native
  @JSName("pie")
  def pie_Datum[Datum](): Pie[_, Datum] = js.native
  @JSName("pie")
  def pie_ThisDatum[This, Datum](): Pie[This, Datum] = js.native
  def piecewise(
    interpolate: js.Function2[/* a */ ZoomView, /* b */ ZoomView, ZoomInterpolator],
    values: js.Array[ZoomView]
  ): ZoomInterpolator = js.native
  @JSName("piecewise")
  def piecewise_A_ArrayWildcard_ArrayInterpolator[A /* <: js.Array[_] */](
    interpolate: js.Function2[/* a */ js.Array[_], /* b */ A, ArrayInterpolator[A]],
    values: js.Array[A]
  ): ArrayInterpolator[A] = js.native
  @JSName("piecewise")
  def piecewise_TDataInterpolator_Function1[TData, Interpolator](interpolate: js.Function2[/* a */ TData, /* b */ TData, Interpolator], values: js.Array[TData]): js.Function1[/* t */ Double, _] = js.native
  def pointRadial(angle: Double, radius: Double): js.Tuple2[Double, Double] = js.native
  def polygonArea(polygon: js.Array[js.Tuple2[Double, Double]]): Double = js.native
  def polygonCentroid(polygon: js.Array[js.Tuple2[Double, Double]]): js.Tuple2[Double, Double] = js.native
  def polygonContains(polygon: js.Array[js.Tuple2[Double, Double]], point: js.Tuple2[Double, Double]): Boolean = js.native
  def polygonHull(points: js.Array[js.Tuple2[Double, Double]]): (js.Array[js.Tuple2[Double, Double]]) | Null = js.native
  def polygonLength(polygon: js.Array[js.Tuple2[Double, Double]]): Double = js.native
  def precisionFixed(step: Double): Double = js.native
  def precisionPrefix(step: Double, value: Double): Double = js.native
  def precisionRound(step: Double, max: Double): Double = js.native
  def quadtree[T](): Quadtree[T] = js.native
  def quadtree[T](data: js.Array[T]): Quadtree[T] = js.native
  def quadtree[T](data: js.Array[T], x: js.Function1[/* d */ T, Double]): Quadtree[T] = js.native
  def quadtree[T](data: js.Array[T], x: js.Function1[/* d */ T, Double], y: js.Function1[/* d */ T, Double]): Quadtree[T] = js.native
  def quantile[T /* <: Numeric */](array: Iterable[js.UndefOr[T | Null]], p: Double): js.UndefOr[Double] = js.native
  def quantile[T](
    array: Iterable[T],
    p: Double,
    accessor: js.Function3[/* element */ T, /* i */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  def quantize[T](interpolator: js.Function1[/* t */ Double, T], n: Double): js.Array[T] = js.native
  def quickselect[T](array: ArrayLike[T], k: Double): js.Array[T] = js.native
  def quickselect[T](array: ArrayLike[T], k: Double, left: Double): js.Array[T] = js.native
  def quickselect[T](array: ArrayLike[T], k: Double, left: Double, right: Double): js.Array[T] = js.native
  def quickselect[T](
    array: ArrayLike[T],
    k: Double,
    left: Double,
    right: Double,
    compare: js.Function2[/* a */ js.UndefOr[Primitive], /* b */ js.UndefOr[Primitive], Double]
  ): js.Array[T] = js.native
  def radialArea(): RadialArea[js.Tuple2[Double, Double]] = js.native
  @JSName("radialArea")
  def radialArea_Datum[Datum](): RadialArea[Datum] = js.native
  def radialLine(): RadialLine[js.Tuple2[Double, Double]] = js.native
  @JSName("radialLine")
  def radialLine_Datum[Datum](): RadialLine[Datum] = js.native
  /**
    * Returns a function for generating random numbers with a Bates distribution with n independent variables.
    *
    * @param n Number of independent random variables to use.
    */
  def randomBates(n: Double): js.Function0[Double] = js.native
  /**
    * Returns a function for generating random numbers with an exponential distribution with the rate lambda;
    * equivalent to time between events in a Poisson process with a mean of 1 / lambda.
    *
    * @param lambda Expected time between events.
    */
  def randomExponential(lambda: Double): js.Function0[Double] = js.native
  /**
    * Returns a function for generating random numbers with an IrwinHall distribution with n independent variables.
    *
    * @param n Number of independent random variables to use.
    */
  def randomIrwinHall(n: Double): js.Function0[Double] = js.native
  /**
    * Returns a function for generating random numbers with a log-normal distribution. The expected value of the random variables natural logarithm is mu,
    * with the given standard deviation sigma. If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.
    *
    * @param mu Expected value, defaults to 0.
    * @param sigma Standard deviation, defaults to 1.
    */
  def randomLogNormal(): js.Function0[Double] = js.native
  def randomLogNormal(mu: Double): js.Function0[Double] = js.native
  def randomLogNormal(mu: Double, sigma: Double): js.Function0[Double] = js.native
  /**
    * Returns a function for generating random numbers with a normal (Gaussian) distribution.
    * The expected value of the generated numbers is mu, with the given standard deviation sigma.
    * If mu is not specified, it defaults to 0; if sigma is not specified, it defaults to 1.
    *
    * @param mu Expected value, defaults to 0.
    * @param sigma Standard deviation, defaults to 1.
    */
  def randomNormal(): js.Function0[Double] = js.native
  def randomNormal(mu: Double): js.Function0[Double] = js.native
  def randomNormal(mu: Double, sigma: Double): js.Function0[Double] = js.native
  /**
    * Returns a function for generating random numbers with a uniform distribution).
    * The minimum allowed value of a returned number is min, and the maximum is max.
    * If min is not specified, it defaults to 0; if max is not specified, it defaults to 1.
    *
    * @param min The minimum allowed value of a returned number, defaults to 0.
    * @param max The maximum allowed value of a returned number, defaults to 1.
    */
  def randomUniform(): js.Function0[Double] = js.native
  def randomUniform(min: Double): js.Function0[Double] = js.native
  def randomUniform(min: Double, max: Double): js.Function0[Double] = js.native
  def range(start: Double, stop: Double): js.Array[Double] = js.native
  def range(start: Double, stop: Double, step: Double): js.Array[Double] = js.native
  def range(stop: Double): js.Array[Double] = js.native
  def rgb(color: ColorCommonInstance): RGBColor = js.native
  /**
    * Converts the provided color instance and returns an RGB color. The color instance is converted to the RGB color space using color.rgb.
    * Note that unlike color.rgb this method always returns a new instance, even if color is already an RGB color.
    *
    * @param color A permissible color space instance.
    */
  def rgb(color: ColorSpaceObject): RGBColor = js.native
  /**
    * Parses the specified CSS Color Module Level 3 specifier string, returning an RGB color.
    * If the specifier was not valid, null is returned.
    *
    * @param cssColorSpecifier A CSS Color Module Level 3 specifier string.
    */
  def rgb(cssColorSpecifier: String): RGBColor = js.native
  /**
    * Constructs a new RGB color based on the specified channel values and opacity.
    *
    * @param r Red channel value.
    * @param g Green channel value.
    * @param b Blue channel value.
    * @param opacity Optional opacity value, defaults to 1.
    */
  def rgb(r: Double, g: Double, b: Double): RGBColor = js.native
  def rgb(r: Double, g: Double, b: Double, opacity: Double): RGBColor = js.native
  def ribbon(): RibbonGenerator[_, Ribbon, RibbonSubgroup] = js.native
  @JSName("ribbon")
  def ribbon_DatumSubgroupDatum[Datum, SubgroupDatum](): RibbonGenerator[_, Datum, SubgroupDatum] = js.native
  @JSName("ribbon")
  def ribbon_ThisDatumSubgroupDatum[This, Datum, SubgroupDatum](): RibbonGenerator[This, Datum, SubgroupDatum] = js.native
  def rollup[TObject, TKey, TReduce](
    a: Iterable[TObject],
    reduce: js.Function1[/* value */ js.Array[TObject], TReduce],
    key: js.Function1[/* value */ TObject, TKey]
  ): Map[TKey, TReduce] = js.native
  def scaleBand(): ScaleBand[String] = js.native
  @JSName("scaleBand")
  def scaleBand_Domain_Anon_ToString[Domain /* <: typings.d3DashScale.Anon_ToString */](): ScaleBand[Domain] = js.native
  def scaleDiverging[T](interpolator: js.Function1[/* t */ Double, T]): ScaleDiverging[T] = js.native
  def scaleIdentity(): ScaleIdentity = js.native
  def scaleLinear(): ScaleLinear[Double, Double] = js.native
  @JSName("scaleLinear")
  def scaleLinear_Output[Output](): ScaleLinear[Output, Output] = js.native
  @JSName("scaleLinear")
  def scaleLinear_RangeOutput[Range, Output](): ScaleLinear[Range, Output] = js.native
  def scaleLog(): ScaleLogarithmic[Double, Double] = js.native
  @JSName("scaleLog")
  def scaleLog_Output[Output](): ScaleLogarithmic[Output, Output] = js.native
  @JSName("scaleLog")
  def scaleLog_RangeOutput[Range, Output](): ScaleLogarithmic[Range, Output] = js.native
  def scaleOrdinal[Range](): ScaleOrdinal[String, Range] = js.native
  def scaleOrdinal[Range](range: js.Array[Range]): ScaleOrdinal[String, Range] = js.native
  @JSName("scaleOrdinal")
  def scaleOrdinal_Domain_Anon_ToStringRange[Domain /* <: typings.d3DashScale.Anon_ToString */, Range](): ScaleOrdinal[Domain, Range] = js.native
  @JSName("scaleOrdinal")
  def scaleOrdinal_Domain_Anon_ToStringRange[Domain /* <: typings.d3DashScale.Anon_ToString */, Range](range: js.Array[Range]): ScaleOrdinal[Domain, Range] = js.native
  def scalePoint(): ScalePoint[String] = js.native
  @JSName("scalePoint")
  def scalePoint_Domain_Anon_ToString[Domain /* <: typings.d3DashScale.Anon_ToString */](): ScalePoint[Domain] = js.native
  def scalePow(): ScalePower[Double, Double] = js.native
  @JSName("scalePow")
  def scalePow_Output[Output](): ScalePower[Output, Output] = js.native
  @JSName("scalePow")
  def scalePow_RangeOutput[Range, Output](): ScalePower[Range, Output] = js.native
  def scaleQuantile(): ScaleQuantile[Double] = js.native
  @JSName("scaleQuantile")
  def scaleQuantile_Range[Range](): ScaleQuantile[Range] = js.native
  def scaleQuantize(): ScaleQuantize[Double] = js.native
  @JSName("scaleQuantize")
  def scaleQuantize_Range[Range](): ScaleQuantize[Range] = js.native
  def scaleSequential[Output](interpolator: js.Function1[/* t */ Double, Output]): ScaleSequential[Output] = js.native
  def scaleSqrt(): ScalePower[Double, Double] = js.native
  @JSName("scaleSqrt")
  def scaleSqrt_Output[Output](): ScalePower[Output, Output] = js.native
  @JSName("scaleSqrt")
  def scaleSqrt_RangeOutput[Range, Output](): ScalePower[Range, Output] = js.native
  def scaleThreshold(): ScaleThreshold[Double, Double] = js.native
  @JSName("scaleThreshold")
  def scaleThreshold_Domain_UnionDoubleStringDateRange[Domain /* <: Double | String | Date */, Range](): ScaleThreshold[Domain, Range] = js.native
  def scaleTime(): ScaleTime[Double, Double] = js.native
  @JSName("scaleTime")
  def scaleTime_Output[Output](): ScaleTime[Output, Output] = js.native
  @JSName("scaleTime")
  def scaleTime_RangeOutput[Range, Output](): ScaleTime[Range, Output] = js.native
  def scaleUtc(): ScaleTime[Double, Double] = js.native
  @JSName("scaleUtc")
  def scaleUtc_Output[Output](): ScaleTime[Output, Output] = js.native
  @JSName("scaleUtc")
  def scaleUtc_RangeOutput[Range, Output](): ScaleTime[Range, Output] = js.native
  def scan(array: Iterable[Double]): js.UndefOr[Double] = js.native
  def scan(array: Iterable[Double], comparator: js.Function2[/* a */ Double, /* b */ Double, Double]): js.UndefOr[Double] = js.native
  @JSName("scan")
  def scan_T[T](array: Iterable[T], comparator: js.Function2[/* a */ T, /* b */ T, Double]): js.UndefOr[Double] = js.native
  def select[OldDatum](): Selection[Null, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def select[OldDatum](node: EnterElement): Selection[EnterElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def select[OldDatum](node: Document): Selection[Document, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def select[OldDatum](node: Element): Selection[Element, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def select[OldDatum](node: Window): Selection[Window, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def select[GElement /* <: BaseType */, OldDatum](selector: String): Selection[GElement, OldDatum, HTMLElement, _] = js.native
  def selectAll(): Selection[Null, js.UndefOr[scala.Nothing], Null, js.UndefOr[scala.Nothing]] = js.native
  def selectAll[GElement /* <: BaseType */, OldDatum](nodes: js.Array[GElement]): Selection[GElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def selectAll[GElement /* <: BaseType */, OldDatum](nodes: typings.d3DashSelection.d3DashSelectionMod.ArrayLike[GElement]): Selection[GElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def selectAll[GElement /* <: BaseType */, OldDatum](selector: String): Selection[GElement, OldDatum, HTMLElement, _] = js.native
  def selection(): Selection[HTMLElement, _, Null, js.UndefOr[scala.Nothing]] = js.native
  def selector[DescElement /* <: Element */](selector: String): js.ThisFunction0[/* this */ BaseType, DescElement] = js.native
  def selectorAll[DescElement /* <: Element */](selector: String): js.ThisFunction0[/* this */ BaseType, NodeListOf[DescElement]] = js.native
  def set(): Set = js.native
  def set(array: js.Array[String | Stringifiable]): Set = js.native
  def set(d3Set: Set): Set = js.native
  def set[T](
    array: js.Array[T],
    key: js.Function3[/* value */ T, /* index */ Double, /* array */ js.Array[T], String]
  ): Set = js.native
  def shuffle(array: Float32Array): Float32Array = js.native
  def shuffle(array: Float32Array, lo: Double): Float32Array = js.native
  def shuffle(array: Float32Array, lo: Double, hi: Double): Float32Array = js.native
  def shuffle(array: Float64Array): Float64Array = js.native
  def shuffle(array: Float64Array, lo: Double): Float64Array = js.native
  def shuffle(array: Float64Array, lo: Double, hi: Double): Float64Array = js.native
  def shuffle(array: Int16Array): Int16Array = js.native
  def shuffle(array: Int16Array, lo: Double): Int16Array = js.native
  def shuffle(array: Int16Array, lo: Double, hi: Double): Int16Array = js.native
  def shuffle(array: Int32Array): Int32Array = js.native
  def shuffle(array: Int32Array, lo: Double): Int32Array = js.native
  def shuffle(array: Int32Array, lo: Double, hi: Double): Int32Array = js.native
  def shuffle(array: Int8Array): Int8Array = js.native
  def shuffle(array: Int8Array, lo: Double): Int8Array = js.native
  def shuffle(array: Int8Array, lo: Double, hi: Double): Int8Array = js.native
  def shuffle(array: Uint16Array): Uint16Array = js.native
  def shuffle(array: Uint16Array, lo: Double): Uint16Array = js.native
  def shuffle(array: Uint16Array, lo: Double, hi: Double): Uint16Array = js.native
  def shuffle(array: Uint32Array): Uint32Array = js.native
  def shuffle(array: Uint32Array, lo: Double): Uint32Array = js.native
  def shuffle(array: Uint32Array, lo: Double, hi: Double): Uint32Array = js.native
  def shuffle(array: Uint8Array): Uint8Array = js.native
  def shuffle(array: Uint8Array, lo: Double): Uint8Array = js.native
  def shuffle(array: Uint8Array, lo: Double, hi: Double): Uint8Array = js.native
  def shuffle(array: Uint8ClampedArray): Uint8ClampedArray = js.native
  def shuffle(array: Uint8ClampedArray, lo: Double): Uint8ClampedArray = js.native
  def shuffle(array: Uint8ClampedArray, lo: Double, hi: Double): Uint8ClampedArray = js.native
  def shuffle[T](array: js.Array[T]): js.Array[T] = js.native
  def shuffle[T](array: js.Array[T], lo: Double): js.Array[T] = js.native
  def shuffle[T](array: js.Array[T], lo: Double, hi: Double): js.Array[T] = js.native
  def stack(): Stack[_, StringDictionary[Double], String] = js.native
  def stackOffsetDiverging(series: Series[_, _], order: js.Array[Double]): Unit = js.native
  def stackOffsetExpand(series: Series[_, _], order: js.Array[Double]): Unit = js.native
  def stackOffsetNone(series: Series[_, _], order: js.Array[Double]): Unit = js.native
  def stackOffsetSilhouette(series: Series[_, _], order: js.Array[Double]): Unit = js.native
  def stackOffsetWiggle(series: Series[_, _], order: js.Array[Double]): Unit = js.native
  def stackOrderAppearance(series: Series[_, _]): js.Array[Double] = js.native
  def stackOrderAscending(series: Series[_, _]): js.Array[Double] = js.native
  def stackOrderDescending(series: Series[_, _]): js.Array[Double] = js.native
  def stackOrderInsideOut(series: Series[_, _]): js.Array[Double] = js.native
  def stackOrderNone(series: Series[_, _]): js.Array[Double] = js.native
  def stackOrderReverse(series: Series[_, _]): js.Array[Double] = js.native
  @JSName("stack")
  def stack_Datum[Datum](): Stack[_, Datum, String] = js.native
  @JSName("stack")
  def stack_DatumKey[Datum, Key](): Stack[_, Datum, Key] = js.native
  @JSName("stack")
  def stack_ThisDatumKey[This, Datum, Key](): Stack[This, Datum, Key] = js.native
  def stratify[Datum](): StratifyOperator[Datum] = js.native
  def style(node: Element, name: String): String = js.native
  def sum[T /* <: Numeric */](array: Iterable[js.UndefOr[T | Null]]): Double = js.native
  def sum[T](
    array: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): Double = js.native
  def svg(url: String): js.Promise[Document] = js.native
  def svg(url: String, init: RequestInit): js.Promise[Document] = js.native
  def symbol(): Symbol[_, _] = js.native
  @JSName("symbol")
  def symbol_Datum[Datum](): Symbol[_, Datum] = js.native
  @JSName("symbol")
  def symbol_ThisDatum[This, Datum](): Symbol[This, Datum] = js.native
  def text(url: String): js.Promise[String] = js.native
  def text(url: String, init: RequestInit): js.Promise[String] = js.native
  def thresholdFreedmanDiaconis(values: ArrayLike[js.UndefOr[Double]], min: Double, max: Double): Double = js.native
  def thresholdScott(values: ArrayLike[js.UndefOr[Double]], min: Double, max: Double): Double = js.native
  def thresholdSturges(values: ArrayLike[js.UndefOr[Double]]): Double = js.native
  def tickIncrement(start: Double, stop: Double, count: Double): Double = js.native
  def tickStep(start: Double, stop: Double, count: Double): Double = js.native
  def ticks(start: Double, stop: Double, count: Double): js.Array[Double] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeDay(date: Date): Date = js.native
  def timeDays(start: Date, stop: Date): js.Array[Date] = js.native
  def timeDays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  def timeFormat(specifier: String): js.Function1[/* date */ Date, String] = js.native
  def timeFormatDefaultLocale(defaultTimeLocale: TimeLocaleDefinition): TimeLocaleObject = js.native
  def timeFormatLocale(timeLocale: TimeLocaleDefinition): TimeLocaleObject = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeFriday(date: Date): Date = js.native
  def timeFridays(start: Date, stop: Date): js.Array[Date] = js.native
  def timeFridays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeHour(date: Date): Date = js.native
  def timeHours(start: Date, stop: Date): js.Array[Date] = js.native
  def timeHours(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  def timeInterval(
    floor: js.Function1[/* date */ Date, Unit],
    offset: js.Function2[/* date */ Date, /* step */ Double, Unit]
  ): TimeInterval = js.native
  def timeInterval(
    floor: js.Function1[/* date */ Date, Unit],
    offset: js.Function2[/* date */ Date, /* step */ Double, Unit],
    count: js.Function2[/* start */ Date, /* end */ Date, Double]
  ): CountableTimeInterval = js.native
  def timeInterval(
    floor: js.Function1[/* date */ Date, Unit],
    offset: js.Function2[/* date */ Date, /* step */ Double, Unit],
    count: js.Function2[/* start */ Date, /* end */ Date, Double],
    field: js.Function1[/* date */ Date, Double]
  ): CountableTimeInterval = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeMillisecond(date: Date): Date = js.native
  def timeMilliseconds(start: Date, stop: Date): js.Array[Date] = js.native
  def timeMilliseconds(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeMinute(date: Date): Date = js.native
  def timeMinutes(start: Date, stop: Date): js.Array[Date] = js.native
  def timeMinutes(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeMonday(date: Date): Date = js.native
  def timeMondays(start: Date, stop: Date): js.Array[Date] = js.native
  def timeMondays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeMonth(date: Date): Date = js.native
  def timeMonths(start: Date, stop: Date): js.Array[Date] = js.native
  def timeMonths(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  def timeParse(specifier: String): js.Function1[/* dateString */ String, Date | Null] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeSaturday(date: Date): Date = js.native
  def timeSaturdays(start: Date, stop: Date): js.Array[Date] = js.native
  def timeSaturdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeSecond(date: Date): Date = js.native
  def timeSeconds(start: Date, stop: Date): js.Array[Date] = js.native
  def timeSeconds(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeSunday(date: Date): Date = js.native
  def timeSundays(start: Date, stop: Date): js.Array[Date] = js.native
  def timeSundays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeThursday(date: Date): Date = js.native
  def timeThursdays(start: Date, stop: Date): js.Array[Date] = js.native
  def timeThursdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeTuesday(date: Date): Date = js.native
  def timeTuesdays(start: Date, stop: Date): js.Array[Date] = js.native
  def timeTuesdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeWednesday(date: Date): Date = js.native
  def timeWednesdays(start: Date, stop: Date): js.Array[Date] = js.native
  def timeWednesdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeWeek(date: Date): Date = js.native
  def timeWeeks(start: Date, stop: Date): js.Array[Date] = js.native
  def timeWeeks(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def timeYear(date: Date): Date = js.native
  def timeYears(start: Date, stop: Date): js.Array[Date] = js.native
  def timeYears(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  def timeout(callback: js.Function1[/* elapsed */ Double, Unit]): Timer = js.native
  def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer = js.native
  def timeout(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer = js.native
  def timer(callback: js.Function1[/* elapsed */ Double, Unit]): Timer = js.native
  def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double): Timer = js.native
  def timer(callback: js.Function1[/* elapsed */ Double, Unit], delay: Double, time: Double): Timer = js.native
  def timerFlush(): Unit = js.native
  def touch(container: ContainerElement, identifier: Double): (js.Tuple2[Double, Double]) | Null = js.native
  def touch(container: ContainerElement, touches: TouchList, identifier: Double): (js.Tuple2[Double, Double]) | Null = js.native
  def touches(container: ContainerElement): js.Array[js.Tuple2[Double, Double]] = js.native
  def touches(container: ContainerElement, touches: TouchList): js.Array[js.Tuple2[Double, Double]] = js.native
  def transition[OldDatum](): typings.d3DashTransition.d3DashTransitionMod.Transition[HTMLElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def transition[OldDatum](name: String): typings.d3DashTransition.d3DashTransitionMod.Transition[HTMLElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def transition[OldDatum](transition: typings.d3DashTransition.d3DashTransitionMod.Transition[BaseType, _, BaseType, _]): typings.d3DashTransition.d3DashTransitionMod.Transition[HTMLElement, OldDatum, Null, js.UndefOr[scala.Nothing]] = js.native
  def transpose[T](matrix: ArrayLike[ArrayLike[T]]): js.Array[js.Array[T]] = js.native
  def tree[Datum](): TreeLayout[Datum] = js.native
  def treemap[Datum](): TreemapLayout[Datum] = js.native
  def treemapBinary(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  def treemapDice(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  def treemapResquarify(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  def treemapSlice(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  def treemapSliceDice(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  def treemapSquarify(node: HierarchyRectangularNode[_], x0: Double, y0: Double, x1: Double, y1: Double): Unit = js.native
  def tsv[Columns /* <: String */](url: String): js.Promise[DSVRowArray[Columns]] = js.native
  def tsv[Columns /* <: String */](url: String, init: RequestInit): js.Promise[DSVRowArray[Columns]] = js.native
  def tsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    url: String,
    init: RequestInit,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  def tsv[ParsedRow /* <: js.Object */, Columns /* <: String */](
    url: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): js.Promise[DSVParsedArray[ParsedRow]] = js.native
  def tsvFormat[T /* <: js.Object */](rows: js.Array[T]): String = js.native
  def tsvFormat[T /* <: js.Object */](rows: js.Array[T], columns: js.Array[String]): String = js.native
  def tsvFormatRows(rows: js.Array[js.Array[String]]): String = js.native
  def tsvParse[Columns /* <: String */](tsvString: String): DSVRowArray[Columns] = js.native
  def tsvParse[ParsedRow /* <: js.Object */, Columns /* <: String */](
    tsvString: String,
    row: js.Function3[
      /* rawRow */ DSVRowString[Columns], 
      /* index */ Double, 
      /* columns */ js.Array[Columns], 
      js.UndefOr[ParsedRow | Null]
    ]
  ): DSVParsedArray[ParsedRow] = js.native
  def tsvParseRows(tsvString: String): js.Array[js.Array[String]] = js.native
  def tsvParseRows[ParsedRow /* <: js.Object */](
    tsvString: String,
    row: js.Function2[/* rawRow */ js.Array[String], /* index */ Double, js.UndefOr[ParsedRow | Null]]
  ): js.Array[ParsedRow] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcDay(date: Date): Date = js.native
  def utcDays(start: Date, stop: Date): js.Array[Date] = js.native
  def utcDays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  def utcFormat(specifier: String): js.Function1[/* date */ Date, String] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcFriday(date: Date): Date = js.native
  def utcFridays(start: Date, stop: Date): js.Array[Date] = js.native
  def utcFridays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcHour(date: Date): Date = js.native
  def utcHours(start: Date, stop: Date): js.Array[Date] = js.native
  def utcHours(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcMillisecond(date: Date): Date = js.native
  def utcMilliseconds(start: Date, stop: Date): js.Array[Date] = js.native
  def utcMilliseconds(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcMinute(date: Date): Date = js.native
  def utcMinutes(start: Date, stop: Date): js.Array[Date] = js.native
  def utcMinutes(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcMonday(date: Date): Date = js.native
  def utcMondays(start: Date, stop: Date): js.Array[Date] = js.native
  def utcMondays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcMonth(date: Date): Date = js.native
  def utcMonths(start: Date, stop: Date): js.Array[Date] = js.native
  def utcMonths(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  def utcParse(specifier: String): js.Function1[/* dateString */ String, Date | Null] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcSaturday(date: Date): Date = js.native
  def utcSaturdays(start: Date, stop: Date): js.Array[Date] = js.native
  def utcSaturdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcSecond(date: Date): Date = js.native
  def utcSeconds(start: Date, stop: Date): js.Array[Date] = js.native
  def utcSeconds(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcSunday(date: Date): Date = js.native
  def utcSundays(start: Date, stop: Date): js.Array[Date] = js.native
  def utcSundays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcThursday(date: Date): Date = js.native
  def utcThursdays(start: Date, stop: Date): js.Array[Date] = js.native
  def utcThursdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcTuesday(date: Date): Date = js.native
  def utcTuesdays(start: Date, stop: Date): js.Array[Date] = js.native
  def utcTuesdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcWednesday(date: Date): Date = js.native
  def utcWednesdays(start: Date, stop: Date): js.Array[Date] = js.native
  def utcWednesdays(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcWeek(date: Date): Date = js.native
  def utcWeeks(start: Date, stop: Date): js.Array[Date] = js.native
  def utcWeeks(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  /**
    * Returns a new date representing the latest interval boundary date before or equal to date.
    * This function is an alias for "TimeInterval.floor(date)". For example, timeYear(date) and timeYear.floor(date) are equivalent.
    *
    * For example, timeDay(date) typically returns 12:00 AM local time on the given date.
    *
    * This function is idempotent: if the specified date is already floored to the current interval,
    * a new date with an identical time is returned.
    * Furthermore, the returned date is the minimum expressible value of the associated interval,
    * such that interval.floor(interval.floor(date) - 1) returns the preceding interval boundary date.
    *
    * Note that the == and === operators do not compare by value with Date objects,
    * and thus you cannot use them to tell whether the specified date has already been floored.
    * Instead, coerce to a number and then compare.
    *
    * This is more reliable than testing whether the time is 12:00 AM, as in some time zones midnight may not exist due to daylight saving.
    *
    * @param date A date object.
    */
  def utcYear(date: Date): Date = js.native
  def utcYears(start: Date, stop: Date): js.Array[Date] = js.native
  def utcYears(start: Date, stop: Date, step: Double): js.Array[Date] = js.native
  def values(obj: js.Object): js.Array[_] = js.native
  def values[T](obj: StringDictionary[T]): js.Array[T] = js.native
  def values[T](obj: ArrayLike[T]): js.Array[T] = js.native
  def variance[T /* <: Numeric */](array: Iterable[js.UndefOr[T | Null]]): js.UndefOr[Double] = js.native
  def variance[T](
    array: Iterable[T],
    accessor: js.Function3[/* datum */ T, /* index */ Double, /* array */ Iterable[T], js.UndefOr[Double | Null]]
  ): js.UndefOr[Double] = js.native
  def voronoi[T](): VoronoiLayout[T] = js.native
  def window(DOMNode: Document): Window = js.native
  def window(DOMNode: Element): Window = js.native
  def window(DOMNode: Window): Window = js.native
  def xml(url: String): js.Promise[XMLDocument] = js.native
  def xml(url: String, init: RequestInit): js.Promise[XMLDocument] = js.native
  def zip[T](arrays: ArrayLike[T]*): js.Array[js.Array[T]] = js.native
  def zoom[ZoomRefElement /* <: ZoomedElementBaseType */, Datum](): ZoomBehavior[ZoomRefElement, Datum] = js.native
  def zoomTransform(node: ZoomedElementBaseType): ZoomTransform = js.native
}

