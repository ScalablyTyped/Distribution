package typings.d3Ease

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  @JSImport("d3-ease", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  @JSImport("d3-ease", "easeBack")
  @js.native
  val easeBack: BackEasingFactory = js.native
  
  @JSImport("d3-ease", "easeBackIn")
  @js.native
  val easeBackIn: BackEasingFactory = js.native
  
  @JSImport("d3-ease", "easeBackInOut")
  @js.native
  val easeBackInOut: BackEasingFactory = js.native
  
  @JSImport("d3-ease", "easeBackOut")
  @js.native
  val easeBackOut: BackEasingFactory = js.native
  
  inline def easeBounce(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeBounce")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeBounceIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeBounceIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeBounceInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeBounceInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeBounceOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeBounceOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeCircle(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCircle")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeCircleIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCircleIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeCircleInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCircleInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeCircleOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCircleOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeCubic(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCubic")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeCubicIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCubicIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeCubicInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCubicInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeCubicOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeCubicOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  @JSImport("d3-ease", "easeElastic")
  @js.native
  val easeElastic: ElasticEasingFactory = js.native
  
  @JSImport("d3-ease", "easeElasticIn")
  @js.native
  val easeElasticIn: ElasticEasingFactory = js.native
  
  @JSImport("d3-ease", "easeElasticInOut")
  @js.native
  val easeElasticInOut: ElasticEasingFactory = js.native
  
  @JSImport("d3-ease", "easeElasticOut")
  @js.native
  val easeElasticOut: ElasticEasingFactory = js.native
  
  inline def easeExp(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeExp")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeExpIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeExpIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeExpInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeExpInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeExpOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeExpOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeLinear(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeLinear")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  @JSImport("d3-ease", "easePoly")
  @js.native
  val easePoly: PolynomialEasingFactory = js.native
  
  @JSImport("d3-ease", "easePolyIn")
  @js.native
  val easePolyIn: PolynomialEasingFactory = js.native
  
  @JSImport("d3-ease", "easePolyInOut")
  @js.native
  val easePolyInOut: PolynomialEasingFactory = js.native
  
  @JSImport("d3-ease", "easePolyOut")
  @js.native
  val easePolyOut: PolynomialEasingFactory = js.native
  
  inline def easeQuad(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeQuad")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeQuadIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeQuadIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeQuadInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeQuadInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeQuadOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeQuadOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeSin(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeSin")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeSinIn(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeSinIn")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeSinInOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeSinInOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def easeSinOut(normalizedTime: Double): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("easeSinOut")(normalizedTime.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  @js.native
  trait BackEasingFactory extends StObject {
    
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def apply(normalizedTime: Double): Double = js.native
    
    /**
      * Returns a new back easing with the specified overshoot s.
      * The degree of overshoot is configurable; if not specified, it defaults to 1.70158.
      *
      * @param s Overshoot parameter
      */
    def overshoot(s: Double): BackEasingFactory = js.native
  }
  
  @js.native
  trait ElasticEasingFactory extends StObject {
    
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def apply(normalizedTime: Double): Double = js.native
    
    /**
      * Returns a new elastic easing with the specified amplitude a.
      * Defaults to 1,if not specified.
      *
      * @param a Amplitude for elastic easing.
      */
    def amplitude(a: Double): ElasticEasingFactory = js.native
    
    /**
      * Returns a new elastic easing with the specified amplitude a.
      * Defaults to 0.3,if not specified.
      *
      * @param p Period for elastic easing.
      */
    def period(p: Double): ElasticEasingFactory = js.native
  }
  
  @js.native
  trait PolynomialEasingFactory extends StObject {
    
    /**
      * Calculate eased time.
      * @param normalizedTime Normalized time typically in the range [0, 1]
      */
    def apply(normalizedTime: Double): Double = js.native
    
    /**
      * Returns a new polynomial easing with the specified exponent e.
      * If the exponent is not specified, it defaults to 3, equivalent to cubic.
      *
      * @param e Exponent for polynomial easing.
      */
    def exponent(e: Double): PolynomialEasingFactory = js.native
  }
}
