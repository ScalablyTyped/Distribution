package typings
package workboxDashWebpackDashPluginLib.workboxDashWebpackDashPluginMod

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait CommonOptions extends js.Object {
  /**
  	 * By default, Workbox will precache assets regardless of which chunk the asset is part of.
  	 *
  	 * If you would like to override this behavior via a whitelist, specify one or more chunk names. Only assets belonging to those chunks will be precached;
  	 * any assets belonging to another chunk or without a chunk association will be skipped.
  	 *
  	 * @default []
  	 * @example chunks: ['chunk-name-1', 'chunk-name-2']
  	 */
  var chunks: js.UndefOr[js.Array[java.lang.String]] = js.undefined
  /**
  	 * Assets that match this regex will be assumed to be uniquely versioned via their URL, and exempted from the normal HTTP cache-busting that's done when populating the precache.
  	 *
  	 * While not required, it's recommended that if your existing build process already inserts a `[hash]` value into each filename, you provide a RegExp that will detect those values,
  	 * as it will reduce the amount of bandwidth consumed when precaching.
  	 *
  	 * @default null
  	 * @example dontCacheBustUrlsMatching: /\.\w{8}\./
  	 */
  var dontCacheBustUrlsMatching: js.UndefOr[stdLib.RegExp | scala.Null] = js.undefined
  /**
  	 * This allows you to specifically omit assets matching any of the provided criteria from being included in the precache manifest. It provides a filename-based approach to filtering.
  	 *
  	 * This filtering takes place after any chunk-based filtering is applied.
  	 *
  	 * @default [/\.map$/, /^manifest.*\.js(?:on)?$/]
  	 * @example exclude: [/\.jpg$/, /\.png$/]
  	 */
  var exclude: js.UndefOr[js.Array[java.lang.String | stdLib.RegExp]] = js.undefined
  /**
  	 * By default, Workbox will precache all assets generated by the webpack compilation, regardless of which chunk the asset is part of.
  	 *
  	 * If you would like to override this behavior via a blacklist, specify one or more chunk names. Any assets belonging to those chunks will be skipped.
  	 *
  	 * @default []
  	 * @example excludeChunks: ['chunk-name-1', 'chunk-name-2']
  	 */
  var excludeChunks: js.UndefOr[js.Array[java.lang.String]] = js.undefined
  /**
  	 * The base directory you wish to match `globPatterns` against, relative to the current working directory.
  	 *
  	 * If you do set this, make sure to also configure `globPatterns`.
  	 *
  	 * @default undefined
  	 * @example globDirectory: '.'
  	 */
  var globDirectory: js.UndefOr[java.lang.String] = js.undefined
  /**
  	 * Determines whether or not symlinks are followed when generating the precache manifest.
  	 *
  	 * For more information, see the definition of `follow` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
  	 *
  	 * @default true
  	 * @example globFollow: false
  	 */
  var globFollow: js.UndefOr[scala.Boolean] = js.undefined
  /**
  	 * A set of patterns matching files to always exclude when generating the precache manifest.
  	 *
  	 * For more information, see the definition of `ignore` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
  	 *
  	 * @default ['node_modules/ **\/ *']
  	 * @example globIgnores: ['**\/ignored.html']
  	 */
  var globIgnores: js.UndefOr[js.Array[java.lang.String]] = js.undefined
  /**
  	 * Files matching against any of these patterns will be included in the precache manifest.
  	 *
  	 * For more information, see the [glob primer](https://github.com/isaacs/node-glob#glob-primer).
  	 *
  	 * Note: Setting `globPatterns` is often unnecessary when using the `workbox-webpack-plugin`, which will automatically precache files that are part of the webpack build pipeline by default.
  	 * When using the webpack plugin, only set it when you need to cache
  	 * [non-webpack assets](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin#cache_additional_non-webpack_assets).
  	 *
  	 * @default []
  	 * @example globPatterns: ['dist/ *.{js,png,html,css}']
  	 */
  var globPatterns: js.UndefOr[js.Array[java.lang.String]] = js.undefined
  /**
  	 * If `true`, an error reading a directory when generating a precache manifest will cause the build to fail. If `false`, the problematic directory will be skipped.
  	 *
  	 * For more information, see the definition of `strict` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
  	 *
  	 * @default true
  	 * @example globStrict: false
  	 */
  var globStrict: js.UndefOr[scala.Boolean] = js.undefined
  /**
  	 * Valid values are `'cdn'`, `'local'`, and `'disabled'`.
  	 *
  	 *  - `'cdn'`, the default, will use a URL for the Workbox runtime libraries hosted on a highly-available Google Cloud Storage instance.
  	 *
  	 *  - `'local'` will copy all of the Workbox runtime libraries into a versioned directory alongside your generated service worker, and configure the service worker to use those local copies.
  	 *    This option is provided for developers who would prefer to host everything themselves and not rely on the Google Cloud Storage CDN.
  	 *
  	 *  - `'disabled'` will opt-out automatic behavior. It's up to you to host a local copy of the Workbox libraries at your preferred URL, and to pass in the correct path to `workbox-sw.js`
  	 *    via the `importScripts` configuration option.
  	 *
  	 *  - Note: In webpack, passing in a string corresponding to the webpack chunk name containing a custom Workbox runtime library bundle is also supported.
  	 *
  	 * @default 'cdn'
  	 * @example importWorkboxFrom: 'local'
  	 */
  var importWorkboxFrom: js.UndefOr[
    workboxDashWebpackDashPluginLib.workboxDashWebpackDashPluginLibStrings.cdn | workboxDashWebpackDashPluginLib.workboxDashWebpackDashPluginLibStrings.local | workboxDashWebpackDashPluginLib.workboxDashWebpackDashPluginLibStrings.disabled
  ] = js.undefined
  /**
  	 * Workbox creates assets as part of your webpack build process: a precache manifest file, and potentially a local copy of the Workbox libraries (if `importWorkboxFrom` is set to `'local'`).
  	 *
  	 * These assets will, by default, be created at the root of your webpack build directory, i.e. `output.path`. You can set the `importsDirectory` option if you want these assets to be created in
  	 * a subdirectory of `output.path` instead of at the top-level.
  	 *
  	 * Note: This option does not effect where the main service worker JavaScript file is created. That is determined by the `swDest` option.
  	 *
  	 * @default ''
  	 * @example importsDirectory: 'wb-assets'
  	 */
  var importsDirectory: js.UndefOr[java.lang.String] = js.undefined
  /**
  	 * This allows you to only include assets matching any of the provided criteria when creating the precache manifest. It provides a filename-based approach to filtering.
  	 *
  	 * This filtering takes place after any chunk-based filtering is applied.
  	 *
  	 * In keeping with [webpack convention](https://webpack.js.org/configuration/module/#condition), the option `test` can be used as an alias/alternative to `include`.
  	 *
  	 * @default []
  	 * @example include: [/\.html$/, /\.js$/]
  	 * @alias test
  	 */
  var include: js.UndefOr[js.Array[java.lang.String | stdLib.RegExp]] = js.undefined
  /**
  	 * One or more [`ManifestTransform`](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-build#.ManifestTransform)
  	 * functions, which will be applied sequentially against the generated manifest.
  	 *
  	 * If `modifyUrlPrefix` or `dontCacheBustUrlsMatching` are also specified, their corresponding transformations will be applied first.
  	 */
  var manifestTransforms: js.UndefOr[
    (js.Array[
      js.Function1[
        /* originalManifest */ js.Array[ManifestEntry], 
        workboxDashWebpackDashPluginLib.Anon_Manifest
      ]
    ]) | scala.Null
  ] = js.undefined
  /**
  	 * This value can be used to determine the maximum size of files that will be precached. This prevents you from inadvertantly precaching very large files that might have
  	 * accidentally matched one of your patterns.
  	 *
  	 * @default 2097152
  	 * @example maximumFileSizeToCacheInBytes: 4 * 1024 * 1024
  	 */
  var maximumFileSizeToCacheInBytes: js.UndefOr[scala.Double] = js.undefined
  /**
  	 * A mapping of prefixes that, if present in an entry in the precache manifest, will be replaced with the corresponding value.
  	 *
  	 * This can be used to, for example, remove or add a path prefix from a manifest entry if your web hosting setup doesn't match your local filesystem setup.
  	 *
  	 * As an alternative with more flexibility, you can use the `manifestTransforms` option and provide a function that modifies the entries in the manifest using whatever logic you provide.
  	 *
  	 * @default null
  	 * @example modifyUrlPrefix: { '/dist': '' }
  	 */
  var modifyUrlPrefix: js.UndefOr[org.scalablytyped.runtime.StringDictionary[java.lang.String] | scala.Null] = js.undefined
  /**
  	 * Workbox automatically creates a JavaScript file that contains information about URLs that need to be precached. By default, this file is called `precache-manifest.[manifestHash].js`,
  	 * where `[manifestHash]` is automatically replaced by a unique value that identifies the contents of the file.
  	 *
  	 * `precacheManifestFilename` can be used to override this default filename. You must include the string `[manifestHash]` somewhere as part of the filename.
  	 *
  	 * If you'd like to change the output directory to which the precache manifest is written, you can configure the `importsDirectory` option.
  	 *
  	 * @default 'precache-manifest.[manifestHash].js'
  	 * @example precacheManifestFilename: 'wb-manifest.[manifestHash].js'
  	 */
  var precacheManifestFilename: js.UndefOr[java.lang.String] = js.undefined
  /**
  	 * The path and filename of the service worker file that will be created by the build process, relative to the webpack output directory.
  	 *
  	 * @default 'service-worker.js'
  	 * @example swDest: 'custom-sw-name.js'
  	 */
  var swDest: js.UndefOr[java.lang.String] = js.undefined
  /**
  	 * If a URL is rendered generated based on some server-side logic, its contents may depend on multiple files or on some other unique string value.
  	 *
  	 * If used with an array of strings, they will be interpreted as glob patterns, and the contents of any files matching the patterns will be used to uniquely version the URL.
  	 *
  	 * If used with a single string, it will be interpreted as unique versioning information that you've generated out of band for a given URL.
  	 *
  	 * @default null
  	 */
  var templatedUrls: js.UndefOr[
    (org.scalablytyped.runtime.StringDictionary[java.lang.String | js.Array[java.lang.String]]) | scala.Null
  ] = js.undefined
  var test: js.UndefOr[js.Array[java.lang.String | stdLib.RegExp]] = js.undefined
}

