package typings.workboxWebpackPlugin

import org.scalablytyped.runtime.StringDictionary
import typings.std.RegExp
import typings.workboxWebpackPlugin.anon.ChannelName
import typings.workboxWebpackPlugin.anon.Headers
import typings.workboxWebpackPlugin.anon.Integrity
import typings.workboxWebpackPlugin.anon.Manifest
import typings.workboxWebpackPlugin.anon.MaxAgeSeconds
import typings.workboxWebpackPlugin.anon.Name
import typings.workboxWebpackPlugin.workboxWebpackPluginStrings.production
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  @JSImport("workbox-webpack-plugin", "GenerateSW")
  @js.native
  class GenerateSW () extends StObject {
    def this(opts: GenerateSWOptions) = this()
    
    @JSName("apply")
    def apply(args: js.Any*): Unit = js.native
  }
  
  @JSImport("workbox-webpack-plugin", "InjectManifest")
  @js.native
  class InjectManifest () extends StObject {
    def this(opts: InjectManifestOptions) = this()
    
    @JSName("apply")
    def apply(args: js.Any*): Unit = js.native
  }
  
  /* Rewritten from type alias, can be one of: 
    - typings.workboxWebpackPlugin.workboxWebpackPluginStrings.CacheFirst
    - typings.workboxWebpackPlugin.workboxWebpackPluginStrings.CacheOnly
    - typings.workboxWebpackPlugin.workboxWebpackPluginStrings.NetworkFirst
    - typings.workboxWebpackPlugin.workboxWebpackPluginStrings.NetworkOnly
    - typings.workboxWebpackPlugin.workboxWebpackPluginStrings.StaleWhileRevalidate
  */
  trait CacheStrategy extends StObject
  object CacheStrategy {
    
    @scala.inline
    def CacheFirst: typings.workboxWebpackPlugin.workboxWebpackPluginStrings.CacheFirst = "CacheFirst".asInstanceOf[typings.workboxWebpackPlugin.workboxWebpackPluginStrings.CacheFirst]
    
    @scala.inline
    def CacheOnly: typings.workboxWebpackPlugin.workboxWebpackPluginStrings.CacheOnly = "CacheOnly".asInstanceOf[typings.workboxWebpackPlugin.workboxWebpackPluginStrings.CacheOnly]
    
    @scala.inline
    def NetworkFirst: typings.workboxWebpackPlugin.workboxWebpackPluginStrings.NetworkFirst = "NetworkFirst".asInstanceOf[typings.workboxWebpackPlugin.workboxWebpackPluginStrings.NetworkFirst]
    
    @scala.inline
    def NetworkOnly: typings.workboxWebpackPlugin.workboxWebpackPluginStrings.NetworkOnly = "NetworkOnly".asInstanceOf[typings.workboxWebpackPlugin.workboxWebpackPluginStrings.NetworkOnly]
    
    @scala.inline
    def StaleWhileRevalidate: typings.workboxWebpackPlugin.workboxWebpackPluginStrings.StaleWhileRevalidate = "StaleWhileRevalidate".asInstanceOf[typings.workboxWebpackPlugin.workboxWebpackPluginStrings.StaleWhileRevalidate]
  }
  
  @js.native
  trait CommonOptions extends StObject {
    
    /**
      * A list of entries to be precached, in addition to any entries that are generated as part of the build configuration.
      */
    var additionalManifestEntries: js.UndefOr[js.Array[Integrity | String]] = js.native
    
    /**
      * By default, Workbox will precache assets regardless of which chunk the asset is part of.
      *
      * If you would like to override this behavior via a whitelist, specify one or more chunk names. Only assets belonging to those chunks will be precached;
      * any assets belonging to another chunk or without a chunk association will be skipped.
      *
      * @default []
      * @example chunks: ['chunk-name-1', 'chunk-name-2']
      */
    var chunks: js.UndefOr[js.Array[String]] = js.native
    
    /**
      * Assets that match this regex will be assumed to be uniquely versioned via their URL, and exempted from the normal HTTP cache-busting that's done when populating the precache.
      *
      * While not required, it's recommended that if your existing build process already inserts a `[hash]` value into each filename, you provide a RegExp that will detect those values,
      * as it will reduce the amount of bandwidth consumed when precaching.
      *
      * @default null
      * @example dontCacheBustURLsMatching: /\.\w{8}\./
      */
    var dontCacheBustURLsMatching: js.UndefOr[RegExp | Null] = js.native
    
    /**
      * This allows you to specifically omit assets matching any of the provided criteria from being included in the precache manifest. It provides a filename-based approach to filtering.
      *
      * This filtering takes place after any chunk-based filtering is applied.
      *
      * @default [/\.map$/, /^manifest.*\.js(?:on)?$/]
      * @example exclude: [/\.jpg$/, /\.png$/]
      */
    var exclude: js.UndefOr[js.Array[String | RegExp]] = js.native
    
    /**
      * By default, Workbox will precache all assets generated by the webpack compilation, regardless of which chunk the asset is part of.
      *
      * If you would like to override this behavior via a blacklist, specify one or more chunk names. Any assets belonging to those chunks will be skipped.
      *
      * @default []
      * @example excludeChunks: ['chunk-name-1', 'chunk-name-2']
      */
    var excludeChunks: js.UndefOr[js.Array[String]] = js.native
    
    /**
      * The base directory you wish to match `globPatterns` against, relative to the current working directory.
      *
      * If you do set this, make sure to also configure `globPatterns`.
      *
      * @default undefined
      * @example globDirectory: '.'
      */
    var globDirectory: js.UndefOr[String] = js.native
    
    /**
      * Determines whether or not symlinks are followed when generating the precache manifest.
      *
      * For more information, see the definition of `follow` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
      *
      * @default true
      * @example globFollow: false
      */
    var globFollow: js.UndefOr[Boolean] = js.native
    
    /**
      * A set of patterns matching files to always exclude when generating the precache manifest.
      *
      * For more information, see the definition of `ignore` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
      *
      * @default ['node_modules/ **\/ *']
      * @example globIgnores: ['**\/ignored.html']
      */
    var globIgnores: js.UndefOr[js.Array[String]] = js.native
    
    /**
      * Files matching against any of these patterns will be included in the precache manifest.
      *
      * For more information, see the [glob primer](https://github.com/isaacs/node-glob#glob-primer).
      *
      * Note: Setting `globPatterns` is often unnecessary when using the `workbox-webpack-plugin`, which will automatically precache files that are part of the webpack build pipeline by default.
      * When using the webpack plugin, only set it when you need to cache
      * [non-webpack assets](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin#cache_additional_non-webpack_assets).
      *
      * @default []
      * @example globPatterns: ['dist/ *.{js,png,html,css}']
      */
    var globPatterns: js.UndefOr[js.Array[String]] = js.native
    
    /**
      * If `true`, an error reading a directory when generating a precache manifest will cause the build to fail. If `false`, the problematic directory will be skipped.
      *
      * For more information, see the definition of `strict` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
      *
      * @default true
      * @example globStrict: false
      */
    var globStrict: js.UndefOr[Boolean] = js.native
    
    /**
      * One or more names of webpack chunks.
      * The content of those chunks will be included in the generated service worker, via a call to importScripts()
      */
    var importScriptsViaChunks: js.UndefOr[js.Array[String]] = js.native
    
    /**
      * Workbox creates assets as part of your webpack build process: a precache manifest file, and potentially a local copy of the Workbox libraries (if `importWorkboxFrom` is set to `'local'`).
      *
      * These assets will, by default, be created at the root of your webpack build directory, i.e. `output.path`. You can set the `importsDirectory` option if you want these assets to be created in
      * a subdirectory of `output.path` instead of at the top-level.
      *
      * Note: This option does not effect where the main service worker JavaScript file is created. That is determined by the `swDest` option.
      *
      * @default ''
      * @example importsDirectory: 'wb-assets'
      */
    var importsDirectory: js.UndefOr[String] = js.native
    
    /**
      * This allows you to only include assets matching any of the provided criteria when creating the precache manifest. It provides a filename-based approach to filtering.
      *
      * This filtering takes place after any chunk-based filtering is applied.
      *
      * In keeping with [webpack convention](https://webpack.js.org/configuration/module/#condition), the option `test` can be used as an alias/alternative to `include`.
      *
      * @default []
      * @example include: [/\.html$/, /\.js$/]
      * @alias test
      */
    var include: js.UndefOr[js.Array[String | RegExp]] = js.native
    
    /**
      * One or more [`ManifestTransform`](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-build#.ManifestTransform)
      * functions, which will be applied sequentially against the generated manifest.
      *
      * If `modifyURLPrefix` or `dontCacheBustURLsMatching` are also specified, their corresponding transformations will be applied first.
      */
    var manifestTransforms: js.UndefOr[
        (js.Array[js.Function1[/* originalManifest */ js.Array[ManifestEntry], Manifest]]) | Null
      ] = js.native
    
    /**
      * This value can be used to determine the maximum size of files that will be precached. This prevents you from inadvertantly precaching very large files that might have
      * accidentally matched one of your patterns.
      *
      * @default 2097152
      * @example maximumFileSizeToCacheInBytes: 4 * 1024 * 1024
      */
    var maximumFileSizeToCacheInBytes: js.UndefOr[Double] = js.native
    
    /**
      * If set to 'production', then an optimized service worker bundle that excludes debugging info will be produced.
      * If not explicitly configured here, the mode value configured in the current webpack compilation will be used
      */
    var mode: js.UndefOr[production | String] = js.native
    
    /**
      * A mapping of prefixes that, if present in an entry in the precache manifest, will be replaced with the corresponding value.
      *
      * This can be used to, for example, remove or add a path prefix from a manifest entry if your web hosting setup doesn't match your local filesystem setup.
      *
      * As an alternative with more flexibility, you can use the `manifestTransforms` option and provide a function that modifies the entries in the manifest using whatever logic you provide.
      *
      * @default null
      * @example modifyURLPrefix: { '/dist': '' }
      */
    var modifyURLPrefix: js.UndefOr[StringDictionary[String] | Null] = js.native
    
    /**
      * Workbox automatically creates a JavaScript file that contains information about URLs that need to be precached. By default, this file is called `precache-manifest.[manifestHash].js`,
      * where `[manifestHash]` is automatically replaced by a unique value that identifies the contents of the file.
      *
      * `precacheManifestFilename` can be used to override this default filename. You must include the string `[manifestHash]` somewhere as part of the filename.
      *
      * If you'd like to change the output directory to which the precache manifest is written, you can configure the `importsDirectory` option.
      *
      * @default 'precache-manifest.[manifestHash].js'
      * @example precacheManifestFilename: 'wb-manifest.[manifestHash].js'
      */
    var precacheManifestFilename: js.UndefOr[String] = js.native
    
    /**
      * The path and filename of the service worker file that will be created by the build process, relative to the webpack output directory.
      *
      * @default 'service-worker.js'
      * @example swDest: 'custom-sw-name.js'
      */
    var swDest: js.UndefOr[String] = js.native
    
    /**
      * If a URL is rendered generated based on some server-side logic, its contents may depend on multiple files or on some other unique string value.
      *
      * If used with an array of strings, they will be interpreted as glob patterns, and the contents of any files matching the patterns will be used to uniquely version the URL.
      *
      * If used with a single string, it will be interpreted as unique versioning information that you've generated out of band for a given URL.
      *
      * @default null
      */
    var templatedUrls: js.UndefOr[(StringDictionary[String | js.Array[String]]) | Null] = js.native
    
    var test: js.UndefOr[js.Array[String | RegExp]] = js.native
  }
  object CommonOptions {
    
    @scala.inline
    def apply(): CommonOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[CommonOptions]
    }
    
    @scala.inline
    implicit class CommonOptionsMutableBuilder[Self <: CommonOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setAdditionalManifestEntries(value: js.Array[Integrity | String]): Self = StObject.set(x, "additionalManifestEntries", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAdditionalManifestEntriesUndefined: Self = StObject.set(x, "additionalManifestEntries", js.undefined)
      
      @scala.inline
      def setAdditionalManifestEntriesVarargs(value: (Integrity | String)*): Self = StObject.set(x, "additionalManifestEntries", js.Array(value :_*))
      
      @scala.inline
      def setChunks(value: js.Array[String]): Self = StObject.set(x, "chunks", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setChunksUndefined: Self = StObject.set(x, "chunks", js.undefined)
      
      @scala.inline
      def setChunksVarargs(value: String*): Self = StObject.set(x, "chunks", js.Array(value :_*))
      
      @scala.inline
      def setDontCacheBustURLsMatching(value: RegExp): Self = StObject.set(x, "dontCacheBustURLsMatching", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDontCacheBustURLsMatchingNull: Self = StObject.set(x, "dontCacheBustURLsMatching", null)
      
      @scala.inline
      def setDontCacheBustURLsMatchingUndefined: Self = StObject.set(x, "dontCacheBustURLsMatching", js.undefined)
      
      @scala.inline
      def setExclude(value: js.Array[String | RegExp]): Self = StObject.set(x, "exclude", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExcludeChunks(value: js.Array[String]): Self = StObject.set(x, "excludeChunks", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExcludeChunksUndefined: Self = StObject.set(x, "excludeChunks", js.undefined)
      
      @scala.inline
      def setExcludeChunksVarargs(value: String*): Self = StObject.set(x, "excludeChunks", js.Array(value :_*))
      
      @scala.inline
      def setExcludeUndefined: Self = StObject.set(x, "exclude", js.undefined)
      
      @scala.inline
      def setExcludeVarargs(value: (String | RegExp)*): Self = StObject.set(x, "exclude", js.Array(value :_*))
      
      @scala.inline
      def setGlobDirectory(value: String): Self = StObject.set(x, "globDirectory", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setGlobDirectoryUndefined: Self = StObject.set(x, "globDirectory", js.undefined)
      
      @scala.inline
      def setGlobFollow(value: Boolean): Self = StObject.set(x, "globFollow", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setGlobFollowUndefined: Self = StObject.set(x, "globFollow", js.undefined)
      
      @scala.inline
      def setGlobIgnores(value: js.Array[String]): Self = StObject.set(x, "globIgnores", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setGlobIgnoresUndefined: Self = StObject.set(x, "globIgnores", js.undefined)
      
      @scala.inline
      def setGlobIgnoresVarargs(value: String*): Self = StObject.set(x, "globIgnores", js.Array(value :_*))
      
      @scala.inline
      def setGlobPatterns(value: js.Array[String]): Self = StObject.set(x, "globPatterns", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setGlobPatternsUndefined: Self = StObject.set(x, "globPatterns", js.undefined)
      
      @scala.inline
      def setGlobPatternsVarargs(value: String*): Self = StObject.set(x, "globPatterns", js.Array(value :_*))
      
      @scala.inline
      def setGlobStrict(value: Boolean): Self = StObject.set(x, "globStrict", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setGlobStrictUndefined: Self = StObject.set(x, "globStrict", js.undefined)
      
      @scala.inline
      def setImportScriptsViaChunks(value: js.Array[String]): Self = StObject.set(x, "importScriptsViaChunks", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportScriptsViaChunksUndefined: Self = StObject.set(x, "importScriptsViaChunks", js.undefined)
      
      @scala.inline
      def setImportScriptsViaChunksVarargs(value: String*): Self = StObject.set(x, "importScriptsViaChunks", js.Array(value :_*))
      
      @scala.inline
      def setImportsDirectory(value: String): Self = StObject.set(x, "importsDirectory", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportsDirectoryUndefined: Self = StObject.set(x, "importsDirectory", js.undefined)
      
      @scala.inline
      def setInclude(value: js.Array[String | RegExp]): Self = StObject.set(x, "include", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIncludeUndefined: Self = StObject.set(x, "include", js.undefined)
      
      @scala.inline
      def setIncludeVarargs(value: (String | RegExp)*): Self = StObject.set(x, "include", js.Array(value :_*))
      
      @scala.inline
      def setManifestTransforms(value: js.Array[js.Function1[/* originalManifest */ js.Array[ManifestEntry], Manifest]]): Self = StObject.set(x, "manifestTransforms", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setManifestTransformsNull: Self = StObject.set(x, "manifestTransforms", null)
      
      @scala.inline
      def setManifestTransformsUndefined: Self = StObject.set(x, "manifestTransforms", js.undefined)
      
      @scala.inline
      def setManifestTransformsVarargs(value: (js.Function1[/* originalManifest */ js.Array[ManifestEntry], Manifest])*): Self = StObject.set(x, "manifestTransforms", js.Array(value :_*))
      
      @scala.inline
      def setMaximumFileSizeToCacheInBytes(value: Double): Self = StObject.set(x, "maximumFileSizeToCacheInBytes", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMaximumFileSizeToCacheInBytesUndefined: Self = StObject.set(x, "maximumFileSizeToCacheInBytes", js.undefined)
      
      @scala.inline
      def setMode(value: production | String): Self = StObject.set(x, "mode", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setModeUndefined: Self = StObject.set(x, "mode", js.undefined)
      
      @scala.inline
      def setModifyURLPrefix(value: StringDictionary[String]): Self = StObject.set(x, "modifyURLPrefix", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setModifyURLPrefixNull: Self = StObject.set(x, "modifyURLPrefix", null)
      
      @scala.inline
      def setModifyURLPrefixUndefined: Self = StObject.set(x, "modifyURLPrefix", js.undefined)
      
      @scala.inline
      def setPrecacheManifestFilename(value: String): Self = StObject.set(x, "precacheManifestFilename", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPrecacheManifestFilenameUndefined: Self = StObject.set(x, "precacheManifestFilename", js.undefined)
      
      @scala.inline
      def setSwDest(value: String): Self = StObject.set(x, "swDest", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSwDestUndefined: Self = StObject.set(x, "swDest", js.undefined)
      
      @scala.inline
      def setTemplatedUrls(value: StringDictionary[String | js.Array[String]]): Self = StObject.set(x, "templatedUrls", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTemplatedUrlsNull: Self = StObject.set(x, "templatedUrls", null)
      
      @scala.inline
      def setTemplatedUrlsUndefined: Self = StObject.set(x, "templatedUrls", js.undefined)
      
      @scala.inline
      def setTest(value: js.Array[String | RegExp]): Self = StObject.set(x, "test", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTestUndefined: Self = StObject.set(x, "test", js.undefined)
      
      @scala.inline
      def setTestVarargs(value: (String | RegExp)*): Self = StObject.set(x, "test", js.Array(value :_*))
    }
  }
  
  @js.native
  trait GenerateSWOptions extends CommonOptions {
    
    /**
      * The targets to pass to babel-preset-env when transpiling the service worker bundle
      */
    var babelPresetEnvTargets: js.UndefOr[js.Array[String]] = js.native
    
    /**
      * An optional ID to be prepended to cache names used by Workbox.
      *
      * This is primarily useful for local development where multiple sites may be served from the same `http://localhost:port` origin.
      *
      * @default null
      * @example cacheId: 'my-app'
      */
    var cacheId: js.UndefOr[String | Null] = js.native
    
    /**
      * Whether or not Workbox should attempt to identify an delete any precaches created by older, incompatible versions
      */
    var cleanupOutdatedCaches: js.UndefOr[Boolean] = js.native
    
    /**
      * Whether or not the service worker should [start controlling](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#clientsclaim)
      * any existing clients as soon as it activates.
      *
      * @default false
      * @example clientsClaim: true
      */
    var clientsClaim: js.UndefOr[Boolean] = js.native
    
    /**
      * If a [navigation request](https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests)
      * for a URL ending in `/` fails to match a precached URL, this value will be appended to the URL and that will be checked for a precache match.
      *
      * This should be configured to whatever your web server is using, if anything, for its [directory index](https://httpd.apache.org/docs/2.0/mod/mod_dir.html).
      *
      * @default 'index.html'
      * @example directoryIndex: 'index.html'
      */
    var directoryIndex: js.UndefOr[String] = js.native
    
    /**
      * Any search parameter names that match against one of the regex's in this array will be removed before looking for a precache match.
      *
      * This is useful if your users might request URLs that contain, for example, URL parameters used to track the source of the traffic.
      * Those URL parameters would normally cause the cache lookup to fail, since the URL strings used as cache keys would not be expected to include them.
      *
      * @default [/^utm_/]
      * @example ignoreURLParametersMatching: [/./]
      */
    var ignoreURLParametersMatching: js.UndefOr[js.Array[RegExp]] = js.native
    
    /**
      * An required list of JavaScript files that should be passed to
      * [`importScripts()`](https://developer.mozilla.org/en-US/docs/Web/API/WorkerGlobalScope/importScripts) inside the generated service worker file.
      *
      * If one of the imported files sets the `self.__precacheManifest` variable to an array of
      * [`ManifestEntrys`](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-build#.ManifestEntry),
      * those entries will be automatically precached in the generated service worker.
      *
      * This is also useful when you want to let Workbox create your top-level service worker file, but want to include some additional code, such as a `push` event listener.
      *
      * @default []
      * @example importScripts: ['push-notifications.abcd1234.js']
      */
    var importScripts: js.UndefOr[js.Array[String]] = js.native
    
    /**
      * Whether the runtime code for the Workbox library should be included in the top-level service worker,
      * or split into a separate file that needs to be deployed alongside the service worker. Keeping the runtime separate means
      * that users will not have to re-download the Workbox code each time your top-level service worker changes
      */
    var inlineWorkboxRuntime: js.UndefOr[Boolean] = js.native
    
    /**
      * This will be used to create a [`NavigationRoute`](https://developers.google.com/web/tools/workbox/reference-docs/latest/workbox.routing.NavigationRoute)
      * that will respond to [navigation requests](https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests)
      * for URLs that that aren't precached.
      *
      * This is meant to be used in a [Single Page App](https://en.wikipedia.org/wiki/Single-page_application) scenario, in which you want all navigations to use common App Shell HTML.
      *
      * It's not intended for use as a fallback that's displayed when the browser is offline.
      *
      * @default undefined
      * @example navigateFallback: '/app-shell'
      */
    var navigateFallback: js.UndefOr[String] = js.native
    
    /**
      * An optional array of regular expressions that restricts which URLs the configured navigateFallback behavior applies to.
      *
      * This is useful if only a subset of your site's URLs should be treated as being part of a Single Page App.
      *
      * If both navigateFallbackDenylist and navigateFallbackAllowlist are configured, the blacklist takes precedent.
      *
      * @default []
      * @example navigateFallbackAllowlist: [/^\/pages/]
      */
    var navigateFallbackAllowlist: js.UndefOr[js.Array[RegExp]] = js.native
    
    /**
      * An optional array of regular expressions that restricts which URLs the configured navigateFallback behavior applies to.
      *
      * This is useful if only a subset of your site's URLs should be treated as being part of a Single Page App.
      *
      * If both navigateFallbackDenylist and navigateFallbackAllowlist are configured, the blacklist takes precedent.
      *
      * @default []
      * @example navigateFallbackDenylist: [/^\/_/, /admin/]
      */
    var navigateFallbackDenylist: js.UndefOr[js.Array[RegExp]] = js.native
    
    /**
      * Whether or not to enable navigation preload in the generated service worker.
      * When set to true, you must also use runtimeCaching to set up an appropriate response strategy that will match navigation requests, and make use of the preloaded response
      */
    var navigationPreload: js.UndefOr[Boolean] = js.native
    
    /**
      * Controls whether or not to include support for [offline Google Analytics](https://developers.google.com/web/tools/workbox/guides/enable-offline-analytics).
      *
      * When `true`, `workbox.googleAnalytics.initialize()` will be added to your new service worker file.
      *
      * @default false
      * @example offlineGoogleAnalytics: true
      */
    var offlineGoogleAnalytics: js.UndefOr[Boolean] = js.native
    
    /**
      * Passing in an array of objects containing `urlPatterns`, `handlers`, and potentially `options` will add the appropriate code to the generated service worker to handle runtime caching.
      *
      * Requests for precached URLs that are picked up via `globPatterns` are handled by default, and don't need to be accommodated in `runtimeCaching`.
      *
      * @default []
      */
    var runtimeCaching: js.UndefOr[js.Array[RuntimeCacheRule]] = js.native
    
    /**
      * Whether or not the service worker should skip over the waiting lifecycle stage. Normally this is used with `clientsClaim: true`.
      *
      * @default false
      * @example skipWaiting: true
      */
    var skipWaiting: js.UndefOr[Boolean] = js.native
    
    /**
      * Whether to create a sourcemap for the generated service worker files
      */
    var sourcemap: js.UndefOr[Boolean] = js.native
  }
  object GenerateSWOptions {
    
    @scala.inline
    def apply(): GenerateSWOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[GenerateSWOptions]
    }
    
    @scala.inline
    implicit class GenerateSWOptionsMutableBuilder[Self <: GenerateSWOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setBabelPresetEnvTargets(value: js.Array[String]): Self = StObject.set(x, "babelPresetEnvTargets", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBabelPresetEnvTargetsUndefined: Self = StObject.set(x, "babelPresetEnvTargets", js.undefined)
      
      @scala.inline
      def setBabelPresetEnvTargetsVarargs(value: String*): Self = StObject.set(x, "babelPresetEnvTargets", js.Array(value :_*))
      
      @scala.inline
      def setCacheId(value: String): Self = StObject.set(x, "cacheId", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCacheIdNull: Self = StObject.set(x, "cacheId", null)
      
      @scala.inline
      def setCacheIdUndefined: Self = StObject.set(x, "cacheId", js.undefined)
      
      @scala.inline
      def setCleanupOutdatedCaches(value: Boolean): Self = StObject.set(x, "cleanupOutdatedCaches", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCleanupOutdatedCachesUndefined: Self = StObject.set(x, "cleanupOutdatedCaches", js.undefined)
      
      @scala.inline
      def setClientsClaim(value: Boolean): Self = StObject.set(x, "clientsClaim", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClientsClaimUndefined: Self = StObject.set(x, "clientsClaim", js.undefined)
      
      @scala.inline
      def setDirectoryIndex(value: String): Self = StObject.set(x, "directoryIndex", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDirectoryIndexUndefined: Self = StObject.set(x, "directoryIndex", js.undefined)
      
      @scala.inline
      def setIgnoreURLParametersMatching(value: js.Array[RegExp]): Self = StObject.set(x, "ignoreURLParametersMatching", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIgnoreURLParametersMatchingUndefined: Self = StObject.set(x, "ignoreURLParametersMatching", js.undefined)
      
      @scala.inline
      def setIgnoreURLParametersMatchingVarargs(value: RegExp*): Self = StObject.set(x, "ignoreURLParametersMatching", js.Array(value :_*))
      
      @scala.inline
      def setImportScripts(value: js.Array[String]): Self = StObject.set(x, "importScripts", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportScriptsUndefined: Self = StObject.set(x, "importScripts", js.undefined)
      
      @scala.inline
      def setImportScriptsVarargs(value: String*): Self = StObject.set(x, "importScripts", js.Array(value :_*))
      
      @scala.inline
      def setInlineWorkboxRuntime(value: Boolean): Self = StObject.set(x, "inlineWorkboxRuntime", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setInlineWorkboxRuntimeUndefined: Self = StObject.set(x, "inlineWorkboxRuntime", js.undefined)
      
      @scala.inline
      def setNavigateFallback(value: String): Self = StObject.set(x, "navigateFallback", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNavigateFallbackAllowlist(value: js.Array[RegExp]): Self = StObject.set(x, "navigateFallbackAllowlist", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNavigateFallbackAllowlistUndefined: Self = StObject.set(x, "navigateFallbackAllowlist", js.undefined)
      
      @scala.inline
      def setNavigateFallbackAllowlistVarargs(value: RegExp*): Self = StObject.set(x, "navigateFallbackAllowlist", js.Array(value :_*))
      
      @scala.inline
      def setNavigateFallbackDenylist(value: js.Array[RegExp]): Self = StObject.set(x, "navigateFallbackDenylist", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNavigateFallbackDenylistUndefined: Self = StObject.set(x, "navigateFallbackDenylist", js.undefined)
      
      @scala.inline
      def setNavigateFallbackDenylistVarargs(value: RegExp*): Self = StObject.set(x, "navigateFallbackDenylist", js.Array(value :_*))
      
      @scala.inline
      def setNavigateFallbackUndefined: Self = StObject.set(x, "navigateFallback", js.undefined)
      
      @scala.inline
      def setNavigationPreload(value: Boolean): Self = StObject.set(x, "navigationPreload", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNavigationPreloadUndefined: Self = StObject.set(x, "navigationPreload", js.undefined)
      
      @scala.inline
      def setOfflineGoogleAnalytics(value: Boolean): Self = StObject.set(x, "offlineGoogleAnalytics", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOfflineGoogleAnalyticsUndefined: Self = StObject.set(x, "offlineGoogleAnalytics", js.undefined)
      
      @scala.inline
      def setRuntimeCaching(value: js.Array[RuntimeCacheRule]): Self = StObject.set(x, "runtimeCaching", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRuntimeCachingUndefined: Self = StObject.set(x, "runtimeCaching", js.undefined)
      
      @scala.inline
      def setRuntimeCachingVarargs(value: RuntimeCacheRule*): Self = StObject.set(x, "runtimeCaching", js.Array(value :_*))
      
      @scala.inline
      def setSkipWaiting(value: Boolean): Self = StObject.set(x, "skipWaiting", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSkipWaitingUndefined: Self = StObject.set(x, "skipWaiting", js.undefined)
      
      @scala.inline
      def setSourcemap(value: Boolean): Self = StObject.set(x, "sourcemap", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSourcemapUndefined: Self = StObject.set(x, "sourcemap", js.undefined)
    }
  }
  
  @js.native
  trait InjectManifestOptions extends CommonOptions {
    
    /**
      * When true (the default), the swSrc file will be compiled by webpack.
      * When false, compilation will not occur (and webpackCompilationPlugins can't be used.)
      * Set to false if you want to inject the manifest into, e.g., a JSON file
      * @default true
      */
    var compileSrc: js.UndefOr[Boolean] = js.native
    
    /**
      * The path to the source service worker file that can contain your own customized code, in addition to containing a match for `injectionPointRegexp`.
      *
      * Your service worker file should reference the `self.__precacheManifest` variable to obtain a list of
      * [`ManifestEntrys`](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-build#.ManifestEntry) obtained as part of the compilation:
      * `workbox.precaching.precacheAndRoute(self.__precacheManifest)`.
      *
      * @example swSrc: path.join('src', 'sw.js')
      */
    var swSrc: String = js.native
    
    /**
      * Optional webpack plugins that will be used when compiling the swSrc input file
      */
    var webpackCompilationPlugins: js.UndefOr[js.Array[_]] = js.native
  }
  object InjectManifestOptions {
    
    @scala.inline
    def apply(swSrc: String): InjectManifestOptions = {
      val __obj = js.Dynamic.literal(swSrc = swSrc.asInstanceOf[js.Any])
      __obj.asInstanceOf[InjectManifestOptions]
    }
    
    @scala.inline
    implicit class InjectManifestOptionsMutableBuilder[Self <: InjectManifestOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setCompileSrc(value: Boolean): Self = StObject.set(x, "compileSrc", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCompileSrcUndefined: Self = StObject.set(x, "compileSrc", js.undefined)
      
      @scala.inline
      def setSwSrc(value: String): Self = StObject.set(x, "swSrc", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setWebpackCompilationPlugins(value: js.Array[_]): Self = StObject.set(x, "webpackCompilationPlugins", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setWebpackCompilationPluginsUndefined: Self = StObject.set(x, "webpackCompilationPlugins", js.undefined)
      
      @scala.inline
      def setWebpackCompilationPluginsVarargs(value: js.Any*): Self = StObject.set(x, "webpackCompilationPlugins", js.Array(value :_*))
    }
  }
  
  @js.native
  trait ManifestEntry extends StObject {
    
    var revision: String = js.native
    
    var url: String = js.native
  }
  object ManifestEntry {
    
    @scala.inline
    def apply(revision: String, url: String): ManifestEntry = {
      val __obj = js.Dynamic.literal(revision = revision.asInstanceOf[js.Any], url = url.asInstanceOf[js.Any])
      __obj.asInstanceOf[ManifestEntry]
    }
    
    @scala.inline
    implicit class ManifestEntryMutableBuilder[Self <: ManifestEntry] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setRevision(value: String): Self = StObject.set(x, "revision", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUrl(value: String): Self = StObject.set(x, "url", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait RuntimeCacheOptions extends StObject {
    
    /**
      * Configure background sync.
      */
    var backgroundSync: js.UndefOr[Name] = js.native
    
    /**
      * Configure the broadcast cache update plugin.
      */
    var broadcastUpdate: js.UndefOr[ChannelName] = js.native
    
    /**
      * A custom cache name for this route.
      */
    var cacheName: js.UndefOr[String] = js.native
    
    /**
      * Configure which responses are considered cacheable.
      */
    var cacheableResponse: js.UndefOr[Headers] = js.native
    
    /**
      * Custom cache expiration.
      */
    var expiration: js.UndefOr[MaxAgeSeconds] = js.native
    
    /**
      * Used to configure the handler.
      */
    var fetchOptions: js.UndefOr[js.Any] = js.native
    
    /**
      * Used to configure the handler.
      */
    var matchOptions: js.UndefOr[js.Any] = js.native
    
    /**
      * Fall back to the cache after X seconds.
      */
    var networkTimeoutSeconds: js.UndefOr[Double] = js.native
    
    /**
      * Add in any additional plugin logic you need.
      */
    var plugins: js.UndefOr[js.Array[_]] = js.native
  }
  object RuntimeCacheOptions {
    
    @scala.inline
    def apply(): RuntimeCacheOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[RuntimeCacheOptions]
    }
    
    @scala.inline
    implicit class RuntimeCacheOptionsMutableBuilder[Self <: RuntimeCacheOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setBackgroundSync(value: Name): Self = StObject.set(x, "backgroundSync", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBackgroundSyncUndefined: Self = StObject.set(x, "backgroundSync", js.undefined)
      
      @scala.inline
      def setBroadcastUpdate(value: ChannelName): Self = StObject.set(x, "broadcastUpdate", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBroadcastUpdateUndefined: Self = StObject.set(x, "broadcastUpdate", js.undefined)
      
      @scala.inline
      def setCacheName(value: String): Self = StObject.set(x, "cacheName", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCacheNameUndefined: Self = StObject.set(x, "cacheName", js.undefined)
      
      @scala.inline
      def setCacheableResponse(value: Headers): Self = StObject.set(x, "cacheableResponse", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCacheableResponseUndefined: Self = StObject.set(x, "cacheableResponse", js.undefined)
      
      @scala.inline
      def setExpiration(value: MaxAgeSeconds): Self = StObject.set(x, "expiration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExpirationUndefined: Self = StObject.set(x, "expiration", js.undefined)
      
      @scala.inline
      def setFetchOptions(value: js.Any): Self = StObject.set(x, "fetchOptions", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFetchOptionsUndefined: Self = StObject.set(x, "fetchOptions", js.undefined)
      
      @scala.inline
      def setMatchOptions(value: js.Any): Self = StObject.set(x, "matchOptions", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMatchOptionsUndefined: Self = StObject.set(x, "matchOptions", js.undefined)
      
      @scala.inline
      def setNetworkTimeoutSeconds(value: Double): Self = StObject.set(x, "networkTimeoutSeconds", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNetworkTimeoutSecondsUndefined: Self = StObject.set(x, "networkTimeoutSeconds", js.undefined)
      
      @scala.inline
      def setPlugins(value: js.Array[_]): Self = StObject.set(x, "plugins", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPluginsUndefined: Self = StObject.set(x, "plugins", js.undefined)
      
      @scala.inline
      def setPluginsVarargs(value: js.Any*): Self = StObject.set(x, "plugins", js.Array(value :_*))
    }
  }
  
  @js.native
  trait RuntimeCacheRule extends StObject {
    
    /**
      * The `handler` values are strings, corresponding to names of the strategies supported by
      * [`workbox.strategies`](https://developers.google.com/web/tools/workbox/reference-docs/latest/workbox.strategies#methods).
      */
    var handler: CacheStrategy = js.native
    
    /**
      * The `options` properties can be used to configure instances of the cache expiration, cacheable response, and broadcast cache update plugins to apply to a given route.
      */
    var options: js.UndefOr[RuntimeCacheOptions] = js.native
    
    /**
      * Cache any same-origin request that matches the pattern.
      */
    var urlPattern: String | RegExp = js.native
  }
  object RuntimeCacheRule {
    
    @scala.inline
    def apply(handler: CacheStrategy, urlPattern: String | RegExp): RuntimeCacheRule = {
      val __obj = js.Dynamic.literal(handler = handler.asInstanceOf[js.Any], urlPattern = urlPattern.asInstanceOf[js.Any])
      __obj.asInstanceOf[RuntimeCacheRule]
    }
    
    @scala.inline
    implicit class RuntimeCacheRuleMutableBuilder[Self <: RuntimeCacheRule] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setHandler(value: CacheStrategy): Self = StObject.set(x, "handler", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOptions(value: RuntimeCacheOptions): Self = StObject.set(x, "options", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOptionsUndefined: Self = StObject.set(x, "options", js.undefined)
      
      @scala.inline
      def setUrlPattern(value: String | RegExp): Self = StObject.set(x, "urlPattern", value.asInstanceOf[js.Any])
    }
  }
}
