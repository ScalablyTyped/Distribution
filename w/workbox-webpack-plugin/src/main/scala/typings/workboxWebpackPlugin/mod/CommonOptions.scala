package typings.workboxWebpackPlugin.mod

import org.scalablytyped.runtime.StringDictionary
import typings.std.RegExp
import typings.workboxWebpackPlugin.AnonIntegrity
import typings.workboxWebpackPlugin.AnonManifest
import typings.workboxWebpackPlugin.workboxWebpackPluginStrings.production
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait CommonOptions extends js.Object {
  /**
  	 * A list of entries to be precached, in addition to any entries that are generated as part of the build configuration.
  	 */
  var additionalManifestEntries: js.UndefOr[js.Array[AnonIntegrity | String]] = js.undefined
  /**
  	 * By default, Workbox will precache assets regardless of which chunk the asset is part of.
  	 *
  	 * If you would like to override this behavior via a whitelist, specify one or more chunk names. Only assets belonging to those chunks will be precached;
  	 * any assets belonging to another chunk or without a chunk association will be skipped.
  	 *
  	 * @default []
  	 * @example chunks: ['chunk-name-1', 'chunk-name-2']
  	 */
  var chunks: js.UndefOr[js.Array[String]] = js.undefined
  /**
  	 * Assets that match this regex will be assumed to be uniquely versioned via their URL, and exempted from the normal HTTP cache-busting that's done when populating the precache.
  	 *
  	 * While not required, it's recommended that if your existing build process already inserts a `[hash]` value into each filename, you provide a RegExp that will detect those values,
  	 * as it will reduce the amount of bandwidth consumed when precaching.
  	 *
  	 * @default null
  	 * @example dontCacheBustUrlsMatching: /\.\w{8}\./
  	 */
  var dontCacheBustUrlsMatching: js.UndefOr[RegExp | Null] = js.undefined
  /**
  	 * This allows you to specifically omit assets matching any of the provided criteria from being included in the precache manifest. It provides a filename-based approach to filtering.
  	 *
  	 * This filtering takes place after any chunk-based filtering is applied.
  	 *
  	 * @default [/\.map$/, /^manifest.*\.js(?:on)?$/]
  	 * @example exclude: [/\.jpg$/, /\.png$/]
  	 */
  var exclude: js.UndefOr[js.Array[String | RegExp]] = js.undefined
  /**
  	 * By default, Workbox will precache all assets generated by the webpack compilation, regardless of which chunk the asset is part of.
  	 *
  	 * If you would like to override this behavior via a blacklist, specify one or more chunk names. Any assets belonging to those chunks will be skipped.
  	 *
  	 * @default []
  	 * @example excludeChunks: ['chunk-name-1', 'chunk-name-2']
  	 */
  var excludeChunks: js.UndefOr[js.Array[String]] = js.undefined
  /**
  	 * The base directory you wish to match `globPatterns` against, relative to the current working directory.
  	 *
  	 * If you do set this, make sure to also configure `globPatterns`.
  	 *
  	 * @default undefined
  	 * @example globDirectory: '.'
  	 */
  var globDirectory: js.UndefOr[String] = js.undefined
  /**
  	 * Determines whether or not symlinks are followed when generating the precache manifest.
  	 *
  	 * For more information, see the definition of `follow` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
  	 *
  	 * @default true
  	 * @example globFollow: false
  	 */
  var globFollow: js.UndefOr[Boolean] = js.undefined
  /**
  	 * A set of patterns matching files to always exclude when generating the precache manifest.
  	 *
  	 * For more information, see the definition of `ignore` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
  	 *
  	 * @default ['node_modules/ **\/ *']
  	 * @example globIgnores: ['**\/ignored.html']
  	 */
  var globIgnores: js.UndefOr[js.Array[String]] = js.undefined
  /**
  	 * Files matching against any of these patterns will be included in the precache manifest.
  	 *
  	 * For more information, see the [glob primer](https://github.com/isaacs/node-glob#glob-primer).
  	 *
  	 * Note: Setting `globPatterns` is often unnecessary when using the `workbox-webpack-plugin`, which will automatically precache files that are part of the webpack build pipeline by default.
  	 * When using the webpack plugin, only set it when you need to cache
  	 * [non-webpack assets](https://developers.google.com/web/tools/workbox/modules/workbox-webpack-plugin#cache_additional_non-webpack_assets).
  	 *
  	 * @default []
  	 * @example globPatterns: ['dist/ *.{js,png,html,css}']
  	 */
  var globPatterns: js.UndefOr[js.Array[String]] = js.undefined
  /**
  	 * If `true`, an error reading a directory when generating a precache manifest will cause the build to fail. If `false`, the problematic directory will be skipped.
  	 *
  	 * For more information, see the definition of `strict` in the `glob` [documentation](https://github.com/isaacs/node-glob#options).
  	 *
  	 * @default true
  	 * @example globStrict: false
  	 */
  var globStrict: js.UndefOr[Boolean] = js.undefined
  /**
  	 * One or more names of webpack chunks.
  	 * The content of those chunks will be included in the generated service worker, via a call to importScripts()
  	 */
  var importScriptsViaChunks: js.UndefOr[js.Array[String]] = js.undefined
  /**
  	 * Workbox creates assets as part of your webpack build process: a precache manifest file, and potentially a local copy of the Workbox libraries (if `importWorkboxFrom` is set to `'local'`).
  	 *
  	 * These assets will, by default, be created at the root of your webpack build directory, i.e. `output.path`. You can set the `importsDirectory` option if you want these assets to be created in
  	 * a subdirectory of `output.path` instead of at the top-level.
  	 *
  	 * Note: This option does not effect where the main service worker JavaScript file is created. That is determined by the `swDest` option.
  	 *
  	 * @default ''
  	 * @example importsDirectory: 'wb-assets'
  	 */
  var importsDirectory: js.UndefOr[String] = js.undefined
  /**
  	 * This allows you to only include assets matching any of the provided criteria when creating the precache manifest. It provides a filename-based approach to filtering.
  	 *
  	 * This filtering takes place after any chunk-based filtering is applied.
  	 *
  	 * In keeping with [webpack convention](https://webpack.js.org/configuration/module/#condition), the option `test` can be used as an alias/alternative to `include`.
  	 *
  	 * @default []
  	 * @example include: [/\.html$/, /\.js$/]
  	 * @alias test
  	 */
  var include: js.UndefOr[js.Array[String | RegExp]] = js.undefined
  /**
  	 * One or more [`ManifestTransform`](https://developers.google.com/web/tools/workbox/reference-docs/latest/module-workbox-build#.ManifestTransform)
  	 * functions, which will be applied sequentially against the generated manifest.
  	 *
  	 * If `modifyUrlPrefix` or `dontCacheBustUrlsMatching` are also specified, their corresponding transformations will be applied first.
  	 */
  var manifestTransforms: js.UndefOr[
    (js.Array[js.Function1[/* originalManifest */ js.Array[ManifestEntry], AnonManifest]]) | Null
  ] = js.undefined
  /**
  	 * This value can be used to determine the maximum size of files that will be precached. This prevents you from inadvertantly precaching very large files that might have
  	 * accidentally matched one of your patterns.
  	 *
  	 * @default 2097152
  	 * @example maximumFileSizeToCacheInBytes: 4 * 1024 * 1024
  	 */
  var maximumFileSizeToCacheInBytes: js.UndefOr[Double] = js.undefined
  /**
  	 * If set to 'production', then an optimized service worker bundle that excludes debugging info will be produced.
  	 * If not explicitly configured here, the mode value configured in the current webpack compilation will be used
  	 */
  var mode: js.UndefOr[production | String] = js.undefined
  /**
  	 * A mapping of prefixes that, if present in an entry in the precache manifest, will be replaced with the corresponding value.
  	 *
  	 * This can be used to, for example, remove or add a path prefix from a manifest entry if your web hosting setup doesn't match your local filesystem setup.
  	 *
  	 * As an alternative with more flexibility, you can use the `manifestTransforms` option and provide a function that modifies the entries in the manifest using whatever logic you provide.
  	 *
  	 * @default null
  	 * @example modifyUrlPrefix: { '/dist': '' }
  	 */
  var modifyUrlPrefix: js.UndefOr[StringDictionary[String] | Null] = js.undefined
  /**
  	 * Workbox automatically creates a JavaScript file that contains information about URLs that need to be precached. By default, this file is called `precache-manifest.[manifestHash].js`,
  	 * where `[manifestHash]` is automatically replaced by a unique value that identifies the contents of the file.
  	 *
  	 * `precacheManifestFilename` can be used to override this default filename. You must include the string `[manifestHash]` somewhere as part of the filename.
  	 *
  	 * If you'd like to change the output directory to which the precache manifest is written, you can configure the `importsDirectory` option.
  	 *
  	 * @default 'precache-manifest.[manifestHash].js'
  	 * @example precacheManifestFilename: 'wb-manifest.[manifestHash].js'
  	 */
  var precacheManifestFilename: js.UndefOr[String] = js.undefined
  /**
  	 * The path and filename of the service worker file that will be created by the build process, relative to the webpack output directory.
  	 *
  	 * @default 'service-worker.js'
  	 * @example swDest: 'custom-sw-name.js'
  	 */
  var swDest: js.UndefOr[String] = js.undefined
  /**
  	 * If a URL is rendered generated based on some server-side logic, its contents may depend on multiple files or on some other unique string value.
  	 *
  	 * If used with an array of strings, they will be interpreted as glob patterns, and the contents of any files matching the patterns will be used to uniquely version the URL.
  	 *
  	 * If used with a single string, it will be interpreted as unique versioning information that you've generated out of band for a given URL.
  	 *
  	 * @default null
  	 */
  var templatedUrls: js.UndefOr[(StringDictionary[String | js.Array[String]]) | Null] = js.undefined
  var test: js.UndefOr[js.Array[String | RegExp]] = js.undefined
}

object CommonOptions {
  @scala.inline
  def apply(
    additionalManifestEntries: js.Array[AnonIntegrity | String] = null,
    chunks: js.Array[String] = null,
    dontCacheBustUrlsMatching: RegExp = null,
    exclude: js.Array[String | RegExp] = null,
    excludeChunks: js.Array[String] = null,
    globDirectory: String = null,
    globFollow: js.UndefOr[Boolean] = js.undefined,
    globIgnores: js.Array[String] = null,
    globPatterns: js.Array[String] = null,
    globStrict: js.UndefOr[Boolean] = js.undefined,
    importScriptsViaChunks: js.Array[String] = null,
    importsDirectory: String = null,
    include: js.Array[String | RegExp] = null,
    manifestTransforms: js.Array[js.Function1[/* originalManifest */ js.Array[ManifestEntry], AnonManifest]] = null,
    maximumFileSizeToCacheInBytes: Int | Double = null,
    mode: production | String = null,
    modifyUrlPrefix: StringDictionary[String] = null,
    precacheManifestFilename: String = null,
    swDest: String = null,
    templatedUrls: StringDictionary[String | js.Array[String]] = null,
    test: js.Array[String | RegExp] = null
  ): CommonOptions = {
    val __obj = js.Dynamic.literal()
    if (additionalManifestEntries != null) __obj.updateDynamic("additionalManifestEntries")(additionalManifestEntries.asInstanceOf[js.Any])
    if (chunks != null) __obj.updateDynamic("chunks")(chunks.asInstanceOf[js.Any])
    if (dontCacheBustUrlsMatching != null) __obj.updateDynamic("dontCacheBustUrlsMatching")(dontCacheBustUrlsMatching.asInstanceOf[js.Any])
    if (exclude != null) __obj.updateDynamic("exclude")(exclude.asInstanceOf[js.Any])
    if (excludeChunks != null) __obj.updateDynamic("excludeChunks")(excludeChunks.asInstanceOf[js.Any])
    if (globDirectory != null) __obj.updateDynamic("globDirectory")(globDirectory.asInstanceOf[js.Any])
    if (!js.isUndefined(globFollow)) __obj.updateDynamic("globFollow")(globFollow.asInstanceOf[js.Any])
    if (globIgnores != null) __obj.updateDynamic("globIgnores")(globIgnores.asInstanceOf[js.Any])
    if (globPatterns != null) __obj.updateDynamic("globPatterns")(globPatterns.asInstanceOf[js.Any])
    if (!js.isUndefined(globStrict)) __obj.updateDynamic("globStrict")(globStrict.asInstanceOf[js.Any])
    if (importScriptsViaChunks != null) __obj.updateDynamic("importScriptsViaChunks")(importScriptsViaChunks.asInstanceOf[js.Any])
    if (importsDirectory != null) __obj.updateDynamic("importsDirectory")(importsDirectory.asInstanceOf[js.Any])
    if (include != null) __obj.updateDynamic("include")(include.asInstanceOf[js.Any])
    if (manifestTransforms != null) __obj.updateDynamic("manifestTransforms")(manifestTransforms.asInstanceOf[js.Any])
    if (maximumFileSizeToCacheInBytes != null) __obj.updateDynamic("maximumFileSizeToCacheInBytes")(maximumFileSizeToCacheInBytes.asInstanceOf[js.Any])
    if (mode != null) __obj.updateDynamic("mode")(mode.asInstanceOf[js.Any])
    if (modifyUrlPrefix != null) __obj.updateDynamic("modifyUrlPrefix")(modifyUrlPrefix.asInstanceOf[js.Any])
    if (precacheManifestFilename != null) __obj.updateDynamic("precacheManifestFilename")(precacheManifestFilename.asInstanceOf[js.Any])
    if (swDest != null) __obj.updateDynamic("swDest")(swDest.asInstanceOf[js.Any])
    if (templatedUrls != null) __obj.updateDynamic("templatedUrls")(templatedUrls.asInstanceOf[js.Any])
    if (test != null) __obj.updateDynamic("test")(test.asInstanceOf[js.Any])
    __obj.asInstanceOf[CommonOptions]
  }
}

