package typings.watsonDeveloperCloud.speechToTextV1GeneratedMod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

/** Word. */
trait Word extends StObject {
  
  /** A sum of the number of times the word is found across all corpora. For example, if the word occurs five times in one corpus and seven times in another, its count is `12`. If you add a custom word to a model before it is added by any corpora, the count begins at `1`; if the word is added from a corpus first and later modified, the count reflects only the number of times it is found in corpora. */
  var count: Double
  
  /** The spelling of the word that the service uses to display the word in a transcript. The field contains an empty string if no display-as value is provided for the word, in which case the word is displayed as it is spelled. */
  var display_as: String
  
  /** If the service discovered one or more problems that you need to correct for the word's definition, an array that describes each of the errors. */
  var error: js.UndefOr[js.Array[WordError]] = js.undefined
  
  /** An array of pronunciations for the word. The array can include the sounds-like pronunciation automatically generated by the service if none is provided for the word; the service adds this pronunciation when it finishes processing the word. */
  var sounds_like: js.Array[String]
  
  /** An array of sources that describes how the word was added to the custom model's words resource. For OOV words added from a corpus, includes the name of the corpus; if the word was added by multiple corpora, the names of all corpora are listed. If the word was modified or added by the user directly, the field includes the string `user`. */
  var source: js.Array[String]
  
  /** A word from the custom model's words resource. The spelling of the word is used to train the model. */
  var word: String
}
object Word {
  
  inline def apply(
    count: Double,
    display_as: String,
    sounds_like: js.Array[String],
    source: js.Array[String],
    word: String
  ): Word = {
    val __obj = js.Dynamic.literal(count = count.asInstanceOf[js.Any], display_as = display_as.asInstanceOf[js.Any], sounds_like = sounds_like.asInstanceOf[js.Any], source = source.asInstanceOf[js.Any], word = word.asInstanceOf[js.Any])
    __obj.asInstanceOf[Word]
  }
  
  @scala.inline
  implicit open class MutableBuilder[Self <: Word] (val x: Self) extends AnyVal {
    
    inline def setCount(value: Double): Self = StObject.set(x, "count", value.asInstanceOf[js.Any])
    
    inline def setDisplay_as(value: String): Self = StObject.set(x, "display_as", value.asInstanceOf[js.Any])
    
    inline def setError(value: js.Array[WordError]): Self = StObject.set(x, "error", value.asInstanceOf[js.Any])
    
    inline def setErrorUndefined: Self = StObject.set(x, "error", js.undefined)
    
    inline def setErrorVarargs(value: WordError*): Self = StObject.set(x, "error", js.Array(value*))
    
    inline def setSounds_like(value: js.Array[String]): Self = StObject.set(x, "sounds_like", value.asInstanceOf[js.Any])
    
    inline def setSounds_likeVarargs(value: String*): Self = StObject.set(x, "sounds_like", js.Array(value*))
    
    inline def setSource(value: js.Array[String]): Self = StObject.set(x, "source", value.asInstanceOf[js.Any])
    
    inline def setSourceVarargs(value: String*): Self = StObject.set(x, "source", js.Array(value*))
    
    inline def setWord(value: String): Self = StObject.set(x, "word", value.asInstanceOf[js.Any])
  }
}
