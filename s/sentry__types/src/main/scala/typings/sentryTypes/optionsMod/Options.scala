package typings.sentryTypes.optionsMod

import org.scalablytyped.runtime.StringDictionary
import typings.sentryTypes.breadcrumbMod.Breadcrumb
import typings.sentryTypes.breadcrumbMod.BreadcrumbHint
import typings.sentryTypes.eventMod.Event
import typings.sentryTypes.eventMod.EventHint
import typings.sentryTypes.integrationMod.Integration
import typings.sentryTypes.loglevelMod.LogLevel
import typings.sentryTypes.sentryTypesBooleans.`false`
import typings.sentryTypes.transactionMod.SamplingContext
import typings.sentryTypes.transportMod.Transport
import typings.sentryTypes.transportMod.TransportClass
import typings.sentryTypes.transportMod.TransportOptions
import typings.std.RegExp
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@js.native
trait Options extends js.Object {
  
  /**
    * Options which are in beta, or otherwise not guaranteed to be stable.
    */
  var _experiments: js.UndefOr[StringDictionary[js.Any]] = js.native
  
  /** Attaches stacktraces to pure capture message / log integrations */
  var attachStacktrace: js.UndefOr[Boolean] = js.native
  
  /**
    * A callback invoked when adding a breadcrumb, allowing to optionally modify
    * it before adding it to future events.
    *
    * Note that you must return a valid breadcrumb from this callback. If you do
    * not wish to modify the breadcrumb, simply return it at the end.
    * Returning null will cause the breadcrumb to be dropped.
    *
    * @param breadcrumb The breadcrumb as created by the SDK.
    * @returns The breadcrumb that will be added | null.
    */
  var beforeBreadcrumb: js.UndefOr[
    js.Function2[
      /* breadcrumb */ Breadcrumb, 
      /* hint */ js.UndefOr[BreadcrumbHint], 
      Breadcrumb | Null
    ]
  ] = js.native
  
  /**
    * A callback invoked during event submission, allowing to optionally modify
    * the event before it is sent to Sentry.
    *
    * Note that you must return a valid event from this callback. If you do not
    * wish to modify the event, simply return it at the end.
    * Returning null will cause the event to be dropped.
    *
    * @param event The error or message event generated by the SDK.
    * @param hint May contain additional information about the original exception.
    * @returns A new event that will be sent | null.
    */
  var beforeSend: js.UndefOr[
    js.Function2[
      /* event */ Event, 
      /* hint */ js.UndefOr[EventHint], 
      (js.Thenable[Event | Null]) | Event | Null
    ]
  ] = js.native
  
  /**
    * Enable debug functionality in the SDK itself
    */
  var debug: js.UndefOr[Boolean] = js.native
  
  /**
    * If this is set to false, default integrations will not be added, otherwise this will internally be set to the
    * recommended default integrations.
    */
  var defaultIntegrations: js.UndefOr[`false` | js.Array[Integration]] = js.native
  
  /** Sets the distribution for all events */
  var dist: js.UndefOr[String] = js.native
  
  /**
    * The Dsn used to connect to Sentry and identify the project. If omitted, the
    * SDK will not send any data to Sentry.
    */
  var dsn: js.UndefOr[String] = js.native
  
  /**
    * Specifies whether this SDK should activate and send events to Sentry.
    * Disabling the SDK reduces all overhead from instrumentation, collecting
    * breadcrumbs and capturing events. Defaults to true.
    */
  var enabled: js.UndefOr[Boolean] = js.native
  
  /** The current environment of your application (e.g. "production"). */
  var environment: js.UndefOr[String] = js.native
  
  /**
    * A pattern for error messages which should not be sent to Sentry.
    * By default, all errors will be sent.
    */
  var ignoreErrors: js.UndefOr[js.Array[String | RegExp]] = js.native
  
  /**
    * List of integrations that should be installed after SDK was initialized.
    * Accepts either a list of integrations or a function that receives
    * default integrations and returns a new, updated list.
    */
  var integrations: js.UndefOr[
    js.Array[Integration] | (js.Function1[/* integrations */ js.Array[Integration], js.Array[Integration]])
  ] = js.native
  
  /** Console logging verbosity for the SDK Client. */
  var logLevel: js.UndefOr[LogLevel] = js.native
  
  /**
    * The maximum number of breadcrumbs sent with events. Defaults to 100.
    * Values over 100 will be ignored and 100 used instead.
    */
  var maxBreadcrumbs: js.UndefOr[Double] = js.native
  
  /** Maxium number of chars a single value can have before it will be truncated. */
  var maxValueLength: js.UndefOr[Double] = js.native
  
  /**
    * Maximum number of levels that normalization algorithm will traverse in objects and arrays.
    * Used when normalizing an event before sending, on all of the listed attributes:
    * - `breadcrumbs.data`
    * - `user`
    * - `contexts`
    * - `extra`
    * Defaults to `3`. Set to `0` to disable.
    */
  var normalizeDepth: js.UndefOr[Double] = js.native
  
  /**
    * The release identifier used when uploading respective source maps. Specify
    * this value to allow Sentry to resolve the correct source maps when
    * processing events.
    */
  var release: js.UndefOr[String] = js.native
  
  /** A global sample rate to apply to all events (0 - 1). */
  var sampleRate: js.UndefOr[Double] = js.native
  
  /**
    * Controls how many milliseconds to wait before shutting down. The default is
    * SDK-specific but typically around 2 seconds. Setting this too low can cause
    * problems for sending events from command line applications. Setting it too
    * high can cause the application to block for users with network connectivity
    * problems.
    */
  var shutdownTimeout: js.UndefOr[Double] = js.native
  
  /**
    * Sample rate to determine trace sampling.
    *
    * 0.0 = 0% chance of a given trace being sent (send no traces) 1.0 = 100% chance of a given trace being sent (send
    * all traces)
    *
    * Tracing is enabled if either this or `tracesSampler` is defined. If both are defined, `tracesSampleRate` is
    * ignored.
    */
  var tracesSampleRate: js.UndefOr[Double] = js.native
  
  /**
    * Function to compute tracing sample rate dynamically and filter unwanted traces.
    *
    * Tracing is enabled if either this or `tracesSampleRate` is defined. If both are defined, `tracesSampleRate` is
    * ignored.
    *
    * Will automatically be passed a context object of default and optional custom data. See
    * {@link Transaction.samplingContext} and {@link Hub.startTransaction}.
    *
    * @returns A sample rate between 0 and 1 (0 drops the trace, 1 guarantees it will be sent). Returning `true` is
    * equivalent to returning 1 and returning `false` is equivalent to returning 0.
    */
  var tracesSampler: js.UndefOr[js.Function1[/* samplingContext */ SamplingContext, Double | Boolean]] = js.native
  
  /**
    * Transport object that should be used to send events to Sentry
    */
  var transport: js.UndefOr[TransportClass[Transport]] = js.native
  
  /**
    * Options for the default transport that the SDK uses.
    */
  var transportOptions: js.UndefOr[TransportOptions] = js.native
}
object Options {
  
  @scala.inline
  def apply(): Options = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[Options]
  }
  
  @scala.inline
  implicit class OptionsOps[Self <: Options] (val x: Self) extends AnyVal {
    
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    
    @scala.inline
    def set(key: String, value: js.Any): Self = {
      x.asInstanceOf[js.Dynamic].updateDynamic(key)(value)
      x
    }
    
    @scala.inline
    def set_experiments(value: StringDictionary[js.Any]): Self = this.set("_experiments", value.asInstanceOf[js.Any])
    
    @scala.inline
    def delete_experiments: Self = this.set("_experiments", js.undefined)
    
    @scala.inline
    def setAttachStacktrace(value: Boolean): Self = this.set("attachStacktrace", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteAttachStacktrace: Self = this.set("attachStacktrace", js.undefined)
    
    @scala.inline
    def setBeforeBreadcrumb(value: (/* breadcrumb */ Breadcrumb, /* hint */ js.UndefOr[BreadcrumbHint]) => Breadcrumb | Null): Self = this.set("beforeBreadcrumb", js.Any.fromFunction2(value))
    
    @scala.inline
    def deleteBeforeBreadcrumb: Self = this.set("beforeBreadcrumb", js.undefined)
    
    @scala.inline
    def setBeforeSend(
      value: (/* event */ Event, /* hint */ js.UndefOr[EventHint]) => (js.Thenable[Event | Null]) | Event | Null
    ): Self = this.set("beforeSend", js.Any.fromFunction2(value))
    
    @scala.inline
    def deleteBeforeSend: Self = this.set("beforeSend", js.undefined)
    
    @scala.inline
    def setDebug(value: Boolean): Self = this.set("debug", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteDebug: Self = this.set("debug", js.undefined)
    
    @scala.inline
    def setDefaultIntegrationsVarargs(value: Integration*): Self = this.set("defaultIntegrations", js.Array(value :_*))
    
    @scala.inline
    def setDefaultIntegrations(value: `false` | js.Array[Integration]): Self = this.set("defaultIntegrations", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteDefaultIntegrations: Self = this.set("defaultIntegrations", js.undefined)
    
    @scala.inline
    def setDist(value: String): Self = this.set("dist", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteDist: Self = this.set("dist", js.undefined)
    
    @scala.inline
    def setDsn(value: String): Self = this.set("dsn", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteDsn: Self = this.set("dsn", js.undefined)
    
    @scala.inline
    def setEnabled(value: Boolean): Self = this.set("enabled", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteEnabled: Self = this.set("enabled", js.undefined)
    
    @scala.inline
    def setEnvironment(value: String): Self = this.set("environment", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteEnvironment: Self = this.set("environment", js.undefined)
    
    @scala.inline
    def setIgnoreErrorsVarargs(value: (String | RegExp)*): Self = this.set("ignoreErrors", js.Array(value :_*))
    
    @scala.inline
    def setIgnoreErrors(value: js.Array[String | RegExp]): Self = this.set("ignoreErrors", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteIgnoreErrors: Self = this.set("ignoreErrors", js.undefined)
    
    @scala.inline
    def setIntegrationsVarargs(value: Integration*): Self = this.set("integrations", js.Array(value :_*))
    
    @scala.inline
    def setIntegrationsFunction1(value: /* integrations */ js.Array[Integration] => js.Array[Integration]): Self = this.set("integrations", js.Any.fromFunction1(value))
    
    @scala.inline
    def setIntegrations(
      value: js.Array[Integration] | (js.Function1[/* integrations */ js.Array[Integration], js.Array[Integration]])
    ): Self = this.set("integrations", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteIntegrations: Self = this.set("integrations", js.undefined)
    
    @scala.inline
    def setLogLevel(value: LogLevel): Self = this.set("logLevel", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteLogLevel: Self = this.set("logLevel", js.undefined)
    
    @scala.inline
    def setMaxBreadcrumbs(value: Double): Self = this.set("maxBreadcrumbs", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteMaxBreadcrumbs: Self = this.set("maxBreadcrumbs", js.undefined)
    
    @scala.inline
    def setMaxValueLength(value: Double): Self = this.set("maxValueLength", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteMaxValueLength: Self = this.set("maxValueLength", js.undefined)
    
    @scala.inline
    def setNormalizeDepth(value: Double): Self = this.set("normalizeDepth", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteNormalizeDepth: Self = this.set("normalizeDepth", js.undefined)
    
    @scala.inline
    def setRelease(value: String): Self = this.set("release", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteRelease: Self = this.set("release", js.undefined)
    
    @scala.inline
    def setSampleRate(value: Double): Self = this.set("sampleRate", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteSampleRate: Self = this.set("sampleRate", js.undefined)
    
    @scala.inline
    def setShutdownTimeout(value: Double): Self = this.set("shutdownTimeout", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteShutdownTimeout: Self = this.set("shutdownTimeout", js.undefined)
    
    @scala.inline
    def setTracesSampleRate(value: Double): Self = this.set("tracesSampleRate", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteTracesSampleRate: Self = this.set("tracesSampleRate", js.undefined)
    
    @scala.inline
    def setTracesSampler(value: /* samplingContext */ SamplingContext => Double | Boolean): Self = this.set("tracesSampler", js.Any.fromFunction1(value))
    
    @scala.inline
    def deleteTracesSampler: Self = this.set("tracesSampler", js.undefined)
    
    @scala.inline
    def setTransport(value: TransportClass[Transport]): Self = this.set("transport", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteTransport: Self = this.set("transport", js.undefined)
    
    @scala.inline
    def setTransportOptions(value: TransportOptions): Self = this.set("transportOptions", value.asInstanceOf[js.Any])
    
    @scala.inline
    def deleteTransportOptions: Self = this.set("transportOptions", js.undefined)
  }
}
