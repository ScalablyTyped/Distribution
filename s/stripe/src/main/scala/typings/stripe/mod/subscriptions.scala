package typings.stripe.mod

import typings.stripe.anon.Amountgte
import typings.stripe.anon.Amountpercent
import typings.stripe.anon.Usagegte
import typings.stripe.mod.cards.ICardSourceCreationOptions
import typings.stripe.mod.coupons.IDiscount
import typings.stripe.mod.customers.ICustomer
import typings.stripe.mod.invoices.IInvoice
import typings.stripe.mod.paymentMethods.IPaymentMethod
import typings.stripe.mod.plans.IPlan
import typings.stripe.mod.subscriptionItems.ISubscriptionItem
import typings.stripe.mod.taxRates.ITaxRate
import typings.stripe.stripeStrings.all
import typings.stripe.stripeStrings.always_invoice
import typings.stripe.stripeStrings.create_prorations
import typings.stripe.stripeStrings.none
import typings.stripe.stripeStrings.now
import typings.stripe.stripeStrings.subscription
import typings.stripe.stripeStrings.unchanged
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object subscriptions {
  
  /**
    * Subscriptions allow you to charge a customer's card on a recurring basis. A subscription ties a customer to
    * a particular plan you've created: https://stripe.com/docs/api#create_plan
    */
  @js.native
  trait ISubscription extends IResourceObject {
    
    /**
      * A positive decimal that represents the fee percentage of the subscription invoice amount that will be transferred to
      * the application owner's Stripe account each billing period.
      */
    var application_fee_percent: Double | Null = js.native
    
    /**
      * Either `charge_automatically`, or `send_invoice`.
      * This field has been renamed to collection_method and will be removed in a future API version.
      */
    var billing: SubscriptionBilling = js.native
    
    /**
      * Determines the date of the first full invoice, and, for plans with month or year intervals, the day of the month
      * for subsequent invoices.
      */
    var billing_cycle_anchor: Double = js.native
    
    /**
      * Define thresholds at which an invoice will be sent, and the subscription advanced to a new billing period.
      */
    var billing_thresholds: Null | Amountgte = js.native
    
    /**
      * A date in the future at which the subscription will automatically get canceled.
      */
    var cancel_at: Double | Null = js.native
    
    /**
      * If the subscription has been canceled with the at_period_end flag set to true, cancel_at_period_end on the
      * subscription will be true. You can use this attribute to determine whether a subscription that has a status
      * of active is scheduled to be canceled at the end of the current period.
      */
    var cancel_at_period_end: Boolean = js.native
    
    /**
      * If the subscription has been canceled, the date of that cancellation. If the subscription was canceled with
      * cancel_at_period_end, canceled_at will still reflect the date of the initial cancellation request, not the end of the
      * subscription period when the subscription is automatically moved to a canceled state.
      */
    var canceled_at: Double | Null = js.native
    
    /**
      * Either "charge_automatically", or "send_invoice". When charging automatically, Stripe will attempt to pay this subscription at the
      * end of the cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an
      * invoice with payment instructions.
      */
    var collection_method: SubscriptionBilling = js.native
    
    /**
      * Time at which the object was created. Measured in seconds since the Unix epoch.
      */
    var created: Double = js.native
    
    /**
      * End of the current period that the subscription has been invoiced for. At the end of this period, a new invoice will be created.
      */
    var current_period_end: Double = js.native
    
    /**
      * Start of the current period that the subscription has been invoiced for
      */
    var current_period_start: Double = js.native
    
    /**
      * ID of the customer who owns the subscription. [Expandable]
      */
    var customer: String | ICustomer = js.native
    
    /**
      * Number of days a customer has to pay invoices generated by this subscription. This value will be null for
      * subscriptions where billing=charge_automatically.
      */
    var days_until_due: Double | Null = js.native
    
    /**
      * ID of the default payment method for the subscription. It must belong to the customer associated with the subscription.
      * If not set, invoices will use the default payment method in the customer’s invoice settings. [Expandable]
      */
    var default_payment_method: String | IPaymentMethod | Null = js.native
    
    /**
      * ID of the default payment source for the subscription.
      * It must belong to the customer associated with the subscription and be in a chargeable state.
      * If not set, defaults to the customer’s default source. [Expandable]
      */
    var default_source: String | Null = js.native
    
    /**
      * The tax rates that will apply to any subscription item that does not have tax_rates set.
      * Invoices created will have their default_tax_rates populated from the subscription.
      */
    var default_tax_rates: js.Array[ITaxRate] = js.native
    
    /**
      * Describes the current discount applied to this subscription, if there is one. When billing, a discount applied to a
      * subscription overrides a discount applied on a customer-wide basis.
      */
    var discount: IDiscount | Null = js.native
    
    /**
      * If the subscription has ended (either because it was canceled or because the customer was switched to a subscription
      * to a new plan), the date the subscription ended
      */
    var ended_at: Double | Null = js.native
    
    /**
      * List of subscription items, each with an attached plan.
      */
    var items: IList[ISubscriptionItem] = js.native
    
    /**
      * The most recent invoice this subscription has generated. [Expandable]
      */
    var latest_invoice: IInvoice | String | Null = js.native
    
    /**
      * Has the value true if the object exists in live mode or the value false if the object exists in test mode.
      */
    var livemode: Boolean = js.native
    
    /**
      * Set of key-value pairs that you can attach to an object. This can be useful for storing additional information
      * about the object in a structured format.
      */
    var metadata: IMetadata = js.native
    
    /**
      * Value is "subscription"
      */
    @JSName("object")
    var object_ISubscription: subscription = js.native
    
    /**
      * Hash describing the plan the customer is subscribed to.  Only set if the subscription
      * contains a single plan.
      */
    var plan: js.UndefOr[IPlan | Null] = js.native
    
    /**
      * The quantity of the plan to which the customer is subscribed. For example, if your plan is $10/user/month,
      * and your customer has 5 users, you could pass 5 as the quantity to have the customer charged $50 (5 x $10) monthly.
      * Only set if the subscription contains a single plan.
      */
    var quantity: js.UndefOr[Double] = js.native
    
    /**
      * Date of the last substantial change to this subscription. For example, a change to the items array,
      * or a change of status, will reset this timestamp.
      */
    var start: Double = js.native
    
    /**
      * Date when the subscription was first created. The date might differ from the created date due to backdating.
      */
    var start_date: Double = js.native
    
    /**
      * Possible values are `incomplete`, `incomplete_expired`, `trialing`, `active`,
      * `past_due`, `canceled`, or `unpaid`.
      *
      * For `billing=charge_automatically` a subscription moves into `incomplete` if the
      * initial payment attempt fails. A subscription in this state can only have metadata
      * and default_source updated. Once the first invoice is paid, the subscription moves
      * into an `active` state. If the first invoice is not paid within 23 hours, the
      * subscription transitions to `incomplete_expired`. This is a terminal state, the open
      * invoice will be voided and no further invoices will be generated.
      *
      * A subscription that is currently in a trial period is `trialing` and moves to
      * `active` when the trial period is over.
      *
      * If subscription `billing=charge_automatically` it becomes `past_due` when payment to
      * renew it fails and `canceled` or `unpaid` (depending on your subscriptions settings)
      * when Stripe has exhausted all payment retry attempts.
      *
      * If subscription `billing=send_invoice` it becomes `past_due` when its invoice is not
      * paid by the due date, and `canceled` or `unpaid` if it is still not paid by an
      * additional deadline after that. Note that when a subscription has a status of
      * `unpaid`, no subsequent invoices will be attempted (invoices will be created, but
      * then immediately automatically closed). After receiving updated payment information
      * from a customer, you may choose to reopen and pay their closed invoices.
      */
    var status: SubscriptionStatus = js.native
    
    /**
      * If provided, each invoice created by this subscription will apply the tax rate, increasing the amount billed to the customer.
      */
    var tax_percent: Double | Null = js.native
    
    /**
      * If the subscription has a trial, the end of that trial.
      */
    var trial_end: Double | Null = js.native
    
    /**
      * If the subscription has a trial, the beginning of that trial.
      */
    var trial_start: Double | Null = js.native
  }
  object ISubscription {
    
    @scala.inline
    def apply(
      billing: SubscriptionBilling,
      billing_cycle_anchor: Double,
      cancel_at_period_end: Boolean,
      collection_method: SubscriptionBilling,
      created: Double,
      current_period_end: Double,
      current_period_start: Double,
      customer: String | ICustomer,
      default_tax_rates: js.Array[ITaxRate],
      id: String,
      items: IList[ISubscriptionItem],
      livemode: Boolean,
      metadata: IMetadata,
      `object`: subscription,
      start: Double,
      start_date: Double,
      status: SubscriptionStatus
    ): ISubscription = {
      val __obj = js.Dynamic.literal(billing = billing.asInstanceOf[js.Any], billing_cycle_anchor = billing_cycle_anchor.asInstanceOf[js.Any], cancel_at_period_end = cancel_at_period_end.asInstanceOf[js.Any], collection_method = collection_method.asInstanceOf[js.Any], created = created.asInstanceOf[js.Any], current_period_end = current_period_end.asInstanceOf[js.Any], current_period_start = current_period_start.asInstanceOf[js.Any], customer = customer.asInstanceOf[js.Any], default_tax_rates = default_tax_rates.asInstanceOf[js.Any], id = id.asInstanceOf[js.Any], items = items.asInstanceOf[js.Any], livemode = livemode.asInstanceOf[js.Any], metadata = metadata.asInstanceOf[js.Any], start = start.asInstanceOf[js.Any], start_date = start_date.asInstanceOf[js.Any], status = status.asInstanceOf[js.Any])
      __obj.updateDynamic("object")(`object`.asInstanceOf[js.Any])
      __obj.asInstanceOf[ISubscription]
    }
    
    @scala.inline
    implicit class ISubscriptionMutableBuilder[Self <: ISubscription] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setApplication_fee_percent(value: Double): Self = StObject.set(x, "application_fee_percent", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setApplication_fee_percentNull: Self = StObject.set(x, "application_fee_percent", null)
      
      @scala.inline
      def setBilling(value: SubscriptionBilling): Self = StObject.set(x, "billing", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBilling_cycle_anchor(value: Double): Self = StObject.set(x, "billing_cycle_anchor", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBilling_thresholds(value: Amountgte): Self = StObject.set(x, "billing_thresholds", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBilling_thresholdsNull: Self = StObject.set(x, "billing_thresholds", null)
      
      @scala.inline
      def setCancel_at(value: Double): Self = StObject.set(x, "cancel_at", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCancel_atNull: Self = StObject.set(x, "cancel_at", null)
      
      @scala.inline
      def setCancel_at_period_end(value: Boolean): Self = StObject.set(x, "cancel_at_period_end", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCanceled_at(value: Double): Self = StObject.set(x, "canceled_at", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCanceled_atNull: Self = StObject.set(x, "canceled_at", null)
      
      @scala.inline
      def setCollection_method(value: SubscriptionBilling): Self = StObject.set(x, "collection_method", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCreated(value: Double): Self = StObject.set(x, "created", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCurrent_period_end(value: Double): Self = StObject.set(x, "current_period_end", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCurrent_period_start(value: Double): Self = StObject.set(x, "current_period_start", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCustomer(value: String | ICustomer): Self = StObject.set(x, "customer", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDays_until_due(value: Double): Self = StObject.set(x, "days_until_due", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDays_until_dueNull: Self = StObject.set(x, "days_until_due", null)
      
      @scala.inline
      def setDefault_payment_method(value: String | IPaymentMethod): Self = StObject.set(x, "default_payment_method", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDefault_payment_methodNull: Self = StObject.set(x, "default_payment_method", null)
      
      @scala.inline
      def setDefault_source(value: String): Self = StObject.set(x, "default_source", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDefault_sourceNull: Self = StObject.set(x, "default_source", null)
      
      @scala.inline
      def setDefault_tax_rates(value: js.Array[ITaxRate]): Self = StObject.set(x, "default_tax_rates", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDefault_tax_ratesVarargs(value: ITaxRate*): Self = StObject.set(x, "default_tax_rates", js.Array(value :_*))
      
      @scala.inline
      def setDiscount(value: IDiscount): Self = StObject.set(x, "discount", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDiscountNull: Self = StObject.set(x, "discount", null)
      
      @scala.inline
      def setEnded_at(value: Double): Self = StObject.set(x, "ended_at", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnded_atNull: Self = StObject.set(x, "ended_at", null)
      
      @scala.inline
      def setItems(value: IList[ISubscriptionItem]): Self = StObject.set(x, "items", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLatest_invoice(value: IInvoice | String): Self = StObject.set(x, "latest_invoice", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLatest_invoiceNull: Self = StObject.set(x, "latest_invoice", null)
      
      @scala.inline
      def setLivemode(value: Boolean): Self = StObject.set(x, "livemode", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMetadata(value: IMetadata): Self = StObject.set(x, "metadata", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObject(value: subscription): Self = StObject.set(x, "object", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPlan(value: IPlan): Self = StObject.set(x, "plan", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPlanNull: Self = StObject.set(x, "plan", null)
      
      @scala.inline
      def setPlanUndefined: Self = StObject.set(x, "plan", js.undefined)
      
      @scala.inline
      def setQuantity(value: Double): Self = StObject.set(x, "quantity", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setQuantityUndefined: Self = StObject.set(x, "quantity", js.undefined)
      
      @scala.inline
      def setStart(value: Double): Self = StObject.set(x, "start", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStart_date(value: Double): Self = StObject.set(x, "start_date", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStatus(value: SubscriptionStatus): Self = StObject.set(x, "status", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTax_percent(value: Double): Self = StObject.set(x, "tax_percent", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTax_percentNull: Self = StObject.set(x, "tax_percent", null)
      
      @scala.inline
      def setTrial_end(value: Double): Self = StObject.set(x, "trial_end", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTrial_endNull: Self = StObject.set(x, "trial_end", null)
      
      @scala.inline
      def setTrial_start(value: Double): Self = StObject.set(x, "trial_start", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTrial_startNull: Self = StObject.set(x, "trial_start", null)
    }
  }
  
  @js.native
  trait ISubscriptionCancellationOptions extends IDataOptions {
    
    /**
      * @deprecated Use subscription update with cancel_at_period_end option as of 2018-08-23.
      *
      * A flag that if set to true will delay the cancellation of the subscription until the end of the current period.
      */
    var at_period_end: js.UndefOr[Boolean] = js.native
    
    /**
      * Will generate a final invoice that invoices for any un-invoiced metered usage and new/pending proration invoice items.
      */
    var invoice_now: js.UndefOr[Boolean] = js.native
    
    /**
      * Will generate a proration invoice item that credits remaining unused time until the subscription period end.
      */
    var prorate: js.UndefOr[Boolean] = js.native
  }
  object ISubscriptionCancellationOptions {
    
    @scala.inline
    def apply(): ISubscriptionCancellationOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[ISubscriptionCancellationOptions]
    }
    
    @scala.inline
    implicit class ISubscriptionCancellationOptionsMutableBuilder[Self <: ISubscriptionCancellationOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setAt_period_end(value: Boolean): Self = StObject.set(x, "at_period_end", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAt_period_endUndefined: Self = StObject.set(x, "at_period_end", js.undefined)
      
      @scala.inline
      def setInvoice_now(value: Boolean): Self = StObject.set(x, "invoice_now", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setInvoice_nowUndefined: Self = StObject.set(x, "invoice_now", js.undefined)
      
      @scala.inline
      def setProrate(value: Boolean): Self = StObject.set(x, "prorate", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setProrateUndefined: Self = StObject.set(x, "prorate", js.undefined)
    }
  }
  
  @js.native
  trait ISubscriptionCreationItem extends StObject {
    
    /**
      * Define thresholds at which an invoice will be sent, and the related subscription advanced to a new billing period.
      */
    var billing_thresholds: js.UndefOr[Usagegte] = js.native
    
    /**
      * A set of key/value pairs that you can attach to an object. It can be useful for storing
      * additional information about the object in a structured format.
      */
    var metadata: js.UndefOr[IOptionsMetadata] = js.native
    
    /**
      * Plan ID for this item.
      */
    var plan: String = js.native
    
    /**
      * Quantity for this item.
      */
    var quantity: js.UndefOr[Double] = js.native
  }
  object ISubscriptionCreationItem {
    
    @scala.inline
    def apply(plan: String): ISubscriptionCreationItem = {
      val __obj = js.Dynamic.literal(plan = plan.asInstanceOf[js.Any])
      __obj.asInstanceOf[ISubscriptionCreationItem]
    }
    
    @scala.inline
    implicit class ISubscriptionCreationItemMutableBuilder[Self <: ISubscriptionCreationItem] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setBilling_thresholds(value: Usagegte): Self = StObject.set(x, "billing_thresholds", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBilling_thresholdsUndefined: Self = StObject.set(x, "billing_thresholds", js.undefined)
      
      @scala.inline
      def setMetadata(value: IOptionsMetadata): Self = StObject.set(x, "metadata", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMetadataUndefined: Self = StObject.set(x, "metadata", js.undefined)
      
      @scala.inline
      def setPlan(value: String): Self = StObject.set(x, "plan", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setQuantity(value: Double): Self = StObject.set(x, "quantity", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setQuantityUndefined: Self = StObject.set(x, "quantity", js.undefined)
    }
  }
  
  @js.native
  trait ISubscriptionCreationOptions extends ISubscriptionCustCreationOptions {
    
    /**
      * A timestamp at which the subscription should cancel. If set to a date before the current period ends
      * this will cause a proration if prorate=true.
      */
    var cancel_at: js.UndefOr[Double | Null] = js.native
    
    /**
      * Boolean indicating whether this subscription should cancel at the end of the current period.
      */
    var cancel_at_period_end: js.UndefOr[Boolean] = js.native
    
    /***
      * The identifier of the customer to subscribe.
      */
    var customer: String = js.native
  }
  object ISubscriptionCreationOptions {
    
    @scala.inline
    def apply(customer: String): ISubscriptionCreationOptions = {
      val __obj = js.Dynamic.literal(customer = customer.asInstanceOf[js.Any])
      __obj.asInstanceOf[ISubscriptionCreationOptions]
    }
    
    @scala.inline
    implicit class ISubscriptionCreationOptionsMutableBuilder[Self <: ISubscriptionCreationOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setCancel_at(value: Double): Self = StObject.set(x, "cancel_at", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCancel_atNull: Self = StObject.set(x, "cancel_at", null)
      
      @scala.inline
      def setCancel_atUndefined: Self = StObject.set(x, "cancel_at", js.undefined)
      
      @scala.inline
      def setCancel_at_period_end(value: Boolean): Self = StObject.set(x, "cancel_at_period_end", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCancel_at_period_endUndefined: Self = StObject.set(x, "cancel_at_period_end", js.undefined)
      
      @scala.inline
      def setCustomer(value: String): Self = StObject.set(x, "customer", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait ISubscriptionCustCreationOptions extends IDataOptionsWithMetadata {
    
    /**
      * A positive decimal (with at most two decimal places) between 1 and 100. This represents the percentage of the subscription invoice
      * subtotal that will be transferred to the application owner’s Stripe account. The request must be made with an OAuth key in order
      * to set an application fee percentage. For more information, see the application fees documentation.
      */
    var application_fee_percent: js.UndefOr[Double] = js.native
    
    /**
      * Either "charge_automatically", or "send_invoice". When charging automatically, Stripe will attempt to pay this subscription at the end of the
      * cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment
      * instructions. Defaults to "charge_automatically".
      */
    var billing: js.UndefOr[SubscriptionBilling] = js.native
    
    /**
      * A future timestamp to anchor the subscription’s billing cycle. This is used to determine the date of the first full invoice, and, for plans
      * with month or year intervals, the day of the month for subsequent invoices.
      */
    var billing_cycle_anchor: js.UndefOr[Double] = js.native
    
    /**
      * The code of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that
      * particular subscription.
      */
    var coupon: js.UndefOr[String] = js.native
    
    /**
      * Number of days a customer has to pay invoices generated by this subscription.
      * Only valid for subscriptions where billing=send_invoice.
      */
    var days_until_due: js.UndefOr[Double] = js.native
    
    /**
      * ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. If not set, invoices will use the default payment method in the customer’s invoice settings.
      */
    var default_payment_method: js.UndefOr[String] = js.native
    
    var default_source: js.UndefOr[String | ICardSourceCreationOptions] = js.native
    
    /**
      * The tax rates that will apply to the subscription.
      */
    var default_tax_rates: js.UndefOr[js.Array[String]] = js.native
    
    /**
      * List of subscription items, each with an attached plan.
      */
    var items: js.UndefOr[js.Array[ISubscriptionCreationItem]] = js.native
    
    /**
      * Indicates if a customer is on or off-session while an invoice payment is attempted.
      */
    var off_session: js.UndefOr[Boolean] = js.native
    
    /**
      * Boolean (default true). Used to prevent Stripe Invoicing from automatically paying the subscription on creation. This can be set
      * to false when used with services like Avalara that need to augment an invoice before the subscription is paid.
      *
      * Using this flag requires contacting Stripe support in order to have the account whitelisted.
      */
    var pay_immediately: js.UndefOr[Boolean] = js.native
    
    /**
      * @deprecated Use items property instead.
      */
    var plan: js.UndefOr[String] = js.native
    
    /**
      * Boolean (default true). Use with a billing_cycle_anchor timestamp to determine whether the customer will be invoiced a prorated amount until
      * the anchor date. If false, the anchor period will be free (similar to a trial).
      */
    var prorate: js.UndefOr[Boolean] = js.native
    
    /**
      * The quantity you'd like to apply to the subscription you're creating. For example, if your plan is £10/user/month, and your customer
      * has 5 users, you could pass 5 as the quantity to have the customer charged £50 (5 x £10) monthly. If you update a subscription but
      * don't change the plan ID (e.g. changing only the trial_end), the subscription will inherit the old subscription's quantity attribute
      * unless you pass a new quantity parameter. If you update a subscription and change the plan ID, the new subscription will not inherit
      * the quantity attribute and will default to 1 unless you pass a quantity parameter.
      */
    var quantity: js.UndefOr[Double] = js.native
    
    /**
      * A positive decimal (with at most two decimal places) between 1 and 100. This represents the percentage of the subscription invoice
      * subtotal that will be calculated and added as tax to the final amount each billing period. For example, a plan which charges $10/month
      * with a tax_percent of 20.0 will charge $12 per invoice.
      */
    var tax_percent: js.UndefOr[Double] = js.native
    
    /**
      * If specified, the funds from the subscription’s invoices will be transferred to the destination and the ID of the resulting transfers will be found on the resulting charges.
      */
    var transfer_data: js.UndefOr[Amountpercent] = js.native
    
    /**
      * Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. If set, trial_end
      * will override the default trial period of the plan the customer is being subscribed to. The special value now can be provided to end the
      * customer's trial immediately.
      */
    var trial_end: js.UndefOr[Double | now] = js.native
    
    /**
      * Indicates if a plan’s trial_period_days should be applied to the subscription. Setting trial_end per subscription is preferred,
      * and this defaults to false. Setting this flag to true together with trial_end is not allowed.
      */
    var trial_from_plan: js.UndefOr[Boolean] = js.native
    
    /**
      * Integer representing the number of trial period days before the customer is charged for the first time.
      */
    var trial_period_days: js.UndefOr[Double] = js.native
  }
  object ISubscriptionCustCreationOptions {
    
    @scala.inline
    def apply(): ISubscriptionCustCreationOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[ISubscriptionCustCreationOptions]
    }
    
    @scala.inline
    implicit class ISubscriptionCustCreationOptionsMutableBuilder[Self <: ISubscriptionCustCreationOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setApplication_fee_percent(value: Double): Self = StObject.set(x, "application_fee_percent", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setApplication_fee_percentUndefined: Self = StObject.set(x, "application_fee_percent", js.undefined)
      
      @scala.inline
      def setBilling(value: SubscriptionBilling): Self = StObject.set(x, "billing", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBillingUndefined: Self = StObject.set(x, "billing", js.undefined)
      
      @scala.inline
      def setBilling_cycle_anchor(value: Double): Self = StObject.set(x, "billing_cycle_anchor", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBilling_cycle_anchorUndefined: Self = StObject.set(x, "billing_cycle_anchor", js.undefined)
      
      @scala.inline
      def setCoupon(value: String): Self = StObject.set(x, "coupon", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCouponUndefined: Self = StObject.set(x, "coupon", js.undefined)
      
      @scala.inline
      def setDays_until_due(value: Double): Self = StObject.set(x, "days_until_due", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDays_until_dueUndefined: Self = StObject.set(x, "days_until_due", js.undefined)
      
      @scala.inline
      def setDefault_payment_method(value: String): Self = StObject.set(x, "default_payment_method", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDefault_payment_methodUndefined: Self = StObject.set(x, "default_payment_method", js.undefined)
      
      @scala.inline
      def setDefault_source(value: String | ICardSourceCreationOptions): Self = StObject.set(x, "default_source", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDefault_sourceUndefined: Self = StObject.set(x, "default_source", js.undefined)
      
      @scala.inline
      def setDefault_tax_rates(value: js.Array[String]): Self = StObject.set(x, "default_tax_rates", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDefault_tax_ratesUndefined: Self = StObject.set(x, "default_tax_rates", js.undefined)
      
      @scala.inline
      def setDefault_tax_ratesVarargs(value: String*): Self = StObject.set(x, "default_tax_rates", js.Array(value :_*))
      
      @scala.inline
      def setItems(value: js.Array[ISubscriptionCreationItem]): Self = StObject.set(x, "items", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setItemsUndefined: Self = StObject.set(x, "items", js.undefined)
      
      @scala.inline
      def setItemsVarargs(value: ISubscriptionCreationItem*): Self = StObject.set(x, "items", js.Array(value :_*))
      
      @scala.inline
      def setOff_session(value: Boolean): Self = StObject.set(x, "off_session", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOff_sessionUndefined: Self = StObject.set(x, "off_session", js.undefined)
      
      @scala.inline
      def setPay_immediately(value: Boolean): Self = StObject.set(x, "pay_immediately", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPay_immediatelyUndefined: Self = StObject.set(x, "pay_immediately", js.undefined)
      
      @scala.inline
      def setPlan(value: String): Self = StObject.set(x, "plan", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPlanUndefined: Self = StObject.set(x, "plan", js.undefined)
      
      @scala.inline
      def setProrate(value: Boolean): Self = StObject.set(x, "prorate", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setProrateUndefined: Self = StObject.set(x, "prorate", js.undefined)
      
      @scala.inline
      def setQuantity(value: Double): Self = StObject.set(x, "quantity", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setQuantityUndefined: Self = StObject.set(x, "quantity", js.undefined)
      
      @scala.inline
      def setTax_percent(value: Double): Self = StObject.set(x, "tax_percent", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTax_percentUndefined: Self = StObject.set(x, "tax_percent", js.undefined)
      
      @scala.inline
      def setTransfer_data(value: Amountpercent): Self = StObject.set(x, "transfer_data", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTransfer_dataUndefined: Self = StObject.set(x, "transfer_data", js.undefined)
      
      @scala.inline
      def setTrial_end(value: Double | now): Self = StObject.set(x, "trial_end", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTrial_endUndefined: Self = StObject.set(x, "trial_end", js.undefined)
      
      @scala.inline
      def setTrial_from_plan(value: Boolean): Self = StObject.set(x, "trial_from_plan", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTrial_from_planUndefined: Self = StObject.set(x, "trial_from_plan", js.undefined)
      
      @scala.inline
      def setTrial_period_days(value: Double): Self = StObject.set(x, "trial_period_days", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTrial_period_daysUndefined: Self = StObject.set(x, "trial_period_days", js.undefined)
    }
  }
  
  @js.native
  trait ISubscriptionListOptions extends IListOptionsCreated {
    
    /**
      * The billing mode of the subscriptions to retrieve. Either "charge_automatically" or "send_invoice".
      */
    var billing: js.UndefOr[SubscriptionBilling] = js.native
    
    /**
      * The ID of the customer whose subscriptions will be retrieved
      */
    var customer: js.UndefOr[String] = js.native
    
    /**
      * The ID of the plan whose subscriptions will be retrieved
      */
    var plan: js.UndefOr[String] = js.native
    
    /**
      * The status of the subscriptions to retrieve.
      */
    var status: js.UndefOr[SubscriptionStatus | all] = js.native
  }
  object ISubscriptionListOptions {
    
    @scala.inline
    def apply(): ISubscriptionListOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[ISubscriptionListOptions]
    }
    
    @scala.inline
    implicit class ISubscriptionListOptionsMutableBuilder[Self <: ISubscriptionListOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setBilling(value: SubscriptionBilling): Self = StObject.set(x, "billing", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBillingUndefined: Self = StObject.set(x, "billing", js.undefined)
      
      @scala.inline
      def setCustomer(value: String): Self = StObject.set(x, "customer", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCustomerUndefined: Self = StObject.set(x, "customer", js.undefined)
      
      @scala.inline
      def setPlan(value: String): Self = StObject.set(x, "plan", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPlanUndefined: Self = StObject.set(x, "plan", js.undefined)
      
      @scala.inline
      def setStatus(value: SubscriptionStatus | all): Self = StObject.set(x, "status", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStatusUndefined: Self = StObject.set(x, "status", js.undefined)
    }
  }
  
  @js.native
  trait ISubscriptionUpdateItem extends StObject {
    
    /**
      * Delete all usage for a given subscription item. Only allowed when deleted is set to true and the current plan’s
      * usage_type is metered.
      */
    var clear_usage: js.UndefOr[Boolean] = js.native
    
    /**
      * Delete the specified item if set to true.
      */
    var deleted: js.UndefOr[Boolean] = js.native
    
    /**
      * SubscriptionItem to update.
      */
    var id: js.UndefOr[String] = js.native
    
    /**
      * Set of key/value pairs that you can attach to an object. It can be useful for storing additional information about
      * the object in a structured format.
      */
    var metadata: js.UndefOr[IOptionsMetadata] = js.native
    
    /**
      * Plan ID for this item.
      */
    var plan: js.UndefOr[String] = js.native
    
    /**
      * Quantity for this item.
      */
    var quantity: js.UndefOr[Double] = js.native
  }
  object ISubscriptionUpdateItem {
    
    @scala.inline
    def apply(): ISubscriptionUpdateItem = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[ISubscriptionUpdateItem]
    }
    
    @scala.inline
    implicit class ISubscriptionUpdateItemMutableBuilder[Self <: ISubscriptionUpdateItem] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setClear_usage(value: Boolean): Self = StObject.set(x, "clear_usage", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClear_usageUndefined: Self = StObject.set(x, "clear_usage", js.undefined)
      
      @scala.inline
      def setDeleted(value: Boolean): Self = StObject.set(x, "deleted", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeletedUndefined: Self = StObject.set(x, "deleted", js.undefined)
      
      @scala.inline
      def setId(value: String): Self = StObject.set(x, "id", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIdUndefined: Self = StObject.set(x, "id", js.undefined)
      
      @scala.inline
      def setMetadata(value: IOptionsMetadata): Self = StObject.set(x, "metadata", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMetadataUndefined: Self = StObject.set(x, "metadata", js.undefined)
      
      @scala.inline
      def setPlan(value: String): Self = StObject.set(x, "plan", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPlanUndefined: Self = StObject.set(x, "plan", js.undefined)
      
      @scala.inline
      def setQuantity(value: Double): Self = StObject.set(x, "quantity", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setQuantityUndefined: Self = StObject.set(x, "quantity", js.undefined)
    }
  }
  
  @js.native
  trait ISubscriptionUpdateOptions extends IDataOptionsWithMetadata {
    
    /**
      * A positive decimal (with at most two decimal places) between 1 and 100. This represents the percentage of the subscription invoice
      * subtotal that will be transferred to the application owner’s Stripe account. The request must be made with an OAuth key in order
      * to set an application fee percentage. For more information, see the application fees documentation.
      */
    var application_fee_percent: js.UndefOr[Double] = js.native
    
    /**
      * Either "charge_automatically", or "send_invoice". When charging automatically, Stripe will attempt to pay this subscription at the end of the
      * cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment
      * instructions.
      */
    var billing: js.UndefOr[SubscriptionBilling] = js.native
    
    /**
      * String, unchanged (default) or now. This allows you to reset the billing cycle of a subscription.
      */
    var billing_cycle_anchor: js.UndefOr[unchanged | now] = js.native
    
    /**
      * Boolean indicating whether this subscription should cancel at the end of the current period.
      */
    var cancel_at_period_end: js.UndefOr[Boolean] = js.native
    
    /**
      * The code of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that
      * particular subscription.  Passing null will remove any coupon previously applied to a subscription.
      */
    var coupon: js.UndefOr[String | Null] = js.native
    
    /**
      * Number of days a customer has to pay invoices generated by this subscription. Only valid for subscriptions where billing=send_invoice.
      */
    var days_until_due: js.UndefOr[Double] = js.native
    
    /**
      * ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. If not set, invoices will use the default payment method in the customer’s invoice settings.
      */
    var default_payment_method: js.UndefOr[String] = js.native
    
    var default_source: js.UndefOr[String | ICardSourceCreationOptions] = js.native
    
    /**
      * List of subscription items, each with an attached plan.
      */
    var items: js.UndefOr[js.Array[ISubscriptionUpdateItem]] = js.native
    
    /**
      * Indicates if a customer is on or off-session while an invoice payment is attempted.
      */
    var off_session: js.UndefOr[Boolean] = js.native
    
    /**
      * Boolean (default true). Used to prevent Stripe Invoicing from automatically paying the subscription when the term changes.
      * This can be set to false when used with services like Avalara that need to augment an invoice before the subscription is paid.
      *
      * Using this flag requires contacting Stripe support in order to have the account whitelisted.
      */
    var pay_immediately: js.UndefOr[Boolean] = js.native
    
    /**
      * @deprecated Use items property instead.
      */
    var plan: js.UndefOr[String] = js.native
    
    /**
      * Flag telling us whether to prorate switching plans during a billing cycle.
      */
    var prorate: js.UndefOr[Boolean] = js.native
    
    /**
      * Determines how to handle prorations when the billing cycle changes or if an item’s quantity changes.
      * Prorations can be disabled by passing none.
      */
    var proration_behavior: js.UndefOr[create_prorations | always_invoice | none] = js.native
    
    /**
      * If set, the proration will be calculated as though the subscription was updated at the given time. This can be used to apply exactly the
      * same proration that was previewed with upcoming invoice endpoint. It can also be used to implement custom proration logic, such as
      * prorating by day instead of by second, by providing the time that you wish to use for proration calculations.
      */
    var proration_date: js.UndefOr[Double] = js.native
    
    /**
      * The quantity you'd like to apply to the subscription you're creating. For example, if your plan is £10/user/month, and your customer
      * has 5 users, you could pass 5 as the quantity to have the customer charged £50 (5 x £10) monthly. If you update a subscription but
      * don't change the plan ID (e.g. changing only the trial_end), the subscription will inherit the old subscription's quantity attribute
      * unless you pass a new quantity parameter. If you update a subscription and change the plan ID, the new subscription will not inherit
      * the quantity attribute and will default to 1 unless you pass a quantity parameter.
      */
    var quantity: js.UndefOr[Double] = js.native
    
    /**
      * A positive decimal (with at most two decimal places) between 1 and 100. This represents the percentage of the subscription invoice
      * subtotal that will be calculated and added as tax to the final amount each billing period. For example, a plan which charges $10/month
      * with a tax_percent of 20.0 will charge $12 per invoice.
      */
    var tax_percent: js.UndefOr[Double] = js.native
    
    /**
      * Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. If set, trial_end
      * will override the default trial period of the plan the customer is being subscribed to. The special value now can be provided to end the
      * customer's trial immediately.
      */
    var trial_end: js.UndefOr[Double | now] = js.native
  }
  object ISubscriptionUpdateOptions {
    
    @scala.inline
    def apply(): ISubscriptionUpdateOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[ISubscriptionUpdateOptions]
    }
    
    @scala.inline
    implicit class ISubscriptionUpdateOptionsMutableBuilder[Self <: ISubscriptionUpdateOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setApplication_fee_percent(value: Double): Self = StObject.set(x, "application_fee_percent", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setApplication_fee_percentUndefined: Self = StObject.set(x, "application_fee_percent", js.undefined)
      
      @scala.inline
      def setBilling(value: SubscriptionBilling): Self = StObject.set(x, "billing", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBillingUndefined: Self = StObject.set(x, "billing", js.undefined)
      
      @scala.inline
      def setBilling_cycle_anchor(value: unchanged | now): Self = StObject.set(x, "billing_cycle_anchor", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBilling_cycle_anchorUndefined: Self = StObject.set(x, "billing_cycle_anchor", js.undefined)
      
      @scala.inline
      def setCancel_at_period_end(value: Boolean): Self = StObject.set(x, "cancel_at_period_end", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCancel_at_period_endUndefined: Self = StObject.set(x, "cancel_at_period_end", js.undefined)
      
      @scala.inline
      def setCoupon(value: String): Self = StObject.set(x, "coupon", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCouponNull: Self = StObject.set(x, "coupon", null)
      
      @scala.inline
      def setCouponUndefined: Self = StObject.set(x, "coupon", js.undefined)
      
      @scala.inline
      def setDays_until_due(value: Double): Self = StObject.set(x, "days_until_due", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDays_until_dueUndefined: Self = StObject.set(x, "days_until_due", js.undefined)
      
      @scala.inline
      def setDefault_payment_method(value: String): Self = StObject.set(x, "default_payment_method", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDefault_payment_methodUndefined: Self = StObject.set(x, "default_payment_method", js.undefined)
      
      @scala.inline
      def setDefault_source(value: String | ICardSourceCreationOptions): Self = StObject.set(x, "default_source", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDefault_sourceUndefined: Self = StObject.set(x, "default_source", js.undefined)
      
      @scala.inline
      def setItems(value: js.Array[ISubscriptionUpdateItem]): Self = StObject.set(x, "items", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setItemsUndefined: Self = StObject.set(x, "items", js.undefined)
      
      @scala.inline
      def setItemsVarargs(value: ISubscriptionUpdateItem*): Self = StObject.set(x, "items", js.Array(value :_*))
      
      @scala.inline
      def setOff_session(value: Boolean): Self = StObject.set(x, "off_session", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOff_sessionUndefined: Self = StObject.set(x, "off_session", js.undefined)
      
      @scala.inline
      def setPay_immediately(value: Boolean): Self = StObject.set(x, "pay_immediately", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPay_immediatelyUndefined: Self = StObject.set(x, "pay_immediately", js.undefined)
      
      @scala.inline
      def setPlan(value: String): Self = StObject.set(x, "plan", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPlanUndefined: Self = StObject.set(x, "plan", js.undefined)
      
      @scala.inline
      def setProrate(value: Boolean): Self = StObject.set(x, "prorate", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setProrateUndefined: Self = StObject.set(x, "prorate", js.undefined)
      
      @scala.inline
      def setProration_behavior(value: create_prorations | always_invoice | none): Self = StObject.set(x, "proration_behavior", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setProration_behaviorUndefined: Self = StObject.set(x, "proration_behavior", js.undefined)
      
      @scala.inline
      def setProration_date(value: Double): Self = StObject.set(x, "proration_date", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setProration_dateUndefined: Self = StObject.set(x, "proration_date", js.undefined)
      
      @scala.inline
      def setQuantity(value: Double): Self = StObject.set(x, "quantity", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setQuantityUndefined: Self = StObject.set(x, "quantity", js.undefined)
      
      @scala.inline
      def setTax_percent(value: Double): Self = StObject.set(x, "tax_percent", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTax_percentUndefined: Self = StObject.set(x, "tax_percent", js.undefined)
      
      @scala.inline
      def setTrial_end(value: Double | now): Self = StObject.set(x, "trial_end", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTrial_endUndefined: Self = StObject.set(x, "trial_end", js.undefined)
    }
  }
  
  /* Rewritten from type alias, can be one of: 
    - typings.stripe.stripeStrings.charge_automatically
    - typings.stripe.stripeStrings.send_invoice
  */
  trait SubscriptionBilling extends StObject
  object SubscriptionBilling {
    
    @scala.inline
    def charge_automatically: typings.stripe.stripeStrings.charge_automatically = "charge_automatically".asInstanceOf[typings.stripe.stripeStrings.charge_automatically]
    
    @scala.inline
    def send_invoice: typings.stripe.stripeStrings.send_invoice = "send_invoice".asInstanceOf[typings.stripe.stripeStrings.send_invoice]
  }
  
  /* Rewritten from type alias, can be one of: 
    - typings.stripe.stripeStrings.incomplete
    - typings.stripe.stripeStrings.incomplete_expired
    - typings.stripe.stripeStrings.trialing
    - typings.stripe.stripeStrings.active
    - typings.stripe.stripeStrings.past_due
    - typings.stripe.stripeStrings.canceled
    - typings.stripe.stripeStrings.unpaid
  */
  trait SubscriptionStatus extends StObject
  object SubscriptionStatus {
    
    @scala.inline
    def active: typings.stripe.stripeStrings.active = "active".asInstanceOf[typings.stripe.stripeStrings.active]
    
    @scala.inline
    def canceled: typings.stripe.stripeStrings.canceled = "canceled".asInstanceOf[typings.stripe.stripeStrings.canceled]
    
    @scala.inline
    def incomplete: typings.stripe.stripeStrings.incomplete = "incomplete".asInstanceOf[typings.stripe.stripeStrings.incomplete]
    
    @scala.inline
    def incomplete_expired: typings.stripe.stripeStrings.incomplete_expired = "incomplete_expired".asInstanceOf[typings.stripe.stripeStrings.incomplete_expired]
    
    @scala.inline
    def past_due: typings.stripe.stripeStrings.past_due = "past_due".asInstanceOf[typings.stripe.stripeStrings.past_due]
    
    @scala.inline
    def trialing: typings.stripe.stripeStrings.trialing = "trialing".asInstanceOf[typings.stripe.stripeStrings.trialing]
    
    @scala.inline
    def unpaid: typings.stripe.stripeStrings.unpaid = "unpaid".asInstanceOf[typings.stripe.stripeStrings.unpaid]
  }
}
