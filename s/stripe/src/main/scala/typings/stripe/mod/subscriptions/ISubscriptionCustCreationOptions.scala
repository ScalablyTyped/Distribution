package typings.stripe.mod.subscriptions

import typings.stripe.mod.IDataOptionsWithMetadata
import typings.stripe.mod.IOptionsMetadata
import typings.stripe.mod.cards.ICardSourceCreationOptions
import typings.stripe.stripeStrings.now
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

trait ISubscriptionCustCreationOptions extends IDataOptionsWithMetadata {
  /**
    * A positive decimal (with at most two decimal places) between 1 and 100. This represents the percentage of the subscription invoice
    * subtotal that will be transferred to the application owner’s Stripe account. The request must be made with an OAuth key in order
    * to set an application fee percentage. For more information, see the application fees documentation.
    */
  var application_fee_percent: js.UndefOr[Double] = js.undefined
  /**
    * Either "charge_automatically", or "send_invoice". When charging automatically, Stripe will attempt to pay this subscription at the end of the
    * cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment
    * instructions. Defaults to "charge_automatically".
    */
  var billing: js.UndefOr[SubscriptionBilling] = js.undefined
  /**
    * A future timestamp to anchor the subscription’s billing cycle. This is used to determine the date of the first full invoice, and, for plans
    * with month or year intervals, the day of the month for subsequent invoices.
    */
  var billing_cycle_anchor: js.UndefOr[Double] = js.undefined
  /**
    * The code of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that
    * particular subscription.
    */
  var coupon: js.UndefOr[String] = js.undefined
  /**
    * Number of days a customer has to pay invoices generated by this subscription.
    * Only valid for subscriptions where billing=send_invoice.
    */
  var days_until_due: js.UndefOr[Double] = js.undefined
  var default_source: js.UndefOr[String | ICardSourceCreationOptions] = js.undefined
  /**
    * The tax rates that will apply to the subscription.
    */
  var default_tax_rates: js.UndefOr[js.Array[String]] = js.undefined
  /**
    * List of subscription items, each with an attached plan.
    */
  var items: js.UndefOr[js.Array[ISubscriptionCreationItem]] = js.undefined
  /**
    * Boolean (default true). Used to prevent Stripe Invoicing from automatically paying the subscription on creation. This can be set
    * to false when used with services like Avalara that need to augment an invoice before the subscription is paid.
    *
    * Using this flag requires contacting Stripe support in order to have the account whitelisted.
    */
  var pay_immediately: js.UndefOr[Boolean] = js.undefined
  /**
    * @deprecated Use items property instead.
    */
  var plan: js.UndefOr[String] = js.undefined
  /**
    * Boolean (default true). Use with a billing_cycle_anchor timestamp to determine whether the customer will be invoiced a prorated amount until
    * the anchor date. If false, the anchor period will be free (similar to a trial).
    */
  var prorate: js.UndefOr[Boolean] = js.undefined
  /**
    * The quantity you'd like to apply to the subscription you're creating. For example, if your plan is £10/user/month, and your customer
    * has 5 users, you could pass 5 as the quantity to have the customer charged £50 (5 x £10) monthly. If you update a subscription but
    * don't change the plan ID (e.g. changing only the trial_end), the subscription will inherit the old subscription's quantity attribute
    * unless you pass a new quantity parameter. If you update a subscription and change the plan ID, the new subscription will not inherit
    * the quantity attribute and will default to 1 unless you pass a quantity parameter.
    */
  var quantity: js.UndefOr[Double] = js.undefined
  /**
    * A positive decimal (with at most two decimal places) between 1 and 100. This represents the percentage of the subscription invoice
    * subtotal that will be calculated and added as tax to the final amount each billing period. For example, a plan which charges $10/month
    * with a tax_percent of 20.0 will charge $12 per invoice.
    */
  var tax_percent: js.UndefOr[Double] = js.undefined
  /**
    * Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. If set, trial_end
    * will override the default trial period of the plan the customer is being subscribed to. The special value now can be provided to end the
    * customer's trial immediately.
    */
  var trial_end: js.UndefOr[Double | now] = js.undefined
  /**
    * Indicates if a plan’s trial_period_days should be applied to the subscription. Setting trial_end per subscription is preferred,
    * and this defaults to false. Setting this flag to true together with trial_end is not allowed.
    */
  var trial_from_plan: js.UndefOr[Boolean] = js.undefined
  /**
    * Integer representing the number of trial period days before the customer is charged for the first time.
    */
  var trial_period_days: js.UndefOr[Double] = js.undefined
}

object ISubscriptionCustCreationOptions {
  @scala.inline
  def apply(
    application_fee_percent: Int | Double = null,
    billing: SubscriptionBilling = null,
    billing_cycle_anchor: Int | Double = null,
    coupon: String = null,
    days_until_due: Int | Double = null,
    default_source: String | ICardSourceCreationOptions = null,
    default_tax_rates: js.Array[String] = null,
    expand: js.Array[String] = null,
    include: js.Array[String] = null,
    items: js.Array[ISubscriptionCreationItem] = null,
    metadata: IOptionsMetadata = null,
    pay_immediately: js.UndefOr[Boolean] = js.undefined,
    plan: String = null,
    prorate: js.UndefOr[Boolean] = js.undefined,
    quantity: Int | Double = null,
    tax_percent: Int | Double = null,
    trial_end: Double | now = null,
    trial_from_plan: js.UndefOr[Boolean] = js.undefined,
    trial_period_days: Int | Double = null
  ): ISubscriptionCustCreationOptions = {
    val __obj = js.Dynamic.literal()
    if (application_fee_percent != null) __obj.updateDynamic("application_fee_percent")(application_fee_percent.asInstanceOf[js.Any])
    if (billing != null) __obj.updateDynamic("billing")(billing.asInstanceOf[js.Any])
    if (billing_cycle_anchor != null) __obj.updateDynamic("billing_cycle_anchor")(billing_cycle_anchor.asInstanceOf[js.Any])
    if (coupon != null) __obj.updateDynamic("coupon")(coupon.asInstanceOf[js.Any])
    if (days_until_due != null) __obj.updateDynamic("days_until_due")(days_until_due.asInstanceOf[js.Any])
    if (default_source != null) __obj.updateDynamic("default_source")(default_source.asInstanceOf[js.Any])
    if (default_tax_rates != null) __obj.updateDynamic("default_tax_rates")(default_tax_rates.asInstanceOf[js.Any])
    if (expand != null) __obj.updateDynamic("expand")(expand.asInstanceOf[js.Any])
    if (include != null) __obj.updateDynamic("include")(include.asInstanceOf[js.Any])
    if (items != null) __obj.updateDynamic("items")(items.asInstanceOf[js.Any])
    if (metadata != null) __obj.updateDynamic("metadata")(metadata.asInstanceOf[js.Any])
    if (!js.isUndefined(pay_immediately)) __obj.updateDynamic("pay_immediately")(pay_immediately.asInstanceOf[js.Any])
    if (plan != null) __obj.updateDynamic("plan")(plan.asInstanceOf[js.Any])
    if (!js.isUndefined(prorate)) __obj.updateDynamic("prorate")(prorate.asInstanceOf[js.Any])
    if (quantity != null) __obj.updateDynamic("quantity")(quantity.asInstanceOf[js.Any])
    if (tax_percent != null) __obj.updateDynamic("tax_percent")(tax_percent.asInstanceOf[js.Any])
    if (trial_end != null) __obj.updateDynamic("trial_end")(trial_end.asInstanceOf[js.Any])
    if (!js.isUndefined(trial_from_plan)) __obj.updateDynamic("trial_from_plan")(trial_from_plan.asInstanceOf[js.Any])
    if (trial_period_days != null) __obj.updateDynamic("trial_period_days")(trial_period_days.asInstanceOf[js.Any])
    __obj.asInstanceOf[ISubscriptionCustCreationOptions]
  }
}

