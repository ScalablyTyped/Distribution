package typings.stripe.mod.subscriptions

import typings.stripe.anon.Amountpercent
import typings.stripe.mod.IDataOptionsWithMetadata
import typings.stripe.mod.cards.ICardSourceCreationOptions
import typings.stripe.stripeStrings.now
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait ISubscriptionCustCreationOptions extends IDataOptionsWithMetadata {
  /**
    * A positive decimal (with at most two decimal places) between 1 and 100. This represents the percentage of the subscription invoice
    * subtotal that will be transferred to the application owner’s Stripe account. The request must be made with an OAuth key in order
    * to set an application fee percentage. For more information, see the application fees documentation.
    */
  var application_fee_percent: js.UndefOr[Double] = js.native
  /**
    * Either "charge_automatically", or "send_invoice". When charging automatically, Stripe will attempt to pay this subscription at the end of the
    * cycle using the default source attached to the customer. When sending an invoice, Stripe will email your customer an invoice with payment
    * instructions. Defaults to "charge_automatically".
    */
  var billing: js.UndefOr[SubscriptionBilling] = js.native
  /**
    * A future timestamp to anchor the subscription’s billing cycle. This is used to determine the date of the first full invoice, and, for plans
    * with month or year intervals, the day of the month for subsequent invoices.
    */
  var billing_cycle_anchor: js.UndefOr[Double] = js.native
  /**
    * The code of the coupon to apply to this subscription. A coupon applied to a subscription will only affect invoices created for that
    * particular subscription.
    */
  var coupon: js.UndefOr[String] = js.native
  /**
    * Number of days a customer has to pay invoices generated by this subscription.
    * Only valid for subscriptions where billing=send_invoice.
    */
  var days_until_due: js.UndefOr[Double] = js.native
  /**
    * ID of the default payment method for the subscription. It must belong to the customer associated with the subscription. If not set, invoices will use the default payment method in the customer’s invoice settings.
    */
  var default_payment_method: js.UndefOr[String] = js.native
  var default_source: js.UndefOr[String | ICardSourceCreationOptions] = js.native
  /**
    * The tax rates that will apply to the subscription.
    */
  var default_tax_rates: js.UndefOr[js.Array[String]] = js.native
  /**
    * List of subscription items, each with an attached plan.
    */
  var items: js.UndefOr[js.Array[ISubscriptionCreationItem]] = js.native
  /**
    * Indicates if a customer is on or off-session while an invoice payment is attempted.
    */
  var off_session: js.UndefOr[Boolean] = js.native
  /**
    * Boolean (default true). Used to prevent Stripe Invoicing from automatically paying the subscription on creation. This can be set
    * to false when used with services like Avalara that need to augment an invoice before the subscription is paid.
    *
    * Using this flag requires contacting Stripe support in order to have the account whitelisted.
    */
  var pay_immediately: js.UndefOr[Boolean] = js.native
  /**
    * @deprecated Use items property instead.
    */
  var plan: js.UndefOr[String] = js.native
  /**
    * Boolean (default true). Use with a billing_cycle_anchor timestamp to determine whether the customer will be invoiced a prorated amount until
    * the anchor date. If false, the anchor period will be free (similar to a trial).
    */
  var prorate: js.UndefOr[Boolean] = js.native
  /**
    * The quantity you'd like to apply to the subscription you're creating. For example, if your plan is £10/user/month, and your customer
    * has 5 users, you could pass 5 as the quantity to have the customer charged £50 (5 x £10) monthly. If you update a subscription but
    * don't change the plan ID (e.g. changing only the trial_end), the subscription will inherit the old subscription's quantity attribute
    * unless you pass a new quantity parameter. If you update a subscription and change the plan ID, the new subscription will not inherit
    * the quantity attribute and will default to 1 unless you pass a quantity parameter.
    */
  var quantity: js.UndefOr[Double] = js.native
  /**
    * A positive decimal (with at most two decimal places) between 1 and 100. This represents the percentage of the subscription invoice
    * subtotal that will be calculated and added as tax to the final amount each billing period. For example, a plan which charges $10/month
    * with a tax_percent of 20.0 will charge $12 per invoice.
    */
  var tax_percent: js.UndefOr[Double] = js.native
  /**
    * If specified, the funds from the subscription’s invoices will be transferred to the destination and the ID of the resulting transfers will be found on the resulting charges.
    */
  var transfer_data: js.UndefOr[Amountpercent] = js.native
  /**
    * Unix timestamp representing the end of the trial period the customer will get before being charged for the first time. If set, trial_end
    * will override the default trial period of the plan the customer is being subscribed to. The special value now can be provided to end the
    * customer's trial immediately.
    */
  var trial_end: js.UndefOr[Double | now] = js.native
  /**
    * Indicates if a plan’s trial_period_days should be applied to the subscription. Setting trial_end per subscription is preferred,
    * and this defaults to false. Setting this flag to true together with trial_end is not allowed.
    */
  var trial_from_plan: js.UndefOr[Boolean] = js.native
  /**
    * Integer representing the number of trial period days before the customer is charged for the first time.
    */
  var trial_period_days: js.UndefOr[Double] = js.native
}

object ISubscriptionCustCreationOptions {
  @scala.inline
  def apply(): ISubscriptionCustCreationOptions = {
    val __obj = js.Dynamic.literal()
    __obj.asInstanceOf[ISubscriptionCustCreationOptions]
  }
  @scala.inline
  implicit class ISubscriptionCustCreationOptionsOps[Self <: ISubscriptionCustCreationOptions] (val x: Self) extends AnyVal {
    @scala.inline
    def duplicate: Self = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x)).asInstanceOf[Self]
    @scala.inline
    def combineWith[Other <: js.Any](other: Other): Self with Other = (js.Dynamic.global.Object.assign(js.Dynamic.literal(), x, other.asInstanceOf[js.Any])).asInstanceOf[Self with Other]
    @scala.inline
    def set(key: String, value: js.Any): Self = {
        x.asInstanceOf[js.Dynamic].updateDynamic(key)(value)
        x
    }
    @scala.inline
    def setApplication_fee_percent(value: Double): Self = this.set("application_fee_percent", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteApplication_fee_percent: Self = this.set("application_fee_percent", js.undefined)
    @scala.inline
    def setBilling(value: SubscriptionBilling): Self = this.set("billing", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteBilling: Self = this.set("billing", js.undefined)
    @scala.inline
    def setBilling_cycle_anchor(value: Double): Self = this.set("billing_cycle_anchor", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteBilling_cycle_anchor: Self = this.set("billing_cycle_anchor", js.undefined)
    @scala.inline
    def setCoupon(value: String): Self = this.set("coupon", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteCoupon: Self = this.set("coupon", js.undefined)
    @scala.inline
    def setDays_until_due(value: Double): Self = this.set("days_until_due", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteDays_until_due: Self = this.set("days_until_due", js.undefined)
    @scala.inline
    def setDefault_payment_method(value: String): Self = this.set("default_payment_method", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteDefault_payment_method: Self = this.set("default_payment_method", js.undefined)
    @scala.inline
    def setDefault_source(value: String | ICardSourceCreationOptions): Self = this.set("default_source", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteDefault_source: Self = this.set("default_source", js.undefined)
    @scala.inline
    def setDefault_tax_ratesVarargs(value: String*): Self = this.set("default_tax_rates", js.Array(value :_*))
    @scala.inline
    def setDefault_tax_rates(value: js.Array[String]): Self = this.set("default_tax_rates", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteDefault_tax_rates: Self = this.set("default_tax_rates", js.undefined)
    @scala.inline
    def setItemsVarargs(value: ISubscriptionCreationItem*): Self = this.set("items", js.Array(value :_*))
    @scala.inline
    def setItems(value: js.Array[ISubscriptionCreationItem]): Self = this.set("items", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteItems: Self = this.set("items", js.undefined)
    @scala.inline
    def setOff_session(value: Boolean): Self = this.set("off_session", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteOff_session: Self = this.set("off_session", js.undefined)
    @scala.inline
    def setPay_immediately(value: Boolean): Self = this.set("pay_immediately", value.asInstanceOf[js.Any])
    @scala.inline
    def deletePay_immediately: Self = this.set("pay_immediately", js.undefined)
    @scala.inline
    def setPlan(value: String): Self = this.set("plan", value.asInstanceOf[js.Any])
    @scala.inline
    def deletePlan: Self = this.set("plan", js.undefined)
    @scala.inline
    def setProrate(value: Boolean): Self = this.set("prorate", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteProrate: Self = this.set("prorate", js.undefined)
    @scala.inline
    def setQuantity(value: Double): Self = this.set("quantity", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteQuantity: Self = this.set("quantity", js.undefined)
    @scala.inline
    def setTax_percent(value: Double): Self = this.set("tax_percent", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteTax_percent: Self = this.set("tax_percent", js.undefined)
    @scala.inline
    def setTransfer_data(value: Amountpercent): Self = this.set("transfer_data", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteTransfer_data: Self = this.set("transfer_data", js.undefined)
    @scala.inline
    def setTrial_end(value: Double | now): Self = this.set("trial_end", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteTrial_end: Self = this.set("trial_end", js.undefined)
    @scala.inline
    def setTrial_from_plan(value: Boolean): Self = this.set("trial_from_plan", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteTrial_from_plan: Self = this.set("trial_from_plan", js.undefined)
    @scala.inline
    def setTrial_period_days(value: Double): Self = this.set("trial_period_days", value.asInstanceOf[js.Any])
    @scala.inline
    def deleteTrial_period_days: Self = this.set("trial_period_days", js.undefined)
  }
  
}

