package typings.oracledb.mod

import org.scalablytyped.runtime.TopLevel
import typings.node.bufferMod.global.Buffer
import typings.oracledb.anon.Correlation
import typings.oracledb.mod.^
import typings.oracledb.oracledbStrings.DBObject_IN
import typings.oracledb.oracledbStrings.DBObject_OUT
import typings.std.Record
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}


/** Constant for the AqDeqOptions Class 'mode' */
inline def AQ_DEQ_MODE_BROWSE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_MODE_BROWSE").asInstanceOf[Double]

/** Constant for the AqDeqOptions Class 'mode' */
inline def AQ_DEQ_MODE_LOCKED: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_MODE_LOCKED").asInstanceOf[Double]

/** Constant for the AqDeqOptions Class 'mode' */
inline def AQ_DEQ_MODE_REMOVE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_MODE_REMOVE").asInstanceOf[Double]

/** Constant for the AqDeqOptions Class 'mode' */
inline def AQ_DEQ_MODE_REMOVE_NO_DAT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_MODE_REMOVE_NO_DAT").asInstanceOf[Double]

/** Constant for the AqDeqOptions Class 'navigation' */
inline def AQ_DEQ_NAV_FIRST_MSG: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_NAV_FIRST_MSG").asInstanceOf[Double]

/** Constant for the AqDeqOptions Class 'navigation' */
inline def AQ_DEQ_NAV_NEXT_MSG: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_NAV_NEXT_MSG").asInstanceOf[Double]

/** Constant for the AqDeqOptions Class 'navigation' */
inline def AQ_DEQ_NAV_NEXT_TRANSACTION: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_NAV_NEXT_TRANSACTION").asInstanceOf[Double]

/** Constant for the AqDeqOptions Class 'wait' */
inline def AQ_DEQ_NO_WAIT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_NO_WAIT").asInstanceOf[Double]

/** Constant for the AqEnqOptions Class 'deliveryMode' */
inline def AQ_DEQ_WAAQ_MSG_DELIV_MODE_PERSISTENTIT_FOREVER: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_WAAQ_MSG_DELIV_MODE_PERSISTENTIT_FOREVER").asInstanceOf[Double]

/** Constant for the AqDeqOptions Class 'wait' */
inline def AQ_DEQ_WAIT_FOREVER: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_WAIT_FOREVER").asInstanceOf[Double]

/** Constant for the AqEnqOptions Class 'deliveryMode' */
inline def AQ_MSG_DELIV_MODE_BUFFERED: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_DELIV_MODE_BUFFERED").asInstanceOf[Double]

/** Constant for the AqEnqOptions Class 'deliveryMode' */
inline def AQ_MSG_DELIV_MODE_PERSISTENT_OR_BUFFERED: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_DELIV_MODE_PERSISTENT_OR_BUFFERED").asInstanceOf[Double]

/** Constant for the AqMessage Class 'state' */
inline def AQ_MSG_STATE_EXPIRED: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_STATE_EXPIRED").asInstanceOf[Double]

/** Constant for the AqMessage Class 'state' */
inline def AQ_MSG_STATE_PROCESSED: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_STATE_PROCESSED").asInstanceOf[Double]

/** Constant for the AqMessage Class 'state' */
inline def AQ_MSG_STATE_READY: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_STATE_READY").asInstanceOf[Double]

/** Constant for the AqMessage Class 'state' */
inline def AQ_MSG_STATE_WAITING: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_STATE_WAITING").asInstanceOf[Double]

/** Constant for the AqEnqOptions Class and AqDeqOptions 'visibility' */
inline def AQ_VISIBILITY_IMMEDIATE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_VISIBILITY_IMMEDIATE").asInstanceOf[Double]

/** Constant for the AqEnqOptions Class and AqDeqOptions 'visibility' */
inline def AQ_VISIBILITY_ON_COMMIT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("AQ_VISIBILITY_ON_COMMIT").asInstanceOf[Double]

/** Constant for the dir property of execute() bindParams, queryStream() and executeMany() bindDefs. */
inline def BIND_IN: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("BIND_IN").asInstanceOf[Double]

/** Constant for the dir property of execute() bindParams, queryStream() and executeMany() bindDefs. */
inline def BIND_INOUT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("BIND_INOUT").asInstanceOf[Double]

/** Constant for the dir property of execute() bindParams, queryStream() and executeMany() bindDefs. */
inline def BIND_OUT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("BIND_OUT").asInstanceOf[Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
inline def BLOB: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("BLOB").asInstanceOf[Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
inline def BUFFER: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("BUFFER").asInstanceOf[Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
inline def CLOB: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("CLOB").asInstanceOf[Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
inline def CQN_OPCODE_ALL_OPS: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_ALL_OPS").asInstanceOf[Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
inline def CQN_OPCODE_ALL_ROWS: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_ALL_ROWS").asInstanceOf[Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
inline def CQN_OPCODE_ALTER: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_ALTER").asInstanceOf[Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
inline def CQN_OPCODE_DELETE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_DELETE").asInstanceOf[Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
inline def CQN_OPCODE_DROP: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_DROP").asInstanceOf[Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
inline def CQN_OPCODE_INSERT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_INSERT").asInstanceOf[Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
inline def CQN_OPCODE_UPDATE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_UPDATE").asInstanceOf[Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
inline def CURSOR: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("CURSOR").asInstanceOf[Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
inline def DATE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DATE").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_BFILE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BFILE").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_BINARY_DOUBLE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BINARY_DOUBLE").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_BINARY_FLOAT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BINARY_FLOAT").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_BINARY_INTEGER: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BINARY_INTEGER").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_BLOB: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BLOB").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_BOOLEAN: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BOOLEAN").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_CHAR: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_CHAR").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_CLOB: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_CLOB").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_CURSOR: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_CURSOR").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_DATE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_DATE").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_INTERVAL_DS: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_INTERVAL_DS").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_INTERVAL_YM: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_INTERVAL_YM").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_JSON: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_JSON").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_LONG: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_LONG").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_LONG_RAW: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_LONG_RAW").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_NCHAR: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_NCHAR").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_NCLOB: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_NCLOB").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_NUMBER: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_NUMBER").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_NVARCHAR: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_NVARCHAR").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_OBJECT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_OBJECT").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_RAW: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_RAW").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_ROWID: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_ROWID").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_TIMESTAMP: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_TIMESTAMP").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_TIMESTAMP_LTZ: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_TIMESTAMP_LTZ").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_TIMESTAMP_TZ: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_TIMESTAMP_TZ").asInstanceOf[Double]

/** Constant which represents the Oracle Database type. */
inline def DB_TYPE_VARCHAR: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_VARCHAR").asInstanceOf[Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
inline def DEFAULT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("DEFAULT").asInstanceOf[Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
inline def NCLOB: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("NCLOB").asInstanceOf[Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
inline def NUMBER: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("NUMBER").asInstanceOf[Double]

/** Deprecated */
// const ARRAY: number;
// const OBJECT: number;
/** Constant for the query result outFormat option. */
inline def OUT_FORMAT_ARRAY: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("OUT_FORMAT_ARRAY").asInstanceOf[Double]

/** Constant for the query result outFormat option. */
inline def OUT_FORMAT_OBJECT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("OUT_FORMAT_OBJECT").asInstanceOf[Double]

/** Constant for the connection pool.status readonly attribute. */
inline def POOL_STATUS_CLOSED: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("POOL_STATUS_CLOSED").asInstanceOf[Double]

/** Constant for the connection pool.status readonly attribute. */
inline def POOL_STATUS_DRAINING: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("POOL_STATUS_DRAINING").asInstanceOf[Double]

/** Constant for the connection pool.status readonly attribute. */
inline def POOL_STATUS_OPEN: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("POOL_STATUS_OPEN").asInstanceOf[Double]

/**
  * The oracledb.Promise property is no longer used in node-oracledb 5 and has no effect.
  *
  * Node-oracledb supports Promises on all methods. The native Promise library is used.
  *
  * @deprecated 5.0
  */
inline def Promise: js.Promise[Any] = ^.asInstanceOf[js.Dynamic].selectDynamic("Promise").asInstanceOf[js.Promise[Any]]
inline def Promise_=(x: js.Promise[Any]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("Promise")(x.asInstanceOf[js.Any])

/** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
inline def SHUTDOWN_MODE_ABORT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_ABORT").asInstanceOf[Double]

/** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
inline def SHUTDOWN_MODE_DEFAULT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_DEFAULT").asInstanceOf[Double]

/** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
inline def SHUTDOWN_MODE_FINAL: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_FINAL").asInstanceOf[Double]

/** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
inline def SHUTDOWN_MODE_IMMEDIATE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_IMMEDIATE").asInstanceOf[Double]

/** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
inline def SHUTDOWN_MODE_TRANSACTIONAL: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_TRANSACTIONAL").asInstanceOf[Double]

/** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
inline def SHUTDOWN_MODE_TRANSACTIONAL_LOCAL: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_TRANSACTIONAL_LOCAL").asInstanceOf[Double]

/** Constant for the sodaDatabase.createCollection() mode property. */
inline def SODA_COLL_MAP_MODE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SODA_COLL_MAP_MODE").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_ALTER: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_ALTER").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_BEGIN: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_BEGIN").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_CALL: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_CALL").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_COMMIT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_COMMIT").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_CREATE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_CREATE").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_DECLARE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_DECLARE").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_DELETE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_DELETE").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_DROP: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_DROP").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_EXPLAIN_PLAN: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_EXPLAIN_PLAN").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_INSERT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_INSERT").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_MERGE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_MERGE").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_ROLLBACK: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_ROLLBACK").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_SELECT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_SELECT").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_UNKNOWN: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_UNKNOWN").asInstanceOf[Double]

/** Constant for connection.getStatementInfo() properties. */
inline def STMT_TYPE_UPDATE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_UPDATE").asInstanceOf[Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
inline def STRING: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("STRING").asInstanceOf[Double]

/** Constant for the Continuous Query Notification message.type. */
inline def SUBSCR_EVENT_TYPE_AQ: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_AQ").asInstanceOf[Double]

/** Constant for the Continuous Query Notification message.type. */
inline def SUBSCR_EVENT_TYPE_DEREG: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_DEREG").asInstanceOf[Double]

/** Constant for the Continuous Query Notification message.type. */
inline def SUBSCR_EVENT_TYPE_OBJ_CHANGE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_OBJ_CHANGE").asInstanceOf[Double]

/** Constant for the Continuous Query Notification message.type. */
inline def SUBSCR_EVENT_TYPE_QUERY_CHANGE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_QUERY_CHANGE").asInstanceOf[Double]

/** Constant for the Continuous Query Notification message.type. */
inline def SUBSCR_EVENT_TYPE_SHUTDOWN: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_SHUTDOWN").asInstanceOf[Double]

/** Constant for the Continuous Query Notification message.type. */
inline def SUBSCR_EVENT_TYPE_SHUTDOWN_ANY: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_SHUTDOWN_ANY").asInstanceOf[Double]

/** Constant for the Continuous Query Notification message.type. */
inline def SUBSCR_EVENT_TYPE_STARTUP: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_STARTUP").asInstanceOf[Double]

/** Constant for the Continuous Query Notification groupingClass. */
inline def SUBSCR_GROUPING_CLASS_TIME: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_GROUPING_CLASS_TIME").asInstanceOf[Double]

/** Constant for the Continuous Query Notification groupingType. */
inline def SUBSCR_GROUPING_TYPE_LAST: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_GROUPING_TYPE_LAST").asInstanceOf[Double]

/** Constant for the Continuous Query Notification groupingType. */
inline def SUBSCR_GROUPING_TYPE_SUMMARY: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_GROUPING_TYPE_SUMMARY").asInstanceOf[Double]

/** Constant for the Continuous Query Notification namespace. */
inline def SUBSCR_NAMESPACE_AQ: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_NAMESPACE_AQ").asInstanceOf[Double]

/** Constant for the Continuous Query Notification namespace. */
inline def SUBSCR_NAMESPACE_DBCHANGE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_NAMESPACE_DBCHANGE").asInstanceOf[Double]

/** Constant for the Continuous Query Notification qos Quality of Service. */
inline def SUBSCR_QOS_BEST_EFFORT: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_BEST_EFFORT").asInstanceOf[Double]

/** Constant for the Continuous Query Notification qos Quality of Service. */
inline def SUBSCR_QOS_DEREG_NFY: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_DEREG_NFY").asInstanceOf[Double]

/** Constant for the Continuous Query Notification qos Quality of Service. */
inline def SUBSCR_QOS_QUERY: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_QUERY").asInstanceOf[Double]

/** Constant for the Continuous Query Notification qos Quality of Service. */
inline def SUBSCR_QOS_RELIABLE: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_RELIABLE").asInstanceOf[Double]

/** Constant for the Continuous Query Notification qos Quality of Service. */
inline def SUBSCR_QOS_ROWIDS: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_ROWIDS").asInstanceOf[Double]

/** Constant for getConnection() privilege properties. */
inline def SYSASM: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SYSASM").asInstanceOf[Double]

/** Constant for getConnection() privilege properties. */
inline def SYSBACKUP: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SYSBACKUP").asInstanceOf[Double]

/** Constant for getConnection() privilege properties. */
inline def SYSDBA: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SYSDBA").asInstanceOf[Double]

/** Constant for getConnection() privilege properties. */
inline def SYSDG: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SYSDG").asInstanceOf[Double]

/** Constant for getConnection() privilege properties. */
inline def SYSKM: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SYSKM").asInstanceOf[Double]

/** Constant for getConnection() privilege properties. */
inline def SYSOPER: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SYSOPER").asInstanceOf[Double]

/** Constant for getConnection() privilege properties. */
inline def SYSPRELIM: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SYSPRELIM").asInstanceOf[Double]

/** Constant for getConnection() privilege properties. */
inline def SYSRAC: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("SYSRAC").asInstanceOf[Double]

/**
  * If true, the transaction in the current connection is automatically committed at the end of statement execution.
  * This property may be overridden in an execute() call.
  *
  * @default false
  * @since 0.5
  */
inline def autoCommit: Boolean = ^.asInstanceOf[js.Dynamic].selectDynamic("autoCommit").asInstanceOf[Boolean]
inline def autoCommit_=(x: Boolean): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("autoCommit")(x.asInstanceOf[js.Any])

/**
  * The user-chosen Connection class value defines a logical name for connections.
  * Most single purpose applications should set connectionClass when using a connection pool or DRCP.
  *
  * When a pooled session has a connection class, Oracle ensures that the session is not shared outside of that connection class.
  *
  * The connection class value is similarly used by Database Resident Connection Pooling (DRCP) to allow or disallow sharing of sessions.
  *
  * For example, where two different kinds of users share one pool, you might set connectionClass to ‘HRPOOL’ for connections that
  * access a Human Resources system, and it might be set to ‘OEPOOL’ for users of an Order Entry system.
  * Users will only be given sessions of the appropriate class, allowing maximal reuse of resources in each case,
  * and preventing any session information leaking between the two systems.
  *
  * If connectionClass is set for a non-pooled connection, the driver name is not recorded in V$ views.
  */
inline def connectionClass: String = ^.asInstanceOf[js.Dynamic].selectDynamic("connectionClass").asInstanceOf[String]
inline def connectionClass_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("connectionClass")(x.asInstanceOf[js.Any])

/**
  * This method creates a pool of connections with the specified user name, password and connection string.
  * A pool is typically created once during application initialization.
  *
  * Internally, createPool() creates an Oracle Call Interface Session Pool for each Pool object.
  *
  * The default properties may be overridden by specifying new properties in the poolAttrs parameter.
  *
  * It is possible to add pools to the pool cache when calling createPool().
  * This allows pools to later be accessed by name, removing the need to pass the pool object through code.
  *
  * A pool should be terminated with the pool.close() call.
  *
  * From node-oracledb 3.1.0, the createPool() error callback will return a DPI-1047 error if node-oracledb cannot load Oracle Client libraries.
  * Previous versions threw this error from require('oracledb').
  *
  * @param poolAttributes Provides connection credentials and pool-specific configuration properties, overriding the defualt pooling properties of the Oracledb object.
  */
inline def createPool(poolAttributes: PoolAttributes): js.Promise[Pool] = ^.asInstanceOf[js.Dynamic].applyDynamic("createPool")(poolAttributes.asInstanceOf[js.Any]).asInstanceOf[js.Promise[Pool]]
inline def createPool(poolAttributes: PoolAttributes, callback: js.Function2[/* error */ DBError, /* pool */ Pool, Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("createPool")(poolAttributes.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]

/**
  * Specify whether Oracle Database named objects or collections that are queried should be returned to the application
  * as “plain old JavaScript objects” or kept as database-backed objects. This option also applies to output BIND_OUT bind variables.
  *
  * Note that LOBs in objects will be represented as Lob instances and will not be String or Buffer, regardless of any fetchAsString,
  * fetchAsBuffer, or fetchInfo setting.
  *
  * Setting dbObjectAsPojo to true can avoid overhead if object attributes are repeatedly accessed. It also allows applications to
  * close connections before any attributes are accessed unless LOBs are involved. Regardless of the value, the interface to access objects is the same.
  *
  * @default false
  * @since 5.1
  */
inline def dbObjectAsPojo: Boolean = ^.asInstanceOf[js.Dynamic].selectDynamic("dbObjectAsPojo").asInstanceOf[Boolean]
inline def dbObjectAsPojo_=(x: Boolean): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("dbObjectAsPojo")(x.asInstanceOf[js.Any])

/**
  * Sets the name used for Edition-Based Redefinition by connections.
  *
  * @since 2.2
  */
inline def edition: String = ^.asInstanceOf[js.Dynamic].selectDynamic("edition").asInstanceOf[String]
inline def edition_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("edition")(x.asInstanceOf[js.Any])

/**
  * This property was removed in node-oracledb 3.0 and queuing was always enabled.
  * In node-oracledb 5.0, set queueMax to 0 to disable queuing.
  *
  * @see https://oracle.github.io/node-oracledb/doc/api.html#connpoolqueue
  */
inline def errorOnConcurrentExecute: Boolean = ^.asInstanceOf[js.Dynamic].selectDynamic("errorOnConcurrentExecute").asInstanceOf[Boolean]
inline def errorOnConcurrentExecute_=(x: Boolean): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("errorOnConcurrentExecute")(x.asInstanceOf[js.Any])

/**
  * Determines whether Oracle Client events mode should be enabled.
  *
  * This property can be overridden in the oracledb.createPool() call and when getting a standalone connection from oracledb.getConnection().
  *
  * Events mode is required for Continuous Query Notification, Fast Application Notification (FAN) and Runtime Load Balancing (RLB).
  *
  * @default true
  * @since 2.2
  */
inline def events: Boolean = ^.asInstanceOf[js.Dynamic].selectDynamic("events").asInstanceOf[Boolean]
inline def events_=(x: Boolean): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("events")(x.asInstanceOf[js.Any])

/**
  * Determines whether additional metadata is available for queries and for REF CURSORs returned from PL/SQL blocks.
  *
  * With this value, the result.metaData result.resultSet.metaData objects only include column names.
  *
  * If extendedMetaData is true then metaData will contain additional attributes.
  *
  * This property may be overridden in an execute() call.
  *
  * @default false
  * @since 1.10
  */
inline def extendedMetaData: Boolean = ^.asInstanceOf[js.Dynamic].selectDynamic("extendedMetaData").asInstanceOf[Boolean]
inline def extendedMetaData_=(x: Boolean): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("extendedMetaData")(x.asInstanceOf[js.Any])

/**
  * If true, connections will be established using external authentication.
  *
  * The user and password properties should not be set when externalAuth is true.
  *
  * This property can be overridden in the oracledb.createPool() call and when getting a standalone connection from oracledb.getConnection().
  *
  * @default false
  * @since 0.5
  */
inline def externalAuth: Boolean = ^.asInstanceOf[js.Dynamic].selectDynamic("externalAuth").asInstanceOf[Boolean]
inline def externalAuth_=(x: Boolean): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("externalAuth")(x.asInstanceOf[js.Any])

/**
  * This property sets the size of an internal buffer used for fetching query rows from Oracle Database.
  * Changing it may affect query performance but does not affect how many rows are returned to the application.
  *
  * The property is used during the default direct fetches, during ResultSet getRow() calls, and for queryStream(). It is not used for getRows().
  *
  * Increasing this value reduces the number of round-trips to the database but increases memory usage for each data fetch.
  * For queries that return a large number of rows, higher values of fetchArraySize may give better performance.
  * For queries that only return a few rows, reduce the value of fetchArraySize to minimize the amount of memory management during data fetches.
  * JavaScript memory fragmentation may occur in some cases.
  *
  * For direct fetches (those using execute() option resultSet: false), the internal buffer size will be based on the lesser of maxRows and fetchArraySize.
  *
  * @default 100
  * @since 2.0
  */
inline def fetchArraySize: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("fetchArraySize").asInstanceOf[Double]
inline def fetchArraySize_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("fetchArraySize")(x.asInstanceOf[js.Any])

/**
  * Configure data types to be returned as a Buffer instead of the default representation when queried with execute() or queryStream().
  *
  * Currently the only valid type is oracledb.BLOB.
  *
  * By default in node-oracledb, all columns are returned as native types or as Lob instances, in the case of CLOB and BLOB types.
  *
  * Individual query columns in execute() or queryStream() calls can override the fetchAsBuffer global setting by using fetchInfo.
  *
  * @since 1.13
  */
inline def fetchAsBuffer: js.Array[Double] = ^.asInstanceOf[js.Dynamic].selectDynamic("fetchAsBuffer").asInstanceOf[js.Array[Double]]
inline def fetchAsBuffer_=(x: js.Array[Double]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("fetchAsBuffer")(x.asInstanceOf[js.Any])

/**
  * An array of node-oracledb types. The valid types are oracledb.DATE, oracledb.NUMBER, oracledb.BUFFER, and oracledb.CLOB.
  * When any column having one of the specified types is queried with execute() or queryStream(), the column data is returned as a string instead of the default representation.
  *
  * By default in node-oracledb, all columns are returned as native types or as Lob instances, in the case of CLOB and BLOB types.
  *
  * This property helps avoid situations where using JavaScript types can lead to numeric precision loss, or where date conversion is unwanted.
  *
  * For raw data returned as a string, Oracle returns the data as a hex-encoded string.
  * For dates and numbers returned as a string, the maximum length of a string created by this mapping is 200 bytes.
  * Strings created for CLOB columns will generally be limited by Node.js and V8 memory restrictions.
  *
  * Individual query columns in execute() or queryStream() calls can override the fetchAsString global setting by using fetchInfo.
  *
  * For non-CLOB types, the conversion to string is handled by Oracle client libraries and is often referred to as defining the fetch type.
  */
inline def fetchAsString: js.Array[Double] = ^.asInstanceOf[js.Dynamic].selectDynamic("fetchAsString").asInstanceOf[js.Array[Double]]
inline def fetchAsString_=(x: js.Array[Double]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("fetchAsString")(x.asInstanceOf[js.Any])

/**
  * Obtains a connection from the default pool.
  *
  * For situations where connections are used infrequently, creating a standalone connection may be more efficient than creating and managing a connection pool.
  * However, in most cases, Oracle recommends getting connections from a connection pool.
  */
inline def getConnection(): js.Promise[Connection] = ^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")().asInstanceOf[js.Promise[Connection]]
inline def getConnection(callback: js.Function2[/* error */ DBError, /* connection */ Connection, Unit]): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(callback.asInstanceOf[js.Any]).asInstanceOf[Unit]
/**
  * Creates a new, standalone, non-pooled connection.
  *
  * For situations where connections are used infrequently, creating a standalone connection may be more efficient than creating and managing a connection pool.
  * However, in most cases, Oracle recommends getting connections from a connection pool.
  *
  * @param connectionAttributes Connection credentials and connection-specific configuration properties.
  */
inline def getConnection(connectionAttributes: ConnectionAttributes): js.Promise[Connection] = ^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(connectionAttributes.asInstanceOf[js.Any]).asInstanceOf[js.Promise[Connection]]
inline def getConnection(
  connectionAttributes: ConnectionAttributes,
  callback: js.Function2[/* error */ DBError, /* connection */ Connection, Unit]
): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(connectionAttributes.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]
/**
  * Obtains a connection from a pool in the connection pool cache.
  *
  * For situations where connections are used infrequently, creating a standalone connection may be more efficient than creating and managing a connection pool.
  * However, in most cases, Oracle recommends getting connections from a connection pool.
  *
  * @param poolAlias Specifies which previously created pool in the connection pool cache to use to obtain the connection.
  */
inline def getConnection(poolAlias: String): js.Promise[Connection] = ^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(poolAlias.asInstanceOf[js.Any]).asInstanceOf[js.Promise[Connection]]
inline def getConnection(poolAlias: String, callback: js.Function2[/* error */ DBError, /* connection */ Connection, Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(poolAlias.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[Unit]

/**
  * Retrieves a previously created pool from the connection pool cache. Note that this is a synchronous method.
  *
  * @param poolAlias
  *
  * The pool alias of the pool to retrieve from the connection pool cache.
  *
  * @default default
  */
inline def getPool(): Pool = ^.asInstanceOf[js.Dynamic].applyDynamic("getPool")().asInstanceOf[Pool]
inline def getPool(poolAlias: String): Pool = ^.asInstanceOf[js.Dynamic].applyDynamic("getPool")(poolAlias.asInstanceOf[js.Any]).asInstanceOf[Pool]

/**
  * This synchronous function loads and initializes the Oracle Client libraries that are necessary
  * for node-oracledb to communicate with Oracle Database. This function is optional. If used, it
  * should be the first node-oracledb call made by an application.
  *
  * If initOracleClient() is not called, then the Oracle Client libraries are loaded at the time of
  * first use in the application, such as when creating a connection pool. The default values described
  * for options will be used in this case.
  *
  * If the Oracle Client libraries cannot be loaded, or they have already been initialized, either by a
  * previous call to this function or because another function call already required the Oracle Client libraries,
  * then initOracleClient() raises an exception.
  *
  * On Linux, ensure a libclntsh.so file exists. On macOS ensure a libclntsh.dylib file exists.
  * Node-oracledb will not directly load libclntsh.*.XX.1 files in libDir. Note other libraries used by libclntsh* are also required.
  *
  * On Linux, using libDir is only useful for forcing initOracleClient() to immediately load the Oracle Client libraries because
  * those libraries still need to be in the operating system search path, such as from running ldconfig or set in the environment
  * variable LD_LIBRARY_PATH.
  *
  * @see https://oracle.github.io/node-oracledb/doc/api.html#initnodeoracledb
  * @since 5.0
  */
inline def initOracleClient(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("initOracleClient")().asInstanceOf[Unit]
inline def initOracleClient(opts: InitialiseOptions): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("initOracleClient")(opts.asInstanceOf[js.Any]).asInstanceOf[Unit]

/**
  * The maximum number of rows that are fetched by a query with connection.execute() when not using a ResultSet.
  * Rows beyond this limit are not fetched from the database. A value of 0 means there is no limit.
  *
  * This property may be overridden in an execute() call.
  *
  * To improve database efficiency, SQL queries should use a row limiting clause like OFFSET / FETCH or equivalent.
  * The maxRows property can be used to stop badly coded queries from returning unexpectedly large numbers of rows.
  *
  * When the number of query rows is relatively big, or can not be predicted, it is recommended to use
  * a ResultSet or queryStream(). This allows applications to process rows in smaller chunks or individually,
  * preventing the Node.js memory limit being exceeded or query results being unexpectedly truncated by a
  * maxRows limit.
  *
  * @default 0 (unlimited)
  */
inline def maxRows: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("maxRows").asInstanceOf[Double]
inline def maxRows_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("maxRows")(x.asInstanceOf[js.Any])

/**
  * This readonly property gives a numeric representation of the Oracle client library version which
  * is useful in comparisons. For version a.b.c.d.e, this property
  * gives the number: (100000000 * a) + (1000000 * b) + (10000 * c) + (100 * d) + e
  *
  * @since 1.3
  */
inline def oracleClientVersion: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("oracleClientVersion").asInstanceOf[Double]

/**
  * This readonly property gives a string representation of the Oracle client library version which is useful for display.
  *
  * @since 2.2
  */
inline def oracleClientVersionString: String = ^.asInstanceOf[js.Dynamic].selectDynamic("oracleClientVersionString").asInstanceOf[String]

/**
  * The format of query rows fetched when using connection.execute() or connection.queryStream().
  * It affects both ResultSet and non-ResultSet queries. It can be used for top level queries and REF CURSOR output.
  *
  * This can be either of the Oracledb constants oracledb.ARRAY or oracledb.OBJECT.
  *
  * If specified as oracledb.ARRAY, each row is fetched as an array of column values.
  *
  * If specified as oracledb.OBJECT, each row is fetched as a JavaScript object.
  * The object has a property for each column name, with the property value set to the respective column value.
  * The property name follows Oracle’s standard name-casing rules. It will commonly be uppercase,
  * since most applications create tables using unquoted, case-insensitive names.
  *
  * From node-oracledb 5.1, when duplicate column names are used in queries, then node-oracledb will append
  * numeric suffixes in oracledb.OUT_FORMAT_OBJECT mode as necessary, so that all columns are represented in the JavaScript object.
  *
  * This property may be overridden in an execute() or queryStream() call.
  *
  * @default ARRAY
  */
inline def outFormat: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("outFormat").asInstanceOf[Double]
inline def outFormat_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("outFormat")(x.asInstanceOf[js.Any])

/**
  * The number of connections that are opened whenever a connection request exceeds the number of currently open connections.
  *
  * This property may be overridden when creating a connection pool.
  *
  * @default 1
  */
inline def poolIncrement: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("poolIncrement").asInstanceOf[Double]
inline def poolIncrement_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("poolIncrement")(x.asInstanceOf[js.Any])

/**
  * The maximum number of connections to which a connection pool can grow.
  *
  * This property may be overridden when creating a connection pool.
  *
  * Importantly, if you increase poolMax you should also increase the number of threads available to node-oracledb.
  *
  * @default 4
  */
inline def poolMax: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("poolMax").asInstanceOf[Double]

/**
  * The maximum number of connections per shard for connection pools. This ensures that the pool is balanced towards each shard.
  *
  * This property may be overridden when creating a connection pool.
  *
  * When this property is set, and a new connection request would cause the number of connections to the target shard to exceed the limit,
  * then that new connection request will block until a suitable connection has been released back to the pool.
  * Importantly, when blocked, the queueTimeout value will be ignored and the pending connection request will consume one worker thread.
  *
  * @since 4.1
  */
inline def poolMaxPerShard: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("poolMaxPerShard").asInstanceOf[Double]
inline def poolMaxPerShard_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("poolMaxPerShard")(x.asInstanceOf[js.Any])

inline def poolMax_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("poolMax")(x.asInstanceOf[js.Any])

/**
  * The minimum number of connections a connection pool maintains, even when there is no activity to the target database.
  *
  * This property may be overridden when creating a connection pool.
  *
  * For pools created with External Authentication or with homogeneous set to false, the number of
  * connections initially created is zero even if a larger value is specified for poolMin.
  * The pool increment is always 1, regardless of the value of poolIncrement.
  * Once the number of open connections exceeds poolMin and connections are idle for more than
  * the poolTimeout seconds, then the number of open connections does not fall below poolMin.
  *
  * @default 0
  */
inline def poolMin: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("poolMin").asInstanceOf[Double]
inline def poolMin_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("poolMin")(x.asInstanceOf[js.Any])

/**
  * When a pool getConnection() is called and the connection has been idle in the pool for at least
  * poolPingInterval seconds, node-oracledb internally “pings” the database to check the connection is alive.
  * After a ping, an unusable connection is destroyed and a usable one is returned by getConnection().
  * Connection pinging improves the chance a pooled connection is valid when it is first used because
  * identified unusable connections will not be returned to the application.
  *
  * This property may be overridden when creating a connection pool.
  *
  * @default 60
  * @since 1.12
  */
inline def poolPingInterval: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("poolPingInterval").asInstanceOf[Double]
inline def poolPingInterval_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("poolPingInterval")(x.asInstanceOf[js.Any])

/**
  * The number of seconds after which idle connections (unused in the pool) are terminated.
  * Idle connections are terminated only when the pool is accessed. If the poolTimeout is set to 0,
  * then idle connections are never terminated.
  *
  * This property may be overridden when creating a connection pool.
  *
  * @default 60
  */
inline def poolTimeout: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("poolTimeout").asInstanceOf[Double]
inline def poolTimeout_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("poolTimeout")(x.asInstanceOf[js.Any])

/**
  * This is a query tuning option to set the number of additional rows the underlying Oracle Client library
  * fetches during the internal initial statement execution phase of a query. The prefetch size does not affect when, or how many,
  * rows are returned by node-oracledb to the application.
  *
  * The prefetchRows attribute can be used in conjunction with oracledb.fetchArraySize to tune query performance, memory use,
  * and to reduce the number of round-trip calls needed to return query results.
  *
  * The prefetchRows value is ignored in some cases, such as when the query involves a LOB.
  *
  * If you fetch a REF CURSOR, retrieve rows from that cursor, and then pass it back to a PL/SQL block, you should set
  * prefetchRows to 0 during the initial statement that gets the REF CURSOR. This ensures that rows are not internally
  * fetched from the REF CURSOR by node-oracledb thus making them unavailable in the final PL/SQL code.
  *
  * This property may be overridden in an connection.execute() call, which is preferred usage if you need to change the value.
  *
  * This attribute is not used in node-oracledb version 2, 3 or 4. In those versions use only oracledb.fetchArraySize instead.
  *
  * @default 2
  * @see https://oracle.github.io/node-oracledb/doc/api.html#rowfetching
  */
inline def prefetchRows: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("prefetchRows").asInstanceOf[Double]
inline def prefetchRows_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("prefetchRows")(x.asInstanceOf[js.Any])

/**
  * The maximum number of pending pool.getConnection() calls that can be queued.
  *
  * When the number of pool.getConnection() calls that have been queued waiting for an available connection reaches queueMax,
  * then any future pool.getConnection() calls will immediately return an error and will not be queued.
  *
  * If queueMax is -1, then the queue length is not limited.
  *
  * This property may be overridden when creating a connection pool.
  *
  * @default 500
  */
inline def queueMax: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("queueMax").asInstanceOf[Double]
inline def queueMax_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("queueMax")(x.asInstanceOf[js.Any])

/**
  * This property can be set to throw an error if concurrent operations are attempted 
  * on a single connection.
  *
  * The default value for errorOnConcurrentExecute is false.
  *
  * Each Oracle connection can only interact with the database for one operation at a time. 
  * Attempting to do more than one operation concurrently may be a sign of an incorrectly coded application, 
  * for example an await may be missing. 
  * Examples of operations that cannot be executed in parallel on a single connection include connection.execute(),
  *  connection.executeMany(), connection.queryStream(), connection.getDbObjectClass(), connection.commit(),
  *  connection.close(), SODA calls, and streaming from Lobs.
  */ 
inline def queueRequests: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("queueRequests").asInstanceOf[Double]
inline def queueRequests_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("queueRequests")(x.asInstanceOf[js.Any])

/**
  * The number of milliseconds after which connection requests waiting in the connection request queue are terminated.
  * If queueTimeout is 0, then queued connection requests are never terminated.
  *
  * This property may be overridden when creating a connection pool.
  *
  * @default 60000
  * @since 1.7
  */
inline def queueTimeout: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("queueTimeout").asInstanceOf[Double]
inline def queueTimeout_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("queueTimeout")(x.asInstanceOf[js.Any])

/**
  * This is the simplified form of connection.shutdown() used for shutting down a database instance. It accepts connection
  * credentials and shuts the database instance completely down.
  *
  * Internally it creates, and closes, a standalone connection using the oracledb.SYSOPER privilege.
  *
  * @see https://oracle.github.io/node-oracledb/doc/api.html#startupshutdown
  * @since 5.0
  */
inline def shutdown(creds: DBCredentials): js.Promise[Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("shutdown")(creds.asInstanceOf[js.Any]).asInstanceOf[js.Promise[Unit]]
inline def shutdown(creds: DBCredentials, cb: js.Function1[/* err */ js.Error, Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("shutdown")(creds.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def shutdown(creds: DBCredentials, mode: Double): js.Promise[Unit] = (^.asInstanceOf[js.Dynamic].applyDynamic("shutdown")(creds.asInstanceOf[js.Any], mode.asInstanceOf[js.Any])).asInstanceOf[js.Promise[Unit]]
inline def shutdown(creds: DBCredentials, mode: Double, cb: js.Function1[/* err */ js.Error, Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("shutdown")(creds.asInstanceOf[js.Any], mode.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[Unit]

/**
  * This is the simplified form of connection.startup() used for starting a database instance up.
  * It accepts connection credentials and starts the database instance completely.
  *
  * As part of the start up process, a standalone connection using the oracledb.SYSOPER privilege is internally created and closed.
  *
  * @see https://oracle.github.io/node-oracledb/doc/api.html#startupshutdown
  * @since 5.0
  */
inline def startup(creds: DBCredentials): js.Promise[Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("startup")(creds.asInstanceOf[js.Any]).asInstanceOf[js.Promise[Unit]]
inline def startup(creds: DBCredentials, cb: js.Function1[/* err */ js.Error, Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("startup")(creds.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[Unit]
inline def startup(creds: DBCredentials, opts: StartupOptions): js.Promise[Unit] = (^.asInstanceOf[js.Dynamic].applyDynamic("startup")(creds.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[js.Promise[Unit]]
inline def startup(creds: DBCredentials, opts: StartupOptions, cb: js.Function1[/* err */ js.Error, Unit]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("startup")(creds.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[Unit]

/**
  * The number of statements that are cached in the statement cache of each connection.
  *
  * This property may be overridden for specific Pool or Connection objects.
  *
  * In general, set the statement cache to the size of the working set of statements being
  * executed by the application. Statement caching can be disabled by setting the size to 0.
  *
  * @default 30
  */
inline def stmtCacheSize: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("stmtCacheSize").asInstanceOf[Double]
inline def stmtCacheSize_=(x: Double): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("stmtCacheSize")(x.asInstanceOf[js.Any])

/**
  * This readonly property gives a numeric representation of the node-oracledb version.
  * For version x.y.z, this property gives the number: (10000 * x) + (100 * y) + z
  */
inline def version: Double = ^.asInstanceOf[js.Dynamic].selectDynamic("version").asInstanceOf[Double]

/**
  * This readonly property gives a string representation of the node-oracledb version, including the version suffix if one is present.
  *
  * @since 2.1
  */
inline def versionString: String = ^.asInstanceOf[js.Dynamic].selectDynamic("versionString").asInstanceOf[String]

/**
  * This readonly property gives a string representing the version suffix (e.g. “-dev” or “-beta”) or an empty string if no version suffix is present.
  *
  * @since 2.1
  */
inline def versionSuffix: String = ^.asInstanceOf[js.Dynamic].selectDynamic("versionSuffix").asInstanceOf[String]

/**
  * Used with connection.execute() to associate values or JavaScript variables to a statement’s bind variables by name.
  *
  * @see https://oracle.github.io/node-oracledb/doc/api.html#executebindParams
  */
type BindParameters = (Record[
String, 
js.UndefOr[BindParameter | String | Double | js.Date | DBObjectIN[Any] | Buffer | Null]]) | (js.Array[Any | BindParameter])

/**
  * @see https://oracle.github.io/node-oracledb/doc/api.html#objects
  * @since 4.0
  */
type DBObjectIN[T] = DBObject_IN & TopLevel[T] & BaseDBObject[T]

/**
  * @see https://oracle.github.io/node-oracledb/doc/api.html#objects
  * @since 4.0
  */
type DBObjectOUT[T] = DBObject_OUT & TopLevel[T] & BaseDBObject[T]

type EnqueueMessage[T] = String | Buffer | DBObjectIN[T] | Correlation[T]
