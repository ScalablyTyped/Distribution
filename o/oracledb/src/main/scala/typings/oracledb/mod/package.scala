package typings.oracledb.mod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}


/** Constant for the AqDeqOptions Class 'mode' */
@scala.inline
def AQ_DEQ_MODE_BROWSE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_MODE_BROWSE").asInstanceOf[scala.Double]

/** Constant for the AqDeqOptions Class 'mode' */
@scala.inline
def AQ_DEQ_MODE_LOCKED: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_MODE_LOCKED").asInstanceOf[scala.Double]

/** Constant for the AqDeqOptions Class 'mode' */
@scala.inline
def AQ_DEQ_MODE_REMOVE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_MODE_REMOVE").asInstanceOf[scala.Double]

/** Constant for the AqDeqOptions Class 'mode' */
@scala.inline
def AQ_DEQ_MODE_REMOVE_NO_DAT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_MODE_REMOVE_NO_DAT").asInstanceOf[scala.Double]

/** Constant for the AqDeqOptions Class 'navigation' */
@scala.inline
def AQ_DEQ_NAV_FIRST_MSG: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_NAV_FIRST_MSG").asInstanceOf[scala.Double]

/** Constant for the AqDeqOptions Class 'navigation' */
@scala.inline
def AQ_DEQ_NAV_NEXT_MS: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_NAV_NEXT_MS").asInstanceOf[scala.Double]

/** Constant for the AqDeqOptions Class 'navigation' */
@scala.inline
def AQ_DEQ_NAV_NEXT_TRANSACTION: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_NAV_NEXT_TRANSACTION").asInstanceOf[scala.Double]

/** Constant for the AqDeqOptions Class 'wait' */
@scala.inline
def AQ_DEQ_NO_WAIT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_NO_WAIT").asInstanceOf[scala.Double]

/** Constant for the AqEnqOptions Class 'deliveryMode' */
@scala.inline
def AQ_DEQ_WAAQ_MSG_DELIV_MODE_PERSISTENTIT_FOREVER: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_WAAQ_MSG_DELIV_MODE_PERSISTENTIT_FOREVER").asInstanceOf[scala.Double]

/** Constant for the AqDeqOptions Class 'wait' */
@scala.inline
def AQ_DEQ_WAIT_FOREVER: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_DEQ_WAIT_FOREVER").asInstanceOf[scala.Double]

/** Constant for the AqEnqOptions Class 'deliveryMode' */
@scala.inline
def AQ_MSG_DELIV_MODE_BUFFERED: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_DELIV_MODE_BUFFERED").asInstanceOf[scala.Double]

/** Constant for the AqEnqOptions Class 'deliveryMode' */
@scala.inline
def AQ_MSG_DELIV_MODE_PERSISTENT_OR_BUFFERED: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_DELIV_MODE_PERSISTENT_OR_BUFFERED").asInstanceOf[scala.Double]

/** Constant for the AqMessage Class 'state' */
@scala.inline
def AQ_MSG_STATE_EXPIRED: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_STATE_EXPIRED").asInstanceOf[scala.Double]

/** Constant for the AqMessage Class 'state' */
@scala.inline
def AQ_MSG_STATE_PROCESSED: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_STATE_PROCESSED").asInstanceOf[scala.Double]

/** Constant for the AqMessage Class 'state' */
@scala.inline
def AQ_MSG_STATE_READY: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_STATE_READY").asInstanceOf[scala.Double]

/** Constant for the AqMessage Class 'state' */
@scala.inline
def AQ_MSG_STATE_WAITING: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_MSG_STATE_WAITING").asInstanceOf[scala.Double]

/** Constant for the AqEnqOptions Class and AqDeqOptions 'visibility' */
@scala.inline
def AQ_VISIBILITY_IMMEDIATE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_VISIBILITY_IMMEDIATE").asInstanceOf[scala.Double]

/** Constant for the AqEnqOptions Class and AqDeqOptions 'visibility' */
@scala.inline
def AQ_VISIBILITY_ON_COMMIT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("AQ_VISIBILITY_ON_COMMIT").asInstanceOf[scala.Double]

/** Constant for the dir property of execute() bindParams, queryStream() and executeMany() bindDefs. */
@scala.inline
def BIND_IN: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("BIND_IN").asInstanceOf[scala.Double]

/** Constant for the dir property of execute() bindParams, queryStream() and executeMany() bindDefs. */
@scala.inline
def BIND_INOUT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("BIND_INOUT").asInstanceOf[scala.Double]

/** Constant for the dir property of execute() bindParams, queryStream() and executeMany() bindDefs. */
@scala.inline
def BIND_OUT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("BIND_OUT").asInstanceOf[scala.Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
@scala.inline
def BLOB: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("BLOB").asInstanceOf[scala.Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
@scala.inline
def BUFFER: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("BUFFER").asInstanceOf[scala.Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
@scala.inline
def CLOB: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CLOB").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
@scala.inline
def CQN_OPCODE_ALL_OPS: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_ALL_OPS").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
@scala.inline
def CQN_OPCODE_ALL_ROWS: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_ALL_ROWS").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
@scala.inline
def CQN_OPCODE_ALTER: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_ALTER").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
@scala.inline
def CQN_OPCODE_DELETE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_DELETE").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
@scala.inline
def CQN_OPCODE_DROP: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_DROP").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
@scala.inline
def CQN_OPCODE_INSERT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_INSERT").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification connection.subscribe() option operations, and for the notification message operation properties. */
@scala.inline
def CQN_OPCODE_UPDATE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CQN_OPCODE_UPDATE").asInstanceOf[scala.Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
@scala.inline
def CURSOR: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("CURSOR").asInstanceOf[scala.Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
@scala.inline
def DATE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DATE").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_BFILE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BFILE").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_BINARY_DOUBLE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BINARY_DOUBLE").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_BINARY_FLOAT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BINARY_FLOAT").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_BINARY_INTEGER: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BINARY_INTEGER").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_BLOB: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BLOB").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_BOOLEAN: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_BOOLEAN").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_CHAR: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_CHAR").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_CLOB: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_CLOB").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_CURSOR: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_CURSOR").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_DATE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_DATE").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_INTERVAL_DS: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_INTERVAL_DS").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_INTERVAL_YM: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_INTERVAL_YM").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_LONG: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_LONG").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_LONG_RAW: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_LONG_RAW").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_NCHAR: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_NCHAR").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_NCLOB: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_NCLOB").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_NUMBER: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_NUMBER").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_NVARCHAR: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_NVARCHAR").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_OBJECT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_OBJECT").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_RAW: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_RAW").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_ROWID: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_ROWID").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_TIMESTAMP: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_TIMESTAMP").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_TIMESTAMP_LTZ: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_TIMESTAMP_LTZ").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_TIMESTAMP_TZ: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_TIMESTAMP_TZ").asInstanceOf[scala.Double]

/** Constant which represents the Oracle Database type. */
@scala.inline
def DB_TYPE_VARCHAR: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DB_TYPE_VARCHAR").asInstanceOf[scala.Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
@scala.inline
def DEFAULT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("DEFAULT").asInstanceOf[scala.Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
@scala.inline
def NCLOB: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("NCLOB").asInstanceOf[scala.Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
@scala.inline
def NUMBER: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("NUMBER").asInstanceOf[scala.Double]

/** Deprecated */
// const ARRAY: number;
// const OBJECT: number;
/** Constant for the query result outFormat option. */
@scala.inline
def OUT_FORMAT_ARRAY: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("OUT_FORMAT_ARRAY").asInstanceOf[scala.Double]

/** Constant for the query result outFormat option. */
@scala.inline
def OUT_FORMAT_OBJECT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("OUT_FORMAT_OBJECT").asInstanceOf[scala.Double]

/** Constant for the connection pool.status readonly attribute. */
@scala.inline
def POOL_STATUS_CLOSED: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("POOL_STATUS_CLOSED").asInstanceOf[scala.Double]

/** Constant for the connection pool.status readonly attribute. */
@scala.inline
def POOL_STATUS_DRAINING: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("POOL_STATUS_DRAINING").asInstanceOf[scala.Double]

/** Constant for the connection pool.status readonly attribute. */
@scala.inline
def POOL_STATUS_OPEN: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("POOL_STATUS_OPEN").asInstanceOf[scala.Double]

/**
  * The oracledb.Promise property is no longer used in node-oracledb 5 and has no effect.
  * 
  * Node-oracledb supports Promises on all methods. The native Promise library is used.
  * 
  * @deprecated 5.0
  */
@scala.inline
def Promise: js.Promise[js.Any] = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("Promise").asInstanceOf[js.Promise[js.Any]]
@scala.inline
def Promise_=(x: js.Promise[js.Any]): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("Promise")(x.asInstanceOf[js.Any])

/** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
@scala.inline
def SHUTDOWN_MODE_ABORT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_ABORT").asInstanceOf[scala.Double]

/** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
@scala.inline
def SHUTDOWN_MODE_DEFAULT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_DEFAULT").asInstanceOf[scala.Double]

/** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
@scala.inline
def SHUTDOWN_MODE_FINAL: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_FINAL").asInstanceOf[scala.Double]

/** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
@scala.inline
def SHUTDOWN_MODE_IMMEDIATE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_IMMEDIATE").asInstanceOf[scala.Double]

/** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
@scala.inline
def SHUTDOWN_MODE_TRANSACTIONAL: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_TRANSACTIONAL").asInstanceOf[scala.Double]

/** Constant for shutting down the Oracle database with oracledb.shutdown() and connection.shutdown() */
@scala.inline
def SHUTDOWN_MODE_TRANSACTIONAL_LOCAL: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SHUTDOWN_MODE_TRANSACTIONAL_LOCAL").asInstanceOf[scala.Double]

/** Constant for the sodaDatabase.createCollection() mode property. */
@scala.inline
def SODA_COLL_MAP_MODE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SODA_COLL_MAP_MODE").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_ALTER: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_ALTER").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_BEGIN: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_BEGIN").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_CALL: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_CALL").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_COMMIT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_COMMIT").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_CREATE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_CREATE").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_DECLARE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_DECLARE").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_DELETE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_DELETE").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_DROP: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_DROP").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_EXPLAIN_PLAN: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_EXPLAIN_PLAN").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_INSERT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_INSERT").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_MERGE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_MERGE").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_ROLLBACK: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_ROLLBACK").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_SELECT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_SELECT").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_UNKNOWN: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_UNKNOWN").asInstanceOf[scala.Double]

/** Constant for connection.getStatementInfo() properties. */
@scala.inline
def STMT_TYPE_UPDATE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STMT_TYPE_UPDATE").asInstanceOf[scala.Double]

/** Constant for execute() bind parameter type property, for the createLob() type parameter, for the Lob type property, for fetchAsBuffer, for fetchAsString and fetchInfo, and for extended metadata. */
@scala.inline
def STRING: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("STRING").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification message.type. */
@scala.inline
def SUBSCR_EVENT_TYPE_AQ: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_AQ").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification message.type. */
@scala.inline
def SUBSCR_EVENT_TYPE_DEREG: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_DEREG").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification message.type. */
@scala.inline
def SUBSCR_EVENT_TYPE_OBJ_CHANGE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_OBJ_CHANGE").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification message.type. */
@scala.inline
def SUBSCR_EVENT_TYPE_QUERY_CHANGE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_QUERY_CHANGE").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification message.type. */
@scala.inline
def SUBSCR_EVENT_TYPE_SHUTDOWN: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_SHUTDOWN").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification message.type. */
@scala.inline
def SUBSCR_EVENT_TYPE_SHUTDOWN_ANY: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_SHUTDOWN_ANY").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification message.type. */
@scala.inline
def SUBSCR_EVENT_TYPE_STARTUP: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_EVENT_TYPE_STARTUP").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification groupingClass. */
@scala.inline
def SUBSCR_GROUPING_CLASS_TIME: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_GROUPING_CLASS_TIME").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification groupingType. */
@scala.inline
def SUBSCR_GROUPING_TYPE_LAST: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_GROUPING_TYPE_LAST").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification groupingType. */
@scala.inline
def SUBSCR_GROUPING_TYPE_SUMMARY: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_GROUPING_TYPE_SUMMARY").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification namespace. */
@scala.inline
def SUBSCR_NAMESPACE_AQ: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_NAMESPACE_AQ").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification namespace. */
@scala.inline
def SUBSCR_NAMESPACE_DBCHANGE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_NAMESPACE_DBCHANGE").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification qos Quality of Service. */
@scala.inline
def SUBSCR_QOS_BEST_EFFORT: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_BEST_EFFORT").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification qos Quality of Service. */
@scala.inline
def SUBSCR_QOS_DEREG_NFY: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_DEREG_NFY").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification qos Quality of Service. */
@scala.inline
def SUBSCR_QOS_QUERY: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_QUERY").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification qos Quality of Service. */
@scala.inline
def SUBSCR_QOS_RELIABLE: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_RELIABLE").asInstanceOf[scala.Double]

/** Constant for the Continuous Query Notification qos Quality of Service. */
@scala.inline
def SUBSCR_QOS_ROWIDS: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SUBSCR_QOS_ROWIDS").asInstanceOf[scala.Double]

/** Constant for getConnection() privilege properties. */
@scala.inline
def SYSASM: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSASM").asInstanceOf[scala.Double]

/** Constant for getConnection() privilege properties. */
@scala.inline
def SYSBACKUP: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSBACKUP").asInstanceOf[scala.Double]

/** Constant for getConnection() privilege properties. */
@scala.inline
def SYSDBA: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSDBA").asInstanceOf[scala.Double]

/** Constant for getConnection() privilege properties. */
@scala.inline
def SYSDG: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSDG").asInstanceOf[scala.Double]

/** Constant for getConnection() privilege properties. */
@scala.inline
def SYSKM: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSKM").asInstanceOf[scala.Double]

/** Constant for getConnection() privilege properties. */
@scala.inline
def SYSOPER: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSOPER").asInstanceOf[scala.Double]

/** Constant for getConnection() privilege properties. */
@scala.inline
def SYSPRELIM: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSPRELIM").asInstanceOf[scala.Double]

/** Constant for getConnection() privilege properties. */
@scala.inline
def SYSRAC: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("SYSRAC").asInstanceOf[scala.Double]

/**
  * If true, the transaction in the current connection is automatically committed at the end of statement execution.
  * This property may be overridden in an execute() call.
  *
  * @default false
  * @since 0.5
  */
@scala.inline
def autoCommit: scala.Boolean = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("autoCommit").asInstanceOf[scala.Boolean]
@scala.inline
def autoCommit_=(x: scala.Boolean): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("autoCommit")(x.asInstanceOf[js.Any])

/**
  * The user-chosen Connection class value defines a logical name for connections.
  * Most single purpose applications should set connectionClass when using a connection pool or DRCP.
  *
  * When a pooled session has a connection class, Oracle ensures that the session is not shared outside of that connection class.
  *
  * The connection class value is similarly used by Database Resident Connection Pooling (DRCP) to allow or disallow sharing of sessions.
  *
  * For example, where two different kinds of users share one pool, you might set connectionClass to ‘HRPOOL’ for connections that
  * access a Human Resources system, and it might be set to ‘OEPOOL’ for users of an Order Entry system.
  * Users will only be given sessions of the appropriate class, allowing maximal reuse of resources in each case,
  * and preventing any session information leaking between the two systems.
  *
  * If connectionClass is set for a non-pooled connection, the driver name is not recorded in V$ views.
  */
@scala.inline
def connectionClass: java.lang.String = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("connectionClass").asInstanceOf[java.lang.String]
@scala.inline
def connectionClass_=(x: java.lang.String): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("connectionClass")(x.asInstanceOf[js.Any])

/**
  * This method creates a pool of connections with the specified user name, password and connection string.
  * A pool is typically created once during application initialization.
  *
  * Internally, createPool() creates an Oracle Call Interface Session Pool for each Pool object.
  *
  * The default properties may be overridden by specifying new properties in the poolAttrs parameter.
  *
  * It is possible to add pools to the pool cache when calling createPool().
  * This allows pools to later be accessed by name, removing the need to pass the pool object through code.
  *
  * A pool should be terminated with the pool.close() call.
  *
  * From node-oracledb 3.1.0, the createPool() error callback will return a DPI-1047 error if node-oracledb cannot load Oracle Client libraries.
  * Previous versions threw this error from require('oracledb').
  *
  * @param poolAttributes Provides connection credentials and pool-specific configuration properties, overriding the defualt pooling properties of the Oracledb object.
  */
@scala.inline
def createPool(poolAttributes: typings.oracledb.mod.PoolAttributes): js.Promise[typings.oracledb.mod.Pool] = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createPool")(poolAttributes.asInstanceOf[js.Any]).asInstanceOf[js.Promise[typings.oracledb.mod.Pool]]
@scala.inline
def createPool(
  poolAttributes: typings.oracledb.mod.PoolAttributes,
  callback: js.Function2[
  /* error */ typings.oracledb.mod.DBError, 
  /* pool */ typings.oracledb.mod.Pool, 
  scala.Unit
]
): scala.Unit = (typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("createPool")(poolAttributes.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

/**
  * Sets the name used for Edition-Based Redefinition by connections.
  *
  * @since 2.2
  */
@scala.inline
def edition: java.lang.String = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("edition").asInstanceOf[java.lang.String]
@scala.inline
def edition_=(x: java.lang.String): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("edition")(x.asInstanceOf[js.Any])

/**
  * Determines whether Oracle Client events mode should be enabled.
  *
  * This property can be overridden in the oracledb.createPool() call and when getting a standalone connection from oracledb.getConnection().
  *
  * Events mode is required for Continuous Query Notification, Fast Application Notification (FAN) and Runtime Load Balancing (RLB).
  *
  * @default true
  * @since 2.2
  */
@scala.inline
def events: scala.Boolean = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("events").asInstanceOf[scala.Boolean]
@scala.inline
def events_=(x: scala.Boolean): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("events")(x.asInstanceOf[js.Any])

/**
  * Determines whether additional metadata is available for queries and for REF CURSORs returned from PL/SQL blocks.
  *
  * With this value, the result.metaData result.resultSet.metaData objects only include column names.
  *
  * If extendedMetaData is true then metaData will contain additional attributes.
  *
  * This property may be overridden in an execute() call.
  *
  * @default false
  * @since 1.10
  */
@scala.inline
def extendedMetaData: scala.Boolean = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("extendedMetaData").asInstanceOf[scala.Boolean]
@scala.inline
def extendedMetaData_=(x: scala.Boolean): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("extendedMetaData")(x.asInstanceOf[js.Any])

/**
  * If true, connections will be established using external authentication.
  *
  * The user and password properties should not be set when externalAuth is true.
  *
  * This property can be overridden in the oracledb.createPool() call and when getting a standalone connection from oracledb.getConnection().
  *
  * @default false
  * @since 0.5
  */
@scala.inline
def externalAuth: scala.Boolean = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("externalAuth").asInstanceOf[scala.Boolean]
@scala.inline
def externalAuth_=(x: scala.Boolean): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("externalAuth")(x.asInstanceOf[js.Any])

/**
  * This property sets the size of an internal buffer used for fetching query rows from Oracle Database.
  * Changing it may affect query performance but does not affect how many rows are returned to the application.
  *
  * The property is used during the default direct fetches, during ResultSet getRow() calls, and for queryStream(). It is not used for getRows().
  *
  * Increasing this value reduces the number of round-trips to the database but increases memory usage for each data fetch.
  * For queries that return a large number of rows, higher values of fetchArraySize may give better performance.
  * For queries that only return a few rows, reduce the value of fetchArraySize to minimize the amount of memory management during data fetches.
  * JavaScript memory fragmentation may occur in some cases.
  *
  * For direct fetches (those using execute() option resultSet: false), the internal buffer size will be based on the lesser of maxRows and fetchArraySize.
  *
  * @default 100
  * @since 2.0
  */
@scala.inline
def fetchArraySize: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("fetchArraySize").asInstanceOf[scala.Double]
@scala.inline
def fetchArraySize_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("fetchArraySize")(x.asInstanceOf[js.Any])

/**
  * Configure data types to be returned as a Buffer instead of the default representation when queried with execute() or queryStream().
  *
  * Currently the only valid type is oracledb.BLOB.
  *
  * By default in node-oracledb, all columns are returned as native types or as Lob instances, in the case of CLOB and BLOB types.
  *
  * Individual query columns in execute() or queryStream() calls can override the fetchAsBuffer global setting by using fetchInfo.
  *
  * @since 1.13
  */
@scala.inline
def fetchAsBuffer: js.Array[scala.Double] = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("fetchAsBuffer").asInstanceOf[js.Array[scala.Double]]
@scala.inline
def fetchAsBuffer_=(x: js.Array[scala.Double]): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("fetchAsBuffer")(x.asInstanceOf[js.Any])

/**
  * An array of node-oracledb types. The valid types are oracledb.DATE, oracledb.NUMBER, oracledb.BUFFER, and oracledb.CLOB.
  * When any column having one of the specified types is queried with execute() or queryStream(), the column data is returned as a string instead of the default representation.
  *
  * By default in node-oracledb, all columns are returned as native types or as Lob instances, in the case of CLOB and BLOB types.
  *
  * This property helps avoid situations where using JavaScript types can lead to numeric precision loss, or where date conversion is unwanted.
  *
  * For raw data returned as a string, Oracle returns the data as a hex-encoded string.
  * For dates and numbers returned as a string, the maximum length of a string created by this mapping is 200 bytes.
  * Strings created for CLOB columns will generally be limited by Node.js and V8 memory restrictions.
  *
  * Individual query columns in execute() or queryStream() calls can override the fetchAsString global setting by using fetchInfo.
  *
  * For non-CLOB types, the conversion to string is handled by Oracle client libraries and is often referred to as defining the fetch type.
  */
@scala.inline
def fetchAsString: js.Array[scala.Double] = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("fetchAsString").asInstanceOf[js.Array[scala.Double]]
@scala.inline
def fetchAsString_=(x: js.Array[scala.Double]): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("fetchAsString")(x.asInstanceOf[js.Any])

/**
  * Obtains a connection from the default pool.
  *
  * For situations where connections are used infrequently, creating a standalone connection may be more efficient than creating and managing a connection pool.
  * However, in most cases, Oracle recommends getting connections from a connection pool.
  */
@scala.inline
def getConnection(): js.Promise[typings.oracledb.mod.Connection] = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")().asInstanceOf[js.Promise[typings.oracledb.mod.Connection]]
@scala.inline
def getConnection(
  callback: js.Function2[
  /* error */ typings.oracledb.mod.DBError, 
  /* connection */ typings.oracledb.mod.Connection, 
  scala.Unit
]
): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(callback.asInstanceOf[js.Any]).asInstanceOf[scala.Unit]
/**
  * Creates a new, standalone, non-pooled connection.
  *
  * For situations where connections are used infrequently, creating a standalone connection may be more efficient than creating and managing a connection pool.
  * However, in most cases, Oracle recommends getting connections from a connection pool.
  *
  * @param connectionAttributes Connection credentials and connection-specific configuration properties.
  */
@scala.inline
def getConnection(connectionAttributes: typings.oracledb.mod.ConnectionAttributes): js.Promise[typings.oracledb.mod.Connection] = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(connectionAttributes.asInstanceOf[js.Any]).asInstanceOf[js.Promise[typings.oracledb.mod.Connection]]
@scala.inline
def getConnection(
  connectionAttributes: typings.oracledb.mod.ConnectionAttributes,
  callback: js.Function2[
  /* error */ typings.oracledb.mod.DBError, 
  /* connection */ typings.oracledb.mod.Connection, 
  scala.Unit
]
): scala.Unit = (typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(connectionAttributes.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
/**
  * Obtains a connection from a pool in the connection pool cache.
  *
  * For situations where connections are used infrequently, creating a standalone connection may be more efficient than creating and managing a connection pool.
  * However, in most cases, Oracle recommends getting connections from a connection pool.
  *
  * @param poolAlias Specifies which previously created pool in the connection pool cache to use to obtain the connection.
  */
@scala.inline
def getConnection(poolAlias: java.lang.String): js.Promise[typings.oracledb.mod.Connection] = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(poolAlias.asInstanceOf[js.Any]).asInstanceOf[js.Promise[typings.oracledb.mod.Connection]]
@scala.inline
def getConnection(
  poolAlias: java.lang.String,
  callback: js.Function2[
  /* error */ typings.oracledb.mod.DBError, 
  /* connection */ typings.oracledb.mod.Connection, 
  scala.Unit
]
): scala.Unit = (typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getConnection")(poolAlias.asInstanceOf[js.Any], callback.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

/**
  * Retrieves a previously created pool from the connection pool cache. Note that this is a synchronous method.
  *
  * @param poolAlias
  *
  * The pool alias of the pool to retrieve from the connection pool cache.
  *
  * @default default
  */
@scala.inline
def getPool(): typings.oracledb.mod.Pool = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getPool")().asInstanceOf[typings.oracledb.mod.Pool]
@scala.inline
def getPool(poolAlias: java.lang.String): typings.oracledb.mod.Pool = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("getPool")(poolAlias.asInstanceOf[js.Any]).asInstanceOf[typings.oracledb.mod.Pool]

/**
  * This synchronous function loads and initializes the Oracle Client libraries that are necessary
  * for node-oracledb to communicate with Oracle Database. This function is optional. If used, it
  * should be the first node-oracledb call made by an application.
  * 
  * If initOracleClient() is not called, then the Oracle Client libraries are loaded at the time of
  * first use in the application, such as when creating a connection pool. The default values described
  * for options will be used in this case.
  * 
  * If the Oracle Client libraries cannot be loaded, or they have already been initialized, either by a
  * previous call to this function or because another function call already required the Oracle Client libraries,
  * then initOracleClient() raises an exception.
  * 
  * On Linux, ensure a libclntsh.so file exists. On macOS ensure a libclntsh.dylib file exists.
  * Node-oracledb will not directly load libclntsh.*.XX.1 files in libDir. Note other libraries used by libclntsh* are also required.
  * 
  * On Linux, using libDir is only useful for forcing initOracleClient() to immediately load the Oracle Client libraries because
  * those libraries still need to be in the operating system search path, such as from running ldconfig or set in the environment
  * variable LD_LIBRARY_PATH.
  * 
  * @see https://oracle.github.io/node-oracledb/doc/api.html#initnodeoracledb
  * @since 5.0
  */
@scala.inline
def initOracleClient(): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("initOracleClient")().asInstanceOf[scala.Unit]
@scala.inline
def initOracleClient(opts: typings.oracledb.mod.InitialiseOptions): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("initOracleClient")(opts.asInstanceOf[js.Any]).asInstanceOf[scala.Unit]

/**
  * The maximum number of rows that are fetched by a query with connection.execute() when not using a ResultSet.
  * Rows beyond this limit are not fetched from the database. A value of 0 means there is no limit.
  *
  * This property may be overridden in an execute() call.
  *
  * To improve database efficiency, SQL queries should use a row limiting clause like OFFSET / FETCH or equivalent.
  * The maxRows property can be used to stop badly coded queries from returning unexpectedly large numbers of rows.
  *
  * When the number of query rows is relatively big, or can not be predicted, it is recommended to use
  * a ResultSet or queryStream(). This allows applications to process rows in smaller chunks or individually,
  * preventing the Node.js memory limit being exceeded or query results being unexpectedly truncated by a
  * maxRows limit.
  *
  * @default 0 (unlimited)
  */
@scala.inline
def maxRows: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("maxRows").asInstanceOf[scala.Double]
@scala.inline
def maxRows_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("maxRows")(x.asInstanceOf[js.Any])

/**
  * This readonly property gives a numeric representation of the Oracle client library version which
  * is useful in comparisons. For version a.b.c.d.e, this property
  * gives the number: (100000000 * a) + (1000000 * b) + (10000 * c) + (100 * d) + e
  *
  * @since 1.3
  */
@scala.inline
def oracleClientVersion: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("oracleClientVersion").asInstanceOf[scala.Double]

/**
  * This readonly property gives a string representation of the Oracle client library version which is useful for display.
  *
  * @since 2.2
  */
@scala.inline
def oracleClientVersionString: java.lang.String = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("oracleClientVersionString").asInstanceOf[java.lang.String]

/**
  * The format of query rows fetched when using connection.execute() or connection.queryStream().
  * It affects both ResultSet and non-ResultSet queries. It can be used for top level queries and REF CURSOR output.
  *
  * This can be either of the Oracledb constants oracledb.ARRAY or oracledb.OBJECT.
  *
  * If specified as oracledb.ARRAY, each row is fetched as an array of column values.
  *
  * If specified as oracledb.OBJECT, each row is fetched as a JavaScript object.
  * The object has a property for each column name, with the property value set to the respective column value.
  * The property name follows Oracle’s standard name-casing rules. It will commonly be uppercase,
  * since most applications create tables using unquoted, case-insensitive names.
  *
  * This property may be overridden in an execute() or queryStream() call.
  *
  * @default ARRAY
  */
@scala.inline
def outFormat: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("outFormat").asInstanceOf[scala.Double]
@scala.inline
def outFormat_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("outFormat")(x.asInstanceOf[js.Any])

/**
  * The number of connections that are opened whenever a connection request exceeds the number of currently open connections.
  *
  * This property may be overridden when creating a connection pool.
  *
  * @default 1
  */
@scala.inline
def poolIncrement: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("poolIncrement").asInstanceOf[scala.Double]
@scala.inline
def poolIncrement_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("poolIncrement")(x.asInstanceOf[js.Any])

/**
  * The maximum number of connections to which a connection pool can grow.
  *
  * This property may be overridden when creating a connection pool.
  *
  * Importantly, if you increase poolMax you should also increase the number of threads available to node-oracledb.
  *
  * @default 4
  */
@scala.inline
def poolMax: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("poolMax").asInstanceOf[scala.Double]

/**
  * The maximum number of connections per shard for connection pools. This ensures that the pool is balanced towards each shard.
  * 
  * This property may be overridden when creating a connection pool.
  * 
  * When this property is set, and a new connection request would cause the number of connections to the target shard to exceed the limit,
  * then that new connection request will block until a suitable connection has been released back to the pool.
  * Importantly, when blocked, the queueTimeout value will be ignored and the pending connection request will consume one worker thread.
  * 
  * @since 4.1
  */
@scala.inline
def poolMaxPerShard: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("poolMaxPerShard").asInstanceOf[scala.Double]
@scala.inline
def poolMaxPerShard_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("poolMaxPerShard")(x.asInstanceOf[js.Any])

@scala.inline
def poolMax_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("poolMax")(x.asInstanceOf[js.Any])

/**
  * The minimum number of connections a connection pool maintains, even when there is no activity to the target database.
  *
  * This property may be overridden when creating a connection pool.
  *
  * For pools created with External Authentication or with homogeneous set to false, the number of
  * connections initially created is zero even if a larger value is specified for poolMin.
  * The pool increment is always 1, regardless of the value of poolIncrement.
  * Once the number of open connections exceeds poolMin and connections are idle for more than
  * the poolTimeout seconds, then the number of open connections does not fall below poolMin.
  *
  * @default 0
  */
@scala.inline
def poolMin: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("poolMin").asInstanceOf[scala.Double]
@scala.inline
def poolMin_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("poolMin")(x.asInstanceOf[js.Any])

/**
  * When a pool getConnection() is called and the connection has been idle in the pool for at least
  * poolPingInterval seconds, node-oracledb internally “pings” the database to check the connection is alive.
  * After a ping, an unusable connection is destroyed and a usable one is returned by getConnection().
  * Connection pinging improves the chance a pooled connection is valid when it is first used because
  * identified unusable connections will not be returned to the application.
  *
  * This property may be overridden when creating a connection pool.
  *
  * @default 60
  * @since 1.12
  */
@scala.inline
def poolPingInterval: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("poolPingInterval").asInstanceOf[scala.Double]
@scala.inline
def poolPingInterval_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("poolPingInterval")(x.asInstanceOf[js.Any])

/**
  * The number of seconds after which idle connections (unused in the pool) are terminated.
  * Idle connections are terminated only when the pool is accessed. If the poolTimeout is set to 0,
  * then idle connections are never terminated.
  *
  * This property may be overridden when creating a connection pool.
  *
  * @default 60
  */
@scala.inline
def poolTimeout: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("poolTimeout").asInstanceOf[scala.Double]
@scala.inline
def poolTimeout_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("poolTimeout")(x.asInstanceOf[js.Any])

/**
  * This is a query tuning option to set the number of additional rows the underlying Oracle Client library
  * fetches during the internal initial statement execution phase of a query. The prefetch size does not affect when, or how many,
  * rows are returned by node-oracledb to the application.
  * 
  * The prefetchRows attribute can be used in conjunction with oracledb.fetchArraySize to tune query performance, memory use,
  * and to reduce the number of round-trip calls needed to return query results.
  * 
  * The prefetchRows value is ignored in some cases, such as when the query involves a LOB.
  * 
  * This property may be overridden in an connection.execute() call, which is preferred usage if you need to change the value.
  * 
  * This attribute is not used in node-oracledb version 2, 3 or 4. In those versions use only oracledb.fetchArraySize instead.
  * 
  * @default 2
  * @see https://oracle.github.io/node-oracledb/doc/api.html#rowfetching
  */
@scala.inline
def prefetchRows: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("prefetchRows").asInstanceOf[scala.Double]
@scala.inline
def prefetchRows_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("prefetchRows")(x.asInstanceOf[js.Any])

/**
  * The maximum number of pending pool.getConnection() calls that can be queued.
  * 
  * When the number of pool.getConnection() calls that have been queued waiting for an available connection reaches queueMax,
  * then any future pool.getConnection() calls will immediately return an error and will not be queued.
  * 
  * If queueMax is -1, then the queue length is not limited.
  * 
  * This property may be overridden when creating a connection pool.
  * 
  * @default 500
  */
@scala.inline
def queueMax: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("queueMax").asInstanceOf[scala.Double]
@scala.inline
def queueMax_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("queueMax")(x.asInstanceOf[js.Any])

/**
  * This property was removed in node-oracledb 3.0 and queuing was always enabled.
  * In node-oracledb 5.0, set queueMax to 0 to disable queuing.
  * 
  * @see https://oracle.github.io/node-oracledb/doc/api.html#connpoolqueue
  */
@scala.inline
def queueRequests: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("queueRequests").asInstanceOf[scala.Double]
@scala.inline
def queueRequests_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("queueRequests")(x.asInstanceOf[js.Any])

/**
  * The number of milliseconds after which connection requests waiting in the connection request queue are terminated.
  * If queueTimeout is 0, then queued connection requests are never terminated.
  *
  * This property may be overridden when creating a connection pool.
  *
  * @default 60000
  * @since 1.7
  */
@scala.inline
def queueTimeout: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("queueTimeout").asInstanceOf[scala.Double]
@scala.inline
def queueTimeout_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("queueTimeout")(x.asInstanceOf[js.Any])

/**
  * This is the simplified form of connection.shutdown() used for shutting down a database instance. It accepts connection
  * credentials and shuts the database instance completely down.
  * 
  * Internally it creates, and closes, a standalone connection using the oracledb.SYSOPER privilege.
  * 
  * @see https://oracle.github.io/node-oracledb/doc/api.html#startupshutdown
  * @since 5.0
  */
@scala.inline
def shutdown(creds: typings.oracledb.mod.DBCredentials): js.Promise[scala.Unit] = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("shutdown")(creds.asInstanceOf[js.Any]).asInstanceOf[js.Promise[scala.Unit]]
@scala.inline
def shutdown(
  creds: typings.oracledb.mod.DBCredentials,
  cb: js.Function1[/* err */ typings.std.Error, scala.Unit]
): scala.Unit = (typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("shutdown")(creds.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def shutdown(creds: typings.oracledb.mod.DBCredentials, mode: scala.Double): js.Promise[scala.Unit] = (typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("shutdown")(creds.asInstanceOf[js.Any], mode.asInstanceOf[js.Any])).asInstanceOf[js.Promise[scala.Unit]]
@scala.inline
def shutdown(
  creds: typings.oracledb.mod.DBCredentials,
  mode: scala.Double,
  cb: js.Function1[/* err */ typings.std.Error, scala.Unit]
): scala.Unit = (typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("shutdown")(creds.asInstanceOf[js.Any], mode.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

/**
  * This is the simplified form of connection.startup() used for starting a database instance up.
  * It accepts connection credentials and starts the database instance completely.
  * 
  * As part of the start up process, a standalone connection using the oracledb.SYSOPER privilege is internally created and closed.
  * 
  * @see https://oracle.github.io/node-oracledb/doc/api.html#startupshutdown
  * @since 5.0
  */
@scala.inline
def startup(creds: typings.oracledb.mod.DBCredentials): js.Promise[scala.Unit] = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("startup")(creds.asInstanceOf[js.Any]).asInstanceOf[js.Promise[scala.Unit]]
@scala.inline
def startup(
  creds: typings.oracledb.mod.DBCredentials,
  cb: js.Function1[/* err */ typings.std.Error, scala.Unit]
): scala.Unit = (typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("startup")(creds.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]
@scala.inline
def startup(creds: typings.oracledb.mod.DBCredentials, opts: typings.oracledb.mod.StartupOptions): js.Promise[scala.Unit] = (typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("startup")(creds.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[js.Promise[scala.Unit]]
@scala.inline
def startup(
  creds: typings.oracledb.mod.DBCredentials,
  opts: typings.oracledb.mod.StartupOptions,
  cb: js.Function1[/* err */ typings.std.Error, scala.Unit]
): scala.Unit = (typings.oracledb.mod.^.asInstanceOf[js.Dynamic].applyDynamic("startup")(creds.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], cb.asInstanceOf[js.Any])).asInstanceOf[scala.Unit]

/**
  * The number of statements that are cached in the statement cache of each connection.
  *
  * This property may be overridden for specific Pool or Connection objects.
  *
  * In general, set the statement cache to the size of the working set of statements being
  * executed by the application. Statement caching can be disabled by setting the size to 0.
  *
  * @default 30
  */
@scala.inline
def stmtCacheSize: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("stmtCacheSize").asInstanceOf[scala.Double]
@scala.inline
def stmtCacheSize_=(x: scala.Double): scala.Unit = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].updateDynamic("stmtCacheSize")(x.asInstanceOf[js.Any])

/**
  * This readonly property gives a numeric representation of the node-oracledb version.
  * For version x.y.z, this property gives the number: (10000 * x) + (100 * y) + z
  */
@scala.inline
def version: scala.Double = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("version").asInstanceOf[scala.Double]

/**
  * This readonly property gives a string representation of the node-oracledb version, including the version suffix if one is present.
  *
  * @since 2.1
  */
@scala.inline
def versionString: java.lang.String = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("versionString").asInstanceOf[java.lang.String]

/**
  * This readonly property gives a string representing the version suffix (e.g. “-dev” or “-beta”) or an empty string if no version suffix is present.
  *
  * @since 2.1
  */
@scala.inline
def versionSuffix: java.lang.String = typings.oracledb.mod.^.asInstanceOf[js.Dynamic].selectDynamic("versionSuffix").asInstanceOf[java.lang.String]

/**
  * Used with connection.execute() to associate values or JavaScript variables to a statement’s bind variables by name.
  *
  * @see https://oracle.github.io/node-oracledb/doc/api.html#executebindParams
  */
type BindParameters = (typings.std.Record[
java.lang.String, 
js.UndefOr[
  typings.oracledb.mod.BindParameter | java.lang.String | scala.Double | typings.std.Date | typings.oracledb.mod.DBObjectIN[js.Any] | typings.node.Buffer | scala.Null
]]) | (js.Array[js.Any | typings.oracledb.mod.BindParameter])

/**
  * @see https://oracle.github.io/node-oracledb/doc/api.html#objects
  * @since 4.0
  */
type DBObjectIN[T] = typings.oracledb.oracledbStrings.DBObject_IN & org.scalablytyped.runtime.TopLevel[T] & typings.oracledb.mod.BaseDBObject[T]

/**
  * @see https://oracle.github.io/node-oracledb/doc/api.html#objects
  * @since 4.0
  */
type DBObjectOUT[T] = typings.oracledb.oracledbStrings.DBObject_OUT & org.scalablytyped.runtime.TopLevel[js.Any] & typings.oracledb.mod.BaseDBObject[T]

type EnqueueMessage[T] = java.lang.String | typings.node.Buffer | typings.oracledb.mod.DBObjectIN[T] | typings.oracledb.anon.Correlation[T]
