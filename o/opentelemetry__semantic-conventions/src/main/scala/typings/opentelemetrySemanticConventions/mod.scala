package typings.opentelemetrySemanticConventions

import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`0`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`10`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`11`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`12`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`13`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`14`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`15`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`16`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`1`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`2`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`3`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`4`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`5`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`6`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`7`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`8`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsInts.`9`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.`1Dot0`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.`1Dot1`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.`2Dot0`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.adabas
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aix
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.alibaba_cloud
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.alibaba_cloud_ecs
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.alibaba_cloud_fc
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.all
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.amd64
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.any
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.arm32
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.arm64
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws_ec2
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws_ecs
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws_eks
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws_elastic_beanstalk
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws_lambda
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure_aks
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure_app_service
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure_container_instances
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure_functions
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure_vm
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cache
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cassandra
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cdma
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cdma2000_1xrtt
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cell
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cloudscape
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cockroachdb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.coldfusion
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cosmosdb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.couchbase
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.couchdb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cpp
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.darwin
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.datasource
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.db2
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.delete
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.derby
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.dotnet
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.dragonflybsd
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.dynamodb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.each_quorum
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ec2
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.edb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.edge
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.edit
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ehrpd
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.elasticsearch
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.erlang
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.evdo_0
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.evdo_a
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.evdo_b
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.fargate
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.filemaker
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.firebird
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.firstsql
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.freebsd
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp_app_engine
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp_cloud_functions
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp_cloud_run
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp_compute_engine
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp_kubernetes_engine
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.geode
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.go
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gprs
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gsm
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.h2
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hanadb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hbase
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hive
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hpux
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hsdpa
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hspa
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hspap
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hsqldb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hsupa
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.http
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ia64
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.iden
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.informix
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ingres
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.inproc
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.insert
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.instantdb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.interbase
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ip
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ip_tcp
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ip_udp
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.iwlan
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.java_
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.linux
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.local_one
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.local_quorum
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.local_serial
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.lte
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.lte_ca
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.mariadb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.maxdb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.memcached
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.mongodb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.mssql
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.mysql
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.neo4j
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.netbsd
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.netezza
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.nodejs
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.nr
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.nrnsa
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.one
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.openbsd
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.oracle
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.other
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.other_sql
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.pervasive
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.php
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.pipe
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.pointbase
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.postgresql
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ppc32
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ppc64
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.process
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.progress
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.pubsub
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.python
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.queue
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.quorum
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.receive
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.redis
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.redshift
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ruby
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.serial
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.solaris
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.sqlite
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.sybase
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.td_scdma
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.teradata
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.three
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.timer
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.topic
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.two
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.umts
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.unavailable
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.unix
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.unknown
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.vertica
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.webjs
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.wifi
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.windows
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.wired
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.x86
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.z_os
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  object AwsEcsLaunchtypeValues {
    
    /** ec2. */
    @JSImport("@opentelemetry/semantic-conventions", "AwsEcsLaunchtypeValues.EC2")
    @js.native
    val EC2: ec2 = js.native
    
    /** fargate. */
    @JSImport("@opentelemetry/semantic-conventions", "AwsEcsLaunchtypeValues.FARGATE")
    @js.native
    val FARGATE: fargate = js.native
  }
  
  object CloudPlatformValues {
    
    /** Alibaba Cloud Elastic Compute Service. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.ALIBABA_CLOUD_ECS")
    @js.native
    val ALIBABA_CLOUD_ECS: alibaba_cloud_ecs = js.native
    
    /** Alibaba Cloud Function Compute. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.ALIBABA_CLOUD_FC")
    @js.native
    val ALIBABA_CLOUD_FC: alibaba_cloud_fc = js.native
    
    /** AWS Elastic Compute Cloud. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.AWS_EC2")
    @js.native
    val AWS_EC2: aws_ec2 = js.native
    
    /** AWS Elastic Container Service. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.AWS_ECS")
    @js.native
    val AWS_ECS: aws_ecs = js.native
    
    /** AWS Elastic Kubernetes Service. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.AWS_EKS")
    @js.native
    val AWS_EKS: aws_eks = js.native
    
    /** AWS Elastic Beanstalk. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.AWS_ELASTIC_BEANSTALK")
    @js.native
    val AWS_ELASTIC_BEANSTALK: aws_elastic_beanstalk = js.native
    
    /** AWS Lambda. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.AWS_LAMBDA")
    @js.native
    val AWS_LAMBDA: aws_lambda = js.native
    
    /** Azure Kubernetes Service. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.AZURE_AKS")
    @js.native
    val AZURE_AKS: azure_aks = js.native
    
    /** Azure App Service. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.AZURE_APP_SERVICE")
    @js.native
    val AZURE_APP_SERVICE: azure_app_service = js.native
    
    /** Azure Container Instances. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.AZURE_CONTAINER_INSTANCES")
    @js.native
    val AZURE_CONTAINER_INSTANCES: azure_container_instances = js.native
    
    /** Azure Functions. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.AZURE_FUNCTIONS")
    @js.native
    val AZURE_FUNCTIONS: azure_functions = js.native
    
    /** Azure Virtual Machines. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.AZURE_VM")
    @js.native
    val AZURE_VM: azure_vm = js.native
    
    /** Google Cloud App Engine (GAE). */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.GCP_APP_ENGINE")
    @js.native
    val GCP_APP_ENGINE: gcp_app_engine = js.native
    
    /** Google Cloud Functions (GCF). */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.GCP_CLOUD_FUNCTIONS")
    @js.native
    val GCP_CLOUD_FUNCTIONS: gcp_cloud_functions = js.native
    
    /** Google Cloud Run. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.GCP_CLOUD_RUN")
    @js.native
    val GCP_CLOUD_RUN: gcp_cloud_run = js.native
    
    /** Google Cloud Compute Engine (GCE). */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.GCP_COMPUTE_ENGINE")
    @js.native
    val GCP_COMPUTE_ENGINE: gcp_compute_engine = js.native
    
    /** Google Cloud Kubernetes Engine (GKE). */
    @JSImport("@opentelemetry/semantic-conventions", "CloudPlatformValues.GCP_KUBERNETES_ENGINE")
    @js.native
    val GCP_KUBERNETES_ENGINE: gcp_kubernetes_engine = js.native
  }
  
  object CloudProviderValues {
    
    /** Alibaba Cloud. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudProviderValues.ALIBABA_CLOUD")
    @js.native
    val ALIBABA_CLOUD: alibaba_cloud = js.native
    
    /** Amazon Web Services. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudProviderValues.AWS")
    @js.native
    val AWS: aws = js.native
    
    /** Microsoft Azure. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudProviderValues.AZURE")
    @js.native
    val AZURE: azure = js.native
    
    /** Google Cloud Platform. */
    @JSImport("@opentelemetry/semantic-conventions", "CloudProviderValues.GCP")
    @js.native
    val GCP: gcp = js.native
  }
  
  object DbCassandraConsistencyLevelValues {
    
    /** all. */
    @JSImport("@opentelemetry/semantic-conventions", "DbCassandraConsistencyLevelValues.ALL")
    @js.native
    val ALL: all = js.native
    
    /** any. */
    @JSImport("@opentelemetry/semantic-conventions", "DbCassandraConsistencyLevelValues.ANY")
    @js.native
    val ANY: any = js.native
    
    /** each_quorum. */
    @JSImport("@opentelemetry/semantic-conventions", "DbCassandraConsistencyLevelValues.EACH_QUORUM")
    @js.native
    val EACH_QUORUM: each_quorum = js.native
    
    /** local_one. */
    @JSImport("@opentelemetry/semantic-conventions", "DbCassandraConsistencyLevelValues.LOCAL_ONE")
    @js.native
    val LOCAL_ONE: local_one = js.native
    
    /** local_quorum. */
    @JSImport("@opentelemetry/semantic-conventions", "DbCassandraConsistencyLevelValues.LOCAL_QUORUM")
    @js.native
    val LOCAL_QUORUM: local_quorum = js.native
    
    /** local_serial. */
    @JSImport("@opentelemetry/semantic-conventions", "DbCassandraConsistencyLevelValues.LOCAL_SERIAL")
    @js.native
    val LOCAL_SERIAL: local_serial = js.native
    
    /** one. */
    @JSImport("@opentelemetry/semantic-conventions", "DbCassandraConsistencyLevelValues.ONE")
    @js.native
    val ONE: one = js.native
    
    /** quorum. */
    @JSImport("@opentelemetry/semantic-conventions", "DbCassandraConsistencyLevelValues.QUORUM")
    @js.native
    val QUORUM: quorum = js.native
    
    /** serial. */
    @JSImport("@opentelemetry/semantic-conventions", "DbCassandraConsistencyLevelValues.SERIAL")
    @js.native
    val SERIAL: serial = js.native
    
    /** three. */
    @JSImport("@opentelemetry/semantic-conventions", "DbCassandraConsistencyLevelValues.THREE")
    @js.native
    val THREE: three = js.native
    
    /** two. */
    @JSImport("@opentelemetry/semantic-conventions", "DbCassandraConsistencyLevelValues.TWO")
    @js.native
    val TWO: two = js.native
  }
  
  object DbSystemValues {
    
    /** Adabas (Adaptable Database System). */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.ADABAS")
    @js.native
    val ADABAS: adabas = js.native
    
    /** InterSystems Cach√©. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.CACHE")
    @js.native
    val CACHE: cache = js.native
    
    /** Apache Cassandra. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.CASSANDRA")
    @js.native
    val CASSANDRA: cassandra = js.native
    
    /** Cloudscape. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.CLOUDSCAPE")
    @js.native
    val CLOUDSCAPE: cloudscape = js.native
    
    /** CockroachDB. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.COCKROACHDB")
    @js.native
    val COCKROACHDB: cockroachdb = js.native
    
    /** ColdFusion IMQ. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.COLDFUSION")
    @js.native
    val COLDFUSION: coldfusion = js.native
    
    /** Microsoft Azure Cosmos DB. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.COSMOSDB")
    @js.native
    val COSMOSDB: cosmosdb = js.native
    
    /** Couchbase. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.COUCHBASE")
    @js.native
    val COUCHBASE: couchbase = js.native
    
    /** CouchDB. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.COUCHDB")
    @js.native
    val COUCHDB: couchdb = js.native
    
    /** IBM Db2. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.DB2")
    @js.native
    val DB2: db2 = js.native
    
    /** Apache Derby. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.DERBY")
    @js.native
    val DERBY: derby = js.native
    
    /** Amazon DynamoDB. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.DYNAMODB")
    @js.native
    val DYNAMODB: dynamodb = js.native
    
    /** EnterpriseDB. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.EDB")
    @js.native
    val EDB: edb = js.native
    
    /** Elasticsearch. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.ELASTICSEARCH")
    @js.native
    val ELASTICSEARCH: elasticsearch = js.native
    
    /** FileMaker. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.FILEMAKER")
    @js.native
    val FILEMAKER: filemaker = js.native
    
    /** Firebird. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.FIREBIRD")
    @js.native
    val FIREBIRD: firebird = js.native
    
    /** FirstSQL. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.FIRSTSQL")
    @js.native
    val FIRSTSQL: firstsql = js.native
    
    /** Apache Geode. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.GEODE")
    @js.native
    val GEODE: geode = js.native
    
    /** H2. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.H2")
    @js.native
    val H2: h2 = js.native
    
    /** SAP HANA. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.HANADB")
    @js.native
    val HANADB: hanadb = js.native
    
    /** Apache HBase. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.HBASE")
    @js.native
    val HBASE: hbase = js.native
    
    /** Apache Hive. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.HIVE")
    @js.native
    val HIVE: hive = js.native
    
    /** HyperSQL DataBase. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.HSQLDB")
    @js.native
    val HSQLDB: hsqldb = js.native
    
    /** Informix. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.INFORMIX")
    @js.native
    val INFORMIX: informix = js.native
    
    /** Ingres. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.INGRES")
    @js.native
    val INGRES: ingres = js.native
    
    /** InstantDB. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.INSTANTDB")
    @js.native
    val INSTANTDB: instantdb = js.native
    
    /** InterBase. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.INTERBASE")
    @js.native
    val INTERBASE: interbase = js.native
    
    /** MariaDB. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.MARIADB")
    @js.native
    val MARIADB: mariadb = js.native
    
    /** SAP MaxDB. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.MAXDB")
    @js.native
    val MAXDB: maxdb = js.native
    
    /** Memcached. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.MEMCACHED")
    @js.native
    val MEMCACHED: memcached = js.native
    
    /** MongoDB. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.MONGODB")
    @js.native
    val MONGODB: mongodb = js.native
    
    /** Microsoft SQL Server. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.MSSQL")
    @js.native
    val MSSQL: mssql = js.native
    
    /** MySQL. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.MYSQL")
    @js.native
    val MYSQL: mysql = js.native
    
    /** Neo4j. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.NEO4J")
    @js.native
    val NEO4J: neo4j = js.native
    
    /** Netezza. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.NETEZZA")
    @js.native
    val NETEZZA: netezza = js.native
    
    /** Oracle Database. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.ORACLE")
    @js.native
    val ORACLE: oracle = js.native
    
    /** Some other SQL database. Fallback only. See notes. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.OTHER_SQL")
    @js.native
    val OTHER_SQL: other_sql = js.native
    
    /** Pervasive PSQL. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.PERVASIVE")
    @js.native
    val PERVASIVE: pervasive = js.native
    
    /** PointBase. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.POINTBASE")
    @js.native
    val POINTBASE: pointbase = js.native
    
    /** PostgreSQL. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.POSTGRESQL")
    @js.native
    val POSTGRESQL: postgresql = js.native
    
    /** Progress Database. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.PROGRESS")
    @js.native
    val PROGRESS: progress = js.native
    
    /** Redis. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.REDIS")
    @js.native
    val REDIS: redis = js.native
    
    /** Amazon Redshift. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.REDSHIFT")
    @js.native
    val REDSHIFT: redshift = js.native
    
    /** SQLite. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.SQLITE")
    @js.native
    val SQLITE: sqlite = js.native
    
    /** Sybase. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.SYBASE")
    @js.native
    val SYBASE: sybase = js.native
    
    /** Teradata. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.TERADATA")
    @js.native
    val TERADATA: teradata = js.native
    
    /** Vertica. */
    @JSImport("@opentelemetry/semantic-conventions", "DbSystemValues.VERTICA")
    @js.native
    val VERTICA: vertica = js.native
  }
  
  object FaasDocumentOperationValues {
    
    /** When an object is deleted. */
    @JSImport("@opentelemetry/semantic-conventions", "FaasDocumentOperationValues.DELETE")
    @js.native
    val DELETE: delete = js.native
    
    /** When an object is modified. */
    @JSImport("@opentelemetry/semantic-conventions", "FaasDocumentOperationValues.EDIT")
    @js.native
    val EDIT: edit = js.native
    
    /** When a new object is created. */
    @JSImport("@opentelemetry/semantic-conventions", "FaasDocumentOperationValues.INSERT")
    @js.native
    val INSERT: insert = js.native
  }
  
  object FaasInvokedProviderValues {
    
    /** Alibaba Cloud. */
    @JSImport("@opentelemetry/semantic-conventions", "FaasInvokedProviderValues.ALIBABA_CLOUD")
    @js.native
    val ALIBABA_CLOUD: alibaba_cloud = js.native
    
    /** Amazon Web Services. */
    @JSImport("@opentelemetry/semantic-conventions", "FaasInvokedProviderValues.AWS")
    @js.native
    val AWS: aws = js.native
    
    /** Microsoft Azure. */
    @JSImport("@opentelemetry/semantic-conventions", "FaasInvokedProviderValues.AZURE")
    @js.native
    val AZURE: azure = js.native
    
    /** Google Cloud Platform. */
    @JSImport("@opentelemetry/semantic-conventions", "FaasInvokedProviderValues.GCP")
    @js.native
    val GCP: gcp = js.native
  }
  
  object FaasTriggerValues {
    
    /** A response to some data source operation such as a database or filesystem read/write. */
    @JSImport("@opentelemetry/semantic-conventions", "FaasTriggerValues.DATASOURCE")
    @js.native
    val DATASOURCE: datasource = js.native
    
    /** To provide an answer to an inbound HTTP request. */
    @JSImport("@opentelemetry/semantic-conventions", "FaasTriggerValues.HTTP")
    @js.native
    val HTTP: http = js.native
    
    /** If none of the others apply. */
    @JSImport("@opentelemetry/semantic-conventions", "FaasTriggerValues.OTHER")
    @js.native
    val OTHER: other = js.native
    
    /** A function is set to be executed when messages are sent to a messaging system. */
    @JSImport("@opentelemetry/semantic-conventions", "FaasTriggerValues.PUBSUB")
    @js.native
    val PUBSUB: pubsub = js.native
    
    /** A function is scheduled to be executed regularly. */
    @JSImport("@opentelemetry/semantic-conventions", "FaasTriggerValues.TIMER")
    @js.native
    val TIMER: timer = js.native
  }
  
  object HostArchValues {
    
    /** AMD64. */
    @JSImport("@opentelemetry/semantic-conventions", "HostArchValues.AMD64")
    @js.native
    val AMD64: amd64 = js.native
    
    /** ARM32. */
    @JSImport("@opentelemetry/semantic-conventions", "HostArchValues.ARM32")
    @js.native
    val ARM32: arm32 = js.native
    
    /** ARM64. */
    @JSImport("@opentelemetry/semantic-conventions", "HostArchValues.ARM64")
    @js.native
    val ARM64: arm64 = js.native
    
    /** Itanium. */
    @JSImport("@opentelemetry/semantic-conventions", "HostArchValues.IA64")
    @js.native
    val IA64: ia64 = js.native
    
    /** 32-bit PowerPC. */
    @JSImport("@opentelemetry/semantic-conventions", "HostArchValues.PPC32")
    @js.native
    val PPC32: ppc32 = js.native
    
    /** 64-bit PowerPC. */
    @JSImport("@opentelemetry/semantic-conventions", "HostArchValues.PPC64")
    @js.native
    val PPC64: ppc64 = js.native
    
    /** 32-bit x86. */
    @JSImport("@opentelemetry/semantic-conventions", "HostArchValues.X86")
    @js.native
    val X86: x86 = js.native
  }
  
  object HttpFlavorValues {
    
    /** HTTP 1.0. */
    @JSImport("@opentelemetry/semantic-conventions", "HttpFlavorValues.HTTP_1_0")
    @js.native
    val HTTP_1_0: `1Dot0` = js.native
    
    /** HTTP 1.1. */
    @JSImport("@opentelemetry/semantic-conventions", "HttpFlavorValues.HTTP_1_1")
    @js.native
    val HTTP_1_1: `1Dot1` = js.native
    
    /** HTTP 2. */
    @JSImport("@opentelemetry/semantic-conventions", "HttpFlavorValues.HTTP_2_0")
    @js.native
    val HTTP_2_0: `2Dot0` = js.native
    
    /** QUIC protocol. */
    @JSImport("@opentelemetry/semantic-conventions", "HttpFlavorValues.QUIC")
    @js.native
    val QUIC: typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.QUIC = js.native
    
    /** SPDY protocol. */
    @JSImport("@opentelemetry/semantic-conventions", "HttpFlavorValues.SPDY")
    @js.native
    val SPDY: typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.SPDY = js.native
  }
  
  object MessageTypeValues {
    
    /** received. */
    @JSImport("@opentelemetry/semantic-conventions", "MessageTypeValues.RECEIVED")
    @js.native
    val RECEIVED: typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.RECEIVED = js.native
    
    /** sent. */
    @JSImport("@opentelemetry/semantic-conventions", "MessageTypeValues.SENT")
    @js.native
    val SENT: typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.SENT = js.native
  }
  
  object MessagingDestinationKindValues {
    
    /** A message sent to a queue. */
    @JSImport("@opentelemetry/semantic-conventions", "MessagingDestinationKindValues.QUEUE")
    @js.native
    val QUEUE: queue = js.native
    
    /** A message sent to a topic. */
    @JSImport("@opentelemetry/semantic-conventions", "MessagingDestinationKindValues.TOPIC")
    @js.native
    val TOPIC: topic = js.native
  }
  
  object MessagingOperationValues {
    
    /** process. */
    @JSImport("@opentelemetry/semantic-conventions", "MessagingOperationValues.PROCESS")
    @js.native
    val PROCESS: process = js.native
    
    /** receive. */
    @JSImport("@opentelemetry/semantic-conventions", "MessagingOperationValues.RECEIVE")
    @js.native
    val RECEIVE: receive = js.native
  }
  
  object NetHostConnectionSubtypeValues {
    
    /** CDMA. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.CDMA")
    @js.native
    val CDMA: cdma = js.native
    
    /** CDMA2000 1XRTT. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.CDMA2000_1XRTT")
    @js.native
    val CDMA2000_1XRTT: cdma2000_1xrtt = js.native
    
    /** EDGE. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.EDGE")
    @js.native
    val EDGE: edge = js.native
    
    /** EHRPD. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.EHRPD")
    @js.native
    val EHRPD: ehrpd = js.native
    
    /** EVDO Rel. 0. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.EVDO_0")
    @js.native
    val EVDO_0: evdo_0 = js.native
    
    /** EVDO Rev. A. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.EVDO_A")
    @js.native
    val EVDO_A: evdo_a = js.native
    
    /** EVDO Rev. B. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.EVDO_B")
    @js.native
    val EVDO_B: evdo_b = js.native
    
    /** GPRS. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.GPRS")
    @js.native
    val GPRS: gprs = js.native
    
    /** GSM. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.GSM")
    @js.native
    val GSM: gsm = js.native
    
    /** HSDPA. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.HSDPA")
    @js.native
    val HSDPA: hsdpa = js.native
    
    /** HSPA. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.HSPA")
    @js.native
    val HSPA: hspa = js.native
    
    /** HSPAP. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.HSPAP")
    @js.native
    val HSPAP: hspap = js.native
    
    /** HSUPA. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.HSUPA")
    @js.native
    val HSUPA: hsupa = js.native
    
    /** IDEN. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.IDEN")
    @js.native
    val IDEN: iden = js.native
    
    /** IWLAN. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.IWLAN")
    @js.native
    val IWLAN: iwlan = js.native
    
    /** LTE. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.LTE")
    @js.native
    val LTE: lte = js.native
    
    /** LTE CA. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.LTE_CA")
    @js.native
    val LTE_CA: lte_ca = js.native
    
    /** 5G NR (New Radio). */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.NR")
    @js.native
    val NR: nr = js.native
    
    /** 5G NRNSA (New Radio Non-Standalone). */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.NRNSA")
    @js.native
    val NRNSA: nrnsa = js.native
    
    /** TD-SCDMA. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.TD_SCDMA")
    @js.native
    val TD_SCDMA: td_scdma = js.native
    
    /** UMTS. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionSubtypeValues.UMTS")
    @js.native
    val UMTS: umts = js.native
  }
  
  object NetHostConnectionTypeValues {
    
    /** cell. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionTypeValues.CELL")
    @js.native
    val CELL: cell = js.native
    
    /** unavailable. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionTypeValues.UNAVAILABLE")
    @js.native
    val UNAVAILABLE: unavailable = js.native
    
    /** unknown. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionTypeValues.UNKNOWN")
    @js.native
    val UNKNOWN: unknown = js.native
    
    /** wifi. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionTypeValues.WIFI")
    @js.native
    val WIFI: wifi = js.native
    
    /** wired. */
    @JSImport("@opentelemetry/semantic-conventions", "NetHostConnectionTypeValues.WIRED")
    @js.native
    val WIRED: wired = js.native
  }
  
  object NetTransportValues {
    
    /** In-process communication. */
    @JSImport("@opentelemetry/semantic-conventions", "NetTransportValues.INPROC")
    @js.native
    val INPROC: inproc = js.native
    
    /** Another IP-based protocol. */
    @JSImport("@opentelemetry/semantic-conventions", "NetTransportValues.IP")
    @js.native
    val IP: ip = js.native
    
    /** ip_tcp. */
    @JSImport("@opentelemetry/semantic-conventions", "NetTransportValues.IP_TCP")
    @js.native
    val IP_TCP: ip_tcp = js.native
    
    /** ip_udp. */
    @JSImport("@opentelemetry/semantic-conventions", "NetTransportValues.IP_UDP")
    @js.native
    val IP_UDP: ip_udp = js.native
    
    /** Something else (non IP-based). */
    @JSImport("@opentelemetry/semantic-conventions", "NetTransportValues.OTHER")
    @js.native
    val OTHER: other = js.native
    
    /** Named or anonymous pipe. See note below. */
    @JSImport("@opentelemetry/semantic-conventions", "NetTransportValues.PIPE")
    @js.native
    val PIPE: pipe = js.native
    
    /** Unix Domain socket. See below. */
    @JSImport("@opentelemetry/semantic-conventions", "NetTransportValues.UNIX")
    @js.native
    val UNIX: unix = js.native
  }
  
  object OsTypeValues {
    
    /** AIX (Advanced Interactive eXecutive). */
    @JSImport("@opentelemetry/semantic-conventions", "OsTypeValues.AIX")
    @js.native
    val AIX: aix = js.native
    
    /** Apple Darwin. */
    @JSImport("@opentelemetry/semantic-conventions", "OsTypeValues.DARWIN")
    @js.native
    val DARWIN: darwin = js.native
    
    /** DragonFly BSD. */
    @JSImport("@opentelemetry/semantic-conventions", "OsTypeValues.DRAGONFLYBSD")
    @js.native
    val DRAGONFLYBSD: dragonflybsd = js.native
    
    /** FreeBSD. */
    @JSImport("@opentelemetry/semantic-conventions", "OsTypeValues.FREEBSD")
    @js.native
    val FREEBSD: freebsd = js.native
    
    /** HP-UX (Hewlett Packard Unix). */
    @JSImport("@opentelemetry/semantic-conventions", "OsTypeValues.HPUX")
    @js.native
    val HPUX: hpux = js.native
    
    /** Linux. */
    @JSImport("@opentelemetry/semantic-conventions", "OsTypeValues.LINUX")
    @js.native
    val LINUX: linux = js.native
    
    /** NetBSD. */
    @JSImport("@opentelemetry/semantic-conventions", "OsTypeValues.NETBSD")
    @js.native
    val NETBSD: netbsd = js.native
    
    /** OpenBSD. */
    @JSImport("@opentelemetry/semantic-conventions", "OsTypeValues.OPENBSD")
    @js.native
    val OPENBSD: openbsd = js.native
    
    /** Oracle Solaris. */
    @JSImport("@opentelemetry/semantic-conventions", "OsTypeValues.SOLARIS")
    @js.native
    val SOLARIS: solaris = js.native
    
    /** Microsoft Windows. */
    @JSImport("@opentelemetry/semantic-conventions", "OsTypeValues.WINDOWS")
    @js.native
    val WINDOWS: windows = js.native
    
    /** IBM z/OS. */
    @JSImport("@opentelemetry/semantic-conventions", "OsTypeValues.Z_OS")
    @js.native
    val Z_OS: z_os = js.native
  }
  
  object RpcGrpcStatusCodeValues {
    
    /** ABORTED. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.ABORTED")
    @js.native
    val ABORTED: `10` = js.native
    
    /** ALREADY_EXISTS. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.ALREADY_EXISTS")
    @js.native
    val ALREADY_EXISTS: `6` = js.native
    
    /** CANCELLED. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.CANCELLED")
    @js.native
    val CANCELLED: `1` = js.native
    
    /** DATA_LOSS. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.DATA_LOSS")
    @js.native
    val DATA_LOSS: `15` = js.native
    
    /** DEADLINE_EXCEEDED. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.DEADLINE_EXCEEDED")
    @js.native
    val DEADLINE_EXCEEDED: `4` = js.native
    
    /** FAILED_PRECONDITION. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.FAILED_PRECONDITION")
    @js.native
    val FAILED_PRECONDITION: `9` = js.native
    
    /** INTERNAL. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.INTERNAL")
    @js.native
    val INTERNAL: `13` = js.native
    
    /** INVALID_ARGUMENT. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.INVALID_ARGUMENT")
    @js.native
    val INVALID_ARGUMENT: `3` = js.native
    
    /** NOT_FOUND. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.NOT_FOUND")
    @js.native
    val NOT_FOUND: `5` = js.native
    
    /** OK. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.OK")
    @js.native
    val OK: `0` = js.native
    
    /** OUT_OF_RANGE. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.OUT_OF_RANGE")
    @js.native
    val OUT_OF_RANGE: `11` = js.native
    
    /** PERMISSION_DENIED. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.PERMISSION_DENIED")
    @js.native
    val PERMISSION_DENIED: `7` = js.native
    
    /** RESOURCE_EXHAUSTED. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.RESOURCE_EXHAUSTED")
    @js.native
    val RESOURCE_EXHAUSTED: `8` = js.native
    
    /** UNAUTHENTICATED. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.UNAUTHENTICATED")
    @js.native
    val UNAUTHENTICATED: `16` = js.native
    
    /** UNAVAILABLE. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.UNAVAILABLE")
    @js.native
    val UNAVAILABLE: `14` = js.native
    
    /** UNIMPLEMENTED. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.UNIMPLEMENTED")
    @js.native
    val UNIMPLEMENTED: `12` = js.native
    
    /** UNKNOWN. */
    @JSImport("@opentelemetry/semantic-conventions", "RpcGrpcStatusCodeValues.UNKNOWN")
    @js.native
    val UNKNOWN: `2` = js.native
  }
  
  object SemanticAttributes {
    
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes")
    @js.native
    val ^ : js.Any = js.native
    
    /**
      * The value of the `AttributesToGet` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_ATTRIBUTES_TO_GET")
    @js.native
    def AWS_DYNAMODB_ATTRIBUTES_TO_GET: String = js.native
    inline def AWS_DYNAMODB_ATTRIBUTES_TO_GET_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_ATTRIBUTES_TO_GET")(x.asInstanceOf[js.Any])
    
    /**
      * The JSON-serialized value of each item in the `AttributeDefinitions` request field.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS")
    @js.native
    def AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: String = js.native
    inline def AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ConsistentRead` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_CONSISTENT_READ")
    @js.native
    def AWS_DYNAMODB_CONSISTENT_READ: String = js.native
    inline def AWS_DYNAMODB_CONSISTENT_READ_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_CONSISTENT_READ")(x.asInstanceOf[js.Any])
    
    /**
      * The JSON-serialized value of each item in the `ConsumedCapacity` response field.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_CONSUMED_CAPACITY")
    @js.native
    def AWS_DYNAMODB_CONSUMED_CAPACITY: String = js.native
    inline def AWS_DYNAMODB_CONSUMED_CAPACITY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_CONSUMED_CAPACITY")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `Count` response parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_COUNT")
    @js.native
    def AWS_DYNAMODB_COUNT: String = js.native
    inline def AWS_DYNAMODB_COUNT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_COUNT")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ExclusiveStartTableName` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_EXCLUSIVE_START_TABLE")
    @js.native
    def AWS_DYNAMODB_EXCLUSIVE_START_TABLE: String = js.native
    inline def AWS_DYNAMODB_EXCLUSIVE_START_TABLE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_EXCLUSIVE_START_TABLE")(x.asInstanceOf[js.Any])
    
    /**
      * The JSON-serialized value of each item of the `GlobalSecondaryIndexes` request field.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES")
    @js.native
    def AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: String = js.native
    inline def AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES")(x.asInstanceOf[js.Any])
    
    /**
      * The JSON-serialized value of each item in the the `GlobalSecondaryIndexUpdates` request field.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES")
    @js.native
    def AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: String = js.native
    inline def AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `IndexName` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_INDEX_NAME")
    @js.native
    def AWS_DYNAMODB_INDEX_NAME: String = js.native
    inline def AWS_DYNAMODB_INDEX_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_INDEX_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The JSON-serialized value of the `ItemCollectionMetrics` response field.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_ITEM_COLLECTION_METRICS")
    @js.native
    def AWS_DYNAMODB_ITEM_COLLECTION_METRICS: String = js.native
    inline def AWS_DYNAMODB_ITEM_COLLECTION_METRICS_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_ITEM_COLLECTION_METRICS")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `Limit` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_LIMIT")
    @js.native
    def AWS_DYNAMODB_LIMIT: String = js.native
    inline def AWS_DYNAMODB_LIMIT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_LIMIT")(x.asInstanceOf[js.Any])
    
    /**
      * The JSON-serialized value of each item of the `LocalSecondaryIndexes` request field.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES")
    @js.native
    def AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: String = js.native
    inline def AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ProjectionExpression` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_PROJECTION")
    @js.native
    def AWS_DYNAMODB_PROJECTION: String = js.native
    inline def AWS_DYNAMODB_PROJECTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_PROJECTION")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ProvisionedThroughput.ReadCapacityUnits` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_PROVISIONED_READ_CAPACITY")
    @js.native
    def AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: String = js.native
    inline def AWS_DYNAMODB_PROVISIONED_READ_CAPACITY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_PROVISIONED_READ_CAPACITY")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ProvisionedThroughput.WriteCapacityUnits` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY")
    @js.native
    def AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: String = js.native
    inline def AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ScannedCount` response parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_SCANNED_COUNT")
    @js.native
    def AWS_DYNAMODB_SCANNED_COUNT: String = js.native
    inline def AWS_DYNAMODB_SCANNED_COUNT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_SCANNED_COUNT")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ScanIndexForward` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_SCAN_FORWARD")
    @js.native
    def AWS_DYNAMODB_SCAN_FORWARD: String = js.native
    inline def AWS_DYNAMODB_SCAN_FORWARD_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_SCAN_FORWARD")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `Segment` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_SEGMENT")
    @js.native
    def AWS_DYNAMODB_SEGMENT: String = js.native
    inline def AWS_DYNAMODB_SEGMENT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_SEGMENT")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `Select` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_SELECT")
    @js.native
    def AWS_DYNAMODB_SELECT: String = js.native
    inline def AWS_DYNAMODB_SELECT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_SELECT")(x.asInstanceOf[js.Any])
    
    /**
      * The the number of items in the `TableNames` response parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_TABLE_COUNT")
    @js.native
    def AWS_DYNAMODB_TABLE_COUNT: String = js.native
    inline def AWS_DYNAMODB_TABLE_COUNT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_TABLE_COUNT")(x.asInstanceOf[js.Any])
    
    /**
      * The keys in the `RequestItems` object field.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_TABLE_NAMES")
    @js.native
    def AWS_DYNAMODB_TABLE_NAMES: String = js.native
    inline def AWS_DYNAMODB_TABLE_NAMES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_TABLE_NAMES")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `TotalSegments` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_DYNAMODB_TOTAL_SEGMENTS")
    @js.native
    def AWS_DYNAMODB_TOTAL_SEGMENTS: String = js.native
    inline def AWS_DYNAMODB_TOTAL_SEGMENTS_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_TOTAL_SEGMENTS")(x.asInstanceOf[js.Any])
    
    /**
      * The full invoked ARN as provided on the `Context` passed to the function (`Lambda-Runtime-Invoked-Function-Arn` header on the `/runtime/invocation/next` applicable).
      *
      * Note: This may be different from `faas.id` if an alias is involved.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.AWS_LAMBDA_INVOKED_ARN")
    @js.native
    def AWS_LAMBDA_INVOKED_ARN: String = js.native
    inline def AWS_LAMBDA_INVOKED_ARN_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_LAMBDA_INVOKED_ARN")(x.asInstanceOf[js.Any])
    
    /**
      * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.CODE_FILEPATH")
    @js.native
    def CODE_FILEPATH: String = js.native
    inline def CODE_FILEPATH_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CODE_FILEPATH")(x.asInstanceOf[js.Any])
    
    /**
      * The method or function name, or equivalent (usually rightmost part of the code unit&#39;s name).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.CODE_FUNCTION")
    @js.native
    def CODE_FUNCTION: String = js.native
    inline def CODE_FUNCTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CODE_FUNCTION")(x.asInstanceOf[js.Any])
    
    /**
      * The line number in `code.filepath` best representing the operation. It SHOULD point within the code unit named in `code.function`.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.CODE_LINENO")
    @js.native
    def CODE_LINENO: String = js.native
    inline def CODE_LINENO_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CODE_LINENO")(x.asInstanceOf[js.Any])
    
    /**
      * The &#34;namespace&#34; within which `code.function` is defined. Usually the qualified class or module name, such that `code.namespace` + some separator + `code.function` form a unique identifier for the code unit.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.CODE_NAMESPACE")
    @js.native
    def CODE_NAMESPACE: String = js.native
    inline def CODE_NAMESPACE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CODE_NAMESPACE")(x.asInstanceOf[js.Any])
    
    /**
      * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_CASSANDRA_CONSISTENCY_LEVEL")
    @js.native
    def DB_CASSANDRA_CONSISTENCY_LEVEL: String = js.native
    inline def DB_CASSANDRA_CONSISTENCY_LEVEL_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_CONSISTENCY_LEVEL")(x.asInstanceOf[js.Any])
    
    /**
      * The data center of the coordinating node for a query.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_CASSANDRA_COORDINATOR_DC")
    @js.native
    def DB_CASSANDRA_COORDINATOR_DC: String = js.native
    inline def DB_CASSANDRA_COORDINATOR_DC_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_COORDINATOR_DC")(x.asInstanceOf[js.Any])
    
    /**
      * The ID of the coordinating node for a query.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_CASSANDRA_COORDINATOR_ID")
    @js.native
    def DB_CASSANDRA_COORDINATOR_ID: String = js.native
    inline def DB_CASSANDRA_COORDINATOR_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_COORDINATOR_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Whether or not the query is idempotent.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_CASSANDRA_IDEMPOTENCE")
    @js.native
    def DB_CASSANDRA_IDEMPOTENCE: String = js.native
    inline def DB_CASSANDRA_IDEMPOTENCE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_IDEMPOTENCE")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the keyspace being accessed. To be used instead of the generic `db.name` attribute.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_CASSANDRA_KEYSPACE")
    @js.native
    def DB_CASSANDRA_KEYSPACE: String = js.native
    inline def DB_CASSANDRA_KEYSPACE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_KEYSPACE")(x.asInstanceOf[js.Any])
    
    /**
      * The fetch size used for paging, i.e. how many rows will be returned at once.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_CASSANDRA_PAGE_SIZE")
    @js.native
    def DB_CASSANDRA_PAGE_SIZE: String = js.native
    inline def DB_CASSANDRA_PAGE_SIZE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_PAGE_SIZE")(x.asInstanceOf[js.Any])
    
    /**
      * The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT")
    @js.native
    def DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: String = js.native
    inline def DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
      *
      * Note: This mirrors the db.sql.table attribute but references cassandra rather than sql. It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_CASSANDRA_TABLE")
    @js.native
    def DB_CASSANDRA_TABLE: String = js.native
    inline def DB_CASSANDRA_TABLE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_TABLE")(x.asInstanceOf[js.Any])
    
    /**
      * The connection string used to connect to the database. It is recommended to remove embedded credentials.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_CONNECTION_STRING")
    @js.native
    def DB_CONNECTION_STRING: String = js.native
    inline def DB_CONNECTION_STRING_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CONNECTION_STRING")(x.asInstanceOf[js.Any])
    
    /**
      * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed. To be used instead of the generic `db.name` attribute.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_HBASE_NAMESPACE")
    @js.native
    def DB_HBASE_NAMESPACE: String = js.native
    inline def DB_HBASE_NAMESPACE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_HBASE_NAMESPACE")(x.asInstanceOf[js.Any])
    
    /**
      * The fully-qualified class name of the [Java Database Connectivity (JDBC)](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/) driver used to connect.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_JDBC_DRIVER_CLASSNAME")
    @js.native
    def DB_JDBC_DRIVER_CLASSNAME: String = js.native
    inline def DB_JDBC_DRIVER_CLASSNAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_JDBC_DRIVER_CLASSNAME")(x.asInstanceOf[js.Any])
    
    /**
      * The collection being accessed within the database stated in `db.name`.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_MONGODB_COLLECTION")
    @js.native
    def DB_MONGODB_COLLECTION: String = js.native
    inline def DB_MONGODB_COLLECTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_MONGODB_COLLECTION")(x.asInstanceOf[js.Any])
    
    /**
      * The Microsoft SQL Server [instance name](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15) connecting to. This name is used to determine the port of a named instance.
      *
      * Note: If setting a `db.mssql.instance_name`, `net.peer.port` is no longer required (but still recommended if non-standard).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_MSSQL_INSTANCE_NAME")
    @js.native
    def DB_MSSQL_INSTANCE_NAME: String = js.native
    inline def DB_MSSQL_INSTANCE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_MSSQL_INSTANCE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * If no [tech-specific attribute](#call-level-attributes-for-specific-technologies) is defined, this attribute is used to report the name of the database being accessed. For commands that switch the database, this should be set to the target database (even if the command fails).
      *
      * Note: In some SQL databases, the database name to be used is called &#34;schema name&#34;.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_NAME")
    @js.native
    def DB_NAME: String = js.native
    inline def DB_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the operation being executed, e.g. the [MongoDB command name](https://docs.mongodb.com/manual/reference/command/#database-operations) such as `findAndModify`, or the SQL keyword.
      *
      * Note: When setting this to an SQL keyword, it is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if the operation name is provided by the library being instrumented. If the SQL statement has an ambiguous operation, or performs more than one operation, this value may be omitted.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_OPERATION")
    @js.native
    def DB_OPERATION: String = js.native
    inline def DB_OPERATION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_OPERATION")(x.asInstanceOf[js.Any])
    
    /**
      * The index of the database being accessed as used in the [`SELECT` command](https://redis.io/commands/select), provided as an integer. To be used instead of the generic `db.name` attribute.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_REDIS_DATABASE_INDEX")
    @js.native
    def DB_REDIS_DATABASE_INDEX: String = js.native
    inline def DB_REDIS_DATABASE_INDEX_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_REDIS_DATABASE_INDEX")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
      *
      * Note: It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_SQL_TABLE")
    @js.native
    def DB_SQL_TABLE: String = js.native
    inline def DB_SQL_TABLE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_SQL_TABLE")(x.asInstanceOf[js.Any])
    
    /**
      * The database statement being executed.
      *
      * Note: The value may be sanitized to exclude sensitive information.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_STATEMENT")
    @js.native
    def DB_STATEMENT: String = js.native
    inline def DB_STATEMENT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_STATEMENT")(x.asInstanceOf[js.Any])
    
    /**
      * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_SYSTEM")
    @js.native
    def DB_SYSTEM: String = js.native
    inline def DB_SYSTEM_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_SYSTEM")(x.asInstanceOf[js.Any])
    
    /**
      * Username for accessing the database.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.DB_USER")
    @js.native
    def DB_USER: String = js.native
    inline def DB_USER_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_USER")(x.asInstanceOf[js.Any])
    
    /**
      * Username or client_id extracted from the access token or [Authorization](https://tools.ietf.org/html/rfc7235#section-4.2) header in the inbound request from outside the system.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.ENDUSER_ID")
    @js.native
    def ENDUSER_ID: String = js.native
    inline def ENDUSER_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ENDUSER_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Actual/assumed role the client is making the request under extracted from token or application security context.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.ENDUSER_ROLE")
    @js.native
    def ENDUSER_ROLE: String = js.native
    inline def ENDUSER_ROLE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ENDUSER_ROLE")(x.asInstanceOf[js.Any])
    
    /**
      * Scopes or granted authorities the client currently possesses extracted from token or application security context. The value would come from the scope associated with an [OAuth 2.0 Access Token](https://tools.ietf.org/html/rfc6749#section-3.3) or an attribute value in a [SAML 2.0 Assertion](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.ENDUSER_SCOPE")
    @js.native
    def ENDUSER_SCOPE: String = js.native
    inline def ENDUSER_SCOPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ENDUSER_SCOPE")(x.asInstanceOf[js.Any])
    
    /**
      * SHOULD be set to true if the exception event is recorded at a point where it is known that the exception is escaping the scope of the span.
      *
      * Note: An exception is considered to have escaped (or left) the scope of a span,
      if that span is ended while the exception is still logically &#34;in flight&#34;.
      This may be actually &#34;in flight&#34; in some languages (e.g. if the exception
      is passed to a Context manager&#39;s `__exit__` method in Python) but will
      usually be caught at the point of recording the exception in most languages.
      
      It is usually not possible to determine at the point where an exception is thrown
      whether it will escape the scope of a span.
      However, it is trivial to know that an exception
      will escape, if one checks for an active exception just before ending the span,
      as done in the [example above](#exception-end-example).
      
      It follows that an exception may still escape the scope of the span
      even if the `exception.escaped` attribute was not set or set to false,
      since the event might have been recorded at a time where it was not
      clear whether the exception will escape.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.EXCEPTION_ESCAPED")
    @js.native
    def EXCEPTION_ESCAPED: String = js.native
    inline def EXCEPTION_ESCAPED_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXCEPTION_ESCAPED")(x.asInstanceOf[js.Any])
    
    /**
      * The exception message.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.EXCEPTION_MESSAGE")
    @js.native
    def EXCEPTION_MESSAGE: String = js.native
    inline def EXCEPTION_MESSAGE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXCEPTION_MESSAGE")(x.asInstanceOf[js.Any])
    
    /**
      * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.EXCEPTION_STACKTRACE")
    @js.native
    def EXCEPTION_STACKTRACE: String = js.native
    inline def EXCEPTION_STACKTRACE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXCEPTION_STACKTRACE")(x.asInstanceOf[js.Any])
    
    /**
      * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.EXCEPTION_TYPE")
    @js.native
    def EXCEPTION_TYPE: String = js.native
    inline def EXCEPTION_TYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXCEPTION_TYPE")(x.asInstanceOf[js.Any])
    
    /**
      * A boolean that is true if the serverless function is executed for the first time (aka cold-start).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.FAAS_COLDSTART")
    @js.native
    def FAAS_COLDSTART: String = js.native
    inline def FAAS_COLDSTART_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_COLDSTART")(x.asInstanceOf[js.Any])
    
    /**
      * A string containing the schedule period as [Cron Expression](https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.FAAS_CRON")
    @js.native
    def FAAS_CRON: String = js.native
    inline def FAAS_CRON_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_CRON")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the source on which the triggering operation was performed. For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.FAAS_DOCUMENT_COLLECTION")
    @js.native
    def FAAS_DOCUMENT_COLLECTION: String = js.native
    inline def FAAS_DOCUMENT_COLLECTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_DOCUMENT_COLLECTION")(x.asInstanceOf[js.Any])
    
    /**
      * The document name/table subjected to the operation. For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.FAAS_DOCUMENT_NAME")
    @js.native
    def FAAS_DOCUMENT_NAME: String = js.native
    inline def FAAS_DOCUMENT_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_DOCUMENT_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * Describes the type of the operation that was performed on the data.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.FAAS_DOCUMENT_OPERATION")
    @js.native
    def FAAS_DOCUMENT_OPERATION: String = js.native
    inline def FAAS_DOCUMENT_OPERATION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_DOCUMENT_OPERATION")(x.asInstanceOf[js.Any])
    
    /**
      * A string containing the time when the data was accessed in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.FAAS_DOCUMENT_TIME")
    @js.native
    def FAAS_DOCUMENT_TIME: String = js.native
    inline def FAAS_DOCUMENT_TIME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_DOCUMENT_TIME")(x.asInstanceOf[js.Any])
    
    /**
      * The execution ID of the current function execution.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.FAAS_EXECUTION")
    @js.native
    def FAAS_EXECUTION: String = js.native
    inline def FAAS_EXECUTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_EXECUTION")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the invoked function.
      *
      * Note: SHOULD be equal to the `faas.name` resource attribute of the invoked function.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.FAAS_INVOKED_NAME")
    @js.native
    def FAAS_INVOKED_NAME: String = js.native
    inline def FAAS_INVOKED_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_INVOKED_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The cloud provider of the invoked function.
      *
      * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.FAAS_INVOKED_PROVIDER")
    @js.native
    def FAAS_INVOKED_PROVIDER: String = js.native
    inline def FAAS_INVOKED_PROVIDER_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_INVOKED_PROVIDER")(x.asInstanceOf[js.Any])
    
    /**
      * The cloud region of the invoked function.
      *
      * Note: SHOULD be equal to the `cloud.region` resource attribute of the invoked function.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.FAAS_INVOKED_REGION")
    @js.native
    def FAAS_INVOKED_REGION: String = js.native
    inline def FAAS_INVOKED_REGION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_INVOKED_REGION")(x.asInstanceOf[js.Any])
    
    /**
      * A string containing the function invocation time in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.FAAS_TIME")
    @js.native
    def FAAS_TIME: String = js.native
    inline def FAAS_TIME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_TIME")(x.asInstanceOf[js.Any])
    
    /**
      * Type of the trigger on which the function is executed.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.FAAS_TRIGGER")
    @js.native
    def FAAS_TRIGGER: String = js.native
    inline def FAAS_TRIGGER_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_TRIGGER")(x.asInstanceOf[js.Any])
    
    /**
      * The IP address of the original client behind all proxies, if known (e.g. from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)).
      *
      * Note: This is not necessarily the same as `net.peer.ip`, which would
      identify the network-level peer, which may be a proxy.
      
      This attribute should be set when a source of information different
      from the one used for `net.peer.ip`, is available even if that other
      source just confirms the same value as `net.peer.ip`.
      Rationale: For `net.peer.ip`, one typically does not know if it
      comes from a proxy, reverse proxy, or the actual client. Setting
      `http.client_ip` when it&#39;s the same as `net.peer.ip` means that
      one is at least somewhat confident that the address is not that of
      the closest proxy.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_CLIENT_IP")
    @js.native
    def HTTP_CLIENT_IP: String = js.native
    inline def HTTP_CLIENT_IP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_CLIENT_IP")(x.asInstanceOf[js.Any])
    
    /**
      * Kind of HTTP protocol used.
      *
      * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_FLAVOR")
    @js.native
    def HTTP_FLAVOR: String = js.native
    inline def HTTP_FLAVOR_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_FLAVOR")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
      *
      * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_HOST")
    @js.native
    def HTTP_HOST: String = js.native
    inline def HTTP_HOST_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_HOST")(x.asInstanceOf[js.Any])
    
    /**
      * HTTP request method.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_METHOD")
    @js.native
    def HTTP_METHOD: String = js.native
    inline def HTTP_METHOD_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_METHOD")(x.asInstanceOf[js.Any])
    
    /**
      * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_REQUEST_CONTENT_LENGTH")
    @js.native
    def HTTP_REQUEST_CONTENT_LENGTH: String = js.native
    inline def HTTP_REQUEST_CONTENT_LENGTH_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_REQUEST_CONTENT_LENGTH")(x.asInstanceOf[js.Any])
    
    /**
      * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED")
    @js.native
    def HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: String = js.native
    inline def HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED")(x.asInstanceOf[js.Any])
    
    /**
      * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH")
    @js.native
    def HTTP_RESPONSE_CONTENT_LENGTH: String = js.native
    inline def HTTP_RESPONSE_CONTENT_LENGTH_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_RESPONSE_CONTENT_LENGTH")(x.asInstanceOf[js.Any])
    
    /**
      * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED")
    @js.native
    def HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: String = js.native
    inline def HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED")(x.asInstanceOf[js.Any])
    
    /**
      * The matched route (path template).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_ROUTE")
    @js.native
    def HTTP_ROUTE: String = js.native
    inline def HTTP_ROUTE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_ROUTE")(x.asInstanceOf[js.Any])
    
    /**
      * The URI scheme identifying the used protocol.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_SCHEME")
    @js.native
    def HTTP_SCHEME: String = js.native
    inline def HTTP_SCHEME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_SCHEME")(x.asInstanceOf[js.Any])
    
    /**
      * The primary server name of the matched virtual host. This should be obtained via configuration. If no such configuration can be obtained, this attribute MUST NOT be set ( `net.host.name` should be used instead).
      *
      * Note: `http.url` is usually not readily available on the server side but would have to be assembled in a cumbersome and sometimes lossy process from other information (see e.g. open-telemetry/opentelemetry-python/pull/148). It is thus preferred to supply the raw data that is available.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_SERVER_NAME")
    @js.native
    def HTTP_SERVER_NAME: String = js.native
    inline def HTTP_SERVER_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_SERVER_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_STATUS_CODE")
    @js.native
    def HTTP_STATUS_CODE: String = js.native
    inline def HTTP_STATUS_CODE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_STATUS_CODE")(x.asInstanceOf[js.Any])
    
    /**
      * The full request target as passed in a HTTP request line or equivalent.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_TARGET")
    @js.native
    def HTTP_TARGET: String = js.native
    inline def HTTP_TARGET_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_TARGET")(x.asInstanceOf[js.Any])
    
    /**
      * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
      *
      * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_URL")
    @js.native
    def HTTP_URL: String = js.native
    inline def HTTP_URL_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_URL")(x.asInstanceOf[js.Any])
    
    /**
      * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.HTTP_USER_AGENT")
    @js.native
    def HTTP_USER_AGENT: String = js.native
    inline def HTTP_USER_AGENT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_USER_AGENT")(x.asInstanceOf[js.Any])
    
    /**
      * Compressed size of the message in bytes.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGE_COMPRESSED_SIZE")
    @js.native
    def MESSAGE_COMPRESSED_SIZE: String = js.native
    inline def MESSAGE_COMPRESSED_SIZE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGE_COMPRESSED_SIZE")(x.asInstanceOf[js.Any])
    
    /**
      * MUST be calculated as two different counters starting from `1` one for sent messages and one for received message.
      *
      * Note: This way we guarantee that the values will be consistent between different implementations.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGE_ID")
    @js.native
    def MESSAGE_ID: String = js.native
    inline def MESSAGE_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGE_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Whether this is a received or sent message.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGE_TYPE")
    @js.native
    def MESSAGE_TYPE: String = js.native
    inline def MESSAGE_TYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGE_TYPE")(x.asInstanceOf[js.Any])
    
    /**
      * Uncompressed size of the message in bytes.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGE_UNCOMPRESSED_SIZE")
    @js.native
    def MESSAGE_UNCOMPRESSED_SIZE: String = js.native
    inline def MESSAGE_UNCOMPRESSED_SIZE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGE_UNCOMPRESSED_SIZE")(x.asInstanceOf[js.Any])
    
    /**
      * The identifier for the consumer receiving a message. For Kafka, set it to `{messaging.kafka.consumer_group} - {messaging.kafka.client_id}`, if both are present, or only `messaging.kafka.consumer_group`. For brokers, such as RabbitMQ and Artemis, set it to the `client_id` of the client consuming the message.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_CONSUMER_ID")
    @js.native
    def MESSAGING_CONSUMER_ID: String = js.native
    inline def MESSAGING_CONSUMER_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_CONSUMER_ID")(x.asInstanceOf[js.Any])
    
    /**
      * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_CONVERSATION_ID")
    @js.native
    def MESSAGING_CONVERSATION_ID: String = js.native
    inline def MESSAGING_CONVERSATION_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_CONVERSATION_ID")(x.asInstanceOf[js.Any])
    
    /**
      * The message destination name. This might be equal to the span name but is required nevertheless.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_DESTINATION")
    @js.native
    def MESSAGING_DESTINATION: String = js.native
    inline def MESSAGING_DESTINATION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_DESTINATION")(x.asInstanceOf[js.Any])
    
    /**
      * The kind of message destination.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_DESTINATION_KIND")
    @js.native
    def MESSAGING_DESTINATION_KIND: String = js.native
    inline def MESSAGING_DESTINATION_KIND_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_DESTINATION_KIND")(x.asInstanceOf[js.Any])
    
    /**
      * Client Id for the Consumer or Producer that is handling the message.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_KAFKA_CLIENT_ID")
    @js.native
    def MESSAGING_KAFKA_CLIENT_ID: String = js.native
    inline def MESSAGING_KAFKA_CLIENT_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_KAFKA_CLIENT_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_KAFKA_CONSUMER_GROUP")
    @js.native
    def MESSAGING_KAFKA_CONSUMER_GROUP: String = js.native
    inline def MESSAGING_KAFKA_CONSUMER_GROUP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_KAFKA_CONSUMER_GROUP")(x.asInstanceOf[js.Any])
    
    /**
      * Message keys in Kafka are used for grouping alike messages to ensure they&#39;re processed on the same partition. They differ from `messaging.message_id` in that they&#39;re not unique. If the key is `null`, the attribute MUST NOT be set.
      *
      * Note: If the key type is not string, it&#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&#39;t include its value.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_KAFKA_MESSAGE_KEY")
    @js.native
    def MESSAGING_KAFKA_MESSAGE_KEY: String = js.native
    inline def MESSAGING_KAFKA_MESSAGE_KEY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_KAFKA_MESSAGE_KEY")(x.asInstanceOf[js.Any])
    
    /**
      * Partition the message is sent to.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_KAFKA_PARTITION")
    @js.native
    def MESSAGING_KAFKA_PARTITION: String = js.native
    inline def MESSAGING_KAFKA_PARTITION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_KAFKA_PARTITION")(x.asInstanceOf[js.Any])
    
    /**
      * A boolean that is true if the message is a tombstone.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_KAFKA_TOMBSTONE")
    @js.native
    def MESSAGING_KAFKA_TOMBSTONE: String = js.native
    inline def MESSAGING_KAFKA_TOMBSTONE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_KAFKA_TOMBSTONE")(x.asInstanceOf[js.Any])
    
    /**
      * A value used by the messaging system as an identifier for the message, represented as a string.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_MESSAGE_ID")
    @js.native
    def MESSAGING_MESSAGE_ID: String = js.native
    inline def MESSAGING_MESSAGE_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_MESSAGE_ID")(x.asInstanceOf[js.Any])
    
    /**
      * The compressed size of the message payload in bytes.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES")
    @js.native
    def MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: String = js.native
    inline def MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES")(x.asInstanceOf[js.Any])
    
    /**
      * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES")
    @js.native
    def MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: String = js.native
    inline def MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES")(x.asInstanceOf[js.Any])
    
    /**
      * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_OPERATION")
    @js.native
    def MESSAGING_OPERATION: String = js.native
    inline def MESSAGING_OPERATION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_OPERATION")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the transport protocol.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_PROTOCOL")
    @js.native
    def MESSAGING_PROTOCOL: String = js.native
    inline def MESSAGING_PROTOCOL_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_PROTOCOL")(x.asInstanceOf[js.Any])
    
    /**
      * The version of the transport protocol.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_PROTOCOL_VERSION")
    @js.native
    def MESSAGING_PROTOCOL_VERSION: String = js.native
    inline def MESSAGING_PROTOCOL_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_PROTOCOL_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * RabbitMQ message routing key.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_RABBITMQ_ROUTING_KEY")
    @js.native
    def MESSAGING_RABBITMQ_ROUTING_KEY: String = js.native
    inline def MESSAGING_RABBITMQ_ROUTING_KEY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_RABBITMQ_ROUTING_KEY")(x.asInstanceOf[js.Any])
    
    /**
      * A string identifying the messaging system.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_SYSTEM")
    @js.native
    def MESSAGING_SYSTEM: String = js.native
    inline def MESSAGING_SYSTEM_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_SYSTEM")(x.asInstanceOf[js.Any])
    
    /**
      * A boolean that is true if the message destination is temporary.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_TEMP_DESTINATION")
    @js.native
    def MESSAGING_TEMP_DESTINATION: String = js.native
    inline def MESSAGING_TEMP_DESTINATION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_TEMP_DESTINATION")(x.asInstanceOf[js.Any])
    
    /**
      * Connection string.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.MESSAGING_URL")
    @js.native
    def MESSAGING_URL: String = js.native
    inline def MESSAGING_URL_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_URL")(x.asInstanceOf[js.Any])
    
    /**
      * The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_HOST_CARRIER_ICC")
    @js.native
    def NET_HOST_CARRIER_ICC: String = js.native
    inline def NET_HOST_CARRIER_ICC_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_CARRIER_ICC")(x.asInstanceOf[js.Any])
    
    /**
      * The mobile carrier country code.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_HOST_CARRIER_MCC")
    @js.native
    def NET_HOST_CARRIER_MCC: String = js.native
    inline def NET_HOST_CARRIER_MCC_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_CARRIER_MCC")(x.asInstanceOf[js.Any])
    
    /**
      * The mobile carrier network code.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_HOST_CARRIER_MNC")
    @js.native
    def NET_HOST_CARRIER_MNC: String = js.native
    inline def NET_HOST_CARRIER_MNC_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_CARRIER_MNC")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the mobile carrier.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_HOST_CARRIER_NAME")
    @js.native
    def NET_HOST_CARRIER_NAME: String = js.native
    inline def NET_HOST_CARRIER_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_CARRIER_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_HOST_CONNECTION_SUBTYPE")
    @js.native
    def NET_HOST_CONNECTION_SUBTYPE: String = js.native
    inline def NET_HOST_CONNECTION_SUBTYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_CONNECTION_SUBTYPE")(x.asInstanceOf[js.Any])
    
    /**
      * The internet connection type currently being used by the host.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_HOST_CONNECTION_TYPE")
    @js.native
    def NET_HOST_CONNECTION_TYPE: String = js.native
    inline def NET_HOST_CONNECTION_TYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_CONNECTION_TYPE")(x.asInstanceOf[js.Any])
    
    /**
      * Like `net.peer.ip` but for the host IP. Useful in case of a multi-IP host.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_HOST_IP")
    @js.native
    def NET_HOST_IP: String = js.native
    inline def NET_HOST_IP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_IP")(x.asInstanceOf[js.Any])
    
    /**
      * Local hostname or similar, see note below.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_HOST_NAME")
    @js.native
    def NET_HOST_NAME: String = js.native
    inline def NET_HOST_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * Like `net.peer.port` but for the host port.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_HOST_PORT")
    @js.native
    def NET_HOST_PORT: String = js.native
    inline def NET_HOST_PORT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_PORT")(x.asInstanceOf[js.Any])
    
    /**
      * Remote address of the peer (dotted decimal for IPv4 or [RFC5952](https://tools.ietf.org/html/rfc5952) for IPv6).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_PEER_IP")
    @js.native
    def NET_PEER_IP: String = js.native
    inline def NET_PEER_IP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_PEER_IP")(x.asInstanceOf[js.Any])
    
    /**
      * Remote hostname or similar, see note below.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_PEER_NAME")
    @js.native
    def NET_PEER_NAME: String = js.native
    inline def NET_PEER_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_PEER_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * Remote port number.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_PEER_PORT")
    @js.native
    def NET_PEER_PORT: String = js.native
    inline def NET_PEER_PORT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_PEER_PORT")(x.asInstanceOf[js.Any])
    
    /**
      * Transport protocol used. See note below.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.NET_TRANSPORT")
    @js.native
    def NET_TRANSPORT: String = js.native
    inline def NET_TRANSPORT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_TRANSPORT")(x.asInstanceOf[js.Any])
    
    /**
      * The [`service.name`](../../resource/semantic_conventions/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.PEER_SERVICE")
    @js.native
    def PEER_SERVICE: String = js.native
    inline def PEER_SERVICE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PEER_SERVICE")(x.asInstanceOf[js.Any])
    
    /**
      * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.RPC_GRPC_STATUS_CODE")
    @js.native
    def RPC_GRPC_STATUS_CODE: String = js.native
    inline def RPC_GRPC_STATUS_CODE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_GRPC_STATUS_CODE")(x.asInstanceOf[js.Any])
    
    /**
      * `error.code` property of response if it is an error response.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.RPC_JSONRPC_ERROR_CODE")
    @js.native
    def RPC_JSONRPC_ERROR_CODE: String = js.native
    inline def RPC_JSONRPC_ERROR_CODE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_JSONRPC_ERROR_CODE")(x.asInstanceOf[js.Any])
    
    /**
      * `error.message` property of response if it is an error response.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.RPC_JSONRPC_ERROR_MESSAGE")
    @js.native
    def RPC_JSONRPC_ERROR_MESSAGE: String = js.native
    inline def RPC_JSONRPC_ERROR_MESSAGE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_JSONRPC_ERROR_MESSAGE")(x.asInstanceOf[js.Any])
    
    /**
      * `id` property of request or response. Since protocol allows id to be int, string, `null` or missing (for notifications), value is expected to be cast to string for simplicity. Use empty string in case of `null` value. Omit entirely if this is a notification.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.RPC_JSONRPC_REQUEST_ID")
    @js.native
    def RPC_JSONRPC_REQUEST_ID: String = js.native
    inline def RPC_JSONRPC_REQUEST_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_JSONRPC_REQUEST_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Protocol version as in `jsonrpc` property of request/response. Since JSON-RPC 1.0 does not specify this, the value can be omitted.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.RPC_JSONRPC_VERSION")
    @js.native
    def RPC_JSONRPC_VERSION: String = js.native
    inline def RPC_JSONRPC_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_JSONRPC_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the (logical) method being called, must be equal to the $method part in the span name.
      *
      * Note: This is the logical name of the method from the RPC interface perspective, which can be different from the name of any implementing method/function. The `code.function` attribute may be used to store the latter (e.g., method actually executing the call on the server side, RPC client stub method on the client side).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.RPC_METHOD")
    @js.native
    def RPC_METHOD: String = js.native
    inline def RPC_METHOD_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_METHOD")(x.asInstanceOf[js.Any])
    
    /**
      * The full (logical) name of the service being called, including its package name, if applicable.
      *
      * Note: This is the logical name of the service from the RPC interface perspective, which can be different from the name of any implementing class. The `code.namespace` attribute may be used to store the latter (despite the attribute name, it may include a class name; e.g., class with method actually executing the call on the server side, RPC client stub class on the client side).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.RPC_SERVICE")
    @js.native
    def RPC_SERVICE: String = js.native
    inline def RPC_SERVICE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_SERVICE")(x.asInstanceOf[js.Any])
    
    /**
      * A string identifying the remoting system.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.RPC_SYSTEM")
    @js.native
    def RPC_SYSTEM: String = js.native
    inline def RPC_SYSTEM_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_SYSTEM")(x.asInstanceOf[js.Any])
    
    /**
      * Current &#34;managed&#34; thread ID (as opposed to OS thread ID).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.THREAD_ID")
    @js.native
    def THREAD_ID: String = js.native
    inline def THREAD_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("THREAD_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Current thread name.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticAttributes.THREAD_NAME")
    @js.native
    def THREAD_NAME: String = js.native
    inline def THREAD_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("THREAD_NAME")(x.asInstanceOf[js.Any])
  }
  
  object SemanticResourceAttributes {
    
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes")
    @js.native
    val ^ : js.Any = js.native
    
    /**
      * The ARN of an [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.AWS_ECS_CLUSTER_ARN")
    @js.native
    def AWS_ECS_CLUSTER_ARN: String = js.native
    inline def AWS_ECS_CLUSTER_ARN_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_ECS_CLUSTER_ARN")(x.asInstanceOf[js.Any])
    
    /**
      * The Amazon Resource Name (ARN) of an [ECS container instance](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_instances.html).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.AWS_ECS_CONTAINER_ARN")
    @js.native
    def AWS_ECS_CONTAINER_ARN: String = js.native
    inline def AWS_ECS_CONTAINER_ARN_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_ECS_CONTAINER_ARN")(x.asInstanceOf[js.Any])
    
    /**
      * The [launch type](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) for an ECS task.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.AWS_ECS_LAUNCHTYPE")
    @js.native
    def AWS_ECS_LAUNCHTYPE: String = js.native
    inline def AWS_ECS_LAUNCHTYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_ECS_LAUNCHTYPE")(x.asInstanceOf[js.Any])
    
    /**
      * The ARN of an [ECS task definition](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.AWS_ECS_TASK_ARN")
    @js.native
    def AWS_ECS_TASK_ARN: String = js.native
    inline def AWS_ECS_TASK_ARN_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_ECS_TASK_ARN")(x.asInstanceOf[js.Any])
    
    /**
      * The task definition family this task definition is a member of.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.AWS_ECS_TASK_FAMILY")
    @js.native
    def AWS_ECS_TASK_FAMILY: String = js.native
    inline def AWS_ECS_TASK_FAMILY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_ECS_TASK_FAMILY")(x.asInstanceOf[js.Any])
    
    /**
      * The revision for this task definition.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.AWS_ECS_TASK_REVISION")
    @js.native
    def AWS_ECS_TASK_REVISION: String = js.native
    inline def AWS_ECS_TASK_REVISION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_ECS_TASK_REVISION")(x.asInstanceOf[js.Any])
    
    /**
      * The ARN of an EKS cluster.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.AWS_EKS_CLUSTER_ARN")
    @js.native
    def AWS_EKS_CLUSTER_ARN: String = js.native
    inline def AWS_EKS_CLUSTER_ARN_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_EKS_CLUSTER_ARN")(x.asInstanceOf[js.Any])
    
    /**
      * The Amazon Resource Name(s) (ARN) of the AWS log group(s).
      *
      * Note: See the [log group ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.AWS_LOG_GROUP_ARNS")
    @js.native
    def AWS_LOG_GROUP_ARNS: String = js.native
    inline def AWS_LOG_GROUP_ARNS_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_LOG_GROUP_ARNS")(x.asInstanceOf[js.Any])
    
    /**
      * The name(s) of the AWS log group(s) an application is writing to.
      *
      * Note: Multiple log groups must be supported for cases like multi-container applications, where a single application has sidecar containers, and each write to their own log group.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.AWS_LOG_GROUP_NAMES")
    @js.native
    def AWS_LOG_GROUP_NAMES: String = js.native
    inline def AWS_LOG_GROUP_NAMES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_LOG_GROUP_NAMES")(x.asInstanceOf[js.Any])
    
    /**
      * The ARN(s) of the AWS log stream(s).
      *
      * Note: See the [log stream ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format). One log group can contain several log streams, so these ARNs necessarily identify both a log group and a log stream.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.AWS_LOG_STREAM_ARNS")
    @js.native
    def AWS_LOG_STREAM_ARNS: String = js.native
    inline def AWS_LOG_STREAM_ARNS_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_LOG_STREAM_ARNS")(x.asInstanceOf[js.Any])
    
    /**
      * The name(s) of the AWS log stream(s) an application is writing to.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.AWS_LOG_STREAM_NAMES")
    @js.native
    def AWS_LOG_STREAM_NAMES: String = js.native
    inline def AWS_LOG_STREAM_NAMES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_LOG_STREAM_NAMES")(x.asInstanceOf[js.Any])
    
    /**
      * The cloud account ID the resource is assigned to.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.CLOUD_ACCOUNT_ID")
    @js.native
    def CLOUD_ACCOUNT_ID: String = js.native
    inline def CLOUD_ACCOUNT_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLOUD_ACCOUNT_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Cloud regions often have multiple, isolated locations known as zones to increase availability. Availability zone represents the zone where the resource is running.
      *
      * Note: Availability zones are called &#34;zones&#34; on Alibaba Cloud and Google Cloud.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.CLOUD_AVAILABILITY_ZONE")
    @js.native
    def CLOUD_AVAILABILITY_ZONE: String = js.native
    inline def CLOUD_AVAILABILITY_ZONE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLOUD_AVAILABILITY_ZONE")(x.asInstanceOf[js.Any])
    
    /**
      * The cloud platform in use.
      *
      * Note: The prefix of the service SHOULD match the one specified in `cloud.provider`.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.CLOUD_PLATFORM")
    @js.native
    def CLOUD_PLATFORM: String = js.native
    inline def CLOUD_PLATFORM_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLOUD_PLATFORM")(x.asInstanceOf[js.Any])
    
    /**
      * Name of the cloud provider.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.CLOUD_PROVIDER")
    @js.native
    def CLOUD_PROVIDER: String = js.native
    inline def CLOUD_PROVIDER_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLOUD_PROVIDER")(x.asInstanceOf[js.Any])
    
    /**
      * The geographical region the resource is running. Refer to your provider&#39;s docs to see the available regions, for example [Alibaba Cloud regions](https://www.alibabacloud.com/help/doc-detail/40654.htm), [AWS regions](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/), [Azure regions](https://azure.microsoft.com/en-us/global-infrastructure/geographies/), or [Google Cloud regions](https://cloud.google.com/about/locations).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.CLOUD_REGION")
    @js.native
    def CLOUD_REGION: String = js.native
    inline def CLOUD_REGION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLOUD_REGION")(x.asInstanceOf[js.Any])
    
    /**
      * Container ID. Usually a UUID, as for example used to [identify Docker containers](https://docs.docker.com/engine/reference/run/#container-identification). The UUID might be abbreviated.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.CONTAINER_ID")
    @js.native
    def CONTAINER_ID: String = js.native
    inline def CONTAINER_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CONTAINER_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Name of the image the container was built on.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.CONTAINER_IMAGE_NAME")
    @js.native
    def CONTAINER_IMAGE_NAME: String = js.native
    inline def CONTAINER_IMAGE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CONTAINER_IMAGE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * Container image tag.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.CONTAINER_IMAGE_TAG")
    @js.native
    def CONTAINER_IMAGE_TAG: String = js.native
    inline def CONTAINER_IMAGE_TAG_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CONTAINER_IMAGE_TAG")(x.asInstanceOf[js.Any])
    
    /**
      * Container name.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.CONTAINER_NAME")
    @js.native
    def CONTAINER_NAME: String = js.native
    inline def CONTAINER_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CONTAINER_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The container runtime managing this container.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.CONTAINER_RUNTIME")
    @js.native
    def CONTAINER_RUNTIME: String = js.native
    inline def CONTAINER_RUNTIME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CONTAINER_RUNTIME")(x.asInstanceOf[js.Any])
    
    /**
      * Name of the [deployment environment](https://en.wikipedia.org/wiki/Deployment_environment) (aka deployment tier).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT")
    @js.native
    def DEPLOYMENT_ENVIRONMENT: String = js.native
    inline def DEPLOYMENT_ENVIRONMENT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DEPLOYMENT_ENVIRONMENT")(x.asInstanceOf[js.Any])
    
    /**
      * A unique identifier representing the device.
      *
      * Note: The device identifier MUST only be defined using the values outlined below. This value is not an advertising identifier and MUST NOT be used as such. On iOS (Swift or Objective-C), this value MUST be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor). On Android (Java or Kotlin), this value MUST be equal to the Firebase Installation ID or a globally unique UUID which is persisted across sessions in your application. More information can be found [here](https://developer.android.com/training/articles/user-data-ids) on best practices and exact implementation details. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply, ensure you do your own due diligence.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.DEVICE_ID")
    @js.native
    def DEVICE_ID: String = js.native
    inline def DEVICE_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DEVICE_ID")(x.asInstanceOf[js.Any])
    
    /**
      * The model identifier for the device.
      *
      * Note: It&#39;s recommended this value represents a machine readable version of the model identifier rather than the market or consumer-friendly name of the device.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.DEVICE_MODEL_IDENTIFIER")
    @js.native
    def DEVICE_MODEL_IDENTIFIER: String = js.native
    inline def DEVICE_MODEL_IDENTIFIER_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DEVICE_MODEL_IDENTIFIER")(x.asInstanceOf[js.Any])
    
    /**
      * The marketing name for the device model.
      *
      * Note: It&#39;s recommended this value represents a human readable version of the device model rather than a machine readable alternative.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.DEVICE_MODEL_NAME")
    @js.native
    def DEVICE_MODEL_NAME: String = js.native
    inline def DEVICE_MODEL_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DEVICE_MODEL_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The unique ID of the single function that this runtime instance executes.
      *
      * Note: Depending on the cloud provider, use:
      
      * **AWS Lambda:** The function [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
      Take care not to use the &#34;invoked ARN&#34; directly but replace any
      [alias suffix](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html) with the resolved function version, as the same runtime instance may be invokable with multiple
      different aliases.
      * **GCP:** The [URI of the resource](https://cloud.google.com/iam/docs/full-resource-names)
      * **Azure:** The [Fully Qualified Resource ID](https://docs.microsoft.com/en-us/rest/api/resources/resources/get-by-id).
      
      On some providers, it may not be possible to determine the full ID at startup,
      which is why this field cannot be made required. For example, on AWS the account ID
      part of the ARN is not available without calling another AWS API
      which may be deemed too slow for a short-running lambda function.
      As an alternative, consider setting `faas.id` as a span attribute instead.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.FAAS_ID")
    @js.native
    def FAAS_ID: String = js.native
    inline def FAAS_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_ID")(x.asInstanceOf[js.Any])
    
    /**
      * The execution environment ID as a string, that will be potentially reused for other invocations to the same function/function version.
      *
      * Note: * **AWS Lambda:** Use the (full) log stream name.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.FAAS_INSTANCE")
    @js.native
    def FAAS_INSTANCE: String = js.native
    inline def FAAS_INSTANCE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_INSTANCE")(x.asInstanceOf[js.Any])
    
    /**
      * The amount of memory available to the serverless function in MiB.
      *
      * Note: It&#39;s recommended to set this attribute since e.g. too little memory can easily stop a Java AWS Lambda function from working correctly. On AWS Lambda, the environment variable `AWS_LAMBDA_FUNCTION_MEMORY_SIZE` provides this information.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.FAAS_MAX_MEMORY")
    @js.native
    def FAAS_MAX_MEMORY: String = js.native
    inline def FAAS_MAX_MEMORY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_MAX_MEMORY")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the single function that this runtime instance executes.
      *
      * Note: This is the name of the function as configured/deployed on the FaaS platform and is usually different from the name of the callback function (which may be stored in the [`code.namespace`/`code.function`](../../trace/semantic_conventions/span-general.md#source-code-attributes) span attributes).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.FAAS_NAME")
    @js.native
    def FAAS_NAME: String = js.native
    inline def FAAS_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The immutable version of the function being executed.
      *
      * Note: Depending on the cloud provider and platform, use:
      
      * **AWS Lambda:** The [function version](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
      (an integer represented as a decimal string).
      * **Google Cloud Run:** The [revision](https://cloud.google.com/run/docs/managing/revisions)
      (i.e., the function name plus the revision suffix).
      * **Google Cloud Functions:** The value of the
      [`K_REVISION` environment variable](https://cloud.google.com/functions/docs/env-var#runtime_environment_variables_set_automatically).
      * **Azure Functions:** Not applicable. Do not set this attribute.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.FAAS_VERSION")
    @js.native
    def FAAS_VERSION: String = js.native
    inline def FAAS_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * The CPU architecture the host system is running on.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.HOST_ARCH")
    @js.native
    def HOST_ARCH: String = js.native
    inline def HOST_ARCH_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_ARCH")(x.asInstanceOf[js.Any])
    
    /**
      * Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.HOST_ID")
    @js.native
    def HOST_ID: String = js.native
    inline def HOST_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_ID")(x.asInstanceOf[js.Any])
    
    /**
      * VM image ID. For Cloud, this value is from the provider.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.HOST_IMAGE_ID")
    @js.native
    def HOST_IMAGE_ID: String = js.native
    inline def HOST_IMAGE_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_IMAGE_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Name of the VM image or OS install the host was instantiated from.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.HOST_IMAGE_NAME")
    @js.native
    def HOST_IMAGE_NAME: String = js.native
    inline def HOST_IMAGE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_IMAGE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The version string of the VM image as defined in [Version SpanAttributes](README.md#version-attributes).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.HOST_IMAGE_VERSION")
    @js.native
    def HOST_IMAGE_VERSION: String = js.native
    inline def HOST_IMAGE_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_IMAGE_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.HOST_NAME")
    @js.native
    def HOST_NAME: String = js.native
    inline def HOST_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * Type of host. For Cloud, this must be the machine type.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.HOST_TYPE")
    @js.native
    def HOST_TYPE: String = js.native
    inline def HOST_TYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_TYPE")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the cluster.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_CLUSTER_NAME")
    @js.native
    def K8S_CLUSTER_NAME: String = js.native
    inline def K8S_CLUSTER_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_CLUSTER_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the Container in a Pod template.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_CONTAINER_NAME")
    @js.native
    def K8S_CONTAINER_NAME: String = js.native
    inline def K8S_CONTAINER_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_CONTAINER_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the CronJob.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_CRONJOB_NAME")
    @js.native
    def K8S_CRONJOB_NAME: String = js.native
    inline def K8S_CRONJOB_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_CRONJOB_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the CronJob.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_CRONJOB_UID")
    @js.native
    def K8S_CRONJOB_UID: String = js.native
    inline def K8S_CRONJOB_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_CRONJOB_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the DaemonSet.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_DAEMONSET_NAME")
    @js.native
    def K8S_DAEMONSET_NAME: String = js.native
    inline def K8S_DAEMONSET_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_DAEMONSET_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the DaemonSet.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_DAEMONSET_UID")
    @js.native
    def K8S_DAEMONSET_UID: String = js.native
    inline def K8S_DAEMONSET_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_DAEMONSET_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the Deployment.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_DEPLOYMENT_NAME")
    @js.native
    def K8S_DEPLOYMENT_NAME: String = js.native
    inline def K8S_DEPLOYMENT_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_DEPLOYMENT_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the Deployment.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_DEPLOYMENT_UID")
    @js.native
    def K8S_DEPLOYMENT_UID: String = js.native
    inline def K8S_DEPLOYMENT_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_DEPLOYMENT_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the Job.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_JOB_NAME")
    @js.native
    def K8S_JOB_NAME: String = js.native
    inline def K8S_JOB_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_JOB_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the Job.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_JOB_UID")
    @js.native
    def K8S_JOB_UID: String = js.native
    inline def K8S_JOB_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_JOB_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the namespace that the pod is running in.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_NAMESPACE_NAME")
    @js.native
    def K8S_NAMESPACE_NAME: String = js.native
    inline def K8S_NAMESPACE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_NAMESPACE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the Node.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_NODE_NAME")
    @js.native
    def K8S_NODE_NAME: String = js.native
    inline def K8S_NODE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_NODE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the Node.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_NODE_UID")
    @js.native
    def K8S_NODE_UID: String = js.native
    inline def K8S_NODE_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_NODE_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the Pod.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_POD_NAME")
    @js.native
    def K8S_POD_NAME: String = js.native
    inline def K8S_POD_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_POD_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the Pod.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_POD_UID")
    @js.native
    def K8S_POD_UID: String = js.native
    inline def K8S_POD_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_POD_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the ReplicaSet.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_REPLICASET_NAME")
    @js.native
    def K8S_REPLICASET_NAME: String = js.native
    inline def K8S_REPLICASET_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_REPLICASET_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the ReplicaSet.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_REPLICASET_UID")
    @js.native
    def K8S_REPLICASET_UID: String = js.native
    inline def K8S_REPLICASET_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_REPLICASET_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the StatefulSet.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_STATEFULSET_NAME")
    @js.native
    def K8S_STATEFULSET_NAME: String = js.native
    inline def K8S_STATEFULSET_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_STATEFULSET_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the StatefulSet.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.K8S_STATEFULSET_UID")
    @js.native
    def K8S_STATEFULSET_UID: String = js.native
    inline def K8S_STATEFULSET_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_STATEFULSET_UID")(x.asInstanceOf[js.Any])
    
    /**
      * Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.OS_DESCRIPTION")
    @js.native
    def OS_DESCRIPTION: String = js.native
    inline def OS_DESCRIPTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("OS_DESCRIPTION")(x.asInstanceOf[js.Any])
    
    /**
      * Human readable operating system name.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.OS_NAME")
    @js.native
    def OS_NAME: String = js.native
    inline def OS_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("OS_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The operating system type.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.OS_TYPE")
    @js.native
    def OS_TYPE: String = js.native
    inline def OS_TYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("OS_TYPE")(x.asInstanceOf[js.Any])
    
    /**
      * The version string of the operating system as defined in [Version SpanAttributes](../../resource/semantic_conventions/README.md#version-attributes).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.OS_VERSION")
    @js.native
    def OS_VERSION: String = js.native
    inline def OS_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("OS_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.PROCESS_COMMAND")
    @js.native
    def PROCESS_COMMAND: String = js.native
    inline def PROCESS_COMMAND_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_COMMAND")(x.asInstanceOf[js.Any])
    
    /**
      * All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.PROCESS_COMMAND_ARGS")
    @js.native
    def PROCESS_COMMAND_ARGS: String = js.native
    inline def PROCESS_COMMAND_ARGS_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_COMMAND_ARGS")(x.asInstanceOf[js.Any])
    
    /**
      * The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.PROCESS_COMMAND_LINE")
    @js.native
    def PROCESS_COMMAND_LINE: String = js.native
    inline def PROCESS_COMMAND_LINE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_COMMAND_LINE")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the process executable. On Linux based systems, can be set to the `Name` in `proc/[pid]/status`. On Windows, can be set to the base name of `GetProcessImageFileNameW`.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME")
    @js.native
    def PROCESS_EXECUTABLE_NAME: String = js.native
    inline def PROCESS_EXECUTABLE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_EXECUTABLE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH")
    @js.native
    def PROCESS_EXECUTABLE_PATH: String = js.native
    inline def PROCESS_EXECUTABLE_PATH_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_EXECUTABLE_PATH")(x.asInstanceOf[js.Any])
    
    /**
      * The username of the user that owns the process.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.PROCESS_OWNER")
    @js.native
    def PROCESS_OWNER: String = js.native
    inline def PROCESS_OWNER_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_OWNER")(x.asInstanceOf[js.Any])
    
    /**
      * Process identifier (PID).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.PROCESS_PID")
    @js.native
    def PROCESS_PID: String = js.native
    inline def PROCESS_PID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_PID")(x.asInstanceOf[js.Any])
    
    /**
      * An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION")
    @js.native
    def PROCESS_RUNTIME_DESCRIPTION: String = js.native
    inline def PROCESS_RUNTIME_DESCRIPTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_RUNTIME_DESCRIPTION")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.PROCESS_RUNTIME_NAME")
    @js.native
    def PROCESS_RUNTIME_NAME: String = js.native
    inline def PROCESS_RUNTIME_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_RUNTIME_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The version of the runtime of this process, as returned by the runtime without modification.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.PROCESS_RUNTIME_VERSION")
    @js.native
    def PROCESS_RUNTIME_VERSION: String = js.native
    inline def PROCESS_RUNTIME_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_RUNTIME_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * The string ID of the service instance.
      *
      * Note: MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled service). It is preferable for the ID to be persistent and stay the same for the lifetime of the service instance, however it is acceptable that the ID is ephemeral and changes during important lifetime events for the service (e.g. service restarts). If the service has no inherent unique ID that can be used as the value of this attribute it is recommended to generate a random Version 1 or Version 4 RFC 4122 UUID (services aiming for reproducible UUIDs may also use Version 5, see RFC 4122 for more recommendations).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.SERVICE_INSTANCE_ID")
    @js.native
    def SERVICE_INSTANCE_ID: String = js.native
    inline def SERVICE_INSTANCE_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SERVICE_INSTANCE_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Logical name of the service.
      *
      * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.SERVICE_NAME")
    @js.native
    def SERVICE_NAME: String = js.native
    
    /**
      * A namespace for `service.name`.
      *
      * Note: A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.SERVICE_NAMESPACE")
    @js.native
    def SERVICE_NAMESPACE: String = js.native
    inline def SERVICE_NAMESPACE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SERVICE_NAMESPACE")(x.asInstanceOf[js.Any])
    
    inline def SERVICE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SERVICE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The version string of the service API or implementation.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.SERVICE_VERSION")
    @js.native
    def SERVICE_VERSION: String = js.native
    inline def SERVICE_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SERVICE_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * The version string of the auto instrumentation agent, if used.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.TELEMETRY_AUTO_VERSION")
    @js.native
    def TELEMETRY_AUTO_VERSION: String = js.native
    inline def TELEMETRY_AUTO_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TELEMETRY_AUTO_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * The language of the telemetry SDK.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE")
    @js.native
    def TELEMETRY_SDK_LANGUAGE: String = js.native
    inline def TELEMETRY_SDK_LANGUAGE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TELEMETRY_SDK_LANGUAGE")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the telemetry SDK as defined above.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.TELEMETRY_SDK_NAME")
    @js.native
    def TELEMETRY_SDK_NAME: String = js.native
    inline def TELEMETRY_SDK_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TELEMETRY_SDK_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The version string of the telemetry SDK.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.TELEMETRY_SDK_VERSION")
    @js.native
    def TELEMETRY_SDK_VERSION: String = js.native
    inline def TELEMETRY_SDK_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TELEMETRY_SDK_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * Additional description of the web engine (e.g. detailed version and edition information).
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.WEBENGINE_DESCRIPTION")
    @js.native
    def WEBENGINE_DESCRIPTION: String = js.native
    inline def WEBENGINE_DESCRIPTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("WEBENGINE_DESCRIPTION")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the web engine.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.WEBENGINE_NAME")
    @js.native
    def WEBENGINE_NAME: String = js.native
    inline def WEBENGINE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("WEBENGINE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The version of the web engine.
      */
    @JSImport("@opentelemetry/semantic-conventions", "SemanticResourceAttributes.WEBENGINE_VERSION")
    @js.native
    def WEBENGINE_VERSION: String = js.native
    inline def WEBENGINE_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("WEBENGINE_VERSION")(x.asInstanceOf[js.Any])
  }
  
  object TelemetrySdkLanguageValues {
    
    /** cpp. */
    @JSImport("@opentelemetry/semantic-conventions", "TelemetrySdkLanguageValues.CPP")
    @js.native
    val CPP: cpp = js.native
    
    /** dotnet. */
    @JSImport("@opentelemetry/semantic-conventions", "TelemetrySdkLanguageValues.DOTNET")
    @js.native
    val DOTNET: dotnet = js.native
    
    /** erlang. */
    @JSImport("@opentelemetry/semantic-conventions", "TelemetrySdkLanguageValues.ERLANG")
    @js.native
    val ERLANG: erlang = js.native
    
    /** go. */
    @JSImport("@opentelemetry/semantic-conventions", "TelemetrySdkLanguageValues.GO")
    @js.native
    val GO: go = js.native
    
    /** java. */
    @JSImport("@opentelemetry/semantic-conventions", "TelemetrySdkLanguageValues.JAVA")
    @js.native
    val JAVA: java_ = js.native
    
    /** nodejs. */
    @JSImport("@opentelemetry/semantic-conventions", "TelemetrySdkLanguageValues.NODEJS")
    @js.native
    val NODEJS: nodejs = js.native
    
    /** php. */
    @JSImport("@opentelemetry/semantic-conventions", "TelemetrySdkLanguageValues.PHP")
    @js.native
    val PHP: php = js.native
    
    /** python. */
    @JSImport("@opentelemetry/semantic-conventions", "TelemetrySdkLanguageValues.PYTHON")
    @js.native
    val PYTHON: python = js.native
    
    /** ruby. */
    @JSImport("@opentelemetry/semantic-conventions", "TelemetrySdkLanguageValues.RUBY")
    @js.native
    val RUBY: ruby = js.native
    
    /** webjs. */
    @JSImport("@opentelemetry/semantic-conventions", "TelemetrySdkLanguageValues.WEBJS")
    @js.native
    val WEBJS: webjs = js.native
  }
}
