package typings.opentelemetrySemanticConventions

import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`0`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`10`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`11`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`12`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`13`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`14`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`15`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`16`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`1`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`2`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`3`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`4`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`5`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`6`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`7`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`8`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsNumbers.`9`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.`1Dot0`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.`1Dot1`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.`2Dot0`
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.adabas
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.alibaba_cloud
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.all
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.any
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cache
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cassandra
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cdma
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cdma2000_1xrtt
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cell
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cloudscape
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cockroachdb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.coldfusion
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cosmosdb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.couchbase
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.couchdb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.datasource
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.db2
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.delete
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.derby
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.dynamodb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.each_quorum
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.edb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.edge
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.edit
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ehrpd
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.elasticsearch
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.evdo_0
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.evdo_a
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.evdo_b
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.filemaker
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.firebird
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.firstsql
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.geode
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gprs
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gsm
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.h2
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hanadb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hbase
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hive
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hsdpa
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hspa
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hspap
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hsqldb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hsupa
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.http
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.iden
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.informix
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ingres
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.inproc
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.insert
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.instantdb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.interbase
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ip
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ip_tcp
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ip_udp
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.iwlan
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.local_one
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.local_quorum
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.local_serial
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.lte
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.lte_ca
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.mariadb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.maxdb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.memcached
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.mongodb
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.mssql
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.mysql
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.neo4j
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.netezza
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.nr
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.nrnsa
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.one
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.oracle
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.other
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.other_sql
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.pervasive
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.pipe
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.pointbase
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.postgresql
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.process
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.progress
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.pubsub
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.queue
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.quorum
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.receive
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.redis
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.redshift
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.serial
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.sqlite
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.sybase
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.td_scdma
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.teradata
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.three
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.timer
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.topic
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.two
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.umts
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.unavailable
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.unix
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.unknown
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.vertica
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.wifi
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.wired
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object traceMod {
  
  object DbCassandraConsistencyLevelValues {
    
    /** all. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbCassandraConsistencyLevelValues.ALL")
    @js.native
    val ALL: all = js.native
    
    /** any. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbCassandraConsistencyLevelValues.ANY")
    @js.native
    val ANY: any = js.native
    
    /** each_quorum. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbCassandraConsistencyLevelValues.EACH_QUORUM")
    @js.native
    val EACH_QUORUM: each_quorum = js.native
    
    /** local_one. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbCassandraConsistencyLevelValues.LOCAL_ONE")
    @js.native
    val LOCAL_ONE: local_one = js.native
    
    /** local_quorum. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbCassandraConsistencyLevelValues.LOCAL_QUORUM")
    @js.native
    val LOCAL_QUORUM: local_quorum = js.native
    
    /** local_serial. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbCassandraConsistencyLevelValues.LOCAL_SERIAL")
    @js.native
    val LOCAL_SERIAL: local_serial = js.native
    
    /** one. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbCassandraConsistencyLevelValues.ONE")
    @js.native
    val ONE: one = js.native
    
    /** quorum. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbCassandraConsistencyLevelValues.QUORUM")
    @js.native
    val QUORUM: quorum = js.native
    
    /** serial. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbCassandraConsistencyLevelValues.SERIAL")
    @js.native
    val SERIAL: serial = js.native
    
    /** three. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbCassandraConsistencyLevelValues.THREE")
    @js.native
    val THREE: three = js.native
    
    /** two. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbCassandraConsistencyLevelValues.TWO")
    @js.native
    val TWO: two = js.native
  }
  
  object DbSystemValues {
    
    /** Adabas (Adaptable Database System). */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.ADABAS")
    @js.native
    val ADABAS: adabas = js.native
    
    /** InterSystems Cach√©. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.CACHE")
    @js.native
    val CACHE: cache = js.native
    
    /** Apache Cassandra. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.CASSANDRA")
    @js.native
    val CASSANDRA: cassandra = js.native
    
    /** Cloudscape. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.CLOUDSCAPE")
    @js.native
    val CLOUDSCAPE: cloudscape = js.native
    
    /** CockroachDB. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.COCKROACHDB")
    @js.native
    val COCKROACHDB: cockroachdb = js.native
    
    /** ColdFusion IMQ. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.COLDFUSION")
    @js.native
    val COLDFUSION: coldfusion = js.native
    
    /** Microsoft Azure Cosmos DB. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.COSMOSDB")
    @js.native
    val COSMOSDB: cosmosdb = js.native
    
    /** Couchbase. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.COUCHBASE")
    @js.native
    val COUCHBASE: couchbase = js.native
    
    /** CouchDB. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.COUCHDB")
    @js.native
    val COUCHDB: couchdb = js.native
    
    /** IBM Db2. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.DB2")
    @js.native
    val DB2: db2 = js.native
    
    /** Apache Derby. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.DERBY")
    @js.native
    val DERBY: derby = js.native
    
    /** Amazon DynamoDB. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.DYNAMODB")
    @js.native
    val DYNAMODB: dynamodb = js.native
    
    /** EnterpriseDB. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.EDB")
    @js.native
    val EDB: edb = js.native
    
    /** Elasticsearch. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.ELASTICSEARCH")
    @js.native
    val ELASTICSEARCH: elasticsearch = js.native
    
    /** FileMaker. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.FILEMAKER")
    @js.native
    val FILEMAKER: filemaker = js.native
    
    /** Firebird. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.FIREBIRD")
    @js.native
    val FIREBIRD: firebird = js.native
    
    /** FirstSQL. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.FIRSTSQL")
    @js.native
    val FIRSTSQL: firstsql = js.native
    
    /** Apache Geode. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.GEODE")
    @js.native
    val GEODE: geode = js.native
    
    /** H2. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.H2")
    @js.native
    val H2: h2 = js.native
    
    /** SAP HANA. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.HANADB")
    @js.native
    val HANADB: hanadb = js.native
    
    /** Apache HBase. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.HBASE")
    @js.native
    val HBASE: hbase = js.native
    
    /** Apache Hive. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.HIVE")
    @js.native
    val HIVE: hive = js.native
    
    /** HyperSQL DataBase. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.HSQLDB")
    @js.native
    val HSQLDB: hsqldb = js.native
    
    /** Informix. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.INFORMIX")
    @js.native
    val INFORMIX: informix = js.native
    
    /** Ingres. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.INGRES")
    @js.native
    val INGRES: ingres = js.native
    
    /** InstantDB. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.INSTANTDB")
    @js.native
    val INSTANTDB: instantdb = js.native
    
    /** InterBase. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.INTERBASE")
    @js.native
    val INTERBASE: interbase = js.native
    
    /** MariaDB. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.MARIADB")
    @js.native
    val MARIADB: mariadb = js.native
    
    /** SAP MaxDB. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.MAXDB")
    @js.native
    val MAXDB: maxdb = js.native
    
    /** Memcached. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.MEMCACHED")
    @js.native
    val MEMCACHED: memcached = js.native
    
    /** MongoDB. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.MONGODB")
    @js.native
    val MONGODB: mongodb = js.native
    
    /** Microsoft SQL Server. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.MSSQL")
    @js.native
    val MSSQL: mssql = js.native
    
    /** MySQL. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.MYSQL")
    @js.native
    val MYSQL: mysql = js.native
    
    /** Neo4j. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.NEO4J")
    @js.native
    val NEO4J: neo4j = js.native
    
    /** Netezza. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.NETEZZA")
    @js.native
    val NETEZZA: netezza = js.native
    
    /** Oracle Database. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.ORACLE")
    @js.native
    val ORACLE: oracle = js.native
    
    /** Some other SQL database. Fallback only. See notes. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.OTHER_SQL")
    @js.native
    val OTHER_SQL: other_sql = js.native
    
    /** Pervasive PSQL. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.PERVASIVE")
    @js.native
    val PERVASIVE: pervasive = js.native
    
    /** PointBase. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.POINTBASE")
    @js.native
    val POINTBASE: pointbase = js.native
    
    /** PostgreSQL. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.POSTGRESQL")
    @js.native
    val POSTGRESQL: postgresql = js.native
    
    /** Progress Database. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.PROGRESS")
    @js.native
    val PROGRESS: progress = js.native
    
    /** Redis. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.REDIS")
    @js.native
    val REDIS: redis = js.native
    
    /** Amazon Redshift. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.REDSHIFT")
    @js.native
    val REDSHIFT: redshift = js.native
    
    /** SQLite. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.SQLITE")
    @js.native
    val SQLITE: sqlite = js.native
    
    /** Sybase. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.SYBASE")
    @js.native
    val SYBASE: sybase = js.native
    
    /** Teradata. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.TERADATA")
    @js.native
    val TERADATA: teradata = js.native
    
    /** Vertica. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "DbSystemValues.VERTICA")
    @js.native
    val VERTICA: vertica = js.native
  }
  
  object FaasDocumentOperationValues {
    
    /** When an object is deleted. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "FaasDocumentOperationValues.DELETE")
    @js.native
    val DELETE: delete = js.native
    
    /** When an object is modified. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "FaasDocumentOperationValues.EDIT")
    @js.native
    val EDIT: edit = js.native
    
    /** When a new object is created. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "FaasDocumentOperationValues.INSERT")
    @js.native
    val INSERT: insert = js.native
  }
  
  object FaasInvokedProviderValues {
    
    /** Alibaba Cloud. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "FaasInvokedProviderValues.ALIBABA_CLOUD")
    @js.native
    val ALIBABA_CLOUD: alibaba_cloud = js.native
    
    /** Amazon Web Services. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "FaasInvokedProviderValues.AWS")
    @js.native
    val AWS: aws = js.native
    
    /** Microsoft Azure. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "FaasInvokedProviderValues.AZURE")
    @js.native
    val AZURE: azure = js.native
    
    /** Google Cloud Platform. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "FaasInvokedProviderValues.GCP")
    @js.native
    val GCP: gcp = js.native
  }
  
  object FaasTriggerValues {
    
    /** A response to some data source operation such as a database or filesystem read/write. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "FaasTriggerValues.DATASOURCE")
    @js.native
    val DATASOURCE: datasource = js.native
    
    /** To provide an answer to an inbound HTTP request. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "FaasTriggerValues.HTTP")
    @js.native
    val HTTP: http = js.native
    
    /** If none of the others apply. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "FaasTriggerValues.OTHER")
    @js.native
    val OTHER: other = js.native
    
    /** A function is set to be executed when messages are sent to a messaging system. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "FaasTriggerValues.PUBSUB")
    @js.native
    val PUBSUB: pubsub = js.native
    
    /** A function is scheduled to be executed regularly. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "FaasTriggerValues.TIMER")
    @js.native
    val TIMER: timer = js.native
  }
  
  object HttpFlavorValues {
    
    /** HTTP 1.0. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "HttpFlavorValues.HTTP_1_0")
    @js.native
    val HTTP_1_0: `1Dot0` = js.native
    
    /** HTTP 1.1. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "HttpFlavorValues.HTTP_1_1")
    @js.native
    val HTTP_1_1: `1Dot1` = js.native
    
    /** HTTP 2. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "HttpFlavorValues.HTTP_2_0")
    @js.native
    val HTTP_2_0: `2Dot0` = js.native
    
    /** QUIC protocol. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "HttpFlavorValues.QUIC")
    @js.native
    val QUIC: typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.QUIC = js.native
    
    /** SPDY protocol. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "HttpFlavorValues.SPDY")
    @js.native
    val SPDY: typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.SPDY = js.native
  }
  
  object MessageTypeValues {
    
    /** received. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "MessageTypeValues.RECEIVED")
    @js.native
    val RECEIVED: typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.RECEIVED = js.native
    
    /** sent. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "MessageTypeValues.SENT")
    @js.native
    val SENT: typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.SENT = js.native
  }
  
  object MessagingDestinationKindValues {
    
    /** A message sent to a queue. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "MessagingDestinationKindValues.QUEUE")
    @js.native
    val QUEUE: queue = js.native
    
    /** A message sent to a topic. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "MessagingDestinationKindValues.TOPIC")
    @js.native
    val TOPIC: topic = js.native
  }
  
  object MessagingOperationValues {
    
    /** process. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "MessagingOperationValues.PROCESS")
    @js.native
    val PROCESS: process = js.native
    
    /** receive. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "MessagingOperationValues.RECEIVE")
    @js.native
    val RECEIVE: receive = js.native
  }
  
  object NetHostConnectionSubtypeValues {
    
    /** CDMA. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.CDMA")
    @js.native
    val CDMA: cdma = js.native
    
    /** CDMA2000 1XRTT. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.CDMA2000_1XRTT")
    @js.native
    val CDMA2000_1XRTT: cdma2000_1xrtt = js.native
    
    /** EDGE. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.EDGE")
    @js.native
    val EDGE: edge = js.native
    
    /** EHRPD. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.EHRPD")
    @js.native
    val EHRPD: ehrpd = js.native
    
    /** EVDO Rel. 0. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.EVDO_0")
    @js.native
    val EVDO_0: evdo_0 = js.native
    
    /** EVDO Rev. A. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.EVDO_A")
    @js.native
    val EVDO_A: evdo_a = js.native
    
    /** EVDO Rev. B. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.EVDO_B")
    @js.native
    val EVDO_B: evdo_b = js.native
    
    /** GPRS. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.GPRS")
    @js.native
    val GPRS: gprs = js.native
    
    /** GSM. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.GSM")
    @js.native
    val GSM: gsm = js.native
    
    /** HSDPA. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.HSDPA")
    @js.native
    val HSDPA: hsdpa = js.native
    
    /** HSPA. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.HSPA")
    @js.native
    val HSPA: hspa = js.native
    
    /** HSPAP. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.HSPAP")
    @js.native
    val HSPAP: hspap = js.native
    
    /** HSUPA. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.HSUPA")
    @js.native
    val HSUPA: hsupa = js.native
    
    /** IDEN. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.IDEN")
    @js.native
    val IDEN: iden = js.native
    
    /** IWLAN. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.IWLAN")
    @js.native
    val IWLAN: iwlan = js.native
    
    /** LTE. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.LTE")
    @js.native
    val LTE: lte = js.native
    
    /** LTE CA. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.LTE_CA")
    @js.native
    val LTE_CA: lte_ca = js.native
    
    /** 5G NR (New Radio). */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.NR")
    @js.native
    val NR: nr = js.native
    
    /** 5G NRNSA (New Radio Non-Standalone). */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.NRNSA")
    @js.native
    val NRNSA: nrnsa = js.native
    
    /** TD-SCDMA. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.TD_SCDMA")
    @js.native
    val TD_SCDMA: td_scdma = js.native
    
    /** UMTS. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionSubtypeValues.UMTS")
    @js.native
    val UMTS: umts = js.native
  }
  
  object NetHostConnectionTypeValues {
    
    /** cell. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionTypeValues.CELL")
    @js.native
    val CELL: cell = js.native
    
    /** unavailable. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionTypeValues.UNAVAILABLE")
    @js.native
    val UNAVAILABLE: unavailable = js.native
    
    /** unknown. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionTypeValues.UNKNOWN")
    @js.native
    val UNKNOWN: unknown = js.native
    
    /** wifi. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionTypeValues.WIFI")
    @js.native
    val WIFI: wifi = js.native
    
    /** wired. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetHostConnectionTypeValues.WIRED")
    @js.native
    val WIRED: wired = js.native
  }
  
  object NetTransportValues {
    
    /** In-process communication. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetTransportValues.INPROC")
    @js.native
    val INPROC: inproc = js.native
    
    /** Another IP-based protocol. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetTransportValues.IP")
    @js.native
    val IP: ip = js.native
    
    /** ip_tcp. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetTransportValues.IP_TCP")
    @js.native
    val IP_TCP: ip_tcp = js.native
    
    /** ip_udp. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetTransportValues.IP_UDP")
    @js.native
    val IP_UDP: ip_udp = js.native
    
    /** Something else (non IP-based). */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetTransportValues.OTHER")
    @js.native
    val OTHER: other = js.native
    
    /** Named or anonymous pipe. See note below. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetTransportValues.PIPE")
    @js.native
    val PIPE: pipe = js.native
    
    /** Unix Domain socket. See below. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "NetTransportValues.UNIX")
    @js.native
    val UNIX: unix = js.native
  }
  
  object RpcGrpcStatusCodeValues {
    
    /** ABORTED. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.ABORTED")
    @js.native
    val ABORTED: `10` = js.native
    
    /** ALREADY_EXISTS. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.ALREADY_EXISTS")
    @js.native
    val ALREADY_EXISTS: `6` = js.native
    
    /** CANCELLED. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.CANCELLED")
    @js.native
    val CANCELLED: `1` = js.native
    
    /** DATA_LOSS. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.DATA_LOSS")
    @js.native
    val DATA_LOSS: `15` = js.native
    
    /** DEADLINE_EXCEEDED. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.DEADLINE_EXCEEDED")
    @js.native
    val DEADLINE_EXCEEDED: `4` = js.native
    
    /** FAILED_PRECONDITION. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.FAILED_PRECONDITION")
    @js.native
    val FAILED_PRECONDITION: `9` = js.native
    
    /** INTERNAL. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.INTERNAL")
    @js.native
    val INTERNAL: `13` = js.native
    
    /** INVALID_ARGUMENT. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.INVALID_ARGUMENT")
    @js.native
    val INVALID_ARGUMENT: `3` = js.native
    
    /** NOT_FOUND. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.NOT_FOUND")
    @js.native
    val NOT_FOUND: `5` = js.native
    
    /** OK. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.OK")
    @js.native
    val OK: `0` = js.native
    
    /** OUT_OF_RANGE. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.OUT_OF_RANGE")
    @js.native
    val OUT_OF_RANGE: `11` = js.native
    
    /** PERMISSION_DENIED. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.PERMISSION_DENIED")
    @js.native
    val PERMISSION_DENIED: `7` = js.native
    
    /** RESOURCE_EXHAUSTED. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.RESOURCE_EXHAUSTED")
    @js.native
    val RESOURCE_EXHAUSTED: `8` = js.native
    
    /** UNAUTHENTICATED. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.UNAUTHENTICATED")
    @js.native
    val UNAUTHENTICATED: `16` = js.native
    
    /** UNAVAILABLE. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.UNAVAILABLE")
    @js.native
    val UNAVAILABLE: `14` = js.native
    
    /** UNIMPLEMENTED. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.UNIMPLEMENTED")
    @js.native
    val UNIMPLEMENTED: `12` = js.native
    
    /** UNKNOWN. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "RpcGrpcStatusCodeValues.UNKNOWN")
    @js.native
    val UNKNOWN: `2` = js.native
  }
  
  object SemanticAttributes {
    
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes")
    @js.native
    val ^ : js.Any = js.native
    
    /**
      * The value of the `AttributesToGet` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_ATTRIBUTES_TO_GET")
    @js.native
    def AWS_DYNAMODB_ATTRIBUTES_TO_GET: String = js.native
    inline def AWS_DYNAMODB_ATTRIBUTES_TO_GET_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_ATTRIBUTES_TO_GET")(x.asInstanceOf[js.Any])
    
    /**
      * The JSON-serialized value of each item in the `AttributeDefinitions` request field.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS")
    @js.native
    def AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS: String = js.native
    inline def AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_ATTRIBUTE_DEFINITIONS")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ConsistentRead` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_CONSISTENT_READ")
    @js.native
    def AWS_DYNAMODB_CONSISTENT_READ: String = js.native
    inline def AWS_DYNAMODB_CONSISTENT_READ_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_CONSISTENT_READ")(x.asInstanceOf[js.Any])
    
    /**
      * The JSON-serialized value of each item in the `ConsumedCapacity` response field.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_CONSUMED_CAPACITY")
    @js.native
    def AWS_DYNAMODB_CONSUMED_CAPACITY: String = js.native
    inline def AWS_DYNAMODB_CONSUMED_CAPACITY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_CONSUMED_CAPACITY")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `Count` response parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_COUNT")
    @js.native
    def AWS_DYNAMODB_COUNT: String = js.native
    inline def AWS_DYNAMODB_COUNT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_COUNT")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ExclusiveStartTableName` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_EXCLUSIVE_START_TABLE")
    @js.native
    def AWS_DYNAMODB_EXCLUSIVE_START_TABLE: String = js.native
    inline def AWS_DYNAMODB_EXCLUSIVE_START_TABLE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_EXCLUSIVE_START_TABLE")(x.asInstanceOf[js.Any])
    
    /**
      * The JSON-serialized value of each item of the `GlobalSecondaryIndexes` request field.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES")
    @js.native
    def AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES: String = js.native
    inline def AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_GLOBAL_SECONDARY_INDEXES")(x.asInstanceOf[js.Any])
    
    /**
      * The JSON-serialized value of each item in the the `GlobalSecondaryIndexUpdates` request field.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES")
    @js.native
    def AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES: String = js.native
    inline def AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_GLOBAL_SECONDARY_INDEX_UPDATES")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `IndexName` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_INDEX_NAME")
    @js.native
    def AWS_DYNAMODB_INDEX_NAME: String = js.native
    inline def AWS_DYNAMODB_INDEX_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_INDEX_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The JSON-serialized value of the `ItemCollectionMetrics` response field.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_ITEM_COLLECTION_METRICS")
    @js.native
    def AWS_DYNAMODB_ITEM_COLLECTION_METRICS: String = js.native
    inline def AWS_DYNAMODB_ITEM_COLLECTION_METRICS_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_ITEM_COLLECTION_METRICS")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `Limit` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_LIMIT")
    @js.native
    def AWS_DYNAMODB_LIMIT: String = js.native
    inline def AWS_DYNAMODB_LIMIT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_LIMIT")(x.asInstanceOf[js.Any])
    
    /**
      * The JSON-serialized value of each item of the `LocalSecondaryIndexes` request field.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES")
    @js.native
    def AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES: String = js.native
    inline def AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_LOCAL_SECONDARY_INDEXES")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ProjectionExpression` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_PROJECTION")
    @js.native
    def AWS_DYNAMODB_PROJECTION: String = js.native
    inline def AWS_DYNAMODB_PROJECTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_PROJECTION")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ProvisionedThroughput.ReadCapacityUnits` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_PROVISIONED_READ_CAPACITY")
    @js.native
    def AWS_DYNAMODB_PROVISIONED_READ_CAPACITY: String = js.native
    inline def AWS_DYNAMODB_PROVISIONED_READ_CAPACITY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_PROVISIONED_READ_CAPACITY")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ProvisionedThroughput.WriteCapacityUnits` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY")
    @js.native
    def AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY: String = js.native
    inline def AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_PROVISIONED_WRITE_CAPACITY")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ScannedCount` response parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_SCANNED_COUNT")
    @js.native
    def AWS_DYNAMODB_SCANNED_COUNT: String = js.native
    inline def AWS_DYNAMODB_SCANNED_COUNT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_SCANNED_COUNT")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `ScanIndexForward` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_SCAN_FORWARD")
    @js.native
    def AWS_DYNAMODB_SCAN_FORWARD: String = js.native
    inline def AWS_DYNAMODB_SCAN_FORWARD_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_SCAN_FORWARD")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `Segment` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_SEGMENT")
    @js.native
    def AWS_DYNAMODB_SEGMENT: String = js.native
    inline def AWS_DYNAMODB_SEGMENT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_SEGMENT")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `Select` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_SELECT")
    @js.native
    def AWS_DYNAMODB_SELECT: String = js.native
    inline def AWS_DYNAMODB_SELECT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_SELECT")(x.asInstanceOf[js.Any])
    
    /**
      * The the number of items in the `TableNames` response parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_TABLE_COUNT")
    @js.native
    def AWS_DYNAMODB_TABLE_COUNT: String = js.native
    inline def AWS_DYNAMODB_TABLE_COUNT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_TABLE_COUNT")(x.asInstanceOf[js.Any])
    
    /**
      * The keys in the `RequestItems` object field.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_TABLE_NAMES")
    @js.native
    def AWS_DYNAMODB_TABLE_NAMES: String = js.native
    inline def AWS_DYNAMODB_TABLE_NAMES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_TABLE_NAMES")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the `TotalSegments` request parameter.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_DYNAMODB_TOTAL_SEGMENTS")
    @js.native
    def AWS_DYNAMODB_TOTAL_SEGMENTS: String = js.native
    inline def AWS_DYNAMODB_TOTAL_SEGMENTS_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_DYNAMODB_TOTAL_SEGMENTS")(x.asInstanceOf[js.Any])
    
    /**
      * The full invoked ARN as provided on the `Context` passed to the function (`Lambda-Runtime-Invoked-Function-Arn` header on the `/runtime/invocation/next` applicable).
      *
      * Note: This may be different from `faas.id` if an alias is involved.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.AWS_LAMBDA_INVOKED_ARN")
    @js.native
    def AWS_LAMBDA_INVOKED_ARN: String = js.native
    inline def AWS_LAMBDA_INVOKED_ARN_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_LAMBDA_INVOKED_ARN")(x.asInstanceOf[js.Any])
    
    /**
      * The source code file name that identifies the code unit as uniquely as possible (preferably an absolute file path).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.CODE_FILEPATH")
    @js.native
    def CODE_FILEPATH: String = js.native
    inline def CODE_FILEPATH_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CODE_FILEPATH")(x.asInstanceOf[js.Any])
    
    /**
      * The method or function name, or equivalent (usually rightmost part of the code unit&#39;s name).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.CODE_FUNCTION")
    @js.native
    def CODE_FUNCTION: String = js.native
    inline def CODE_FUNCTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CODE_FUNCTION")(x.asInstanceOf[js.Any])
    
    /**
      * The line number in `code.filepath` best representing the operation. It SHOULD point within the code unit named in `code.function`.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.CODE_LINENO")
    @js.native
    def CODE_LINENO: String = js.native
    inline def CODE_LINENO_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CODE_LINENO")(x.asInstanceOf[js.Any])
    
    /**
      * The &#34;namespace&#34; within which `code.function` is defined. Usually the qualified class or module name, such that `code.namespace` + some separator + `code.function` form a unique identifier for the code unit.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.CODE_NAMESPACE")
    @js.native
    def CODE_NAMESPACE: String = js.native
    inline def CODE_NAMESPACE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CODE_NAMESPACE")(x.asInstanceOf[js.Any])
    
    /**
      * The consistency level of the query. Based on consistency values from [CQL](https://docs.datastax.com/en/cassandra-oss/3.0/cassandra/dml/dmlConfigConsistency.html).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_CASSANDRA_CONSISTENCY_LEVEL")
    @js.native
    def DB_CASSANDRA_CONSISTENCY_LEVEL: String = js.native
    inline def DB_CASSANDRA_CONSISTENCY_LEVEL_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_CONSISTENCY_LEVEL")(x.asInstanceOf[js.Any])
    
    /**
      * The data center of the coordinating node for a query.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_CASSANDRA_COORDINATOR_DC")
    @js.native
    def DB_CASSANDRA_COORDINATOR_DC: String = js.native
    inline def DB_CASSANDRA_COORDINATOR_DC_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_COORDINATOR_DC")(x.asInstanceOf[js.Any])
    
    /**
      * The ID of the coordinating node for a query.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_CASSANDRA_COORDINATOR_ID")
    @js.native
    def DB_CASSANDRA_COORDINATOR_ID: String = js.native
    inline def DB_CASSANDRA_COORDINATOR_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_COORDINATOR_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Whether or not the query is idempotent.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_CASSANDRA_IDEMPOTENCE")
    @js.native
    def DB_CASSANDRA_IDEMPOTENCE: String = js.native
    inline def DB_CASSANDRA_IDEMPOTENCE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_IDEMPOTENCE")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the keyspace being accessed. To be used instead of the generic `db.name` attribute.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_CASSANDRA_KEYSPACE")
    @js.native
    def DB_CASSANDRA_KEYSPACE: String = js.native
    inline def DB_CASSANDRA_KEYSPACE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_KEYSPACE")(x.asInstanceOf[js.Any])
    
    /**
      * The fetch size used for paging, i.e. how many rows will be returned at once.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_CASSANDRA_PAGE_SIZE")
    @js.native
    def DB_CASSANDRA_PAGE_SIZE: String = js.native
    inline def DB_CASSANDRA_PAGE_SIZE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_PAGE_SIZE")(x.asInstanceOf[js.Any])
    
    /**
      * The number of times a query was speculatively executed. Not set or `0` if the query was not executed speculatively.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT")
    @js.native
    def DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT: String = js.native
    inline def DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_SPECULATIVE_EXECUTION_COUNT")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
      *
      * Note: This mirrors the db.sql.table attribute but references cassandra rather than sql. It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_CASSANDRA_TABLE")
    @js.native
    def DB_CASSANDRA_TABLE: String = js.native
    inline def DB_CASSANDRA_TABLE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CASSANDRA_TABLE")(x.asInstanceOf[js.Any])
    
    /**
      * The connection string used to connect to the database. It is recommended to remove embedded credentials.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_CONNECTION_STRING")
    @js.native
    def DB_CONNECTION_STRING: String = js.native
    inline def DB_CONNECTION_STRING_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_CONNECTION_STRING")(x.asInstanceOf[js.Any])
    
    /**
      * The [HBase namespace](https://hbase.apache.org/book.html#_namespace) being accessed. To be used instead of the generic `db.name` attribute.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_HBASE_NAMESPACE")
    @js.native
    def DB_HBASE_NAMESPACE: String = js.native
    inline def DB_HBASE_NAMESPACE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_HBASE_NAMESPACE")(x.asInstanceOf[js.Any])
    
    /**
      * The fully-qualified class name of the [Java Database Connectivity (JDBC)](https://docs.oracle.com/javase/8/docs/technotes/guides/jdbc/) driver used to connect.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_JDBC_DRIVER_CLASSNAME")
    @js.native
    def DB_JDBC_DRIVER_CLASSNAME: String = js.native
    inline def DB_JDBC_DRIVER_CLASSNAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_JDBC_DRIVER_CLASSNAME")(x.asInstanceOf[js.Any])
    
    /**
      * The collection being accessed within the database stated in `db.name`.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_MONGODB_COLLECTION")
    @js.native
    def DB_MONGODB_COLLECTION: String = js.native
    inline def DB_MONGODB_COLLECTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_MONGODB_COLLECTION")(x.asInstanceOf[js.Any])
    
    /**
      * The Microsoft SQL Server [instance name](https://docs.microsoft.com/en-us/sql/connect/jdbc/building-the-connection-url?view=sql-server-ver15) connecting to. This name is used to determine the port of a named instance.
      *
      * Note: If setting a `db.mssql.instance_name`, `net.peer.port` is no longer required (but still recommended if non-standard).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_MSSQL_INSTANCE_NAME")
    @js.native
    def DB_MSSQL_INSTANCE_NAME: String = js.native
    inline def DB_MSSQL_INSTANCE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_MSSQL_INSTANCE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * If no [tech-specific attribute](#call-level-attributes-for-specific-technologies) is defined, this attribute is used to report the name of the database being accessed. For commands that switch the database, this should be set to the target database (even if the command fails).
      *
      * Note: In some SQL databases, the database name to be used is called &#34;schema name&#34;.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_NAME")
    @js.native
    def DB_NAME: String = js.native
    inline def DB_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the operation being executed, e.g. the [MongoDB command name](https://docs.mongodb.com/manual/reference/command/#database-operations) such as `findAndModify`, or the SQL keyword.
      *
      * Note: When setting this to an SQL keyword, it is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if the operation name is provided by the library being instrumented. If the SQL statement has an ambiguous operation, or performs more than one operation, this value may be omitted.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_OPERATION")
    @js.native
    def DB_OPERATION: String = js.native
    inline def DB_OPERATION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_OPERATION")(x.asInstanceOf[js.Any])
    
    /**
      * The index of the database being accessed as used in the [`SELECT` command](https://redis.io/commands/select), provided as an integer. To be used instead of the generic `db.name` attribute.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_REDIS_DATABASE_INDEX")
    @js.native
    def DB_REDIS_DATABASE_INDEX: String = js.native
    inline def DB_REDIS_DATABASE_INDEX_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_REDIS_DATABASE_INDEX")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the primary table that the operation is acting upon, including the schema name (if applicable).
      *
      * Note: It is not recommended to attempt any client-side parsing of `db.statement` just to get this property, but it should be set if it is provided by the library being instrumented. If the operation is acting upon an anonymous table, or more than one table, this value MUST NOT be set.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_SQL_TABLE")
    @js.native
    def DB_SQL_TABLE: String = js.native
    inline def DB_SQL_TABLE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_SQL_TABLE")(x.asInstanceOf[js.Any])
    
    /**
      * The database statement being executed.
      *
      * Note: The value may be sanitized to exclude sensitive information.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_STATEMENT")
    @js.native
    def DB_STATEMENT: String = js.native
    inline def DB_STATEMENT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_STATEMENT")(x.asInstanceOf[js.Any])
    
    /**
      * An identifier for the database management system (DBMS) product being used. See below for a list of well-known identifiers.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_SYSTEM")
    @js.native
    def DB_SYSTEM: String = js.native
    inline def DB_SYSTEM_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_SYSTEM")(x.asInstanceOf[js.Any])
    
    /**
      * Username for accessing the database.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.DB_USER")
    @js.native
    def DB_USER: String = js.native
    inline def DB_USER_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DB_USER")(x.asInstanceOf[js.Any])
    
    /**
      * Username or client_id extracted from the access token or [Authorization](https://tools.ietf.org/html/rfc7235#section-4.2) header in the inbound request from outside the system.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.ENDUSER_ID")
    @js.native
    def ENDUSER_ID: String = js.native
    inline def ENDUSER_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ENDUSER_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Actual/assumed role the client is making the request under extracted from token or application security context.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.ENDUSER_ROLE")
    @js.native
    def ENDUSER_ROLE: String = js.native
    inline def ENDUSER_ROLE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ENDUSER_ROLE")(x.asInstanceOf[js.Any])
    
    /**
      * Scopes or granted authorities the client currently possesses extracted from token or application security context. The value would come from the scope associated with an [OAuth 2.0 Access Token](https://tools.ietf.org/html/rfc6749#section-3.3) or an attribute value in a [SAML 2.0 Assertion](http://docs.oasis-open.org/security/saml/Post2.0/sstc-saml-tech-overview-2.0.html).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.ENDUSER_SCOPE")
    @js.native
    def ENDUSER_SCOPE: String = js.native
    inline def ENDUSER_SCOPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("ENDUSER_SCOPE")(x.asInstanceOf[js.Any])
    
    /**
      * SHOULD be set to true if the exception event is recorded at a point where it is known that the exception is escaping the scope of the span.
      *
      * Note: An exception is considered to have escaped (or left) the scope of a span,
      if that span is ended while the exception is still logically &#34;in flight&#34;.
      This may be actually &#34;in flight&#34; in some languages (e.g. if the exception
      is passed to a Context manager&#39;s `__exit__` method in Python) but will
      usually be caught at the point of recording the exception in most languages.
      
      It is usually not possible to determine at the point where an exception is thrown
      whether it will escape the scope of a span.
      However, it is trivial to know that an exception
      will escape, if one checks for an active exception just before ending the span,
      as done in the [example above](#exception-end-example).
      
      It follows that an exception may still escape the scope of the span
      even if the `exception.escaped` attribute was not set or set to false,
      since the event might have been recorded at a time where it was not
      clear whether the exception will escape.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.EXCEPTION_ESCAPED")
    @js.native
    def EXCEPTION_ESCAPED: String = js.native
    inline def EXCEPTION_ESCAPED_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXCEPTION_ESCAPED")(x.asInstanceOf[js.Any])
    
    /**
      * The exception message.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.EXCEPTION_MESSAGE")
    @js.native
    def EXCEPTION_MESSAGE: String = js.native
    inline def EXCEPTION_MESSAGE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXCEPTION_MESSAGE")(x.asInstanceOf[js.Any])
    
    /**
      * A stacktrace as a string in the natural representation for the language runtime. The representation is to be determined and documented by each language SIG.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.EXCEPTION_STACKTRACE")
    @js.native
    def EXCEPTION_STACKTRACE: String = js.native
    inline def EXCEPTION_STACKTRACE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXCEPTION_STACKTRACE")(x.asInstanceOf[js.Any])
    
    /**
      * The type of the exception (its fully-qualified class name, if applicable). The dynamic type of the exception should be preferred over the static type in languages that support it.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.EXCEPTION_TYPE")
    @js.native
    def EXCEPTION_TYPE: String = js.native
    inline def EXCEPTION_TYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("EXCEPTION_TYPE")(x.asInstanceOf[js.Any])
    
    /**
      * A boolean that is true if the serverless function is executed for the first time (aka cold-start).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.FAAS_COLDSTART")
    @js.native
    def FAAS_COLDSTART: String = js.native
    inline def FAAS_COLDSTART_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_COLDSTART")(x.asInstanceOf[js.Any])
    
    /**
      * A string containing the schedule period as [Cron Expression](https://docs.oracle.com/cd/E12058_01/doc/doc.1014/e12030/cron_expressions.htm).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.FAAS_CRON")
    @js.native
    def FAAS_CRON: String = js.native
    inline def FAAS_CRON_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_CRON")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the source on which the triggering operation was performed. For example, in Cloud Storage or S3 corresponds to the bucket name, and in Cosmos DB to the database name.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.FAAS_DOCUMENT_COLLECTION")
    @js.native
    def FAAS_DOCUMENT_COLLECTION: String = js.native
    inline def FAAS_DOCUMENT_COLLECTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_DOCUMENT_COLLECTION")(x.asInstanceOf[js.Any])
    
    /**
      * The document name/table subjected to the operation. For example, in Cloud Storage or S3 is the name of the file, and in Cosmos DB the table name.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.FAAS_DOCUMENT_NAME")
    @js.native
    def FAAS_DOCUMENT_NAME: String = js.native
    inline def FAAS_DOCUMENT_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_DOCUMENT_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * Describes the type of the operation that was performed on the data.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.FAAS_DOCUMENT_OPERATION")
    @js.native
    def FAAS_DOCUMENT_OPERATION: String = js.native
    inline def FAAS_DOCUMENT_OPERATION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_DOCUMENT_OPERATION")(x.asInstanceOf[js.Any])
    
    /**
      * A string containing the time when the data was accessed in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.FAAS_DOCUMENT_TIME")
    @js.native
    def FAAS_DOCUMENT_TIME: String = js.native
    inline def FAAS_DOCUMENT_TIME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_DOCUMENT_TIME")(x.asInstanceOf[js.Any])
    
    /**
      * The execution ID of the current function execution.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.FAAS_EXECUTION")
    @js.native
    def FAAS_EXECUTION: String = js.native
    inline def FAAS_EXECUTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_EXECUTION")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the invoked function.
      *
      * Note: SHOULD be equal to the `faas.name` resource attribute of the invoked function.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.FAAS_INVOKED_NAME")
    @js.native
    def FAAS_INVOKED_NAME: String = js.native
    inline def FAAS_INVOKED_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_INVOKED_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The cloud provider of the invoked function.
      *
      * Note: SHOULD be equal to the `cloud.provider` resource attribute of the invoked function.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.FAAS_INVOKED_PROVIDER")
    @js.native
    def FAAS_INVOKED_PROVIDER: String = js.native
    inline def FAAS_INVOKED_PROVIDER_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_INVOKED_PROVIDER")(x.asInstanceOf[js.Any])
    
    /**
      * The cloud region of the invoked function.
      *
      * Note: SHOULD be equal to the `cloud.region` resource attribute of the invoked function.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.FAAS_INVOKED_REGION")
    @js.native
    def FAAS_INVOKED_REGION: String = js.native
    inline def FAAS_INVOKED_REGION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_INVOKED_REGION")(x.asInstanceOf[js.Any])
    
    /**
      * A string containing the function invocation time in the [ISO 8601](https://www.iso.org/iso-8601-date-and-time-format.html) format expressed in [UTC](https://www.w3.org/TR/NOTE-datetime).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.FAAS_TIME")
    @js.native
    def FAAS_TIME: String = js.native
    inline def FAAS_TIME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_TIME")(x.asInstanceOf[js.Any])
    
    /**
      * Type of the trigger on which the function is executed.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.FAAS_TRIGGER")
    @js.native
    def FAAS_TRIGGER: String = js.native
    inline def FAAS_TRIGGER_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_TRIGGER")(x.asInstanceOf[js.Any])
    
    /**
      * The IP address of the original client behind all proxies, if known (e.g. from [X-Forwarded-For](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/X-Forwarded-For)).
      *
      * Note: This is not necessarily the same as `net.peer.ip`, which would
      identify the network-level peer, which may be a proxy.
      
      This attribute should be set when a source of information different
      from the one used for `net.peer.ip`, is available even if that other
      source just confirms the same value as `net.peer.ip`.
      Rationale: For `net.peer.ip`, one typically does not know if it
      comes from a proxy, reverse proxy, or the actual client. Setting
      `http.client_ip` when it&#39;s the same as `net.peer.ip` means that
      one is at least somewhat confident that the address is not that of
      the closest proxy.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_CLIENT_IP")
    @js.native
    def HTTP_CLIENT_IP: String = js.native
    inline def HTTP_CLIENT_IP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_CLIENT_IP")(x.asInstanceOf[js.Any])
    
    /**
      * Kind of HTTP protocol used.
      *
      * Note: If `net.transport` is not specified, it can be assumed to be `IP.TCP` except if `http.flavor` is `QUIC`, in which case `IP.UDP` is assumed.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_FLAVOR")
    @js.native
    def HTTP_FLAVOR: String = js.native
    inline def HTTP_FLAVOR_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_FLAVOR")(x.asInstanceOf[js.Any])
    
    /**
      * The value of the [HTTP host header](https://tools.ietf.org/html/rfc7230#section-5.4). An empty Host header should also be reported, see note.
      *
      * Note: When the header is present but empty the attribute SHOULD be set to the empty string. Note that this is a valid situation that is expected in certain cases, according the aforementioned [section of RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.4). When the header is not set the attribute MUST NOT be set.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_HOST")
    @js.native
    def HTTP_HOST: String = js.native
    inline def HTTP_HOST_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_HOST")(x.asInstanceOf[js.Any])
    
    /**
      * HTTP request method.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_METHOD")
    @js.native
    def HTTP_METHOD: String = js.native
    inline def HTTP_METHOD_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_METHOD")(x.asInstanceOf[js.Any])
    
    /**
      * The size of the request payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_REQUEST_CONTENT_LENGTH")
    @js.native
    def HTTP_REQUEST_CONTENT_LENGTH: String = js.native
    inline def HTTP_REQUEST_CONTENT_LENGTH_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_REQUEST_CONTENT_LENGTH")(x.asInstanceOf[js.Any])
    
    /**
      * The size of the uncompressed request payload body after transport decoding. Not set if transport encoding not used.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED")
    @js.native
    def HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED: String = js.native
    inline def HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_REQUEST_CONTENT_LENGTH_UNCOMPRESSED")(x.asInstanceOf[js.Any])
    
    /**
      * The size of the response payload body in bytes. This is the number of bytes transferred excluding headers and is often, but not always, present as the [Content-Length](https://tools.ietf.org/html/rfc7230#section-3.3.2) header. For requests using transport encoding, this should be the compressed size.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH")
    @js.native
    def HTTP_RESPONSE_CONTENT_LENGTH: String = js.native
    inline def HTTP_RESPONSE_CONTENT_LENGTH_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_RESPONSE_CONTENT_LENGTH")(x.asInstanceOf[js.Any])
    
    /**
      * The size of the uncompressed response payload body after transport decoding. Not set if transport encoding not used.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED")
    @js.native
    def HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED: String = js.native
    inline def HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_RESPONSE_CONTENT_LENGTH_UNCOMPRESSED")(x.asInstanceOf[js.Any])
    
    /**
      * The matched route (path template).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_ROUTE")
    @js.native
    def HTTP_ROUTE: String = js.native
    inline def HTTP_ROUTE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_ROUTE")(x.asInstanceOf[js.Any])
    
    /**
      * The URI scheme identifying the used protocol.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_SCHEME")
    @js.native
    def HTTP_SCHEME: String = js.native
    inline def HTTP_SCHEME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_SCHEME")(x.asInstanceOf[js.Any])
    
    /**
      * The primary server name of the matched virtual host. This should be obtained via configuration. If no such configuration can be obtained, this attribute MUST NOT be set ( `net.host.name` should be used instead).
      *
      * Note: `http.url` is usually not readily available on the server side but would have to be assembled in a cumbersome and sometimes lossy process from other information (see e.g. open-telemetry/opentelemetry-python/pull/148). It is thus preferred to supply the raw data that is available.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_SERVER_NAME")
    @js.native
    def HTTP_SERVER_NAME: String = js.native
    inline def HTTP_SERVER_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_SERVER_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * [HTTP response status code](https://tools.ietf.org/html/rfc7231#section-6).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_STATUS_CODE")
    @js.native
    def HTTP_STATUS_CODE: String = js.native
    inline def HTTP_STATUS_CODE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_STATUS_CODE")(x.asInstanceOf[js.Any])
    
    /**
      * The full request target as passed in a HTTP request line or equivalent.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_TARGET")
    @js.native
    def HTTP_TARGET: String = js.native
    inline def HTTP_TARGET_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_TARGET")(x.asInstanceOf[js.Any])
    
    /**
      * Full HTTP request URL in the form `scheme://host[:port]/path?query[#fragment]`. Usually the fragment is not transmitted over HTTP, but if it is known, it should be included nevertheless.
      *
      * Note: `http.url` MUST NOT contain credentials passed via URL in form of `https://username:password@www.example.com/`. In such case the attribute&#39;s value should be `https://www.example.com/`.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_URL")
    @js.native
    def HTTP_URL: String = js.native
    inline def HTTP_URL_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_URL")(x.asInstanceOf[js.Any])
    
    /**
      * Value of the [HTTP User-Agent](https://tools.ietf.org/html/rfc7231#section-5.5.3) header sent by the client.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.HTTP_USER_AGENT")
    @js.native
    def HTTP_USER_AGENT: String = js.native
    inline def HTTP_USER_AGENT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HTTP_USER_AGENT")(x.asInstanceOf[js.Any])
    
    /**
      * Compressed size of the message in bytes.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGE_COMPRESSED_SIZE")
    @js.native
    def MESSAGE_COMPRESSED_SIZE: String = js.native
    inline def MESSAGE_COMPRESSED_SIZE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGE_COMPRESSED_SIZE")(x.asInstanceOf[js.Any])
    
    /**
      * MUST be calculated as two different counters starting from `1` one for sent messages and one for received message.
      *
      * Note: This way we guarantee that the values will be consistent between different implementations.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGE_ID")
    @js.native
    def MESSAGE_ID: String = js.native
    inline def MESSAGE_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGE_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Whether this is a received or sent message.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGE_TYPE")
    @js.native
    def MESSAGE_TYPE: String = js.native
    inline def MESSAGE_TYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGE_TYPE")(x.asInstanceOf[js.Any])
    
    /**
      * Uncompressed size of the message in bytes.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGE_UNCOMPRESSED_SIZE")
    @js.native
    def MESSAGE_UNCOMPRESSED_SIZE: String = js.native
    inline def MESSAGE_UNCOMPRESSED_SIZE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGE_UNCOMPRESSED_SIZE")(x.asInstanceOf[js.Any])
    
    /**
      * The identifier for the consumer receiving a message. For Kafka, set it to `{messaging.kafka.consumer_group} - {messaging.kafka.client_id}`, if both are present, or only `messaging.kafka.consumer_group`. For brokers, such as RabbitMQ and Artemis, set it to the `client_id` of the client consuming the message.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_CONSUMER_ID")
    @js.native
    def MESSAGING_CONSUMER_ID: String = js.native
    inline def MESSAGING_CONSUMER_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_CONSUMER_ID")(x.asInstanceOf[js.Any])
    
    /**
      * The [conversation ID](#conversations) identifying the conversation to which the message belongs, represented as a string. Sometimes called &#34;Correlation ID&#34;.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_CONVERSATION_ID")
    @js.native
    def MESSAGING_CONVERSATION_ID: String = js.native
    inline def MESSAGING_CONVERSATION_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_CONVERSATION_ID")(x.asInstanceOf[js.Any])
    
    /**
      * The message destination name. This might be equal to the span name but is required nevertheless.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_DESTINATION")
    @js.native
    def MESSAGING_DESTINATION: String = js.native
    inline def MESSAGING_DESTINATION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_DESTINATION")(x.asInstanceOf[js.Any])
    
    /**
      * The kind of message destination.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_DESTINATION_KIND")
    @js.native
    def MESSAGING_DESTINATION_KIND: String = js.native
    inline def MESSAGING_DESTINATION_KIND_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_DESTINATION_KIND")(x.asInstanceOf[js.Any])
    
    /**
      * Client Id for the Consumer or Producer that is handling the message.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_KAFKA_CLIENT_ID")
    @js.native
    def MESSAGING_KAFKA_CLIENT_ID: String = js.native
    inline def MESSAGING_KAFKA_CLIENT_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_KAFKA_CLIENT_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Name of the Kafka Consumer Group that is handling the message. Only applies to consumers, not producers.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_KAFKA_CONSUMER_GROUP")
    @js.native
    def MESSAGING_KAFKA_CONSUMER_GROUP: String = js.native
    inline def MESSAGING_KAFKA_CONSUMER_GROUP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_KAFKA_CONSUMER_GROUP")(x.asInstanceOf[js.Any])
    
    /**
      * Message keys in Kafka are used for grouping alike messages to ensure they&#39;re processed on the same partition. They differ from `messaging.message_id` in that they&#39;re not unique. If the key is `null`, the attribute MUST NOT be set.
      *
      * Note: If the key type is not string, it&#39;s string representation has to be supplied for the attribute. If the key has no unambiguous, canonical string form, don&#39;t include its value.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_KAFKA_MESSAGE_KEY")
    @js.native
    def MESSAGING_KAFKA_MESSAGE_KEY: String = js.native
    inline def MESSAGING_KAFKA_MESSAGE_KEY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_KAFKA_MESSAGE_KEY")(x.asInstanceOf[js.Any])
    
    /**
      * Partition the message is sent to.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_KAFKA_PARTITION")
    @js.native
    def MESSAGING_KAFKA_PARTITION: String = js.native
    inline def MESSAGING_KAFKA_PARTITION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_KAFKA_PARTITION")(x.asInstanceOf[js.Any])
    
    /**
      * A boolean that is true if the message is a tombstone.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_KAFKA_TOMBSTONE")
    @js.native
    def MESSAGING_KAFKA_TOMBSTONE: String = js.native
    inline def MESSAGING_KAFKA_TOMBSTONE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_KAFKA_TOMBSTONE")(x.asInstanceOf[js.Any])
    
    /**
      * A value used by the messaging system as an identifier for the message, represented as a string.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_MESSAGE_ID")
    @js.native
    def MESSAGING_MESSAGE_ID: String = js.native
    inline def MESSAGING_MESSAGE_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_MESSAGE_ID")(x.asInstanceOf[js.Any])
    
    /**
      * The compressed size of the message payload in bytes.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES")
    @js.native
    def MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES: String = js.native
    inline def MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_MESSAGE_PAYLOAD_COMPRESSED_SIZE_BYTES")(x.asInstanceOf[js.Any])
    
    /**
      * The (uncompressed) size of the message payload in bytes. Also use this attribute if it is unknown whether the compressed or uncompressed payload size is reported.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES")
    @js.native
    def MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES: String = js.native
    inline def MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_MESSAGE_PAYLOAD_SIZE_BYTES")(x.asInstanceOf[js.Any])
    
    /**
      * A string identifying the kind of message consumption as defined in the [Operation names](#operation-names) section above. If the operation is &#34;send&#34;, this attribute MUST NOT be set, since the operation can be inferred from the span kind in that case.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_OPERATION")
    @js.native
    def MESSAGING_OPERATION: String = js.native
    inline def MESSAGING_OPERATION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_OPERATION")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the transport protocol.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_PROTOCOL")
    @js.native
    def MESSAGING_PROTOCOL: String = js.native
    inline def MESSAGING_PROTOCOL_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_PROTOCOL")(x.asInstanceOf[js.Any])
    
    /**
      * The version of the transport protocol.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_PROTOCOL_VERSION")
    @js.native
    def MESSAGING_PROTOCOL_VERSION: String = js.native
    inline def MESSAGING_PROTOCOL_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_PROTOCOL_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * RabbitMQ message routing key.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_RABBITMQ_ROUTING_KEY")
    @js.native
    def MESSAGING_RABBITMQ_ROUTING_KEY: String = js.native
    inline def MESSAGING_RABBITMQ_ROUTING_KEY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_RABBITMQ_ROUTING_KEY")(x.asInstanceOf[js.Any])
    
    /**
      * A string identifying the messaging system.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_SYSTEM")
    @js.native
    def MESSAGING_SYSTEM: String = js.native
    inline def MESSAGING_SYSTEM_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_SYSTEM")(x.asInstanceOf[js.Any])
    
    /**
      * A boolean that is true if the message destination is temporary.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_TEMP_DESTINATION")
    @js.native
    def MESSAGING_TEMP_DESTINATION: String = js.native
    inline def MESSAGING_TEMP_DESTINATION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_TEMP_DESTINATION")(x.asInstanceOf[js.Any])
    
    /**
      * Connection string.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.MESSAGING_URL")
    @js.native
    def MESSAGING_URL: String = js.native
    inline def MESSAGING_URL_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("MESSAGING_URL")(x.asInstanceOf[js.Any])
    
    /**
      * The ISO 3166-1 alpha-2 2-character country code associated with the mobile carrier network.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_HOST_CARRIER_ICC")
    @js.native
    def NET_HOST_CARRIER_ICC: String = js.native
    inline def NET_HOST_CARRIER_ICC_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_CARRIER_ICC")(x.asInstanceOf[js.Any])
    
    /**
      * The mobile carrier country code.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_HOST_CARRIER_MCC")
    @js.native
    def NET_HOST_CARRIER_MCC: String = js.native
    inline def NET_HOST_CARRIER_MCC_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_CARRIER_MCC")(x.asInstanceOf[js.Any])
    
    /**
      * The mobile carrier network code.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_HOST_CARRIER_MNC")
    @js.native
    def NET_HOST_CARRIER_MNC: String = js.native
    inline def NET_HOST_CARRIER_MNC_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_CARRIER_MNC")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the mobile carrier.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_HOST_CARRIER_NAME")
    @js.native
    def NET_HOST_CARRIER_NAME: String = js.native
    inline def NET_HOST_CARRIER_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_CARRIER_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * This describes more details regarding the connection.type. It may be the type of cell technology connection, but it could be used for describing details about a wifi connection.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_HOST_CONNECTION_SUBTYPE")
    @js.native
    def NET_HOST_CONNECTION_SUBTYPE: String = js.native
    inline def NET_HOST_CONNECTION_SUBTYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_CONNECTION_SUBTYPE")(x.asInstanceOf[js.Any])
    
    /**
      * The internet connection type currently being used by the host.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_HOST_CONNECTION_TYPE")
    @js.native
    def NET_HOST_CONNECTION_TYPE: String = js.native
    inline def NET_HOST_CONNECTION_TYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_CONNECTION_TYPE")(x.asInstanceOf[js.Any])
    
    /**
      * Like `net.peer.ip` but for the host IP. Useful in case of a multi-IP host.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_HOST_IP")
    @js.native
    def NET_HOST_IP: String = js.native
    inline def NET_HOST_IP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_IP")(x.asInstanceOf[js.Any])
    
    /**
      * Local hostname or similar, see note below.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_HOST_NAME")
    @js.native
    def NET_HOST_NAME: String = js.native
    inline def NET_HOST_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * Like `net.peer.port` but for the host port.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_HOST_PORT")
    @js.native
    def NET_HOST_PORT: String = js.native
    inline def NET_HOST_PORT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_HOST_PORT")(x.asInstanceOf[js.Any])
    
    /**
      * Remote address of the peer (dotted decimal for IPv4 or [RFC5952](https://tools.ietf.org/html/rfc5952) for IPv6).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_PEER_IP")
    @js.native
    def NET_PEER_IP: String = js.native
    inline def NET_PEER_IP_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_PEER_IP")(x.asInstanceOf[js.Any])
    
    /**
      * Remote hostname or similar, see note below.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_PEER_NAME")
    @js.native
    def NET_PEER_NAME: String = js.native
    inline def NET_PEER_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_PEER_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * Remote port number.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_PEER_PORT")
    @js.native
    def NET_PEER_PORT: String = js.native
    inline def NET_PEER_PORT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_PEER_PORT")(x.asInstanceOf[js.Any])
    
    /**
      * Transport protocol used. See note below.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.NET_TRANSPORT")
    @js.native
    def NET_TRANSPORT: String = js.native
    inline def NET_TRANSPORT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("NET_TRANSPORT")(x.asInstanceOf[js.Any])
    
    /**
      * The [`service.name`](../../resource/semantic_conventions/README.md#service) of the remote service. SHOULD be equal to the actual `service.name` resource attribute of the remote service if any.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.PEER_SERVICE")
    @js.native
    def PEER_SERVICE: String = js.native
    inline def PEER_SERVICE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PEER_SERVICE")(x.asInstanceOf[js.Any])
    
    /**
      * The [numeric status code](https://github.com/grpc/grpc/blob/v1.33.2/doc/statuscodes.md) of the gRPC request.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.RPC_GRPC_STATUS_CODE")
    @js.native
    def RPC_GRPC_STATUS_CODE: String = js.native
    inline def RPC_GRPC_STATUS_CODE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_GRPC_STATUS_CODE")(x.asInstanceOf[js.Any])
    
    /**
      * `error.code` property of response if it is an error response.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.RPC_JSONRPC_ERROR_CODE")
    @js.native
    def RPC_JSONRPC_ERROR_CODE: String = js.native
    inline def RPC_JSONRPC_ERROR_CODE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_JSONRPC_ERROR_CODE")(x.asInstanceOf[js.Any])
    
    /**
      * `error.message` property of response if it is an error response.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.RPC_JSONRPC_ERROR_MESSAGE")
    @js.native
    def RPC_JSONRPC_ERROR_MESSAGE: String = js.native
    inline def RPC_JSONRPC_ERROR_MESSAGE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_JSONRPC_ERROR_MESSAGE")(x.asInstanceOf[js.Any])
    
    /**
      * `id` property of request or response. Since protocol allows id to be int, string, `null` or missing (for notifications), value is expected to be cast to string for simplicity. Use empty string in case of `null` value. Omit entirely if this is a notification.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.RPC_JSONRPC_REQUEST_ID")
    @js.native
    def RPC_JSONRPC_REQUEST_ID: String = js.native
    inline def RPC_JSONRPC_REQUEST_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_JSONRPC_REQUEST_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Protocol version as in `jsonrpc` property of request/response. Since JSON-RPC 1.0 does not specify this, the value can be omitted.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.RPC_JSONRPC_VERSION")
    @js.native
    def RPC_JSONRPC_VERSION: String = js.native
    inline def RPC_JSONRPC_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_JSONRPC_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the (logical) method being called, must be equal to the $method part in the span name.
      *
      * Note: This is the logical name of the method from the RPC interface perspective, which can be different from the name of any implementing method/function. The `code.function` attribute may be used to store the latter (e.g., method actually executing the call on the server side, RPC client stub method on the client side).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.RPC_METHOD")
    @js.native
    def RPC_METHOD: String = js.native
    inline def RPC_METHOD_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_METHOD")(x.asInstanceOf[js.Any])
    
    /**
      * The full (logical) name of the service being called, including its package name, if applicable.
      *
      * Note: This is the logical name of the service from the RPC interface perspective, which can be different from the name of any implementing class. The `code.namespace` attribute may be used to store the latter (despite the attribute name, it may include a class name; e.g., class with method actually executing the call on the server side, RPC client stub class on the client side).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.RPC_SERVICE")
    @js.native
    def RPC_SERVICE: String = js.native
    inline def RPC_SERVICE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_SERVICE")(x.asInstanceOf[js.Any])
    
    /**
      * A string identifying the remoting system.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.RPC_SYSTEM")
    @js.native
    def RPC_SYSTEM: String = js.native
    inline def RPC_SYSTEM_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("RPC_SYSTEM")(x.asInstanceOf[js.Any])
    
    /**
      * Current &#34;managed&#34; thread ID (as opposed to OS thread ID).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.THREAD_ID")
    @js.native
    def THREAD_ID: String = js.native
    inline def THREAD_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("THREAD_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Current thread name.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/trace", "SemanticAttributes.THREAD_NAME")
    @js.native
    def THREAD_NAME: String = js.native
    inline def THREAD_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("THREAD_NAME")(x.asInstanceOf[js.Any])
  }
}
