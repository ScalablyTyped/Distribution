package typings.opentelemetrySemanticConventions

import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aix
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.alibaba_cloud
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.alibaba_cloud_ecs
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.alibaba_cloud_fc
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.amd64
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.arm32
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.arm64
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws_ec2
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws_ecs
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws_eks
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws_elastic_beanstalk
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.aws_lambda
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure_aks
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure_app_service
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure_container_instances
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure_functions
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.azure_vm
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.cpp
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.darwin
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.dotnet
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.dragonflybsd
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ec2
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.erlang
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.fargate
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.freebsd
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp_app_engine
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp_cloud_functions
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp_cloud_run
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp_compute_engine
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.gcp_kubernetes_engine
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.go
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.hpux
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ia64
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.java_
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.linux
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.netbsd
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.nodejs
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.openbsd
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.php
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ppc32
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ppc64
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.python
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.ruby
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.solaris
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.webjs
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.windows
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.x86
import typings.opentelemetrySemanticConventions.opentelemetrySemanticConventionsStrings.z_os
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object buildSrcResourceMod {
  
  object AwsEcsLaunchtypeValues {
    
    /** ec2. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "AwsEcsLaunchtypeValues.EC2")
    @js.native
    val EC2: ec2 = js.native
    
    /** fargate. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "AwsEcsLaunchtypeValues.FARGATE")
    @js.native
    val FARGATE: fargate = js.native
  }
  
  object CloudPlatformValues {
    
    /** Alibaba Cloud Elastic Compute Service. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.ALIBABA_CLOUD_ECS")
    @js.native
    val ALIBABA_CLOUD_ECS: alibaba_cloud_ecs = js.native
    
    /** Alibaba Cloud Function Compute. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.ALIBABA_CLOUD_FC")
    @js.native
    val ALIBABA_CLOUD_FC: alibaba_cloud_fc = js.native
    
    /** AWS Elastic Compute Cloud. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.AWS_EC2")
    @js.native
    val AWS_EC2: aws_ec2 = js.native
    
    /** AWS Elastic Container Service. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.AWS_ECS")
    @js.native
    val AWS_ECS: aws_ecs = js.native
    
    /** AWS Elastic Kubernetes Service. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.AWS_EKS")
    @js.native
    val AWS_EKS: aws_eks = js.native
    
    /** AWS Elastic Beanstalk. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.AWS_ELASTIC_BEANSTALK")
    @js.native
    val AWS_ELASTIC_BEANSTALK: aws_elastic_beanstalk = js.native
    
    /** AWS Lambda. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.AWS_LAMBDA")
    @js.native
    val AWS_LAMBDA: aws_lambda = js.native
    
    /** Azure Kubernetes Service. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.AZURE_AKS")
    @js.native
    val AZURE_AKS: azure_aks = js.native
    
    /** Azure App Service. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.AZURE_APP_SERVICE")
    @js.native
    val AZURE_APP_SERVICE: azure_app_service = js.native
    
    /** Azure Container Instances. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.AZURE_CONTAINER_INSTANCES")
    @js.native
    val AZURE_CONTAINER_INSTANCES: azure_container_instances = js.native
    
    /** Azure Functions. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.AZURE_FUNCTIONS")
    @js.native
    val AZURE_FUNCTIONS: azure_functions = js.native
    
    /** Azure Virtual Machines. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.AZURE_VM")
    @js.native
    val AZURE_VM: azure_vm = js.native
    
    /** Google Cloud App Engine (GAE). */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.GCP_APP_ENGINE")
    @js.native
    val GCP_APP_ENGINE: gcp_app_engine = js.native
    
    /** Google Cloud Functions (GCF). */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.GCP_CLOUD_FUNCTIONS")
    @js.native
    val GCP_CLOUD_FUNCTIONS: gcp_cloud_functions = js.native
    
    /** Google Cloud Run. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.GCP_CLOUD_RUN")
    @js.native
    val GCP_CLOUD_RUN: gcp_cloud_run = js.native
    
    /** Google Cloud Compute Engine (GCE). */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.GCP_COMPUTE_ENGINE")
    @js.native
    val GCP_COMPUTE_ENGINE: gcp_compute_engine = js.native
    
    /** Google Cloud Kubernetes Engine (GKE). */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudPlatformValues.GCP_KUBERNETES_ENGINE")
    @js.native
    val GCP_KUBERNETES_ENGINE: gcp_kubernetes_engine = js.native
  }
  
  object CloudProviderValues {
    
    /** Alibaba Cloud. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudProviderValues.ALIBABA_CLOUD")
    @js.native
    val ALIBABA_CLOUD: alibaba_cloud = js.native
    
    /** Amazon Web Services. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudProviderValues.AWS")
    @js.native
    val AWS: aws = js.native
    
    /** Microsoft Azure. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudProviderValues.AZURE")
    @js.native
    val AZURE: azure = js.native
    
    /** Google Cloud Platform. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "CloudProviderValues.GCP")
    @js.native
    val GCP: gcp = js.native
  }
  
  object HostArchValues {
    
    /** AMD64. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "HostArchValues.AMD64")
    @js.native
    val AMD64: amd64 = js.native
    
    /** ARM32. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "HostArchValues.ARM32")
    @js.native
    val ARM32: arm32 = js.native
    
    /** ARM64. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "HostArchValues.ARM64")
    @js.native
    val ARM64: arm64 = js.native
    
    /** Itanium. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "HostArchValues.IA64")
    @js.native
    val IA64: ia64 = js.native
    
    /** 32-bit PowerPC. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "HostArchValues.PPC32")
    @js.native
    val PPC32: ppc32 = js.native
    
    /** 64-bit PowerPC. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "HostArchValues.PPC64")
    @js.native
    val PPC64: ppc64 = js.native
    
    /** 32-bit x86. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "HostArchValues.X86")
    @js.native
    val X86: x86 = js.native
  }
  
  object OsTypeValues {
    
    /** AIX (Advanced Interactive eXecutive). */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "OsTypeValues.AIX")
    @js.native
    val AIX: aix = js.native
    
    /** Apple Darwin. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "OsTypeValues.DARWIN")
    @js.native
    val DARWIN: darwin = js.native
    
    /** DragonFly BSD. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "OsTypeValues.DRAGONFLYBSD")
    @js.native
    val DRAGONFLYBSD: dragonflybsd = js.native
    
    /** FreeBSD. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "OsTypeValues.FREEBSD")
    @js.native
    val FREEBSD: freebsd = js.native
    
    /** HP-UX (Hewlett Packard Unix). */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "OsTypeValues.HPUX")
    @js.native
    val HPUX: hpux = js.native
    
    /** Linux. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "OsTypeValues.LINUX")
    @js.native
    val LINUX: linux = js.native
    
    /** NetBSD. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "OsTypeValues.NETBSD")
    @js.native
    val NETBSD: netbsd = js.native
    
    /** OpenBSD. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "OsTypeValues.OPENBSD")
    @js.native
    val OPENBSD: openbsd = js.native
    
    /** Oracle Solaris. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "OsTypeValues.SOLARIS")
    @js.native
    val SOLARIS: solaris = js.native
    
    /** Microsoft Windows. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "OsTypeValues.WINDOWS")
    @js.native
    val WINDOWS: windows = js.native
    
    /** IBM z/OS. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "OsTypeValues.Z_OS")
    @js.native
    val Z_OS: z_os = js.native
  }
  
  object SemanticResourceAttributes {
    
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes")
    @js.native
    val ^ : js.Any = js.native
    
    /**
      * The ARN of an [ECS cluster](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/clusters.html).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.AWS_ECS_CLUSTER_ARN")
    @js.native
    def AWS_ECS_CLUSTER_ARN: String = js.native
    inline def AWS_ECS_CLUSTER_ARN_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_ECS_CLUSTER_ARN")(x.asInstanceOf[js.Any])
    
    /**
      * The Amazon Resource Name (ARN) of an [ECS container instance](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ECS_instances.html).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.AWS_ECS_CONTAINER_ARN")
    @js.native
    def AWS_ECS_CONTAINER_ARN: String = js.native
    inline def AWS_ECS_CONTAINER_ARN_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_ECS_CONTAINER_ARN")(x.asInstanceOf[js.Any])
    
    /**
      * The [launch type](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/launch_types.html) for an ECS task.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.AWS_ECS_LAUNCHTYPE")
    @js.native
    def AWS_ECS_LAUNCHTYPE: String = js.native
    inline def AWS_ECS_LAUNCHTYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_ECS_LAUNCHTYPE")(x.asInstanceOf[js.Any])
    
    /**
      * The ARN of an [ECS task definition](https://docs.aws.amazon.com/AmazonECS/latest/developerguide/task_definitions.html).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.AWS_ECS_TASK_ARN")
    @js.native
    def AWS_ECS_TASK_ARN: String = js.native
    inline def AWS_ECS_TASK_ARN_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_ECS_TASK_ARN")(x.asInstanceOf[js.Any])
    
    /**
      * The task definition family this task definition is a member of.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.AWS_ECS_TASK_FAMILY")
    @js.native
    def AWS_ECS_TASK_FAMILY: String = js.native
    inline def AWS_ECS_TASK_FAMILY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_ECS_TASK_FAMILY")(x.asInstanceOf[js.Any])
    
    /**
      * The revision for this task definition.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.AWS_ECS_TASK_REVISION")
    @js.native
    def AWS_ECS_TASK_REVISION: String = js.native
    inline def AWS_ECS_TASK_REVISION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_ECS_TASK_REVISION")(x.asInstanceOf[js.Any])
    
    /**
      * The ARN of an EKS cluster.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.AWS_EKS_CLUSTER_ARN")
    @js.native
    def AWS_EKS_CLUSTER_ARN: String = js.native
    inline def AWS_EKS_CLUSTER_ARN_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_EKS_CLUSTER_ARN")(x.asInstanceOf[js.Any])
    
    /**
      * The Amazon Resource Name(s) (ARN) of the AWS log group(s).
      *
      * Note: See the [log group ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.AWS_LOG_GROUP_ARNS")
    @js.native
    def AWS_LOG_GROUP_ARNS: String = js.native
    inline def AWS_LOG_GROUP_ARNS_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_LOG_GROUP_ARNS")(x.asInstanceOf[js.Any])
    
    /**
      * The name(s) of the AWS log group(s) an application is writing to.
      *
      * Note: Multiple log groups must be supported for cases like multi-container applications, where a single application has sidecar containers, and each write to their own log group.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.AWS_LOG_GROUP_NAMES")
    @js.native
    def AWS_LOG_GROUP_NAMES: String = js.native
    inline def AWS_LOG_GROUP_NAMES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_LOG_GROUP_NAMES")(x.asInstanceOf[js.Any])
    
    /**
      * The ARN(s) of the AWS log stream(s).
      *
      * Note: See the [log stream ARN format documentation](https://docs.aws.amazon.com/AmazonCloudWatch/latest/logs/iam-access-control-overview-cwl.html#CWL_ARN_Format). One log group can contain several log streams, so these ARNs necessarily identify both a log group and a log stream.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.AWS_LOG_STREAM_ARNS")
    @js.native
    def AWS_LOG_STREAM_ARNS: String = js.native
    inline def AWS_LOG_STREAM_ARNS_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_LOG_STREAM_ARNS")(x.asInstanceOf[js.Any])
    
    /**
      * The name(s) of the AWS log stream(s) an application is writing to.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.AWS_LOG_STREAM_NAMES")
    @js.native
    def AWS_LOG_STREAM_NAMES: String = js.native
    inline def AWS_LOG_STREAM_NAMES_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("AWS_LOG_STREAM_NAMES")(x.asInstanceOf[js.Any])
    
    /**
      * The cloud account ID the resource is assigned to.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.CLOUD_ACCOUNT_ID")
    @js.native
    def CLOUD_ACCOUNT_ID: String = js.native
    inline def CLOUD_ACCOUNT_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLOUD_ACCOUNT_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Cloud regions often have multiple, isolated locations known as zones to increase availability. Availability zone represents the zone where the resource is running.
      *
      * Note: Availability zones are called &#34;zones&#34; on Alibaba Cloud and Google Cloud.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.CLOUD_AVAILABILITY_ZONE")
    @js.native
    def CLOUD_AVAILABILITY_ZONE: String = js.native
    inline def CLOUD_AVAILABILITY_ZONE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLOUD_AVAILABILITY_ZONE")(x.asInstanceOf[js.Any])
    
    /**
      * The cloud platform in use.
      *
      * Note: The prefix of the service SHOULD match the one specified in `cloud.provider`.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.CLOUD_PLATFORM")
    @js.native
    def CLOUD_PLATFORM: String = js.native
    inline def CLOUD_PLATFORM_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLOUD_PLATFORM")(x.asInstanceOf[js.Any])
    
    /**
      * Name of the cloud provider.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.CLOUD_PROVIDER")
    @js.native
    def CLOUD_PROVIDER: String = js.native
    inline def CLOUD_PROVIDER_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLOUD_PROVIDER")(x.asInstanceOf[js.Any])
    
    /**
      * The geographical region the resource is running. Refer to your provider&#39;s docs to see the available regions, for example [Alibaba Cloud regions](https://www.alibabacloud.com/help/doc-detail/40654.htm), [AWS regions](https://aws.amazon.com/about-aws/global-infrastructure/regions_az/), [Azure regions](https://azure.microsoft.com/en-us/global-infrastructure/geographies/), or [Google Cloud regions](https://cloud.google.com/about/locations).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.CLOUD_REGION")
    @js.native
    def CLOUD_REGION: String = js.native
    inline def CLOUD_REGION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CLOUD_REGION")(x.asInstanceOf[js.Any])
    
    /**
      * Container ID. Usually a UUID, as for example used to [identify Docker containers](https://docs.docker.com/engine/reference/run/#container-identification). The UUID might be abbreviated.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.CONTAINER_ID")
    @js.native
    def CONTAINER_ID: String = js.native
    inline def CONTAINER_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CONTAINER_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Name of the image the container was built on.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.CONTAINER_IMAGE_NAME")
    @js.native
    def CONTAINER_IMAGE_NAME: String = js.native
    inline def CONTAINER_IMAGE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CONTAINER_IMAGE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * Container image tag.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.CONTAINER_IMAGE_TAG")
    @js.native
    def CONTAINER_IMAGE_TAG: String = js.native
    inline def CONTAINER_IMAGE_TAG_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CONTAINER_IMAGE_TAG")(x.asInstanceOf[js.Any])
    
    /**
      * Container name.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.CONTAINER_NAME")
    @js.native
    def CONTAINER_NAME: String = js.native
    inline def CONTAINER_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CONTAINER_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The container runtime managing this container.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.CONTAINER_RUNTIME")
    @js.native
    def CONTAINER_RUNTIME: String = js.native
    inline def CONTAINER_RUNTIME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("CONTAINER_RUNTIME")(x.asInstanceOf[js.Any])
    
    /**
      * Name of the [deployment environment](https://en.wikipedia.org/wiki/Deployment_environment) (aka deployment tier).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT")
    @js.native
    def DEPLOYMENT_ENVIRONMENT: String = js.native
    inline def DEPLOYMENT_ENVIRONMENT_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DEPLOYMENT_ENVIRONMENT")(x.asInstanceOf[js.Any])
    
    /**
      * A unique identifier representing the device.
      *
      * Note: The device identifier MUST only be defined using the values outlined below. This value is not an advertising identifier and MUST NOT be used as such. On iOS (Swift or Objective-C), this value MUST be equal to the [vendor identifier](https://developer.apple.com/documentation/uikit/uidevice/1620059-identifierforvendor). On Android (Java or Kotlin), this value MUST be equal to the Firebase Installation ID or a globally unique UUID which is persisted across sessions in your application. More information can be found [here](https://developer.android.com/training/articles/user-data-ids) on best practices and exact implementation details. Caution should be taken when storing personal data or anything which can identify a user. GDPR and data protection laws may apply, ensure you do your own due diligence.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.DEVICE_ID")
    @js.native
    def DEVICE_ID: String = js.native
    inline def DEVICE_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DEVICE_ID")(x.asInstanceOf[js.Any])
    
    /**
      * The model identifier for the device.
      *
      * Note: It&#39;s recommended this value represents a machine readable version of the model identifier rather than the market or consumer-friendly name of the device.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.DEVICE_MODEL_IDENTIFIER")
    @js.native
    def DEVICE_MODEL_IDENTIFIER: String = js.native
    inline def DEVICE_MODEL_IDENTIFIER_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DEVICE_MODEL_IDENTIFIER")(x.asInstanceOf[js.Any])
    
    /**
      * The marketing name for the device model.
      *
      * Note: It&#39;s recommended this value represents a human readable version of the device model rather than a machine readable alternative.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.DEVICE_MODEL_NAME")
    @js.native
    def DEVICE_MODEL_NAME: String = js.native
    inline def DEVICE_MODEL_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("DEVICE_MODEL_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The unique ID of the single function that this runtime instance executes.
      *
      * Note: Depending on the cloud provider, use:
      
      * **AWS Lambda:** The function [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html).
      Take care not to use the &#34;invoked ARN&#34; directly but replace any
      [alias suffix](https://docs.aws.amazon.com/lambda/latest/dg/configuration-aliases.html) with the resolved function version, as the same runtime instance may be invokable with multiple
      different aliases.
      * **GCP:** The [URI of the resource](https://cloud.google.com/iam/docs/full-resource-names)
      * **Azure:** The [Fully Qualified Resource ID](https://docs.microsoft.com/en-us/rest/api/resources/resources/get-by-id).
      
      On some providers, it may not be possible to determine the full ID at startup,
      which is why this field cannot be made required. For example, on AWS the account ID
      part of the ARN is not available without calling another AWS API
      which may be deemed too slow for a short-running lambda function.
      As an alternative, consider setting `faas.id` as a span attribute instead.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.FAAS_ID")
    @js.native
    def FAAS_ID: String = js.native
    inline def FAAS_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_ID")(x.asInstanceOf[js.Any])
    
    /**
      * The execution environment ID as a string, that will be potentially reused for other invocations to the same function/function version.
      *
      * Note: * **AWS Lambda:** Use the (full) log stream name.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.FAAS_INSTANCE")
    @js.native
    def FAAS_INSTANCE: String = js.native
    inline def FAAS_INSTANCE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_INSTANCE")(x.asInstanceOf[js.Any])
    
    /**
      * The amount of memory available to the serverless function in MiB.
      *
      * Note: It&#39;s recommended to set this attribute since e.g. too little memory can easily stop a Java AWS Lambda function from working correctly. On AWS Lambda, the environment variable `AWS_LAMBDA_FUNCTION_MEMORY_SIZE` provides this information.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.FAAS_MAX_MEMORY")
    @js.native
    def FAAS_MAX_MEMORY: String = js.native
    inline def FAAS_MAX_MEMORY_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_MAX_MEMORY")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the single function that this runtime instance executes.
      *
      * Note: This is the name of the function as configured/deployed on the FaaS platform and is usually different from the name of the callback function (which may be stored in the [`code.namespace`/`code.function`](../../trace/semantic_conventions/span-general.md#source-code-attributes) span attributes).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.FAAS_NAME")
    @js.native
    def FAAS_NAME: String = js.native
    inline def FAAS_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The immutable version of the function being executed.
      *
      * Note: Depending on the cloud provider and platform, use:
      
      * **AWS Lambda:** The [function version](https://docs.aws.amazon.com/lambda/latest/dg/configuration-versions.html)
      (an integer represented as a decimal string).
      * **Google Cloud Run:** The [revision](https://cloud.google.com/run/docs/managing/revisions)
      (i.e., the function name plus the revision suffix).
      * **Google Cloud Functions:** The value of the
      [`K_REVISION` environment variable](https://cloud.google.com/functions/docs/env-var#runtime_environment_variables_set_automatically).
      * **Azure Functions:** Not applicable. Do not set this attribute.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.FAAS_VERSION")
    @js.native
    def FAAS_VERSION: String = js.native
    inline def FAAS_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("FAAS_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * The CPU architecture the host system is running on.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.HOST_ARCH")
    @js.native
    def HOST_ARCH: String = js.native
    inline def HOST_ARCH_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_ARCH")(x.asInstanceOf[js.Any])
    
    /**
      * Unique host ID. For Cloud, this must be the instance_id assigned by the cloud provider.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.HOST_ID")
    @js.native
    def HOST_ID: String = js.native
    inline def HOST_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_ID")(x.asInstanceOf[js.Any])
    
    /**
      * VM image ID. For Cloud, this value is from the provider.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.HOST_IMAGE_ID")
    @js.native
    def HOST_IMAGE_ID: String = js.native
    inline def HOST_IMAGE_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_IMAGE_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Name of the VM image or OS install the host was instantiated from.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.HOST_IMAGE_NAME")
    @js.native
    def HOST_IMAGE_NAME: String = js.native
    inline def HOST_IMAGE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_IMAGE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The version string of the VM image as defined in [Version SpanAttributes](README.md#version-attributes).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.HOST_IMAGE_VERSION")
    @js.native
    def HOST_IMAGE_VERSION: String = js.native
    inline def HOST_IMAGE_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_IMAGE_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * Name of the host. On Unix systems, it may contain what the hostname command returns, or the fully qualified hostname, or another name specified by the user.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.HOST_NAME")
    @js.native
    def HOST_NAME: String = js.native
    inline def HOST_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * Type of host. For Cloud, this must be the machine type.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.HOST_TYPE")
    @js.native
    def HOST_TYPE: String = js.native
    inline def HOST_TYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("HOST_TYPE")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the cluster.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_CLUSTER_NAME")
    @js.native
    def K8S_CLUSTER_NAME: String = js.native
    inline def K8S_CLUSTER_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_CLUSTER_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the Container in a Pod template.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_CONTAINER_NAME")
    @js.native
    def K8S_CONTAINER_NAME: String = js.native
    inline def K8S_CONTAINER_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_CONTAINER_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the CronJob.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_CRONJOB_NAME")
    @js.native
    def K8S_CRONJOB_NAME: String = js.native
    inline def K8S_CRONJOB_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_CRONJOB_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the CronJob.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_CRONJOB_UID")
    @js.native
    def K8S_CRONJOB_UID: String = js.native
    inline def K8S_CRONJOB_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_CRONJOB_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the DaemonSet.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_DAEMONSET_NAME")
    @js.native
    def K8S_DAEMONSET_NAME: String = js.native
    inline def K8S_DAEMONSET_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_DAEMONSET_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the DaemonSet.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_DAEMONSET_UID")
    @js.native
    def K8S_DAEMONSET_UID: String = js.native
    inline def K8S_DAEMONSET_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_DAEMONSET_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the Deployment.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_DEPLOYMENT_NAME")
    @js.native
    def K8S_DEPLOYMENT_NAME: String = js.native
    inline def K8S_DEPLOYMENT_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_DEPLOYMENT_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the Deployment.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_DEPLOYMENT_UID")
    @js.native
    def K8S_DEPLOYMENT_UID: String = js.native
    inline def K8S_DEPLOYMENT_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_DEPLOYMENT_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the Job.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_JOB_NAME")
    @js.native
    def K8S_JOB_NAME: String = js.native
    inline def K8S_JOB_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_JOB_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the Job.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_JOB_UID")
    @js.native
    def K8S_JOB_UID: String = js.native
    inline def K8S_JOB_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_JOB_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the namespace that the pod is running in.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_NAMESPACE_NAME")
    @js.native
    def K8S_NAMESPACE_NAME: String = js.native
    inline def K8S_NAMESPACE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_NAMESPACE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the Node.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_NODE_NAME")
    @js.native
    def K8S_NODE_NAME: String = js.native
    inline def K8S_NODE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_NODE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the Node.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_NODE_UID")
    @js.native
    def K8S_NODE_UID: String = js.native
    inline def K8S_NODE_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_NODE_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the Pod.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_POD_NAME")
    @js.native
    def K8S_POD_NAME: String = js.native
    inline def K8S_POD_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_POD_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the Pod.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_POD_UID")
    @js.native
    def K8S_POD_UID: String = js.native
    inline def K8S_POD_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_POD_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the ReplicaSet.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_REPLICASET_NAME")
    @js.native
    def K8S_REPLICASET_NAME: String = js.native
    inline def K8S_REPLICASET_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_REPLICASET_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the ReplicaSet.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_REPLICASET_UID")
    @js.native
    def K8S_REPLICASET_UID: String = js.native
    inline def K8S_REPLICASET_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_REPLICASET_UID")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the StatefulSet.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_STATEFULSET_NAME")
    @js.native
    def K8S_STATEFULSET_NAME: String = js.native
    inline def K8S_STATEFULSET_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_STATEFULSET_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The UID of the StatefulSet.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.K8S_STATEFULSET_UID")
    @js.native
    def K8S_STATEFULSET_UID: String = js.native
    inline def K8S_STATEFULSET_UID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("K8S_STATEFULSET_UID")(x.asInstanceOf[js.Any])
    
    /**
      * Human readable (not intended to be parsed) OS version information, like e.g. reported by `ver` or `lsb_release -a` commands.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.OS_DESCRIPTION")
    @js.native
    def OS_DESCRIPTION: String = js.native
    inline def OS_DESCRIPTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("OS_DESCRIPTION")(x.asInstanceOf[js.Any])
    
    /**
      * Human readable operating system name.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.OS_NAME")
    @js.native
    def OS_NAME: String = js.native
    inline def OS_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("OS_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The operating system type.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.OS_TYPE")
    @js.native
    def OS_TYPE: String = js.native
    inline def OS_TYPE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("OS_TYPE")(x.asInstanceOf[js.Any])
    
    /**
      * The version string of the operating system as defined in [Version SpanAttributes](../../resource/semantic_conventions/README.md#version-attributes).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.OS_VERSION")
    @js.native
    def OS_VERSION: String = js.native
    inline def OS_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("OS_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * The command used to launch the process (i.e. the command name). On Linux based systems, can be set to the zeroth string in `proc/[pid]/cmdline`. On Windows, can be set to the first parameter extracted from `GetCommandLineW`.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.PROCESS_COMMAND")
    @js.native
    def PROCESS_COMMAND: String = js.native
    inline def PROCESS_COMMAND_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_COMMAND")(x.asInstanceOf[js.Any])
    
    /**
      * All the command arguments (including the command/executable itself) as received by the process. On Linux-based systems (and some other Unixoid systems supporting procfs), can be set according to the list of null-delimited strings extracted from `proc/[pid]/cmdline`. For libc-based executables, this would be the full argv vector passed to `main`.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.PROCESS_COMMAND_ARGS")
    @js.native
    def PROCESS_COMMAND_ARGS: String = js.native
    inline def PROCESS_COMMAND_ARGS_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_COMMAND_ARGS")(x.asInstanceOf[js.Any])
    
    /**
      * The full command used to launch the process as a single string representing the full command. On Windows, can be set to the result of `GetCommandLineW`. Do not set this if you have to assemble it just for monitoring; use `process.command_args` instead.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.PROCESS_COMMAND_LINE")
    @js.native
    def PROCESS_COMMAND_LINE: String = js.native
    inline def PROCESS_COMMAND_LINE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_COMMAND_LINE")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the process executable. On Linux based systems, can be set to the `Name` in `proc/[pid]/status`. On Windows, can be set to the base name of `GetProcessImageFileNameW`.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME")
    @js.native
    def PROCESS_EXECUTABLE_NAME: String = js.native
    inline def PROCESS_EXECUTABLE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_EXECUTABLE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The full path to the process executable. On Linux based systems, can be set to the target of `proc/[pid]/exe`. On Windows, can be set to the result of `GetProcessImageFileNameW`.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.PROCESS_EXECUTABLE_PATH")
    @js.native
    def PROCESS_EXECUTABLE_PATH: String = js.native
    inline def PROCESS_EXECUTABLE_PATH_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_EXECUTABLE_PATH")(x.asInstanceOf[js.Any])
    
    /**
      * The username of the user that owns the process.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.PROCESS_OWNER")
    @js.native
    def PROCESS_OWNER: String = js.native
    inline def PROCESS_OWNER_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_OWNER")(x.asInstanceOf[js.Any])
    
    /**
      * Process identifier (PID).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.PROCESS_PID")
    @js.native
    def PROCESS_PID: String = js.native
    inline def PROCESS_PID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_PID")(x.asInstanceOf[js.Any])
    
    /**
      * An additional description about the runtime of the process, for example a specific vendor customization of the runtime environment.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.PROCESS_RUNTIME_DESCRIPTION")
    @js.native
    def PROCESS_RUNTIME_DESCRIPTION: String = js.native
    inline def PROCESS_RUNTIME_DESCRIPTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_RUNTIME_DESCRIPTION")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the runtime of this process. For compiled native binaries, this SHOULD be the name of the compiler.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.PROCESS_RUNTIME_NAME")
    @js.native
    def PROCESS_RUNTIME_NAME: String = js.native
    inline def PROCESS_RUNTIME_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_RUNTIME_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The version of the runtime of this process, as returned by the runtime without modification.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.PROCESS_RUNTIME_VERSION")
    @js.native
    def PROCESS_RUNTIME_VERSION: String = js.native
    inline def PROCESS_RUNTIME_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("PROCESS_RUNTIME_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * The string ID of the service instance.
      *
      * Note: MUST be unique for each instance of the same `service.namespace,service.name` pair (in other words `service.namespace,service.name,service.instance.id` triplet MUST be globally unique). The ID helps to distinguish instances of the same service that exist at the same time (e.g. instances of a horizontally scaled service). It is preferable for the ID to be persistent and stay the same for the lifetime of the service instance, however it is acceptable that the ID is ephemeral and changes during important lifetime events for the service (e.g. service restarts). If the service has no inherent unique ID that can be used as the value of this attribute it is recommended to generate a random Version 1 or Version 4 RFC 4122 UUID (services aiming for reproducible UUIDs may also use Version 5, see RFC 4122 for more recommendations).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.SERVICE_INSTANCE_ID")
    @js.native
    def SERVICE_INSTANCE_ID: String = js.native
    inline def SERVICE_INSTANCE_ID_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SERVICE_INSTANCE_ID")(x.asInstanceOf[js.Any])
    
    /**
      * Logical name of the service.
      *
      * Note: MUST be the same for all instances of horizontally scaled services. If the value was not specified, SDKs MUST fallback to `unknown_service:` concatenated with [`process.executable.name`](process.md#process), e.g. `unknown_service:bash`. If `process.executable.name` is not available, the value MUST be set to `unknown_service`.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.SERVICE_NAME")
    @js.native
    def SERVICE_NAME: String = js.native
    
    /**
      * A namespace for `service.name`.
      *
      * Note: A string value having a meaning that helps to distinguish a group of services, for example the team name that owns a group of services. `service.name` is expected to be unique within the same namespace. If `service.namespace` is not specified in the Resource then `service.name` is expected to be unique for all services that have no explicit namespace defined (so the empty/unspecified namespace is simply one more valid namespace). Zero-length namespace string is assumed equal to unspecified namespace.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.SERVICE_NAMESPACE")
    @js.native
    def SERVICE_NAMESPACE: String = js.native
    inline def SERVICE_NAMESPACE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SERVICE_NAMESPACE")(x.asInstanceOf[js.Any])
    
    inline def SERVICE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SERVICE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The version string of the service API or implementation.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.SERVICE_VERSION")
    @js.native
    def SERVICE_VERSION: String = js.native
    inline def SERVICE_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SERVICE_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * The version string of the auto instrumentation agent, if used.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.TELEMETRY_AUTO_VERSION")
    @js.native
    def TELEMETRY_AUTO_VERSION: String = js.native
    inline def TELEMETRY_AUTO_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TELEMETRY_AUTO_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * The language of the telemetry SDK.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.TELEMETRY_SDK_LANGUAGE")
    @js.native
    def TELEMETRY_SDK_LANGUAGE: String = js.native
    inline def TELEMETRY_SDK_LANGUAGE_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TELEMETRY_SDK_LANGUAGE")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the telemetry SDK as defined above.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.TELEMETRY_SDK_NAME")
    @js.native
    def TELEMETRY_SDK_NAME: String = js.native
    inline def TELEMETRY_SDK_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TELEMETRY_SDK_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The version string of the telemetry SDK.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.TELEMETRY_SDK_VERSION")
    @js.native
    def TELEMETRY_SDK_VERSION: String = js.native
    inline def TELEMETRY_SDK_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("TELEMETRY_SDK_VERSION")(x.asInstanceOf[js.Any])
    
    /**
      * Additional description of the web engine (e.g. detailed version and edition information).
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.WEBENGINE_DESCRIPTION")
    @js.native
    def WEBENGINE_DESCRIPTION: String = js.native
    inline def WEBENGINE_DESCRIPTION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("WEBENGINE_DESCRIPTION")(x.asInstanceOf[js.Any])
    
    /**
      * The name of the web engine.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.WEBENGINE_NAME")
    @js.native
    def WEBENGINE_NAME: String = js.native
    inline def WEBENGINE_NAME_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("WEBENGINE_NAME")(x.asInstanceOf[js.Any])
    
    /**
      * The version of the web engine.
      */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "SemanticResourceAttributes.WEBENGINE_VERSION")
    @js.native
    def WEBENGINE_VERSION: String = js.native
    inline def WEBENGINE_VERSION_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("WEBENGINE_VERSION")(x.asInstanceOf[js.Any])
  }
  
  object TelemetrySdkLanguageValues {
    
    /** cpp. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "TelemetrySdkLanguageValues.CPP")
    @js.native
    val CPP: cpp = js.native
    
    /** dotnet. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "TelemetrySdkLanguageValues.DOTNET")
    @js.native
    val DOTNET: dotnet = js.native
    
    /** erlang. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "TelemetrySdkLanguageValues.ERLANG")
    @js.native
    val ERLANG: erlang = js.native
    
    /** go. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "TelemetrySdkLanguageValues.GO")
    @js.native
    val GO: go = js.native
    
    /** java. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "TelemetrySdkLanguageValues.JAVA")
    @js.native
    val JAVA: java_ = js.native
    
    /** nodejs. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "TelemetrySdkLanguageValues.NODEJS")
    @js.native
    val NODEJS: nodejs = js.native
    
    /** php. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "TelemetrySdkLanguageValues.PHP")
    @js.native
    val PHP: php = js.native
    
    /** python. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "TelemetrySdkLanguageValues.PYTHON")
    @js.native
    val PYTHON: python = js.native
    
    /** ruby. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "TelemetrySdkLanguageValues.RUBY")
    @js.native
    val RUBY: ruby = js.native
    
    /** webjs. */
    @JSImport("@opentelemetry/semantic-conventions/build/src/resource", "TelemetrySdkLanguageValues.WEBJS")
    @js.native
    val WEBJS: webjs = js.native
  }
}
