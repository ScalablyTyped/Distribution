package typings.babylonjs

import typings.babylonjs.icanvasMod.ICanvasRenderingContext
import typings.babylonjs.sceneMod.Scene
import typings.babylonjs.textureMod.Texture
import typings.babylonjs.typesMod.Nullable
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object dynamicTextureMod {
  
  @JSImport("babylonjs/Materials/Textures/dynamicTexture", "DynamicTexture")
  @js.native
  open class DynamicTexture protected () extends Texture {
    /**
      * Creates a DynamicTexture
      * @param name defines the name of the texture
      * @param options provides 3 alternatives for width and height of texture, a canvas, object with width and height properties, number for both width and height
      * @param scene defines the scene where you want the texture
      * @param generateMipMaps defines the use of MinMaps or not (default is false)
      * @param samplingMode defines the sampling mode to use (default is Texture.TRILINEAR_SAMPLINGMODE)
      * @param format defines the texture format to use (default is Engine.TEXTUREFORMAT_RGBA)
      * @param invertY defines if the texture needs to be inverted on the y axis during loading
      */
    def this(name: String, options: Any) = this()
    def this(name: String, options: Any, scene: Nullable[Scene]) = this()
    def this(name: String, options: Any, scene: Unit, generateMipMaps: Boolean) = this()
    def this(name: String, options: Any, scene: Nullable[Scene], generateMipMaps: Boolean) = this()
    def this(name: String, options: Any, scene: Unit, generateMipMaps: Boolean, samplingMode: Double) = this()
    def this(name: String, options: Any, scene: Unit, generateMipMaps: Unit, samplingMode: Double) = this()
    def this(name: String, options: Any, scene: Nullable[Scene], generateMipMaps: Boolean, samplingMode: Double) = this()
    def this(name: String, options: Any, scene: Nullable[Scene], generateMipMaps: Unit, samplingMode: Double) = this()
    def this(
      name: String,
      options: Any,
      scene: Unit,
      generateMipMaps: Boolean,
      samplingMode: Double,
      format: Double
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Unit,
      generateMipMaps: Boolean,
      samplingMode: Unit,
      format: Double
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Unit,
      generateMipMaps: Unit,
      samplingMode: Double,
      format: Double
    ) = this()
    def this(name: String, options: Any, scene: Unit, generateMipMaps: Unit, samplingMode: Unit, format: Double) = this()
    def this(
      name: String,
      options: Any,
      scene: Nullable[Scene],
      generateMipMaps: Boolean,
      samplingMode: Double,
      format: Double
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Nullable[Scene],
      generateMipMaps: Boolean,
      samplingMode: Unit,
      format: Double
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Nullable[Scene],
      generateMipMaps: Unit,
      samplingMode: Double,
      format: Double
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Nullable[Scene],
      generateMipMaps: Unit,
      samplingMode: Unit,
      format: Double
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Unit,
      generateMipMaps: Boolean,
      samplingMode: Double,
      format: Double,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Unit,
      generateMipMaps: Boolean,
      samplingMode: Double,
      format: Unit,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Unit,
      generateMipMaps: Boolean,
      samplingMode: Unit,
      format: Double,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Unit,
      generateMipMaps: Boolean,
      samplingMode: Unit,
      format: Unit,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Unit,
      generateMipMaps: Unit,
      samplingMode: Double,
      format: Double,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Unit,
      generateMipMaps: Unit,
      samplingMode: Double,
      format: Unit,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Unit,
      generateMipMaps: Unit,
      samplingMode: Unit,
      format: Double,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Unit,
      generateMipMaps: Unit,
      samplingMode: Unit,
      format: Unit,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Nullable[Scene],
      generateMipMaps: Boolean,
      samplingMode: Double,
      format: Double,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Nullable[Scene],
      generateMipMaps: Boolean,
      samplingMode: Double,
      format: Unit,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Nullable[Scene],
      generateMipMaps: Boolean,
      samplingMode: Unit,
      format: Double,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Nullable[Scene],
      generateMipMaps: Boolean,
      samplingMode: Unit,
      format: Unit,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Nullable[Scene],
      generateMipMaps: Unit,
      samplingMode: Double,
      format: Double,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Nullable[Scene],
      generateMipMaps: Unit,
      samplingMode: Double,
      format: Unit,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Nullable[Scene],
      generateMipMaps: Unit,
      samplingMode: Unit,
      format: Double,
      invertY: Boolean
    ) = this()
    def this(
      name: String,
      options: Any,
      scene: Nullable[Scene],
      generateMipMaps: Unit,
      samplingMode: Unit,
      format: Unit,
      invertY: Boolean
    ) = this()
    
    /* private */ var _canvas: Any = js.native
    
    /* private */ var _context: Any = js.native
    
    /* private */ var _generateMipMaps: Any = js.native
    
    /* private */ var _recreate: Any = js.native
    
    /**
      * Clears the texture
      */
    def clear(): Unit = js.native
    
    /**
      * Draws text onto the texture
      * @param text defines the text to be drawn
      * @param x defines the placement of the text from the left
      * @param y defines the placement of the text from the top when invertY is true and from the bottom when false
      * @param font defines the font to be used with font-style, font-size, font-name
      * @param color defines the color used for the text
      * @param clearColor defines the color for the canvas, use null to not overwrite canvas
      * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
      * @param update defines whether texture is immediately update (default is true)
      */
    def drawText(
      text: String,
      x: js.UndefOr[Double | Null],
      y: js.UndefOr[Double | Null],
      font: String,
      color: String | Null,
      clearColor: String | Null,
      invertY: js.UndefOr[Boolean],
      update: js.UndefOr[Boolean]
    ): Unit = js.native
    
    /**
      * Gets the context of the canvas used by the texture
      * @returns the canvas context of the dynamic texture
      */
    def getContext(): ICanvasRenderingContext = js.native
    
    /**
      * Resizes the texture
      * @param width the new width
      * @param height the new height
      */
    def scaleTo(width: Double, height: Double): Unit = js.native
    
    /**
      * Updates the texture
      * @param invertY defines the direction for the Y axis (default is true - y increases downwards)
      * @param premulAlpha defines if alpha is stored as premultiplied (default is false)
      * @param allowGPUOptimization true to allow some specific GPU optimizations (subject to engine feature "allowGPUOptimizationsForGUI" being true)
      */
    def update(): Unit = js.native
    def update(invertY: Boolean): Unit = js.native
    def update(invertY: Boolean, premulAlpha: Boolean): Unit = js.native
    def update(invertY: Boolean, premulAlpha: Boolean, allowGPUOptimization: Boolean): Unit = js.native
    def update(invertY: Boolean, premulAlpha: Unit, allowGPUOptimization: Boolean): Unit = js.native
    def update(invertY: Unit, premulAlpha: Boolean): Unit = js.native
    def update(invertY: Unit, premulAlpha: Boolean, allowGPUOptimization: Boolean): Unit = js.native
    def update(invertY: Unit, premulAlpha: Unit, allowGPUOptimization: Boolean): Unit = js.native
  }
  /* static members */
  object DynamicTexture {
    
    @JSImport("babylonjs/Materials/Textures/dynamicTexture", "DynamicTexture")
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("babylonjs/Materials/Textures/dynamicTexture", "DynamicTexture._IsCanvasElement")
    @js.native
    def _IsCanvasElement: Any = js.native
    inline def _IsCanvasElement_=(x: Any): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("_IsCanvasElement")(x.asInstanceOf[js.Any])
  }
}
