package typings.babylonjs.indexMod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

@JSImport("babylonjs/index", "Constants")
@js.native
open class Constants ()
  extends typings.babylonjs.enginesIndexMod.Constants
/* static members */
object Constants {
  
  @JSImport("babylonjs/index", "Constants")
  @js.native
  val ^ : js.Any = js.native
  
  /**
    * Nothing
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_NothingTrigger")
  @js.native
  val ACTION_NothingTrigger: Double = js.native
  
  /**
    * On center pick
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnCenterPickTrigger")
  @js.native
  val ACTION_OnCenterPickTrigger: Double = js.native
  
  /**
    * On double pick
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnDoublePickTrigger")
  @js.native
  val ACTION_OnDoublePickTrigger: Double = js.native
  
  /**
    * On every frame
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnEveryFrameTrigger")
  @js.native
  val ACTION_OnEveryFrameTrigger: Double = js.native
  
  /**
    * On intersection enter
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnIntersectionEnterTrigger")
  @js.native
  val ACTION_OnIntersectionEnterTrigger: Double = js.native
  
  /**
    * On intersection exit
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnIntersectionExitTrigger")
  @js.native
  val ACTION_OnIntersectionExitTrigger: Double = js.native
  
  /**
    * On key down
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnKeyDownTrigger")
  @js.native
  val ACTION_OnKeyDownTrigger: Double = js.native
  
  /**
    * On key up
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnKeyUpTrigger")
  @js.native
  val ACTION_OnKeyUpTrigger: Double = js.native
  
  /**
    * On left pick
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnLeftPickTrigger")
  @js.native
  val ACTION_OnLeftPickTrigger: Double = js.native
  
  /**
    * On long press
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnLongPressTrigger")
  @js.native
  val ACTION_OnLongPressTrigger: Double = js.native
  
  /**
    * On pick down
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnPickDownTrigger")
  @js.native
  val ACTION_OnPickDownTrigger: Double = js.native
  
  /**
    * On pick out.
    * This trigger will only be raised if you also declared a OnPickDown
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnPickOutTrigger")
  @js.native
  val ACTION_OnPickOutTrigger: Double = js.native
  
  /**
    * On pick
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnPickTrigger")
  @js.native
  val ACTION_OnPickTrigger: Double = js.native
  
  /**
    * On pick up
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnPickUpTrigger")
  @js.native
  val ACTION_OnPickUpTrigger: Double = js.native
  
  /**
    * On pointer out
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnPointerOutTrigger")
  @js.native
  val ACTION_OnPointerOutTrigger: Double = js.native
  
  /**
    * On pointer over
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnPointerOverTrigger")
  @js.native
  val ACTION_OnPointerOverTrigger: Double = js.native
  
  /**
    * On right pick
    * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions#triggers
    */
  @JSImport("babylonjs/index", "Constants.ACTION_OnRightPickTrigger")
  @js.native
  val ACTION_OnRightPickTrigger: Double = js.native
  
  /** Defines that alpha blending is SRC ALPHA * SRC + DEST */
  @JSImport("babylonjs/index", "Constants.ALPHA_ADD")
  @js.native
  val ALPHA_ADD: Double = js.native
  
  /**
    * Defines that alpha blending is SRC * DST ALPHA + DST
    * Alpha will be set to 0
    */
  @JSImport("babylonjs/index", "Constants.ALPHA_ALPHATOCOLOR")
  @js.native
  val ALPHA_ALPHATOCOLOR: Double = js.native
  
  /** Defines that alpha blending is SRC ALPHA * SRC + (1 - SRC ALPHA) * DEST */
  @JSImport("babylonjs/index", "Constants.ALPHA_COMBINE")
  @js.native
  val ALPHA_COMBINE: Double = js.native
  
  /** Defines that alpha blending is disabled */
  @JSImport("babylonjs/index", "Constants.ALPHA_DISABLE")
  @js.native
  val ALPHA_DISABLE: Double = js.native
  
  /** Defines that alpha blending equation a SUM */
  @JSImport("babylonjs/index", "Constants.ALPHA_EQUATION_ADD")
  @js.native
  val ALPHA_EQUATION_ADD: Double = js.native
  
  /**
    * Defines that alpha blending equation a DARKEN operation:
    * It takes the min of the src and sums the alpha channels.
    */
  @JSImport("babylonjs/index", "Constants.ALPHA_EQUATION_DARKEN")
  @js.native
  val ALPHA_EQUATION_DARKEN: Double = js.native
  
  /** Defines that alpha blending equation a MAX operation */
  @JSImport("babylonjs/index", "Constants.ALPHA_EQUATION_MAX")
  @js.native
  val ALPHA_EQUATION_MAX: Double = js.native
  
  /** Defines that alpha blending equation a MIN operation */
  @JSImport("babylonjs/index", "Constants.ALPHA_EQUATION_MIN")
  @js.native
  val ALPHA_EQUATION_MIN: Double = js.native
  
  /** Defines that alpha blending equation a REVERSE SUBSTRACTION */
  @JSImport("babylonjs/index", "Constants.ALPHA_EQUATION_REVERSE_SUBTRACT")
  @js.native
  val ALPHA_EQUATION_REVERSE_SUBTRACT: Double = js.native
  
  /** Defines that alpha blending equation a SUBSTRACTION */
  @JSImport("babylonjs/index", "Constants.ALPHA_EQUATION_SUBSTRACT")
  @js.native
  val ALPHA_EQUATION_SUBSTRACT: Double = js.native
  
  /**
    * Defines that alpha blending is SRC * (1 - DST) + DST * (1 - SRC)
    * Alpha will be set to DST ALPHA
    */
  @JSImport("babylonjs/index", "Constants.ALPHA_EXCLUSION")
  @js.native
  val ALPHA_EXCLUSION: Double = js.native
  
  /** Defines that alpha blending is CST * SRC + (1 - CST) * DEST */
  @JSImport("babylonjs/index", "Constants.ALPHA_INTERPOLATE")
  @js.native
  val ALPHA_INTERPOLATE: Double = js.native
  
  /**
    * Defines that alpha blending is SRC * SRC ALPHA + DST * (1 - SRC ALPHA)
    * Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DST ALPHA
    */
  @JSImport("babylonjs/index", "Constants.ALPHA_LAYER_ACCUMULATE")
  @js.native
  val ALPHA_LAYER_ACCUMULATE: Double = js.native
  
  /** Defines that alpha blending is SRC ALPHA * SRC + (1 - SRC) * DEST */
  @JSImport("babylonjs/index", "Constants.ALPHA_MAXIMIZED")
  @js.native
  val ALPHA_MAXIMIZED: Double = js.native
  
  /** Defines that alpha blending is SRC * DEST */
  @JSImport("babylonjs/index", "Constants.ALPHA_MULTIPLY")
  @js.native
  val ALPHA_MULTIPLY: Double = js.native
  
  /** Defines that alpha blending is SRC + DEST */
  @JSImport("babylonjs/index", "Constants.ALPHA_ONEONE")
  @js.native
  val ALPHA_ONEONE: Double = js.native
  
  /**
    * Defines that alpha blending is SRC + DST
    * Alpha will be set to SRC ALPHA + DST ALPHA
    */
  @JSImport("babylonjs/index", "Constants.ALPHA_ONEONE_ONEONE")
  @js.native
  val ALPHA_ONEONE_ONEONE: Double = js.native
  
  /**
    * Defines that alpha blending is SRC + DST
    * Alpha will be set to SRC ALPHA
    */
  @JSImport("babylonjs/index", "Constants.ALPHA_ONEONE_ONEZERO")
  @js.native
  val ALPHA_ONEONE_ONEZERO: Double = js.native
  
  /** Defines that alpha blending is SRC + (1 - SRC ALPHA) * DEST */
  @JSImport("babylonjs/index", "Constants.ALPHA_PREMULTIPLIED")
  @js.native
  val ALPHA_PREMULTIPLIED: Double = js.native
  
  /**
    * Defines that alpha blending is SRC + (1 - SRC ALPHA) * DEST
    * Alpha will be set to (1 - SRC ALPHA) * DEST ALPHA
    */
  @JSImport("babylonjs/index", "Constants.ALPHA_PREMULTIPLIED_PORTERDUFF")
  @js.native
  val ALPHA_PREMULTIPLIED_PORTERDUFF: Double = js.native
  
  /**
    * Defines that alpha blending is SRC * (1 - DST) + DST * (1 - SRC)
    */
  @JSImport("babylonjs/index", "Constants.ALPHA_REVERSEONEMINUS")
  @js.native
  val ALPHA_REVERSEONEMINUS: Double = js.native
  
  /**
    * Defines that alpha blending is SRC + (1 - SRC) * DEST
    * Alpha will be set to SRC ALPHA + (1 - SRC ALPHA) * DEST ALPHA
    */
  @JSImport("babylonjs/index", "Constants.ALPHA_SCREENMODE")
  @js.native
  val ALPHA_SCREENMODE: Double = js.native
  
  /**
    * Defines that alpha blending is SRC + DST * (1 - SRC ALPHA)
    * Alpha will be set to SRC ALPHA + DST ALPHA * (1 - SRC ALPHA)
    */
  @JSImport("babylonjs/index", "Constants.ALPHA_SRC_DSTONEMINUSSRCALPHA")
  @js.native
  val ALPHA_SRC_DSTONEMINUSSRCALPHA: Double = js.native
  
  /** Defines that alpha blending is DEST - SRC * DEST */
  @JSImport("babylonjs/index", "Constants.ALPHA_SUBTRACT")
  @js.native
  val ALPHA_SUBTRACT: Double = js.native
  
  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will always pass. i.e. Pixels will be drawn in the order they are drawn */
  @JSImport("babylonjs/index", "Constants.ALWAYS")
  @js.native
  val ALWAYS: Double = js.native
  
  /** Flag to create a buffer suitable to be used as an index buffer */
  @JSImport("babylonjs/index", "Constants.BUFFER_CREATIONFLAG_INDEX")
  @js.native
  val BUFFER_CREATIONFLAG_INDEX: Double = js.native
  
  /** Flag to create a readable buffer (the buffer can be the source of a copy) */
  @JSImport("babylonjs/index", "Constants.BUFFER_CREATIONFLAG_READ")
  @js.native
  val BUFFER_CREATIONFLAG_READ: Double = js.native
  
  /** Flag to create a readable and writable buffer */
  @JSImport("babylonjs/index", "Constants.BUFFER_CREATIONFLAG_READWRITE")
  @js.native
  val BUFFER_CREATIONFLAG_READWRITE: Double = js.native
  
  /** Flag to create a buffer suitable to be used as a storage buffer */
  @JSImport("babylonjs/index", "Constants.BUFFER_CREATIONFLAG_STORAGE")
  @js.native
  val BUFFER_CREATIONFLAG_STORAGE: Double = js.native
  
  /** Flag to create a buffer suitable to be used as a uniform buffer */
  @JSImport("babylonjs/index", "Constants.BUFFER_CREATIONFLAG_UNIFORM")
  @js.native
  val BUFFER_CREATIONFLAG_UNIFORM: Double = js.native
  
  /** Flag to create a buffer suitable to be used as a vertex buffer */
  @JSImport("babylonjs/index", "Constants.BUFFER_CREATIONFLAG_VERTEX")
  @js.native
  val BUFFER_CREATIONFLAG_VERTEX: Double = js.native
  
  /** Flag to create a writable buffer (the buffer can be the destination of a copy) */
  @JSImport("babylonjs/index", "Constants.BUFFER_CREATIONFLAG_WRITE")
  @js.native
  val BUFFER_CREATIONFLAG_WRITE: Double = js.native
  
  /** Passed to stencilOperation to specify that stencil value must be decremented */
  @JSImport("babylonjs/index", "Constants.DECR")
  @js.native
  val DECR: Double = js.native
  
  /** Passed to stencilOperation to specify that stencil value must be decremented with wrapping */
  @JSImport("babylonjs/index", "Constants.DECR_WRAP")
  @js.native
  val DECR_WRAP: Double = js.native
  
  /** Defines that the resource was successfully delay loaded */
  @JSImport("babylonjs/index", "Constants.DELAYLOADSTATE_LOADED")
  @js.native
  val DELAYLOADSTATE_LOADED: Double = js.native
  
  /** Defines that the resource is currently delay loading */
  @JSImport("babylonjs/index", "Constants.DELAYLOADSTATE_LOADING")
  @js.native
  val DELAYLOADSTATE_LOADING: Double = js.native
  
  /** Defines that the resource is not delayed*/
  @JSImport("babylonjs/index", "Constants.DELAYLOADSTATE_NONE")
  @js.native
  val DELAYLOADSTATE_NONE: Double = js.native
  
  /** Defines that the resource is delayed and has not started loading */
  @JSImport("babylonjs/index", "Constants.DELAYLOADSTATE_NOTLOADED")
  @js.native
  val DELAYLOADSTATE_NOTLOADED: Double = js.native
  
  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is equals to the stored value */
  @JSImport("babylonjs/index", "Constants.EQUAL")
  @js.native
  val EQUAL: Double = js.native
  
  /**
    * This setting aligns the left and right bounds of the viewport to the left and right bounds of the camera frustum.
    */
  @JSImport("babylonjs/index", "Constants.FOVMODE_HORIZONTAL_FIXED")
  @js.native
  val FOVMODE_HORIZONTAL_FIXED: Double = js.native
  
  /**
    * This is the default FOV mode for perspective cameras.
    * This setting aligns the upper and lower bounds of the viewport to the upper and lower bounds of the camera frustum.
    */
  @JSImport("babylonjs/index", "Constants.FOVMODE_VERTICAL_FIXED")
  @js.native
  val FOVMODE_VERTICAL_FIXED: Double = js.native
  
  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than or equal to the stored value */
  @JSImport("babylonjs/index", "Constants.GEQUAL")
  @js.native
  val GEQUAL: Double = js.native
  
  /**
    * GL constants
    */
  /** Alpha blend equation: ADD */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_EQUATION_ADD")
  @js.native
  val GL_ALPHA_EQUATION_ADD: Double = js.native
  
  /** Alpha equation: MAX */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_EQUATION_MAX")
  @js.native
  val GL_ALPHA_EQUATION_MAX: Double = js.native
  
  /** Alpha equation: MIN */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_EQUATION_MIN")
  @js.native
  val GL_ALPHA_EQUATION_MIN: Double = js.native
  
  /** Alpha equation: REVERSE_SUBTRACT */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_EQUATION_REVERSE_SUBTRACT")
  @js.native
  val GL_ALPHA_EQUATION_REVERSE_SUBTRACT: Double = js.native
  
  /** Alpha equation: SUBTRACT */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_EQUATION_SUBTRACT")
  @js.native
  val GL_ALPHA_EQUATION_SUBTRACT: Double = js.native
  
  /** Alpha blend function: CONSTANT_ALPHA */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_CONSTANT_ALPHA")
  @js.native
  val GL_ALPHA_FUNCTION_CONSTANT_ALPHA: Double = js.native
  
  /** Alpha blend function: CONSTANT */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_CONSTANT_COLOR")
  @js.native
  val GL_ALPHA_FUNCTION_CONSTANT_COLOR: Double = js.native
  
  /** Alpha blend function: DST_ALPHA */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_DST_ALPHA")
  @js.native
  val GL_ALPHA_FUNCTION_DST_ALPHA: Double = js.native
  
  /** Alpha blend function: ONE_MINUS_DST */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_DST_COLOR")
  @js.native
  val GL_ALPHA_FUNCTION_DST_COLOR: Double = js.native
  
  /** Alpha blend function: ONE_MINUS_CONSTANT_ALPHA */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA")
  @js.native
  val GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA: Double = js.native
  
  /** Alpha blend function: ONE_MINUS_CONSTANT */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR")
  @js.native
  val GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR: Double = js.native
  
  /** Alpha blend function: ONE_MINUS_DST_ALPHA */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA")
  @js.native
  val GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA: Double = js.native
  
  /** Alpha blend function: ONE_MINUS_DST */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR")
  @js.native
  val GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR: Double = js.native
  
  /** Alpha blend function: ONE_MINUS_SRC_ALPHA */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA")
  @js.native
  val GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA: Double = js.native
  
  /** Alpha blend function: ONE_MINUS_SRC */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR")
  @js.native
  val GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR: Double = js.native
  
  /** Alpha blend function: SRC */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_SRC")
  @js.native
  val GL_ALPHA_FUNCTION_SRC: Double = js.native
  
  /** Alpha blend function: SRC_ALPHA */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_SRC_ALPHA")
  @js.native
  val GL_ALPHA_FUNCTION_SRC_ALPHA: Double = js.native
  
  /** Alpha blend function: SRC_ALPHA_SATURATED */
  @JSImport("babylonjs/index", "Constants.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED")
  @js.native
  val GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED: Double = js.native
  
  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is greater than the stored value */
  @JSImport("babylonjs/index", "Constants.GREATER")
  @js.native
  val GREATER: Double = js.native
  
  /** Passed to stencilOperation to specify that stencil value must be incremented */
  @JSImport("babylonjs/index", "Constants.INCR")
  @js.native
  val INCR: Double = js.native
  
  /** Passed to stencilOperation to specify that stencil value must be incremented with wrapping */
  @JSImport("babylonjs/index", "Constants.INCR_WRAP")
  @js.native
  val INCR_WRAP: Double = js.native
  
  /**
    * Constant used as key code for Alt key
    */
  @JSImport("babylonjs/index", "Constants.INPUT_ALT_KEY")
  @js.native
  val INPUT_ALT_KEY: Double = js.native
  
  /**
    * Constant used as key code for Ctrl key
    */
  @JSImport("babylonjs/index", "Constants.INPUT_CTRL_KEY")
  @js.native
  val INPUT_CTRL_KEY: Double = js.native
  
  /**
    * Constant used as key code for Meta key (Left Win, Left Cmd)
    */
  @JSImport("babylonjs/index", "Constants.INPUT_META_KEY1")
  @js.native
  val INPUT_META_KEY1: Double = js.native
  
  /**
    * Constant used as key code for Meta key (Right Win)
    */
  @JSImport("babylonjs/index", "Constants.INPUT_META_KEY2")
  @js.native
  val INPUT_META_KEY2: Double = js.native
  
  /**
    * Constant used as key code for Meta key (Right Win, Right Cmd)
    */
  @JSImport("babylonjs/index", "Constants.INPUT_META_KEY3")
  @js.native
  val INPUT_META_KEY3: Double = js.native
  
  /**
    * Constant used as key code for Shift key
    */
  @JSImport("babylonjs/index", "Constants.INPUT_SHIFT_KEY")
  @js.native
  val INPUT_SHIFT_KEY: Double = js.native
  
  /** Passed to stencilOperation to specify that stencil value must be inverted */
  @JSImport("babylonjs/index", "Constants.INVERT")
  @js.native
  val INVERT: Double = js.native
  
  /** Passed to stencilOperation to specify that stencil value must be kept */
  @JSImport("babylonjs/index", "Constants.KEEP")
  @js.native
  val KEEP: Double = js.native
  
  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than or equal to the stored value */
  @JSImport("babylonjs/index", "Constants.LEQUAL")
  @js.native
  val LEQUAL: Double = js.native
  
  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is less than the stored value */
  @JSImport("babylonjs/index", "Constants.LESS")
  @js.native
  val LESS: Double = js.native
  
  /**
    * The all dirty flag value
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_AllDirtyFlag")
  @js.native
  val MATERIAL_AllDirtyFlag: Double = js.native
  
  /**
    * The dirty attribute flag value
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_AttributesDirtyFlag")
  @js.native
  val MATERIAL_AttributesDirtyFlag: Double = js.native
  
  /**
    * Stores the clock-wise side orientation
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_ClockWiseSideOrientation")
  @js.native
  val MATERIAL_ClockWiseSideOrientation: Double = js.native
  
  /**
    * Stores the counter clock-wise side orientation
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_CounterClockWiseSideOrientation")
  @js.native
  val MATERIAL_CounterClockWiseSideOrientation: Double = js.native
  
  /**
    * The dirty fresnel flag value
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_FresnelDirtyFlag")
  @js.native
  val MATERIAL_FresnelDirtyFlag: Double = js.native
  
  /**
    * The dirty light flag value
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_LightDirtyFlag")
  @js.native
  val MATERIAL_LightDirtyFlag: Double = js.native
  
  /**
    * Returns the line list draw mode
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_LineListDrawMode")
  @js.native
  val MATERIAL_LineListDrawMode: Double = js.native
  
  /**
    * Returns the line loop draw mode
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_LineLoopDrawMode")
  @js.native
  val MATERIAL_LineLoopDrawMode: Double = js.native
  
  /**
    * Returns the line strip draw mode
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_LineStripDrawMode")
  @js.native
  val MATERIAL_LineStripDrawMode: Double = js.native
  
  /**
    * The dirty misc flag value
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_MiscDirtyFlag")
  @js.native
  val MATERIAL_MiscDirtyFlag: Double = js.native
  
  /**
    * Returns the point fill mode
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_PointFillMode")
  @js.native
  val MATERIAL_PointFillMode: Double = js.native
  
  /**
    * Returns the point list draw mode
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_PointListDrawMode")
  @js.native
  val MATERIAL_PointListDrawMode: Double = js.native
  
  /**
    * The dirty prepass flag value
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_PrePassDirtyFlag")
  @js.native
  val MATERIAL_PrePassDirtyFlag: Double = js.native
  
  /**
    * The dirty texture flag value
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_TextureDirtyFlag")
  @js.native
  val MATERIAL_TextureDirtyFlag: Double = js.native
  
  /**
    * Returns the triangle fan draw mode
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_TriangleFanDrawMode")
  @js.native
  val MATERIAL_TriangleFanDrawMode: Double = js.native
  
  /**
    * Returns the triangle fill mode
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_TriangleFillMode")
  @js.native
  val MATERIAL_TriangleFillMode: Double = js.native
  
  /**
    * Returns the triangle strip draw mode
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_TriangleStripDrawMode")
  @js.native
  val MATERIAL_TriangleStripDrawMode: Double = js.native
  
  /**
    * Returns the wireframe mode
    */
  @JSImport("babylonjs/index", "Constants.MATERIAL_WireFrameFillMode")
  @js.native
  val MATERIAL_WireFrameFillMode: Double = js.native
  
  /**
    * Maximum number of uv sets supported
    */
  @JSImport("babylonjs/index", "Constants.MAX_SUPPORTED_UV_SETS")
  @js.native
  val MAX_SUPPORTED_UV_SETS: Double = js.native
  
  /** Culling strategy : Bounding Sphere Only.
    *  This is an exclusion test. It's faster than the standard strategy because the bounding box is not tested.
    *  It's also less accurate than the standard because some not visible objects can still be selected.
    *  Test : is the bounding sphere outside the frustum ?
    *  If not, then the cullable object is in the frustum.
    */
  @JSImport("babylonjs/index", "Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY")
  @js.native
  val MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY: Double = js.native
  
  /** Culling strategy : Optimistic Inclusion.
    *  This in an inclusion test first, then the standard exclusion test.
    *  This can be faster when a cullable object is expected to be almost always in the camera frustum.
    *  This could also be a little slower than the standard test when the tested object center is not the frustum but one of its bounding box vertex is still inside.
    *  Anyway, it's as accurate as the standard strategy.
    *  Test :
    *  Is the cullable object bounding sphere center in the frustum ?
    *  If not, apply the default culling strategy.
    */
  @JSImport("babylonjs/index", "Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION")
  @js.native
  val MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION: Double = js.native
  
  /** Culling strategy : Optimistic Inclusion then Bounding Sphere Only.
    *  This in an inclusion test first, then the bounding sphere only exclusion test.
    *  This can be the fastest test when a cullable object is expected to be almost always in the camera frustum.
    *  This could also be a little slower than the BoundingSphereOnly strategy when the tested object center is not in the frustum but its bounding sphere still intersects it.
    *  It's less accurate than the standard strategy and as accurate as the BoundingSphereOnly strategy.
    *  Test :
    *  Is the cullable object bounding sphere center in the frustum ?
    *  If not, apply the Bounding Sphere Only strategy. No Bounding Box is tested here.
    */
  @JSImport("babylonjs/index", "Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY")
  @js.native
  val MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY: Double = js.native
  
  /** Default culling strategy : this is an exclusion test and it's the more accurate.
    *  Test order :
    *  Is the bounding sphere outside the frustum ?
    *  If not, are the bounding box vertices outside the frustum ?
    *  It not, then the cullable object is in the frustum.
    */
  @JSImport("babylonjs/index", "Constants.MESHES_CULLINGSTRATEGY_STANDARD")
  @js.native
  val MESHES_CULLINGSTRATEGY_STANDARD: Double = js.native
  
  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will never pass. i.e. Nothing will be drawn */
  @JSImport("babylonjs/index", "Constants.NEVER")
  @js.native
  val NEVER: Double = js.native
  
  /** Passed to depthFunction or stencilFunction to specify depth or stencil tests will pass if the new depth value is not equal to the stored value */
  @JSImport("babylonjs/index", "Constants.NOTEQUAL")
  @js.native
  val NOTEQUAL: Double = js.native
  
  /**
    * This helps creating camera with an orthographic mode.
    * Orthographic is commonly used in engineering as a means to produce object specifications that communicate dimensions unambiguously, each line of 1 unit length (cm, meter..whatever) will appear to have the same length everywhere on the drawing. This allows the drafter to dimension only a subset of lines and let the reader know that other lines of that length on the drawing are also that length in reality. Every parallel line in the drawing is also parallel in the object.
    */
  @JSImport("babylonjs/index", "Constants.ORTHOGRAPHIC_CAMERA")
  @js.native
  val ORTHOGRAPHIC_CAMERA: Double = js.native
  
  /**
    * Billboard mode will apply to all axes
    */
  @JSImport("babylonjs/index", "Constants.PARTICLES_BILLBOARDMODE_ALL")
  @js.native
  val PARTICLES_BILLBOARDMODE_ALL: Double = js.native
  
  /**
    * Special billboard mode where the particle will be biilboard to the camera but rotated to align with direction
    */
  @JSImport("babylonjs/index", "Constants.PARTICLES_BILLBOARDMODE_STRETCHED")
  @js.native
  val PARTICLES_BILLBOARDMODE_STRETCHED: Double = js.native
  
  /**
    * Special billboard mode where the particle will be billboard to the camera but only around the axis of the direction of particle emission
    */
  @JSImport("babylonjs/index", "Constants.PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL")
  @js.native
  val PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL: Double = js.native
  
  /**
    * Billboard mode will only apply to Y axis
    */
  @JSImport("babylonjs/index", "Constants.PARTICLES_BILLBOARDMODE_Y")
  @js.native
  val PARTICLES_BILLBOARDMODE_Y: Double = js.native
  
  /**
    * This is the default projection mode used by the cameras.
    * It helps recreating a feeling of perspective and better appreciate depth.
    * This is the best way to simulate real life cameras.
    */
  @JSImport("babylonjs/index", "Constants.PERSPECTIVE_CAMERA")
  @js.native
  val PERSPECTIVE_CAMERA: Double = js.native
  
  /**
    * Constant used to retrieve albedo index in the textures array in the prepass
    * using the getIndex(Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE)
    */
  @JSImport("babylonjs/index", "Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE")
  @js.native
  val PREPASS_ALBEDO_SQRT_TEXTURE_TYPE: Double = js.native
  
  /**
    * Constant used to retrieve the lit color texture index in the textures array in the prepass
    * using the getIndex(Constants.PREPASS_COLOR_TEXTURE_TYPE)
    */
  @JSImport("babylonjs/index", "Constants.PREPASS_COLOR_TEXTURE_TYPE")
  @js.native
  val PREPASS_COLOR_TEXTURE_TYPE: Double = js.native
  
  /**
    * Constant used to retrieve depth index in the textures array in the prepass
    * using the getIndex(Constants.PREPASS_DEPTH_TEXTURE_TYPE)
    */
  @JSImport("babylonjs/index", "Constants.PREPASS_DEPTH_TEXTURE_TYPE")
  @js.native
  val PREPASS_DEPTH_TEXTURE_TYPE: Double = js.native
  
  /**
    * Constant used to retrieve the irradiance texture index in the textures array in the prepass
    * using getIndex(Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE)
    */
  @JSImport("babylonjs/index", "Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE")
  @js.native
  val PREPASS_IRRADIANCE_TEXTURE_TYPE: Double = js.native
  
  /**
    * Constant used to retrieve normal index in the textures array in the prepass
    * using the getIndex(Constants.PREPASS_NORMAL_TEXTURE_TYPE)
    */
  @JSImport("babylonjs/index", "Constants.PREPASS_NORMAL_TEXTURE_TYPE")
  @js.native
  val PREPASS_NORMAL_TEXTURE_TYPE: Double = js.native
  
  /**
    * Constant used to retrieve the position texture index in the textures array in the prepass
    * using getIndex(Constants.PREPASS_POSITION_TEXTURE_INDEX)
    */
  @JSImport("babylonjs/index", "Constants.PREPASS_POSITION_TEXTURE_TYPE")
  @js.native
  val PREPASS_POSITION_TEXTURE_TYPE: Double = js.native
  
  /**
    * Constant used to retrieve the reflectivity texture index in the textures array in the prepass
    * using the getIndex(Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE)
    */
  @JSImport("babylonjs/index", "Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE")
  @js.native
  val PREPASS_REFLECTIVITY_TEXTURE_TYPE: Double = js.native
  
  /**
    * Constant used to retrieve the velocity texture index in the textures array in the prepass
    * using getIndex(Constants.PREPASS_VELOCITY_TEXTURE_INDEX)
    */
  @JSImport("babylonjs/index", "Constants.PREPASS_VELOCITY_TEXTURE_TYPE")
  @js.native
  val PREPASS_VELOCITY_TEXTURE_TYPE: Double = js.native
  
  /**
    * Prefixes used by the engine for sub mesh draw wrappers
    */
  /** @internal */
  @JSImport("babylonjs/index", "Constants.RENDERPASS_MAIN")
  @js.native
  val RENDERPASS_MAIN: Double = js.native
  
  /** Passed to stencilOperation to specify that stencil value must be replaced */
  @JSImport("babylonjs/index", "Constants.REPLACE")
  @js.native
  val REPLACE: Double = js.native
  
  /**
    * Custom rig mode allowing rig cameras to be populated manually with any number of cameras
    */
  @JSImport("babylonjs/index", "Constants.RIG_MODE_CUSTOM")
  @js.native
  val RIG_MODE_CUSTOM: Double = js.native
  
  /**
    * This specifies there is no need for a camera rig.
    * Basically only one eye is rendered corresponding to the camera.
    */
  @JSImport("babylonjs/index", "Constants.RIG_MODE_NONE")
  @js.native
  val RIG_MODE_NONE: Double = js.native
  
  /**
    * Simulates a camera Rig with one blue eye and one red eye.
    * This can be use with 3d blue and red glasses.
    */
  @JSImport("babylonjs/index", "Constants.RIG_MODE_STEREOSCOPIC_ANAGLYPH")
  @js.native
  val RIG_MODE_STEREOSCOPIC_ANAGLYPH: Double = js.native
  
  /**
    * Defines that both eyes of the camera will be rendered on successive lines interlaced for passive 3d monitors.
    */
  @JSImport("babylonjs/index", "Constants.RIG_MODE_STEREOSCOPIC_INTERLACED")
  @js.native
  val RIG_MODE_STEREOSCOPIC_INTERLACED: Double = js.native
  
  /**
    * Defines that both eyes of the camera will be rendered over under each other.
    */
  @JSImport("babylonjs/index", "Constants.RIG_MODE_STEREOSCOPIC_OVERUNDER")
  @js.native
  val RIG_MODE_STEREOSCOPIC_OVERUNDER: Double = js.native
  
  /**
    * Defines that both eyes of the camera will be rendered side by side with a none parallel target.
    */
  @JSImport("babylonjs/index", "Constants.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED")
  @js.native
  val RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED: Double = js.native
  
  /**
    * Defines that both eyes of the camera will be rendered side by side with a parallel target.
    */
  @JSImport("babylonjs/index", "Constants.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL")
  @js.native
  val RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL: Double = js.native
  
  /**
    * Defines that both eyes of the camera should be renderered in a VR mode (carbox).
    */
  @JSImport("babylonjs/index", "Constants.RIG_MODE_VR")
  @js.native
  val RIG_MODE_VR: Double = js.native
  
  /**
    * Defines that both eyes of the camera should be renderered in a VR mode (webVR).
    */
  @JSImport("babylonjs/index", "Constants.RIG_MODE_WEBVR")
  @js.native
  val RIG_MODE_WEBVR: Double = js.native
  
  /** Defines that texture rescaling will use a ceil to find the closer power of 2 size */
  @JSImport("babylonjs/index", "Constants.SCALEMODE_CEILING")
  @js.native
  val SCALEMODE_CEILING: Double = js.native
  
  /** Defines that texture rescaling will use a floor to find the closer power of 2 size */
  @JSImport("babylonjs/index", "Constants.SCALEMODE_FLOOR")
  @js.native
  val SCALEMODE_FLOOR: Double = js.native
  
  /** Defines that texture rescaling will look for the nearest power of 2 size */
  @JSImport("babylonjs/index", "Constants.SCALEMODE_NEAREST")
  @js.native
  val SCALEMODE_NEAREST: Double = js.native
  
  /**
    * Detailed logging while loading
    */
  @JSImport("babylonjs/index", "Constants.SCENELOADER_DETAILED_LOGGING")
  @js.native
  val SCENELOADER_DETAILED_LOGGING: Double = js.native
  
  /**
    * Minimal logging while loading
    */
  @JSImport("babylonjs/index", "Constants.SCENELOADER_MINIMAL_LOGGING")
  @js.native
  val SCENELOADER_MINIMAL_LOGGING: Double = js.native
  
  /**
    * No logging while loading
    */
  @JSImport("babylonjs/index", "Constants.SCENELOADER_NO_LOGGING")
  @js.native
  val SCENELOADER_NO_LOGGING: Double = js.native
  
  /**
    * Summary logging while loading
    */
  @JSImport("babylonjs/index", "Constants.SCENELOADER_SUMMARY_LOGGING")
  @js.native
  val SCENELOADER_SUMMARY_LOGGING: Double = js.native
  
  /** Fast snapshot rendering. In this mode, everything is static and only some limited form of dynamic behaviour is possible */
  @JSImport("babylonjs/index", "Constants.SNAPSHOTRENDERING_FAST")
  @js.native
  val SNAPSHOTRENDERING_FAST: Double = js.native
  
  /** Standard snapshot rendering. In this mode, some form of dynamic behavior is possible (for eg, uniform buffers are still updated) */
  @JSImport("babylonjs/index", "Constants.SNAPSHOTRENDERING_STANDARD")
  @js.native
  val SNAPSHOTRENDERING_STANDARD: Double = js.native
  
  /** URL to the snippet server. Points to the public snippet server by default */
  @JSImport("babylonjs/index", "Constants.SnippetUrl")
  @js.native
  def SnippetUrl: String = js.native
  inline def SnippetUrl_=(x: String): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("SnippetUrl")(x.asInstanceOf[js.Any])
  
  /** ALPHA */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_ALPHA")
  @js.native
  val TEXTUREFORMAT_ALPHA: Double = js.native
  
  /** BGRA */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_BGRA")
  @js.native
  val TEXTUREFORMAT_BGRA: Double = js.native
  
  /** Compressed ETC2 (RGB) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_RGB8_ETC2: Double = js.native
  
  /** Compressed ETC2 (RGB+A1) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2: Double = js.native
  
  /** Compressed ETC2 (RGB+A) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC: Double = js.native
  
  /** Compressed ASTC 4x4 */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4: Double = js.native
  
  /** Compressed BC7 */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM: Double = js.native
  
  /** Compressed BC1 (RGBA) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1: Double = js.native
  
  /** Compressed BC2 */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3: Double = js.native
  
  /** Compressed BC3 */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5: Double = js.native
  
  /** Compressed BC6 signed float */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: Double = js.native
  
  /** Compressed BC6 unsigned float */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: Double = js.native
  
  /** Compressed ETC1 (RGB) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL: Double = js.native
  
  /** Compressed BC1 (RGB) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1: Double = js.native
  
  /** Compressed ASTC 4x4 (SRGB) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR: Double = js.native
  
  /** Compressed ETC2 (SRGB+1) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC: Double = js.native
  
  /** Compressed ETC2 (SRGB) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2: Double = js.native
  
  /** Compressed ETC2 (SRGB+A1)*/
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2: Double = js.native
  
  /** Compressed BC7 (SRGB) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM: Double = js.native
  
  /** Compressed BC1 (SRGB+A) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT: Double = js.native
  
  /** Compressed BC2 (SRGB) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT: Double = js.native
  
  /** Compressed BC3 (SRGB) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT: Double = js.native
  
  /** Compressed BC1 (SRGB) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT")
  @js.native
  val TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT: Double = js.native
  
  /** Depth 16 bits */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_DEPTH16")
  @js.native
  val TEXTUREFORMAT_DEPTH16: Double = js.native
  
  /** Depth 24 bits */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_DEPTH24")
  @js.native
  val TEXTUREFORMAT_DEPTH24: Double = js.native
  
  /** Depth 24 bits unorm + Stencil 8 bits */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8")
  @js.native
  val TEXTUREFORMAT_DEPTH24UNORM_STENCIL8: Double = js.native
  
  /** Depth 24 bits + Stencil 8 bits */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_DEPTH24_STENCIL8")
  @js.native
  val TEXTUREFORMAT_DEPTH24_STENCIL8: Double = js.native
  
  /** Depth 32 bits float + Stencil 8 bits */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8")
  @js.native
  val TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8: Double = js.native
  
  /** Depth 32 bits float */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_DEPTH32_FLOAT")
  @js.native
  val TEXTUREFORMAT_DEPTH32_FLOAT: Double = js.native
  
  /** LUMINANCE */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_LUMINANCE")
  @js.native
  val TEXTUREFORMAT_LUMINANCE: Double = js.native
  
  /** LUMINANCE_ALPHA */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_LUMINANCE_ALPHA")
  @js.native
  val TEXTUREFORMAT_LUMINANCE_ALPHA: Double = js.native
  
  /** RED (2nd reference) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_R")
  @js.native
  val TEXTUREFORMAT_R: Double = js.native
  
  /** RED */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_RED")
  @js.native
  val TEXTUREFORMAT_RED: Double = js.native
  
  /** RED_INTEGER */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_RED_INTEGER")
  @js.native
  val TEXTUREFORMAT_RED_INTEGER: Double = js.native
  
  /** RG */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_RG")
  @js.native
  val TEXTUREFORMAT_RG: Double = js.native
  
  /** RGB */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_RGB")
  @js.native
  val TEXTUREFORMAT_RGB: Double = js.native
  
  /** RGBA */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_RGBA")
  @js.native
  val TEXTUREFORMAT_RGBA: Double = js.native
  
  /** RGBA_INTEGER */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_RGBA_INTEGER")
  @js.native
  val TEXTUREFORMAT_RGBA_INTEGER: Double = js.native
  
  /** RGB_INTEGER */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_RGB_INTEGER")
  @js.native
  val TEXTUREFORMAT_RGB_INTEGER: Double = js.native
  
  /** RG_INTEGER */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_RG_INTEGER")
  @js.native
  val TEXTUREFORMAT_RG_INTEGER: Double = js.native
  
  /** RED_INTEGER (2nd reference) */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_R_INTEGER")
  @js.native
  val TEXTUREFORMAT_R_INTEGER: Double = js.native
  
  /** Stencil 8 bits */
  @JSImport("babylonjs/index", "Constants.TEXTUREFORMAT_STENCIL8")
  @js.native
  val TEXTUREFORMAT_STENCIL8: Double = js.native
  
  /** BYTE */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_BYTE")
  @js.native
  val TEXTURETYPE_BYTE: Double = js.native
  
  /** FLOAT */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_FLOAT")
  @js.native
  val TEXTURETYPE_FLOAT: Double = js.native
  
  /** FLOAT_32_UNSIGNED_INT_24_8_REV */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV")
  @js.native
  val TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV: Double = js.native
  
  /** HALF_FLOAT */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_HALF_FLOAT")
  @js.native
  val TEXTURETYPE_HALF_FLOAT: Double = js.native
  
  /** INT */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_INT")
  @js.native
  val TEXTURETYPE_INT: Double = js.native
  
  /** SHORT */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_SHORT")
  @js.native
  val TEXTURETYPE_SHORT: Double = js.native
  
  /** UNDEFINED */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_UNDEFINED")
  @js.native
  val TEXTURETYPE_UNDEFINED: Double = js.native
  
  /** UNSIGNED_BYTE */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_UNSIGNED_BYTE")
  @js.native
  val TEXTURETYPE_UNSIGNED_BYTE: Double = js.native
  
  /** UNSIGNED_BYTE (2nd reference) */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_UNSIGNED_INT")
  @js.native
  val TEXTURETYPE_UNSIGNED_INT: Double = js.native
  
  /** UNSIGNED_INT */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_UNSIGNED_INTEGER")
  @js.native
  val TEXTURETYPE_UNSIGNED_INTEGER: Double = js.native
  
  /** UNSIGNED_INT_10F_11F_11F_REV */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV")
  @js.native
  val TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV: Double = js.native
  
  /** UNSIGNED_INT_24_8 */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_UNSIGNED_INT_24_8")
  @js.native
  val TEXTURETYPE_UNSIGNED_INT_24_8: Double = js.native
  
  /** UNSIGNED_INT_2_10_10_10_REV */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV")
  @js.native
  val TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV: Double = js.native
  
  /** UNSIGNED_INT_5_9_9_9_REV */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV")
  @js.native
  val TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV: Double = js.native
  
  /** UNSIGNED_SHORT */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_UNSIGNED_SHORT")
  @js.native
  val TEXTURETYPE_UNSIGNED_SHORT: Double = js.native
  
  /** UNSIGNED_SHORT_4_4_4_4 */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4")
  @js.native
  val TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4: Double = js.native
  
  /** UNSIGNED_SHORT_5_5_5_1 */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1")
  @js.native
  val TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1: Double = js.native
  
  /** UNSIGNED_SHORT_5_6_5 */
  @JSImport("babylonjs/index", "Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5")
  @js.native
  val TEXTURETYPE_UNSIGNED_SHORT_5_6_5: Double = js.native
  
  /** 2D Texture target*/
  @JSImport("babylonjs/index", "Constants.TEXTURE_2D")
  @js.native
  val TEXTURE_2D: Double = js.native
  
  /** 2D Array Texture target */
  @JSImport("babylonjs/index", "Constants.TEXTURE_2D_ARRAY")
  @js.native
  val TEXTURE_2D_ARRAY: Double = js.native
  
  /** 3D Texture target */
  @JSImport("babylonjs/index", "Constants.TEXTURE_3D")
  @js.native
  val TEXTURE_3D: Double = js.native
  
  /** Bilinear is mag = linear and min = linear and no mip */
  @JSImport("babylonjs/index", "Constants.TEXTURE_BILINEAR_SAMPLINGMODE")
  @js.native
  val TEXTURE_BILINEAR_SAMPLINGMODE: Double = js.native
  
  /** Texture is not repeating outside of 0..1 UVs */
  @JSImport("babylonjs/index", "Constants.TEXTURE_CLAMP_ADDRESSMODE")
  @js.native
  val TEXTURE_CLAMP_ADDRESSMODE: Double = js.native
  
  /** Flag to create a storage texture */
  @JSImport("babylonjs/index", "Constants.TEXTURE_CREATIONFLAG_STORAGE")
  @js.native
  val TEXTURE_CREATIONFLAG_STORAGE: Double = js.native
  
  /** Cube Map Texture target */
  @JSImport("babylonjs/index", "Constants.TEXTURE_CUBE_MAP")
  @js.native
  val TEXTURE_CUBE_MAP: Double = js.native
  
  /** Cube Map Array Texture target */
  @JSImport("babylonjs/index", "Constants.TEXTURE_CUBE_MAP_ARRAY")
  @js.native
  val TEXTURE_CUBE_MAP_ARRAY: Double = js.native
  
  /** Cubic coordinates mode */
  @JSImport("babylonjs/index", "Constants.TEXTURE_CUBIC_MODE")
  @js.native
  val TEXTURE_CUBIC_MODE: Double = js.native
  
  /** Equirectangular coordinates mode */
  @JSImport("babylonjs/index", "Constants.TEXTURE_EQUIRECTANGULAR_MODE")
  @js.native
  val TEXTURE_EQUIRECTANGULAR_MODE: Double = js.native
  
  /** Explicit coordinates mode */
  @JSImport("babylonjs/index", "Constants.TEXTURE_EXPLICIT_MODE")
  @js.native
  val TEXTURE_EXPLICIT_MODE: Double = js.native
  
  /** High quality for texture filtering */
  @JSImport("babylonjs/index", "Constants.TEXTURE_FILTERING_QUALITY_HIGH")
  @js.native
  val TEXTURE_FILTERING_QUALITY_HIGH: Double = js.native
  
  /** Low quality for texture filtering */
  @JSImport("babylonjs/index", "Constants.TEXTURE_FILTERING_QUALITY_LOW")
  @js.native
  val TEXTURE_FILTERING_QUALITY_LOW: Double = js.native
  
  /** Medium quality for texture filtering */
  @JSImport("babylonjs/index", "Constants.TEXTURE_FILTERING_QUALITY_MEDIUM")
  @js.native
  val TEXTURE_FILTERING_QUALITY_MEDIUM: Double = js.native
  
  /** Offline (baking) quality for texture filtering */
  @JSImport("babylonjs/index", "Constants.TEXTURE_FILTERING_QUALITY_OFFLINE")
  @js.native
  val TEXTURE_FILTERING_QUALITY_OFFLINE: Double = js.native
  
  /** Equirectangular Fixed Mirrored coordinates mode */
  @JSImport("babylonjs/index", "Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE")
  @js.native
  val TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE: Double = js.native
  
  /** Equirectangular Fixed coordinates mode */
  @JSImport("babylonjs/index", "Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE")
  @js.native
  val TEXTURE_FIXED_EQUIRECTANGULAR_MODE: Double = js.native
  
  /** Inverse Cubic coordinates mode */
  @JSImport("babylonjs/index", "Constants.TEXTURE_INVCUBIC_MODE")
  @js.native
  val TEXTURE_INVCUBIC_MODE: Double = js.native
  
  /** mag = linear and min = linear and mip = none */
  @JSImport("babylonjs/index", "Constants.TEXTURE_LINEAR_LINEAR")
  @js.native
  val TEXTURE_LINEAR_LINEAR: Double = js.native
  
  /** Trilinear is mag = linear and min = linear and mip = linear */
  @JSImport("babylonjs/index", "Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR")
  @js.native
  val TEXTURE_LINEAR_LINEAR_MIPLINEAR: Double = js.native
  
  /** Bilinear is mag = linear and min = linear and mip = nearest */
  @JSImport("babylonjs/index", "Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST")
  @js.native
  val TEXTURE_LINEAR_LINEAR_MIPNEAREST: Double = js.native
  
  /** mag = linear and min = nearest and mip = none */
  @JSImport("babylonjs/index", "Constants.TEXTURE_LINEAR_NEAREST")
  @js.native
  val TEXTURE_LINEAR_NEAREST: Double = js.native
  
  /** mag = linear and min = nearest and mip = linear */
  @JSImport("babylonjs/index", "Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR")
  @js.native
  val TEXTURE_LINEAR_NEAREST_MIPLINEAR: Double = js.native
  
  /** mag = linear and min = nearest and mip = nearest */
  @JSImport("babylonjs/index", "Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST")
  @js.native
  val TEXTURE_LINEAR_NEAREST_MIPNEAREST: Double = js.native
  
  /** Texture is repeating and mirrored */
  @JSImport("babylonjs/index", "Constants.TEXTURE_MIRROR_ADDRESSMODE")
  @js.native
  val TEXTURE_MIRROR_ADDRESSMODE: Double = js.native
  
  /** mag = nearest and min = linear and mip = none */
  @JSImport("babylonjs/index", "Constants.TEXTURE_NEAREST_LINEAR")
  @js.native
  val TEXTURE_NEAREST_LINEAR: Double = js.native
  
  /** mag = nearest and min = linear and mip = linear */
  @JSImport("babylonjs/index", "Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR")
  @js.native
  val TEXTURE_NEAREST_LINEAR_MIPLINEAR: Double = js.native
  
  /** mag = nearest and min = linear and mip = nearest */
  @JSImport("babylonjs/index", "Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST")
  @js.native
  val TEXTURE_NEAREST_LINEAR_MIPNEAREST: Double = js.native
  
  /** mag = nearest and min = nearest and mip = none */
  @JSImport("babylonjs/index", "Constants.TEXTURE_NEAREST_NEAREST")
  @js.native
  val TEXTURE_NEAREST_NEAREST: Double = js.native
  
  /** nearest is mag = nearest and min = nearest and mip = linear */
  @JSImport("babylonjs/index", "Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR")
  @js.native
  val TEXTURE_NEAREST_NEAREST_MIPLINEAR: Double = js.native
  
  /** mag = nearest and min = nearest and mip = nearest */
  @JSImport("babylonjs/index", "Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST")
  @js.native
  val TEXTURE_NEAREST_NEAREST_MIPNEAREST: Double = js.native
  
  /** nearest is mag = nearest and min = nearest and no mip */
  @JSImport("babylonjs/index", "Constants.TEXTURE_NEAREST_SAMPLINGMODE")
  @js.native
  val TEXTURE_NEAREST_SAMPLINGMODE: Double = js.native
  
  /** Planar coordinates mode */
  @JSImport("babylonjs/index", "Constants.TEXTURE_PLANAR_MODE")
  @js.native
  val TEXTURE_PLANAR_MODE: Double = js.native
  
  /** Projection coordinates mode */
  @JSImport("babylonjs/index", "Constants.TEXTURE_PROJECTION_MODE")
  @js.native
  val TEXTURE_PROJECTION_MODE: Double = js.native
  
  /** Skybox coordinates mode */
  @JSImport("babylonjs/index", "Constants.TEXTURE_SKYBOX_MODE")
  @js.native
  val TEXTURE_SKYBOX_MODE: Double = js.native
  
  /** Spherical coordinates mode */
  @JSImport("babylonjs/index", "Constants.TEXTURE_SPHERICAL_MODE")
  @js.native
  val TEXTURE_SPHERICAL_MODE: Double = js.native
  
  /** Trilinear is mag = linear and min = linear and mip = linear */
  @JSImport("babylonjs/index", "Constants.TEXTURE_TRILINEAR_SAMPLINGMODE")
  @js.native
  val TEXTURE_TRILINEAR_SAMPLINGMODE: Double = js.native
  
  /** Texture is repeating outside of 0..1 UVs */
  @JSImport("babylonjs/index", "Constants.TEXTURE_WRAP_ADDRESSMODE")
  @js.native
  val TEXTURE_WRAP_ADDRESSMODE: Double = js.native
  
  /** Passed to stencilOperation to specify that stencil value must be zero */
  @JSImport("babylonjs/index", "Constants.ZERO")
  @js.native
  val ZERO: Double = js.native
}
