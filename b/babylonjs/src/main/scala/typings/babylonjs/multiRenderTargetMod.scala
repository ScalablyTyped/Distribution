package typings.babylonjs

import typings.babylonjs.renderTargetTextureMod.RenderTargetTexture
import typings.babylonjs.sceneMod.Scene
import typings.babylonjs.textureMod.Texture
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object multiRenderTargetMod {
  
  @JSImport("babylonjs/Materials/Textures/multiRenderTarget", "MultiRenderTarget")
  @js.native
  class MultiRenderTarget protected () extends RenderTargetTexture {
    /**
      * Instantiate a new multi render target texture.
      * A multi render target, like a render target provides the ability to render to a texture.
      * Unlike the render target, it can render to several draw buffers in one draw.
      * This is specially interesting in deferred rendering or for any effects requiring more than
      * just one color from a single pass.
      * @param name Define the name of the texture
      * @param size Define the size of the buffers to render to
      * @param count Define the number of target we are rendering into
      * @param scene Define the scene the texture belongs to
      * @param options Define the options used to create the multi render target
      */
    def this(name: String, size: js.Any, count: Double, scene: Scene) = this()
    def this(name: String, size: js.Any, count: Double, scene: Scene, options: IMultiRenderTargetOptions) = this()
    
    var _count: js.Any = js.native
    
    var _createInternalTextures: js.Any = js.native
    
    var _createTextures: js.Any = js.native
    
    var _initTypes: js.Any = js.native
    
    var _internalTextures: js.Any = js.native
    
    var _multiRenderTargetOptions: js.Any = js.native
    
    def _rebuild(forceFullRebuild: Boolean): Unit = js.native
    
    var _textures: js.Any = js.native
    
    /**
      * Gets the number of textures in this MRT. This number can be different from `_textures.length` in case a depth texture is generated.
      */
    def count: Double = js.native
    
    /**
      * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set
      */
    def depthTexture: Texture = js.native
    
    /**
      * Get if draw buffers are currently supported by the used hardware and browser.
      */
    def isSupported: Boolean = js.native
    
    /**
      * Release all the underlying texture used as draw buffers.
      */
    def releaseInternalTextures(): Unit = js.native
    
    /**
      * Replaces a texture within the MRT.
      * @param texture The new texture to insert in the MRT
      * @param index The index of the texture to replace
      */
    def replaceTexture(texture: Texture, index: Double): Unit = js.native
    
    /**
      * Resize all the textures in the multi render target.
      * Be careful as it will recreate all the data in the new texture.
      * @param size Define the new size
      */
    def resize(size: js.Any): Unit = js.native
    
    /**
      * Get the list of textures generated by the multi render target.
      */
    def textures: js.Array[Texture] = js.native
    
    /**
      * Changes the number of render targets in this MRT
      * Be careful as it will recreate all the data in the new texture.
      * @param count new texture count
      * @param options Specifies texture types and sampling modes for new textures
      */
    def updateCount(count: Double): Unit = js.native
    def updateCount(count: Double, options: IMultiRenderTargetOptions): Unit = js.native
  }
  
  @js.native
  trait IMultiRenderTargetOptions extends StObject {
    
    /**
      * Define the default type of the buffers we are creating
      */
    var defaultType: js.UndefOr[Double] = js.native
    
    /**
      * Define if aspect ratio should be adapted to the texture or stay the scene one
      */
    var doNotChangeAspectRatio: js.UndefOr[Boolean] = js.native
    
    /**
      * Define if a depth buffer is required
      */
    var generateDepthBuffer: js.UndefOr[Boolean] = js.native
    
    /**
      * Define if a depth texture is required instead of a depth buffer
      */
    var generateDepthTexture: js.UndefOr[Boolean] = js.native
    
    /**
      * Define if the texture needs to create mip maps after render.
      */
    var generateMipMaps: js.UndefOr[Boolean] = js.native
    
    /**
      * Define if a stencil buffer is required
      */
    var generateStencilBuffer: js.UndefOr[Boolean] = js.native
    
    /**
      * Define the sampling modes of all the draw buffers we want to create
      */
    var samplingModes: js.UndefOr[js.Array[Double]] = js.native
    
    /**
      * Define the number of desired draw buffers
      */
    var textureCount: js.UndefOr[Double] = js.native
    
    /**
      * Define the types of all the draw buffers we want to create
      */
    var types: js.UndefOr[js.Array[Double]] = js.native
  }
  object IMultiRenderTargetOptions {
    
    @scala.inline
    def apply(): IMultiRenderTargetOptions = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[IMultiRenderTargetOptions]
    }
    
    @scala.inline
    implicit class IMultiRenderTargetOptionsMutableBuilder[Self <: IMultiRenderTargetOptions] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setDefaultType(value: Double): Self = StObject.set(x, "defaultType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDefaultTypeUndefined: Self = StObject.set(x, "defaultType", js.undefined)
      
      @scala.inline
      def setDoNotChangeAspectRatio(value: Boolean): Self = StObject.set(x, "doNotChangeAspectRatio", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDoNotChangeAspectRatioUndefined: Self = StObject.set(x, "doNotChangeAspectRatio", js.undefined)
      
      @scala.inline
      def setGenerateDepthBuffer(value: Boolean): Self = StObject.set(x, "generateDepthBuffer", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setGenerateDepthBufferUndefined: Self = StObject.set(x, "generateDepthBuffer", js.undefined)
      
      @scala.inline
      def setGenerateDepthTexture(value: Boolean): Self = StObject.set(x, "generateDepthTexture", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setGenerateDepthTextureUndefined: Self = StObject.set(x, "generateDepthTexture", js.undefined)
      
      @scala.inline
      def setGenerateMipMaps(value: Boolean): Self = StObject.set(x, "generateMipMaps", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setGenerateMipMapsUndefined: Self = StObject.set(x, "generateMipMaps", js.undefined)
      
      @scala.inline
      def setGenerateStencilBuffer(value: Boolean): Self = StObject.set(x, "generateStencilBuffer", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setGenerateStencilBufferUndefined: Self = StObject.set(x, "generateStencilBuffer", js.undefined)
      
      @scala.inline
      def setSamplingModes(value: js.Array[Double]): Self = StObject.set(x, "samplingModes", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSamplingModesUndefined: Self = StObject.set(x, "samplingModes", js.undefined)
      
      @scala.inline
      def setSamplingModesVarargs(value: Double*): Self = StObject.set(x, "samplingModes", js.Array(value :_*))
      
      @scala.inline
      def setTextureCount(value: Double): Self = StObject.set(x, "textureCount", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTextureCountUndefined: Self = StObject.set(x, "textureCount", js.undefined)
      
      @scala.inline
      def setTypes(value: js.Array[Double]): Self = StObject.set(x, "types", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypesUndefined: Self = StObject.set(x, "types", js.undefined)
      
      @scala.inline
      def setTypesVarargs(value: Double*): Self = StObject.set(x, "types", js.Array(value :_*))
    }
  }
}
