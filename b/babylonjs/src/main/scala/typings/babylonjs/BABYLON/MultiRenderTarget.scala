package typings.babylonjs.BABYLON

import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@js.native
trait MultiRenderTarget extends RenderTargetTexture {
  var _createInternalTextures: js.Any = js.native
  var _createTextures: js.Any = js.native
  var _internalTextures: js.Any = js.native
  var _multiRenderTargetOptions: js.Any = js.native
  var _textures: js.Any = js.native
  /**
    * Get the depth texture generated by the multi render target if options.generateDepthTexture has been set
    */
  def depthTexture: Texture = js.native
  /**
    * Get if draw buffers are currently supported by the used hardware and browser.
    */
  def isSupported: Boolean = js.native
  /**
    * Release all the underlying texture used as draw buffers.
    */
  def releaseInternalTextures(): Unit = js.native
  /**
    * Resize all the textures in the multi render target.
    * Be carrefull as it will recreate all the data in the new texture.
    * @param size Define the new size
    */
  def resize(size: js.Any): Unit = js.native
  /**
    * Get the list of textures generated by the multi render target.
    */
  def textures: js.Array[Texture] = js.native
  /**
    * Set the wrapping mode on U of all the textures we are rendering to.
    * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
    */
  @JSName("wrapU")
  def wrapU_MMultiRenderTarget(wrap: Double): js.Any = js.native
  /**
    * Set the wrapping mode on V of all the textures we are rendering to.
    * Can be any of the Texture. (CLAMP_ADDRESSMODE, MIRROR_ADDRESSMODE or WRAP_ADDRESSMODE)
    */
  @JSName("wrapV")
  def wrapV_MMultiRenderTarget(wrap: Double): js.Any = js.native
}

