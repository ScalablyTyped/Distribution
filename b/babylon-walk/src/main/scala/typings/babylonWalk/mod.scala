package typings.babylonWalk

import typings.babelTypes.ts36Mod.AnyTypeAnnotation_
import typings.babelTypes.ts36Mod.ArrayExpression_
import typings.babelTypes.ts36Mod.ArrayPattern_
import typings.babelTypes.ts36Mod.ArrayTypeAnnotation_
import typings.babelTypes.ts36Mod.ArrowFunctionExpression_
import typings.babelTypes.ts36Mod.AssignmentExpression_
import typings.babelTypes.ts36Mod.AssignmentPattern_
import typings.babelTypes.ts36Mod.AwaitExpression_
import typings.babelTypes.ts36Mod.BinaryExpression_
import typings.babelTypes.ts36Mod.BindExpression_
import typings.babelTypes.ts36Mod.BlockStatement_
import typings.babelTypes.ts36Mod.BooleanLiteralTypeAnnotation_
import typings.babelTypes.ts36Mod.BooleanLiteral_
import typings.babelTypes.ts36Mod.BooleanTypeAnnotation_
import typings.babelTypes.ts36Mod.BreakStatement_
import typings.babelTypes.ts36Mod.CallExpression_
import typings.babelTypes.ts36Mod.CatchClause_
import typings.babelTypes.ts36Mod.ClassBody_
import typings.babelTypes.ts36Mod.ClassDeclaration_
import typings.babelTypes.ts36Mod.ClassExpression_
import typings.babelTypes.ts36Mod.ClassImplements_
import typings.babelTypes.ts36Mod.ClassMethod_
import typings.babelTypes.ts36Mod.ClassProperty_
import typings.babelTypes.ts36Mod.ConditionalExpression_
import typings.babelTypes.ts36Mod.ContinueStatement_
import typings.babelTypes.ts36Mod.DebuggerStatement_
import typings.babelTypes.ts36Mod.DeclareClass_
import typings.babelTypes.ts36Mod.DeclareFunction_
import typings.babelTypes.ts36Mod.DeclareInterface_
import typings.babelTypes.ts36Mod.DeclareModule_
import typings.babelTypes.ts36Mod.DeclareTypeAlias_
import typings.babelTypes.ts36Mod.DeclareVariable_
import typings.babelTypes.ts36Mod.Decorator_
import typings.babelTypes.ts36Mod.DirectiveLiteral_
import typings.babelTypes.ts36Mod.Directive_
import typings.babelTypes.ts36Mod.DoExpression_
import typings.babelTypes.ts36Mod.DoWhileStatement_
import typings.babelTypes.ts36Mod.EmptyStatement_
import typings.babelTypes.ts36Mod.ExportAllDeclaration_
import typings.babelTypes.ts36Mod.ExportDefaultDeclaration_
import typings.babelTypes.ts36Mod.ExportDefaultSpecifier_
import typings.babelTypes.ts36Mod.ExportNamedDeclaration_
import typings.babelTypes.ts36Mod.ExportNamespaceSpecifier_
import typings.babelTypes.ts36Mod.ExportSpecifier_
import typings.babelTypes.ts36Mod.ExpressionStatement_
import typings.babelTypes.ts36Mod.File_
import typings.babelTypes.ts36Mod.ForInStatement_
import typings.babelTypes.ts36Mod.ForOfStatement_
import typings.babelTypes.ts36Mod.ForStatement_
import typings.babelTypes.ts36Mod.FunctionDeclaration_
import typings.babelTypes.ts36Mod.FunctionExpression_
import typings.babelTypes.ts36Mod.FunctionTypeAnnotation_
import typings.babelTypes.ts36Mod.FunctionTypeParam_
import typings.babelTypes.ts36Mod.GenericTypeAnnotation_
import typings.babelTypes.ts36Mod.Identifier_
import typings.babelTypes.ts36Mod.IfStatement_
import typings.babelTypes.ts36Mod.ImportDeclaration_
import typings.babelTypes.ts36Mod.ImportDefaultSpecifier_
import typings.babelTypes.ts36Mod.ImportNamespaceSpecifier_
import typings.babelTypes.ts36Mod.ImportSpecifier_
import typings.babelTypes.ts36Mod.InterfaceDeclaration_
import typings.babelTypes.ts36Mod.InterfaceExtends_
import typings.babelTypes.ts36Mod.IntersectionTypeAnnotation_
import typings.babelTypes.ts36Mod.JSXAttribute_
import typings.babelTypes.ts36Mod.JSXClosingElement_
import typings.babelTypes.ts36Mod.JSXElement_
import typings.babelTypes.ts36Mod.JSXEmptyExpression_
import typings.babelTypes.ts36Mod.JSXExpressionContainer_
import typings.babelTypes.ts36Mod.JSXIdentifier_
import typings.babelTypes.ts36Mod.JSXMemberExpression_
import typings.babelTypes.ts36Mod.JSXNamespacedName_
import typings.babelTypes.ts36Mod.JSXOpeningElement_
import typings.babelTypes.ts36Mod.JSXSpreadAttribute_
import typings.babelTypes.ts36Mod.JSXText_
import typings.babelTypes.ts36Mod.LabeledStatement_
import typings.babelTypes.ts36Mod.LogicalExpression_
import typings.babelTypes.ts36Mod.MemberExpression_
import typings.babelTypes.ts36Mod.MetaProperty_
import typings.babelTypes.ts36Mod.MixedTypeAnnotation_
import typings.babelTypes.ts36Mod.NewExpression_
import typings.babelTypes.ts36Mod.Node
import typings.babelTypes.ts36Mod.Noop_
import typings.babelTypes.ts36Mod.NullLiteralTypeAnnotation_
import typings.babelTypes.ts36Mod.NullLiteral_
import typings.babelTypes.ts36Mod.NullableTypeAnnotation_
import typings.babelTypes.ts36Mod.NumberTypeAnnotation_
import typings.babelTypes.ts36Mod.NumericLiteral_
import typings.babelTypes.ts36Mod.ObjectExpression_
import typings.babelTypes.ts36Mod.ObjectMethod_
import typings.babelTypes.ts36Mod.ObjectPattern_
import typings.babelTypes.ts36Mod.ObjectProperty_
import typings.babelTypes.ts36Mod.ObjectTypeAnnotation_
import typings.babelTypes.ts36Mod.ObjectTypeCallProperty_
import typings.babelTypes.ts36Mod.ObjectTypeIndexer_
import typings.babelTypes.ts36Mod.ObjectTypeProperty_
import typings.babelTypes.ts36Mod.ParenthesizedExpression_
import typings.babelTypes.ts36Mod.Program_
import typings.babelTypes.ts36Mod.QualifiedTypeIdentifier_
import typings.babelTypes.ts36Mod.RegExpLiteral_
import typings.babelTypes.ts36Mod.RestElement_
import typings.babelTypes.ts36Mod.ReturnStatement_
import typings.babelTypes.ts36Mod.SequenceExpression_
import typings.babelTypes.ts36Mod.SpreadElement_
import typings.babelTypes.ts36Mod.StringLiteralTypeAnnotation_
import typings.babelTypes.ts36Mod.StringLiteral_
import typings.babelTypes.ts36Mod.StringTypeAnnotation_
import typings.babelTypes.ts36Mod.Super
import typings.babelTypes.ts36Mod.SwitchCase_
import typings.babelTypes.ts36Mod.SwitchStatement_
import typings.babelTypes.ts36Mod.TaggedTemplateExpression_
import typings.babelTypes.ts36Mod.TemplateElement_
import typings.babelTypes.ts36Mod.TemplateLiteral_
import typings.babelTypes.ts36Mod.ThisExpression_
import typings.babelTypes.ts36Mod.ThisTypeAnnotation_
import typings.babelTypes.ts36Mod.ThrowStatement_
import typings.babelTypes.ts36Mod.TryStatement_
import typings.babelTypes.ts36Mod.TupleTypeAnnotation_
import typings.babelTypes.ts36Mod.TypeAlias_
import typings.babelTypes.ts36Mod.TypeAnnotation_
import typings.babelTypes.ts36Mod.TypeCastExpression_
import typings.babelTypes.ts36Mod.TypeParameterDeclaration_
import typings.babelTypes.ts36Mod.TypeParameterInstantiation_
import typings.babelTypes.ts36Mod.TypeofTypeAnnotation_
import typings.babelTypes.ts36Mod.UnaryExpression_
import typings.babelTypes.ts36Mod.UnionTypeAnnotation_
import typings.babelTypes.ts36Mod.UpdateExpression_
import typings.babelTypes.ts36Mod.VariableDeclaration_
import typings.babelTypes.ts36Mod.VariableDeclarator_
import typings.babelTypes.ts36Mod.VoidTypeAnnotation_
import typings.babelTypes.ts36Mod.WhileStatement_
import typings.babelTypes.ts36Mod.WithStatement_
import typings.babelTypes.ts36Mod.YieldExpression_
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  @JSImport("babylon-walk", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  inline def ancestor(node: NodeTypes, visitors: visitors[AncestorVisitor], state: js.Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("ancestor")(node.asInstanceOf[js.Any], visitors.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def recursive(node: NodeTypes, visitors: visitors[RecursiveVisitor], state: js.Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("recursive")(node.asInstanceOf[js.Any], visitors.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def simple(node: NodeTypes, visitors: visitors[SimpleVisitor], state: js.Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("simple")(node.asInstanceOf[js.Any], visitors.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  type AncestorStatelessVisitor = js.Function3[/* node */ NodeTypes, /* state */ js.Any, /* ancestors */ js.Array[Node], Unit]
  
  type AncestorVisitor = js.Function3[/* node */ NodeTypes, /* state */ js.Any, /* ancestors */ js.Array[Node], Unit]
  
  type NodeTypes = coreTypes | es2015Types | flowTypes | jsxTypes | miscTypes
  
  type RecursiveVisitor = js.Function3[
    /* node */ NodeTypes, 
    /* state */ js.Any, 
    /* next */ js.Function1[/* node */ Node, Unit], 
    Unit
  ]
  
  type SimpleVisitor = js.Function2[/* node */ NodeTypes, /* state */ js.Any, Unit]
  
  type Visitor = js.Function2[/* commentBlock */ NodeTypes, /* state */ js.Any, Unit]
  
  type coreTypes = ArrayExpression_ | AssignmentExpression_ | BinaryExpression_ | Directive_ | DirectiveLiteral_ | BlockStatement_ | BreakStatement_ | CallExpression_ | CatchClause_ | ConditionalExpression_ | ContinueStatement_ | DebuggerStatement_ | DoWhileStatement_ | EmptyStatement_ | ExpressionStatement_ | File_ | ForInStatement_ | ForStatement_ | FunctionDeclaration_ | FunctionExpression_ | Identifier_ | IfStatement_ | LabeledStatement_ | StringLiteral_ | NumericLiteral_ | NullLiteral_ | BooleanLiteral_ | RegExpLiteral_ | LogicalExpression_ | MemberExpression_ | NewExpression_ | Program_ | ObjectExpression_ | ObjectMethod_ | ObjectProperty_ | RestElement_ | ReturnStatement_ | SequenceExpression_ | SwitchCase_ | SwitchStatement_ | ThisExpression_ | ThrowStatement_ | TryStatement_ | UnaryExpression_ | UpdateExpression_ | VariableDeclaration_ | VariableDeclarator_ | WhileStatement_ | WithStatement_
  
  trait coreVisitors[V] extends StObject {
    
    var ArrayExpression: js.UndefOr[V] = js.undefined
    
    var AssignmentExpression: js.UndefOr[V] = js.undefined
    
    var BinaryExpression: js.UndefOr[V] = js.undefined
    
    var BlockStatement: js.UndefOr[V] = js.undefined
    
    var BooleanLiteral: js.UndefOr[V] = js.undefined
    
    var BreakStatement: js.UndefOr[V] = js.undefined
    
    var CallExpression: js.UndefOr[V] = js.undefined
    
    var CatchClause: js.UndefOr[V] = js.undefined
    
    var ConditionalExpression: js.UndefOr[V] = js.undefined
    
    var ContinueStatement: js.UndefOr[V] = js.undefined
    
    var DebuggerStatement: js.UndefOr[V] = js.undefined
    
    var Directive: js.UndefOr[V] = js.undefined
    
    var DirectiveLiteral: js.UndefOr[V] = js.undefined
    
    var DoWhileStatement: js.UndefOr[V] = js.undefined
    
    var EmptyStatement: js.UndefOr[V] = js.undefined
    
    var ExpressionStatement: js.UndefOr[V] = js.undefined
    
    var File: js.UndefOr[V] = js.undefined
    
    var ForInStatement: js.UndefOr[V] = js.undefined
    
    var ForStatement: js.UndefOr[V] = js.undefined
    
    var FunctionDeclaration: js.UndefOr[V] = js.undefined
    
    var FunctionExpression: js.UndefOr[V] = js.undefined
    
    var Identifier: js.UndefOr[V] = js.undefined
    
    var IfStatement: js.UndefOr[V] = js.undefined
    
    var LabeledStatement: js.UndefOr[V] = js.undefined
    
    var LogicalExpression: js.UndefOr[V] = js.undefined
    
    var MemberExpression: js.UndefOr[V] = js.undefined
    
    var NewExpression: js.UndefOr[V] = js.undefined
    
    var NullLiteral: js.UndefOr[V] = js.undefined
    
    var NumericLiteral: js.UndefOr[V] = js.undefined
    
    var ObjectExpression: js.UndefOr[V] = js.undefined
    
    var ObjectMethod: js.UndefOr[V] = js.undefined
    
    var ObjectProperty: js.UndefOr[V] = js.undefined
    
    var Program: js.UndefOr[V] = js.undefined
    
    var RegExpLiteral: js.UndefOr[V] = js.undefined
    
    var RestElement: js.UndefOr[V] = js.undefined
    
    var ReturnStatement: js.UndefOr[V] = js.undefined
    
    var SequenceExpression: js.UndefOr[V] = js.undefined
    
    var StringLiteral: js.UndefOr[V] = js.undefined
    
    var SwitchCase: js.UndefOr[V] = js.undefined
    
    var SwitchStatement: js.UndefOr[V] = js.undefined
    
    var ThisExpression: js.UndefOr[V] = js.undefined
    
    var ThrowStatement: js.UndefOr[V] = js.undefined
    
    var TryStatement: js.UndefOr[V] = js.undefined
    
    var UnaryExpression: js.UndefOr[V] = js.undefined
    
    var UpdateExpression: js.UndefOr[V] = js.undefined
    
    var VariableDeclaration: js.UndefOr[V] = js.undefined
    
    var VariableDeclarator: js.UndefOr[V] = js.undefined
    
    var WhileStatement: js.UndefOr[V] = js.undefined
    
    var WithStatement: js.UndefOr[V] = js.undefined
  }
  object coreVisitors {
    
    inline def apply[V](): coreVisitors[V] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[coreVisitors[V]]
    }
    
    extension [Self <: coreVisitors[?], V](x: Self & coreVisitors[V]) {
      
      inline def setArrayExpression(value: V): Self = StObject.set(x, "ArrayExpression", value.asInstanceOf[js.Any])
      
      inline def setArrayExpressionUndefined: Self = StObject.set(x, "ArrayExpression", js.undefined)
      
      inline def setAssignmentExpression(value: V): Self = StObject.set(x, "AssignmentExpression", value.asInstanceOf[js.Any])
      
      inline def setAssignmentExpressionUndefined: Self = StObject.set(x, "AssignmentExpression", js.undefined)
      
      inline def setBinaryExpression(value: V): Self = StObject.set(x, "BinaryExpression", value.asInstanceOf[js.Any])
      
      inline def setBinaryExpressionUndefined: Self = StObject.set(x, "BinaryExpression", js.undefined)
      
      inline def setBlockStatement(value: V): Self = StObject.set(x, "BlockStatement", value.asInstanceOf[js.Any])
      
      inline def setBlockStatementUndefined: Self = StObject.set(x, "BlockStatement", js.undefined)
      
      inline def setBooleanLiteral(value: V): Self = StObject.set(x, "BooleanLiteral", value.asInstanceOf[js.Any])
      
      inline def setBooleanLiteralUndefined: Self = StObject.set(x, "BooleanLiteral", js.undefined)
      
      inline def setBreakStatement(value: V): Self = StObject.set(x, "BreakStatement", value.asInstanceOf[js.Any])
      
      inline def setBreakStatementUndefined: Self = StObject.set(x, "BreakStatement", js.undefined)
      
      inline def setCallExpression(value: V): Self = StObject.set(x, "CallExpression", value.asInstanceOf[js.Any])
      
      inline def setCallExpressionUndefined: Self = StObject.set(x, "CallExpression", js.undefined)
      
      inline def setCatchClause(value: V): Self = StObject.set(x, "CatchClause", value.asInstanceOf[js.Any])
      
      inline def setCatchClauseUndefined: Self = StObject.set(x, "CatchClause", js.undefined)
      
      inline def setConditionalExpression(value: V): Self = StObject.set(x, "ConditionalExpression", value.asInstanceOf[js.Any])
      
      inline def setConditionalExpressionUndefined: Self = StObject.set(x, "ConditionalExpression", js.undefined)
      
      inline def setContinueStatement(value: V): Self = StObject.set(x, "ContinueStatement", value.asInstanceOf[js.Any])
      
      inline def setContinueStatementUndefined: Self = StObject.set(x, "ContinueStatement", js.undefined)
      
      inline def setDebuggerStatement(value: V): Self = StObject.set(x, "DebuggerStatement", value.asInstanceOf[js.Any])
      
      inline def setDebuggerStatementUndefined: Self = StObject.set(x, "DebuggerStatement", js.undefined)
      
      inline def setDirective(value: V): Self = StObject.set(x, "Directive", value.asInstanceOf[js.Any])
      
      inline def setDirectiveLiteral(value: V): Self = StObject.set(x, "DirectiveLiteral", value.asInstanceOf[js.Any])
      
      inline def setDirectiveLiteralUndefined: Self = StObject.set(x, "DirectiveLiteral", js.undefined)
      
      inline def setDirectiveUndefined: Self = StObject.set(x, "Directive", js.undefined)
      
      inline def setDoWhileStatement(value: V): Self = StObject.set(x, "DoWhileStatement", value.asInstanceOf[js.Any])
      
      inline def setDoWhileStatementUndefined: Self = StObject.set(x, "DoWhileStatement", js.undefined)
      
      inline def setEmptyStatement(value: V): Self = StObject.set(x, "EmptyStatement", value.asInstanceOf[js.Any])
      
      inline def setEmptyStatementUndefined: Self = StObject.set(x, "EmptyStatement", js.undefined)
      
      inline def setExpressionStatement(value: V): Self = StObject.set(x, "ExpressionStatement", value.asInstanceOf[js.Any])
      
      inline def setExpressionStatementUndefined: Self = StObject.set(x, "ExpressionStatement", js.undefined)
      
      inline def setFile(value: V): Self = StObject.set(x, "File", value.asInstanceOf[js.Any])
      
      inline def setFileUndefined: Self = StObject.set(x, "File", js.undefined)
      
      inline def setForInStatement(value: V): Self = StObject.set(x, "ForInStatement", value.asInstanceOf[js.Any])
      
      inline def setForInStatementUndefined: Self = StObject.set(x, "ForInStatement", js.undefined)
      
      inline def setForStatement(value: V): Self = StObject.set(x, "ForStatement", value.asInstanceOf[js.Any])
      
      inline def setForStatementUndefined: Self = StObject.set(x, "ForStatement", js.undefined)
      
      inline def setFunctionDeclaration(value: V): Self = StObject.set(x, "FunctionDeclaration", value.asInstanceOf[js.Any])
      
      inline def setFunctionDeclarationUndefined: Self = StObject.set(x, "FunctionDeclaration", js.undefined)
      
      inline def setFunctionExpression(value: V): Self = StObject.set(x, "FunctionExpression", value.asInstanceOf[js.Any])
      
      inline def setFunctionExpressionUndefined: Self = StObject.set(x, "FunctionExpression", js.undefined)
      
      inline def setIdentifier(value: V): Self = StObject.set(x, "Identifier", value.asInstanceOf[js.Any])
      
      inline def setIdentifierUndefined: Self = StObject.set(x, "Identifier", js.undefined)
      
      inline def setIfStatement(value: V): Self = StObject.set(x, "IfStatement", value.asInstanceOf[js.Any])
      
      inline def setIfStatementUndefined: Self = StObject.set(x, "IfStatement", js.undefined)
      
      inline def setLabeledStatement(value: V): Self = StObject.set(x, "LabeledStatement", value.asInstanceOf[js.Any])
      
      inline def setLabeledStatementUndefined: Self = StObject.set(x, "LabeledStatement", js.undefined)
      
      inline def setLogicalExpression(value: V): Self = StObject.set(x, "LogicalExpression", value.asInstanceOf[js.Any])
      
      inline def setLogicalExpressionUndefined: Self = StObject.set(x, "LogicalExpression", js.undefined)
      
      inline def setMemberExpression(value: V): Self = StObject.set(x, "MemberExpression", value.asInstanceOf[js.Any])
      
      inline def setMemberExpressionUndefined: Self = StObject.set(x, "MemberExpression", js.undefined)
      
      inline def setNewExpression(value: V): Self = StObject.set(x, "NewExpression", value.asInstanceOf[js.Any])
      
      inline def setNewExpressionUndefined: Self = StObject.set(x, "NewExpression", js.undefined)
      
      inline def setNullLiteral(value: V): Self = StObject.set(x, "NullLiteral", value.asInstanceOf[js.Any])
      
      inline def setNullLiteralUndefined: Self = StObject.set(x, "NullLiteral", js.undefined)
      
      inline def setNumericLiteral(value: V): Self = StObject.set(x, "NumericLiteral", value.asInstanceOf[js.Any])
      
      inline def setNumericLiteralUndefined: Self = StObject.set(x, "NumericLiteral", js.undefined)
      
      inline def setObjectExpression(value: V): Self = StObject.set(x, "ObjectExpression", value.asInstanceOf[js.Any])
      
      inline def setObjectExpressionUndefined: Self = StObject.set(x, "ObjectExpression", js.undefined)
      
      inline def setObjectMethod(value: V): Self = StObject.set(x, "ObjectMethod", value.asInstanceOf[js.Any])
      
      inline def setObjectMethodUndefined: Self = StObject.set(x, "ObjectMethod", js.undefined)
      
      inline def setObjectProperty(value: V): Self = StObject.set(x, "ObjectProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectPropertyUndefined: Self = StObject.set(x, "ObjectProperty", js.undefined)
      
      inline def setProgram(value: V): Self = StObject.set(x, "Program", value.asInstanceOf[js.Any])
      
      inline def setProgramUndefined: Self = StObject.set(x, "Program", js.undefined)
      
      inline def setRegExpLiteral(value: V): Self = StObject.set(x, "RegExpLiteral", value.asInstanceOf[js.Any])
      
      inline def setRegExpLiteralUndefined: Self = StObject.set(x, "RegExpLiteral", js.undefined)
      
      inline def setRestElement(value: V): Self = StObject.set(x, "RestElement", value.asInstanceOf[js.Any])
      
      inline def setRestElementUndefined: Self = StObject.set(x, "RestElement", js.undefined)
      
      inline def setReturnStatement(value: V): Self = StObject.set(x, "ReturnStatement", value.asInstanceOf[js.Any])
      
      inline def setReturnStatementUndefined: Self = StObject.set(x, "ReturnStatement", js.undefined)
      
      inline def setSequenceExpression(value: V): Self = StObject.set(x, "SequenceExpression", value.asInstanceOf[js.Any])
      
      inline def setSequenceExpressionUndefined: Self = StObject.set(x, "SequenceExpression", js.undefined)
      
      inline def setStringLiteral(value: V): Self = StObject.set(x, "StringLiteral", value.asInstanceOf[js.Any])
      
      inline def setStringLiteralUndefined: Self = StObject.set(x, "StringLiteral", js.undefined)
      
      inline def setSwitchCase(value: V): Self = StObject.set(x, "SwitchCase", value.asInstanceOf[js.Any])
      
      inline def setSwitchCaseUndefined: Self = StObject.set(x, "SwitchCase", js.undefined)
      
      inline def setSwitchStatement(value: V): Self = StObject.set(x, "SwitchStatement", value.asInstanceOf[js.Any])
      
      inline def setSwitchStatementUndefined: Self = StObject.set(x, "SwitchStatement", js.undefined)
      
      inline def setThisExpression(value: V): Self = StObject.set(x, "ThisExpression", value.asInstanceOf[js.Any])
      
      inline def setThisExpressionUndefined: Self = StObject.set(x, "ThisExpression", js.undefined)
      
      inline def setThrowStatement(value: V): Self = StObject.set(x, "ThrowStatement", value.asInstanceOf[js.Any])
      
      inline def setThrowStatementUndefined: Self = StObject.set(x, "ThrowStatement", js.undefined)
      
      inline def setTryStatement(value: V): Self = StObject.set(x, "TryStatement", value.asInstanceOf[js.Any])
      
      inline def setTryStatementUndefined: Self = StObject.set(x, "TryStatement", js.undefined)
      
      inline def setUnaryExpression(value: V): Self = StObject.set(x, "UnaryExpression", value.asInstanceOf[js.Any])
      
      inline def setUnaryExpressionUndefined: Self = StObject.set(x, "UnaryExpression", js.undefined)
      
      inline def setUpdateExpression(value: V): Self = StObject.set(x, "UpdateExpression", value.asInstanceOf[js.Any])
      
      inline def setUpdateExpressionUndefined: Self = StObject.set(x, "UpdateExpression", js.undefined)
      
      inline def setVariableDeclaration(value: V): Self = StObject.set(x, "VariableDeclaration", value.asInstanceOf[js.Any])
      
      inline def setVariableDeclarationUndefined: Self = StObject.set(x, "VariableDeclaration", js.undefined)
      
      inline def setVariableDeclarator(value: V): Self = StObject.set(x, "VariableDeclarator", value.asInstanceOf[js.Any])
      
      inline def setVariableDeclaratorUndefined: Self = StObject.set(x, "VariableDeclarator", js.undefined)
      
      inline def setWhileStatement(value: V): Self = StObject.set(x, "WhileStatement", value.asInstanceOf[js.Any])
      
      inline def setWhileStatementUndefined: Self = StObject.set(x, "WhileStatement", js.undefined)
      
      inline def setWithStatement(value: V): Self = StObject.set(x, "WithStatement", value.asInstanceOf[js.Any])
      
      inline def setWithStatementUndefined: Self = StObject.set(x, "WithStatement", js.undefined)
    }
  }
  
  type es2015Types = AssignmentPattern_ | ArrayPattern_ | ArrowFunctionExpression_ | ClassBody_ | ClassDeclaration_ | ClassExpression_ | ExportAllDeclaration_ | ExportDefaultDeclaration_ | ExportNamedDeclaration_ | ExportSpecifier_ | ForOfStatement_ | ImportDeclaration_ | ImportDefaultSpecifier_ | ImportNamespaceSpecifier_ | ImportSpecifier_ | MetaProperty_ | ClassMethod_ | ObjectPattern_ | SpreadElement_ | Super | TaggedTemplateExpression_ | TemplateElement_ | TemplateLiteral_ | YieldExpression_ | AwaitExpression_ | BindExpression_ | ClassProperty_ | Decorator_ | DoExpression_ | ExportDefaultSpecifier_ | ExportNamespaceSpecifier_
  
  trait es2015Visitors[V] extends StObject {
    
    var ArrayPattern: js.UndefOr[V] = js.undefined
    
    var ArrowFunctionExpression: js.UndefOr[V] = js.undefined
    
    var AssignmentPattern: js.UndefOr[V] = js.undefined
    
    var AwaitExpression: js.UndefOr[V] = js.undefined
    
    var BindExpression: js.UndefOr[V] = js.undefined
    
    var ClassBody: js.UndefOr[V] = js.undefined
    
    var ClassDeclaration: js.UndefOr[V] = js.undefined
    
    var ClassExpression: js.UndefOr[V] = js.undefined
    
    var ClassMethod: js.UndefOr[V] = js.undefined
    
    var ClassProperty: js.UndefOr[V] = js.undefined
    
    var Decorator: js.UndefOr[V] = js.undefined
    
    var DoExpression: js.UndefOr[V] = js.undefined
    
    var ExportAllDeclaration: js.UndefOr[V] = js.undefined
    
    var ExportDefaultDeclaration: js.UndefOr[V] = js.undefined
    
    var ExportDefaultSpecifier: js.UndefOr[V] = js.undefined
    
    var ExportNamedDeclaration: js.UndefOr[V] = js.undefined
    
    var ExportNamespaceSpecifier: js.UndefOr[V] = js.undefined
    
    var ExportSpecifier: js.UndefOr[V] = js.undefined
    
    var ForOfStatement: js.UndefOr[V] = js.undefined
    
    var ImportDeclaration: js.UndefOr[V] = js.undefined
    
    var ImportDefaultSpecifier: js.UndefOr[V] = js.undefined
    
    var ImportNamespaceSpecifier: js.UndefOr[V] = js.undefined
    
    var ImportSpecifier: js.UndefOr[V] = js.undefined
    
    var MetaProperty: js.UndefOr[V] = js.undefined
    
    var ObjectPattern: js.UndefOr[V] = js.undefined
    
    var SpreadElement: js.UndefOr[V] = js.undefined
    
    var Super: js.UndefOr[V] = js.undefined
    
    var TaggedTemplateExpression: js.UndefOr[V] = js.undefined
    
    var TemplateElement: js.UndefOr[V] = js.undefined
    
    var TemplateLiteral: js.UndefOr[V] = js.undefined
    
    var YieldExpression: js.UndefOr[V] = js.undefined
  }
  object es2015Visitors {
    
    inline def apply[V](): es2015Visitors[V] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[es2015Visitors[V]]
    }
    
    extension [Self <: es2015Visitors[?], V](x: Self & es2015Visitors[V]) {
      
      inline def setArrayPattern(value: V): Self = StObject.set(x, "ArrayPattern", value.asInstanceOf[js.Any])
      
      inline def setArrayPatternUndefined: Self = StObject.set(x, "ArrayPattern", js.undefined)
      
      inline def setArrowFunctionExpression(value: V): Self = StObject.set(x, "ArrowFunctionExpression", value.asInstanceOf[js.Any])
      
      inline def setArrowFunctionExpressionUndefined: Self = StObject.set(x, "ArrowFunctionExpression", js.undefined)
      
      inline def setAssignmentPattern(value: V): Self = StObject.set(x, "AssignmentPattern", value.asInstanceOf[js.Any])
      
      inline def setAssignmentPatternUndefined: Self = StObject.set(x, "AssignmentPattern", js.undefined)
      
      inline def setAwaitExpression(value: V): Self = StObject.set(x, "AwaitExpression", value.asInstanceOf[js.Any])
      
      inline def setAwaitExpressionUndefined: Self = StObject.set(x, "AwaitExpression", js.undefined)
      
      inline def setBindExpression(value: V): Self = StObject.set(x, "BindExpression", value.asInstanceOf[js.Any])
      
      inline def setBindExpressionUndefined: Self = StObject.set(x, "BindExpression", js.undefined)
      
      inline def setClassBody(value: V): Self = StObject.set(x, "ClassBody", value.asInstanceOf[js.Any])
      
      inline def setClassBodyUndefined: Self = StObject.set(x, "ClassBody", js.undefined)
      
      inline def setClassDeclaration(value: V): Self = StObject.set(x, "ClassDeclaration", value.asInstanceOf[js.Any])
      
      inline def setClassDeclarationUndefined: Self = StObject.set(x, "ClassDeclaration", js.undefined)
      
      inline def setClassExpression(value: V): Self = StObject.set(x, "ClassExpression", value.asInstanceOf[js.Any])
      
      inline def setClassExpressionUndefined: Self = StObject.set(x, "ClassExpression", js.undefined)
      
      inline def setClassMethod(value: V): Self = StObject.set(x, "ClassMethod", value.asInstanceOf[js.Any])
      
      inline def setClassMethodUndefined: Self = StObject.set(x, "ClassMethod", js.undefined)
      
      inline def setClassProperty(value: V): Self = StObject.set(x, "ClassProperty", value.asInstanceOf[js.Any])
      
      inline def setClassPropertyUndefined: Self = StObject.set(x, "ClassProperty", js.undefined)
      
      inline def setDecorator(value: V): Self = StObject.set(x, "Decorator", value.asInstanceOf[js.Any])
      
      inline def setDecoratorUndefined: Self = StObject.set(x, "Decorator", js.undefined)
      
      inline def setDoExpression(value: V): Self = StObject.set(x, "DoExpression", value.asInstanceOf[js.Any])
      
      inline def setDoExpressionUndefined: Self = StObject.set(x, "DoExpression", js.undefined)
      
      inline def setExportAllDeclaration(value: V): Self = StObject.set(x, "ExportAllDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportAllDeclarationUndefined: Self = StObject.set(x, "ExportAllDeclaration", js.undefined)
      
      inline def setExportDefaultDeclaration(value: V): Self = StObject.set(x, "ExportDefaultDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportDefaultDeclarationUndefined: Self = StObject.set(x, "ExportDefaultDeclaration", js.undefined)
      
      inline def setExportDefaultSpecifier(value: V): Self = StObject.set(x, "ExportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportDefaultSpecifierUndefined: Self = StObject.set(x, "ExportDefaultSpecifier", js.undefined)
      
      inline def setExportNamedDeclaration(value: V): Self = StObject.set(x, "ExportNamedDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportNamedDeclarationUndefined: Self = StObject.set(x, "ExportNamedDeclaration", js.undefined)
      
      inline def setExportNamespaceSpecifier(value: V): Self = StObject.set(x, "ExportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportNamespaceSpecifierUndefined: Self = StObject.set(x, "ExportNamespaceSpecifier", js.undefined)
      
      inline def setExportSpecifier(value: V): Self = StObject.set(x, "ExportSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportSpecifierUndefined: Self = StObject.set(x, "ExportSpecifier", js.undefined)
      
      inline def setForOfStatement(value: V): Self = StObject.set(x, "ForOfStatement", value.asInstanceOf[js.Any])
      
      inline def setForOfStatementUndefined: Self = StObject.set(x, "ForOfStatement", js.undefined)
      
      inline def setImportDeclaration(value: V): Self = StObject.set(x, "ImportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setImportDeclarationUndefined: Self = StObject.set(x, "ImportDeclaration", js.undefined)
      
      inline def setImportDefaultSpecifier(value: V): Self = StObject.set(x, "ImportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportDefaultSpecifierUndefined: Self = StObject.set(x, "ImportDefaultSpecifier", js.undefined)
      
      inline def setImportNamespaceSpecifier(value: V): Self = StObject.set(x, "ImportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportNamespaceSpecifierUndefined: Self = StObject.set(x, "ImportNamespaceSpecifier", js.undefined)
      
      inline def setImportSpecifier(value: V): Self = StObject.set(x, "ImportSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportSpecifierUndefined: Self = StObject.set(x, "ImportSpecifier", js.undefined)
      
      inline def setMetaProperty(value: V): Self = StObject.set(x, "MetaProperty", value.asInstanceOf[js.Any])
      
      inline def setMetaPropertyUndefined: Self = StObject.set(x, "MetaProperty", js.undefined)
      
      inline def setObjectPattern(value: V): Self = StObject.set(x, "ObjectPattern", value.asInstanceOf[js.Any])
      
      inline def setObjectPatternUndefined: Self = StObject.set(x, "ObjectPattern", js.undefined)
      
      inline def setSpreadElement(value: V): Self = StObject.set(x, "SpreadElement", value.asInstanceOf[js.Any])
      
      inline def setSpreadElementUndefined: Self = StObject.set(x, "SpreadElement", js.undefined)
      
      inline def setSuper(value: V): Self = StObject.set(x, "Super", value.asInstanceOf[js.Any])
      
      inline def setSuperUndefined: Self = StObject.set(x, "Super", js.undefined)
      
      inline def setTaggedTemplateExpression(value: V): Self = StObject.set(x, "TaggedTemplateExpression", value.asInstanceOf[js.Any])
      
      inline def setTaggedTemplateExpressionUndefined: Self = StObject.set(x, "TaggedTemplateExpression", js.undefined)
      
      inline def setTemplateElement(value: V): Self = StObject.set(x, "TemplateElement", value.asInstanceOf[js.Any])
      
      inline def setTemplateElementUndefined: Self = StObject.set(x, "TemplateElement", js.undefined)
      
      inline def setTemplateLiteral(value: V): Self = StObject.set(x, "TemplateLiteral", value.asInstanceOf[js.Any])
      
      inline def setTemplateLiteralUndefined: Self = StObject.set(x, "TemplateLiteral", js.undefined)
      
      inline def setYieldExpression(value: V): Self = StObject.set(x, "YieldExpression", value.asInstanceOf[js.Any])
      
      inline def setYieldExpressionUndefined: Self = StObject.set(x, "YieldExpression", js.undefined)
    }
  }
  
  type flowTypes = AnyTypeAnnotation_ | ArrayTypeAnnotation_ | BooleanTypeAnnotation_ | BooleanLiteralTypeAnnotation_ | NullLiteralTypeAnnotation_ | ClassImplements_ | DeclareClass_ | DeclareFunction_ | DeclareInterface_ | DeclareModule_ | DeclareTypeAlias_ | DeclareVariable_ | FunctionTypeAnnotation_ | FunctionTypeParam_ | GenericTypeAnnotation_ | InterfaceExtends_ | InterfaceDeclaration_ | IntersectionTypeAnnotation_ | MixedTypeAnnotation_ | NullableTypeAnnotation_ | NumberTypeAnnotation_ | ObjectTypeAnnotation_ | ObjectTypeCallProperty_ | ObjectTypeIndexer_ | ObjectTypeProperty_ | QualifiedTypeIdentifier_ | StringLiteralTypeAnnotation_ | StringTypeAnnotation_ | ThisTypeAnnotation_ | TupleTypeAnnotation_ | TypeofTypeAnnotation_ | TypeAlias_ | TypeAnnotation_ | TypeCastExpression_ | TypeParameterDeclaration_ | TypeParameterInstantiation_ | UnionTypeAnnotation_ | VoidTypeAnnotation_
  
  trait flowVisitors[V] extends StObject {
    
    var AnyTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var ArrayTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var BooleanLiteralTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var BooleanTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var ClassImplements: js.UndefOr[V] = js.undefined
    
    var DeclareClass: js.UndefOr[V] = js.undefined
    
    var DeclareFunction: js.UndefOr[V] = js.undefined
    
    var DeclareInterface: js.UndefOr[V] = js.undefined
    
    var DeclareModule: js.UndefOr[V] = js.undefined
    
    var DeclareTypeAlias: js.UndefOr[V] = js.undefined
    
    var DeclareVariable: js.UndefOr[V] = js.undefined
    
    var FunctionTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var FunctionTypeParam: js.UndefOr[V] = js.undefined
    
    var GenericTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var InterfaceDeclaration: js.UndefOr[V] = js.undefined
    
    var InterfaceExtends: js.UndefOr[V] = js.undefined
    
    var IntersectionTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var MixedTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var NullLiteralTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var NullableTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var NumberTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var ObjectTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var ObjectTypeCallProperty: js.UndefOr[V] = js.undefined
    
    var ObjectTypeIndexer: js.UndefOr[V] = js.undefined
    
    var ObjectTypeProperty: js.UndefOr[V] = js.undefined
    
    var QualifiedTypeIdentifier: js.UndefOr[V] = js.undefined
    
    var StringLiteralTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var StringTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var ThisTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var TupleTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var TypeAlias: js.UndefOr[V] = js.undefined
    
    var TypeAnnotation: js.UndefOr[V] = js.undefined
    
    var TypeCastExpression: js.UndefOr[V] = js.undefined
    
    var TypeParameterDeclaration: js.UndefOr[V] = js.undefined
    
    var TypeParameterInstantiation: js.UndefOr[V] = js.undefined
    
    var TypeofTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var UnionTypeAnnotation: js.UndefOr[V] = js.undefined
    
    var VoidTypeAnnotation: js.UndefOr[V] = js.undefined
  }
  object flowVisitors {
    
    inline def apply[V](): flowVisitors[V] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[flowVisitors[V]]
    }
    
    extension [Self <: flowVisitors[?], V](x: Self & flowVisitors[V]) {
      
      inline def setAnyTypeAnnotation(value: V): Self = StObject.set(x, "AnyTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setAnyTypeAnnotationUndefined: Self = StObject.set(x, "AnyTypeAnnotation", js.undefined)
      
      inline def setArrayTypeAnnotation(value: V): Self = StObject.set(x, "ArrayTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setArrayTypeAnnotationUndefined: Self = StObject.set(x, "ArrayTypeAnnotation", js.undefined)
      
      inline def setBooleanLiteralTypeAnnotation(value: V): Self = StObject.set(x, "BooleanLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setBooleanLiteralTypeAnnotationUndefined: Self = StObject.set(x, "BooleanLiteralTypeAnnotation", js.undefined)
      
      inline def setBooleanTypeAnnotation(value: V): Self = StObject.set(x, "BooleanTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setBooleanTypeAnnotationUndefined: Self = StObject.set(x, "BooleanTypeAnnotation", js.undefined)
      
      inline def setClassImplements(value: V): Self = StObject.set(x, "ClassImplements", value.asInstanceOf[js.Any])
      
      inline def setClassImplementsUndefined: Self = StObject.set(x, "ClassImplements", js.undefined)
      
      inline def setDeclareClass(value: V): Self = StObject.set(x, "DeclareClass", value.asInstanceOf[js.Any])
      
      inline def setDeclareClassUndefined: Self = StObject.set(x, "DeclareClass", js.undefined)
      
      inline def setDeclareFunction(value: V): Self = StObject.set(x, "DeclareFunction", value.asInstanceOf[js.Any])
      
      inline def setDeclareFunctionUndefined: Self = StObject.set(x, "DeclareFunction", js.undefined)
      
      inline def setDeclareInterface(value: V): Self = StObject.set(x, "DeclareInterface", value.asInstanceOf[js.Any])
      
      inline def setDeclareInterfaceUndefined: Self = StObject.set(x, "DeclareInterface", js.undefined)
      
      inline def setDeclareModule(value: V): Self = StObject.set(x, "DeclareModule", value.asInstanceOf[js.Any])
      
      inline def setDeclareModuleUndefined: Self = StObject.set(x, "DeclareModule", js.undefined)
      
      inline def setDeclareTypeAlias(value: V): Self = StObject.set(x, "DeclareTypeAlias", value.asInstanceOf[js.Any])
      
      inline def setDeclareTypeAliasUndefined: Self = StObject.set(x, "DeclareTypeAlias", js.undefined)
      
      inline def setDeclareVariable(value: V): Self = StObject.set(x, "DeclareVariable", value.asInstanceOf[js.Any])
      
      inline def setDeclareVariableUndefined: Self = StObject.set(x, "DeclareVariable", js.undefined)
      
      inline def setFunctionTypeAnnotation(value: V): Self = StObject.set(x, "FunctionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setFunctionTypeAnnotationUndefined: Self = StObject.set(x, "FunctionTypeAnnotation", js.undefined)
      
      inline def setFunctionTypeParam(value: V): Self = StObject.set(x, "FunctionTypeParam", value.asInstanceOf[js.Any])
      
      inline def setFunctionTypeParamUndefined: Self = StObject.set(x, "FunctionTypeParam", js.undefined)
      
      inline def setGenericTypeAnnotation(value: V): Self = StObject.set(x, "GenericTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setGenericTypeAnnotationUndefined: Self = StObject.set(x, "GenericTypeAnnotation", js.undefined)
      
      inline def setInterfaceDeclaration(value: V): Self = StObject.set(x, "InterfaceDeclaration", value.asInstanceOf[js.Any])
      
      inline def setInterfaceDeclarationUndefined: Self = StObject.set(x, "InterfaceDeclaration", js.undefined)
      
      inline def setInterfaceExtends(value: V): Self = StObject.set(x, "InterfaceExtends", value.asInstanceOf[js.Any])
      
      inline def setInterfaceExtendsUndefined: Self = StObject.set(x, "InterfaceExtends", js.undefined)
      
      inline def setIntersectionTypeAnnotation(value: V): Self = StObject.set(x, "IntersectionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setIntersectionTypeAnnotationUndefined: Self = StObject.set(x, "IntersectionTypeAnnotation", js.undefined)
      
      inline def setMixedTypeAnnotation(value: V): Self = StObject.set(x, "MixedTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setMixedTypeAnnotationUndefined: Self = StObject.set(x, "MixedTypeAnnotation", js.undefined)
      
      inline def setNullLiteralTypeAnnotation(value: V): Self = StObject.set(x, "NullLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNullLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NullLiteralTypeAnnotation", js.undefined)
      
      inline def setNullableTypeAnnotation(value: V): Self = StObject.set(x, "NullableTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNullableTypeAnnotationUndefined: Self = StObject.set(x, "NullableTypeAnnotation", js.undefined)
      
      inline def setNumberTypeAnnotation(value: V): Self = StObject.set(x, "NumberTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNumberTypeAnnotationUndefined: Self = StObject.set(x, "NumberTypeAnnotation", js.undefined)
      
      inline def setObjectTypeAnnotation(value: V): Self = StObject.set(x, "ObjectTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeAnnotationUndefined: Self = StObject.set(x, "ObjectTypeAnnotation", js.undefined)
      
      inline def setObjectTypeCallProperty(value: V): Self = StObject.set(x, "ObjectTypeCallProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeCallPropertyUndefined: Self = StObject.set(x, "ObjectTypeCallProperty", js.undefined)
      
      inline def setObjectTypeIndexer(value: V): Self = StObject.set(x, "ObjectTypeIndexer", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeIndexerUndefined: Self = StObject.set(x, "ObjectTypeIndexer", js.undefined)
      
      inline def setObjectTypeProperty(value: V): Self = StObject.set(x, "ObjectTypeProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypePropertyUndefined: Self = StObject.set(x, "ObjectTypeProperty", js.undefined)
      
      inline def setQualifiedTypeIdentifier(value: V): Self = StObject.set(x, "QualifiedTypeIdentifier", value.asInstanceOf[js.Any])
      
      inline def setQualifiedTypeIdentifierUndefined: Self = StObject.set(x, "QualifiedTypeIdentifier", js.undefined)
      
      inline def setStringLiteralTypeAnnotation(value: V): Self = StObject.set(x, "StringLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setStringLiteralTypeAnnotationUndefined: Self = StObject.set(x, "StringLiteralTypeAnnotation", js.undefined)
      
      inline def setStringTypeAnnotation(value: V): Self = StObject.set(x, "StringTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setStringTypeAnnotationUndefined: Self = StObject.set(x, "StringTypeAnnotation", js.undefined)
      
      inline def setThisTypeAnnotation(value: V): Self = StObject.set(x, "ThisTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setThisTypeAnnotationUndefined: Self = StObject.set(x, "ThisTypeAnnotation", js.undefined)
      
      inline def setTupleTypeAnnotation(value: V): Self = StObject.set(x, "TupleTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTupleTypeAnnotationUndefined: Self = StObject.set(x, "TupleTypeAnnotation", js.undefined)
      
      inline def setTypeAlias(value: V): Self = StObject.set(x, "TypeAlias", value.asInstanceOf[js.Any])
      
      inline def setTypeAliasUndefined: Self = StObject.set(x, "TypeAlias", js.undefined)
      
      inline def setTypeAnnotation(value: V): Self = StObject.set(x, "TypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTypeAnnotationUndefined: Self = StObject.set(x, "TypeAnnotation", js.undefined)
      
      inline def setTypeCastExpression(value: V): Self = StObject.set(x, "TypeCastExpression", value.asInstanceOf[js.Any])
      
      inline def setTypeCastExpressionUndefined: Self = StObject.set(x, "TypeCastExpression", js.undefined)
      
      inline def setTypeParameterDeclaration(value: V): Self = StObject.set(x, "TypeParameterDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterDeclarationUndefined: Self = StObject.set(x, "TypeParameterDeclaration", js.undefined)
      
      inline def setTypeParameterInstantiation(value: V): Self = StObject.set(x, "TypeParameterInstantiation", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterInstantiationUndefined: Self = StObject.set(x, "TypeParameterInstantiation", js.undefined)
      
      inline def setTypeofTypeAnnotation(value: V): Self = StObject.set(x, "TypeofTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTypeofTypeAnnotationUndefined: Self = StObject.set(x, "TypeofTypeAnnotation", js.undefined)
      
      inline def setUnionTypeAnnotation(value: V): Self = StObject.set(x, "UnionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setUnionTypeAnnotationUndefined: Self = StObject.set(x, "UnionTypeAnnotation", js.undefined)
      
      inline def setVoidTypeAnnotation(value: V): Self = StObject.set(x, "VoidTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setVoidTypeAnnotationUndefined: Self = StObject.set(x, "VoidTypeAnnotation", js.undefined)
    }
  }
  
  type jsxTypes = JSXAttribute_ | JSXClosingElement_ | JSXElement_ | JSXEmptyExpression_ | JSXExpressionContainer_ | JSXIdentifier_ | JSXMemberExpression_ | JSXNamespacedName_ | JSXOpeningElement_ | JSXSpreadAttribute_ | JSXText_
  
  trait jsxVisitors[V] extends StObject {
    
    var JSXAttribute: js.UndefOr[V] = js.undefined
    
    var JSXClosingElement: js.UndefOr[V] = js.undefined
    
    var JSXElement: js.UndefOr[V] = js.undefined
    
    var JSXEmptyExpression: js.UndefOr[V] = js.undefined
    
    var JSXExpressionContainer: js.UndefOr[V] = js.undefined
    
    var JSXIdentifier: js.UndefOr[V] = js.undefined
    
    var JSXMemberExpression: js.UndefOr[V] = js.undefined
    
    var JSXNamespacedName: js.UndefOr[V] = js.undefined
    
    var JSXOpeningElement: js.UndefOr[V] = js.undefined
    
    var JSXSpreadAttribute: js.UndefOr[V] = js.undefined
    
    var JSXText: js.UndefOr[V] = js.undefined
  }
  object jsxVisitors {
    
    inline def apply[V](): jsxVisitors[V] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[jsxVisitors[V]]
    }
    
    extension [Self <: jsxVisitors[?], V](x: Self & jsxVisitors[V]) {
      
      inline def setJSXAttribute(value: V): Self = StObject.set(x, "JSXAttribute", value.asInstanceOf[js.Any])
      
      inline def setJSXAttributeUndefined: Self = StObject.set(x, "JSXAttribute", js.undefined)
      
      inline def setJSXClosingElement(value: V): Self = StObject.set(x, "JSXClosingElement", value.asInstanceOf[js.Any])
      
      inline def setJSXClosingElementUndefined: Self = StObject.set(x, "JSXClosingElement", js.undefined)
      
      inline def setJSXElement(value: V): Self = StObject.set(x, "JSXElement", value.asInstanceOf[js.Any])
      
      inline def setJSXElementUndefined: Self = StObject.set(x, "JSXElement", js.undefined)
      
      inline def setJSXEmptyExpression(value: V): Self = StObject.set(x, "JSXEmptyExpression", value.asInstanceOf[js.Any])
      
      inline def setJSXEmptyExpressionUndefined: Self = StObject.set(x, "JSXEmptyExpression", js.undefined)
      
      inline def setJSXExpressionContainer(value: V): Self = StObject.set(x, "JSXExpressionContainer", value.asInstanceOf[js.Any])
      
      inline def setJSXExpressionContainerUndefined: Self = StObject.set(x, "JSXExpressionContainer", js.undefined)
      
      inline def setJSXIdentifier(value: V): Self = StObject.set(x, "JSXIdentifier", value.asInstanceOf[js.Any])
      
      inline def setJSXIdentifierUndefined: Self = StObject.set(x, "JSXIdentifier", js.undefined)
      
      inline def setJSXMemberExpression(value: V): Self = StObject.set(x, "JSXMemberExpression", value.asInstanceOf[js.Any])
      
      inline def setJSXMemberExpressionUndefined: Self = StObject.set(x, "JSXMemberExpression", js.undefined)
      
      inline def setJSXNamespacedName(value: V): Self = StObject.set(x, "JSXNamespacedName", value.asInstanceOf[js.Any])
      
      inline def setJSXNamespacedNameUndefined: Self = StObject.set(x, "JSXNamespacedName", js.undefined)
      
      inline def setJSXOpeningElement(value: V): Self = StObject.set(x, "JSXOpeningElement", value.asInstanceOf[js.Any])
      
      inline def setJSXOpeningElementUndefined: Self = StObject.set(x, "JSXOpeningElement", js.undefined)
      
      inline def setJSXSpreadAttribute(value: V): Self = StObject.set(x, "JSXSpreadAttribute", value.asInstanceOf[js.Any])
      
      inline def setJSXSpreadAttributeUndefined: Self = StObject.set(x, "JSXSpreadAttribute", js.undefined)
      
      inline def setJSXText(value: V): Self = StObject.set(x, "JSXText", value.asInstanceOf[js.Any])
      
      inline def setJSXTextUndefined: Self = StObject.set(x, "JSXText", js.undefined)
    }
  }
  
  type miscTypes = Noop_ | ParenthesizedExpression_
  
  trait miscVisitors[V] extends StObject {
    
    var Noop: js.UndefOr[V] = js.undefined
    
    var ParenthesizedExpression: js.UndefOr[V] = js.undefined
  }
  object miscVisitors {
    
    inline def apply[V](): miscVisitors[V] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[miscVisitors[V]]
    }
    
    extension [Self <: miscVisitors[?], V](x: Self & miscVisitors[V]) {
      
      inline def setNoop(value: V): Self = StObject.set(x, "Noop", value.asInstanceOf[js.Any])
      
      inline def setNoopUndefined: Self = StObject.set(x, "Noop", js.undefined)
      
      inline def setParenthesizedExpression(value: V): Self = StObject.set(x, "ParenthesizedExpression", value.asInstanceOf[js.Any])
      
      inline def setParenthesizedExpressionUndefined: Self = StObject.set(x, "ParenthesizedExpression", js.undefined)
    }
  }
  
  trait visitors[V]
    extends StObject
       with coreVisitors[V]
       with es2015Visitors[V]
       with flowVisitors[V]
       with jsxVisitors[V]
       with miscVisitors[V]
  object visitors {
    
    inline def apply[V](): visitors[V] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[visitors[V]]
    }
  }
}
