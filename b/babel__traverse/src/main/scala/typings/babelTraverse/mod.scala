package typings.babelTraverse

import org.scalablytyped.runtime.Instantiable1
import org.scalablytyped.runtime.StringDictionary
import org.scalablytyped.runtime.TopLevel
import typings.babelTraverse.anon.Confident
import typings.babelTraverse.anon.Container
import typings.babelTraverse.anon.Existing
import typings.babelTraverse.anon.FnCall
import typings.babelTraverse.anon.Id
import typings.babelTraverse.anon.Type
import typings.babelTraverse.anon.Typeofvisitors
import typings.babelTraverse.anon.`0`
import typings.babelTraverse.anon.`100`
import typings.babelTraverse.anon.`101`
import typings.babelTraverse.anon.`102`
import typings.babelTraverse.anon.`103`
import typings.babelTraverse.anon.`104`
import typings.babelTraverse.anon.`105`
import typings.babelTraverse.anon.`106`
import typings.babelTraverse.anon.`107`
import typings.babelTraverse.anon.`108`
import typings.babelTraverse.anon.`109`
import typings.babelTraverse.anon.`10`
import typings.babelTraverse.anon.`110`
import typings.babelTraverse.anon.`111`
import typings.babelTraverse.anon.`112`
import typings.babelTraverse.anon.`113`
import typings.babelTraverse.anon.`114`
import typings.babelTraverse.anon.`115`
import typings.babelTraverse.anon.`116`
import typings.babelTraverse.anon.`117`
import typings.babelTraverse.anon.`118`
import typings.babelTraverse.anon.`119`
import typings.babelTraverse.anon.`11`
import typings.babelTraverse.anon.`120`
import typings.babelTraverse.anon.`121`
import typings.babelTraverse.anon.`122`
import typings.babelTraverse.anon.`123`
import typings.babelTraverse.anon.`124`
import typings.babelTraverse.anon.`125`
import typings.babelTraverse.anon.`126`
import typings.babelTraverse.anon.`127`
import typings.babelTraverse.anon.`128`
import typings.babelTraverse.anon.`129`
import typings.babelTraverse.anon.`12`
import typings.babelTraverse.anon.`130`
import typings.babelTraverse.anon.`131`
import typings.babelTraverse.anon.`132`
import typings.babelTraverse.anon.`133`
import typings.babelTraverse.anon.`134`
import typings.babelTraverse.anon.`135`
import typings.babelTraverse.anon.`136`
import typings.babelTraverse.anon.`137`
import typings.babelTraverse.anon.`138`
import typings.babelTraverse.anon.`139`
import typings.babelTraverse.anon.`13`
import typings.babelTraverse.anon.`140`
import typings.babelTraverse.anon.`141`
import typings.babelTraverse.anon.`142`
import typings.babelTraverse.anon.`143`
import typings.babelTraverse.anon.`144`
import typings.babelTraverse.anon.`145`
import typings.babelTraverse.anon.`146`
import typings.babelTraverse.anon.`147`
import typings.babelTraverse.anon.`148`
import typings.babelTraverse.anon.`149`
import typings.babelTraverse.anon.`14`
import typings.babelTraverse.anon.`150`
import typings.babelTraverse.anon.`151`
import typings.babelTraverse.anon.`152`
import typings.babelTraverse.anon.`153`
import typings.babelTraverse.anon.`154`
import typings.babelTraverse.anon.`155`
import typings.babelTraverse.anon.`156`
import typings.babelTraverse.anon.`157`
import typings.babelTraverse.anon.`158`
import typings.babelTraverse.anon.`159`
import typings.babelTraverse.anon.`15`
import typings.babelTraverse.anon.`160`
import typings.babelTraverse.anon.`161`
import typings.babelTraverse.anon.`162`
import typings.babelTraverse.anon.`163`
import typings.babelTraverse.anon.`164`
import typings.babelTraverse.anon.`165`
import typings.babelTraverse.anon.`166`
import typings.babelTraverse.anon.`167`
import typings.babelTraverse.anon.`168`
import typings.babelTraverse.anon.`169`
import typings.babelTraverse.anon.`16`
import typings.babelTraverse.anon.`170`
import typings.babelTraverse.anon.`171`
import typings.babelTraverse.anon.`172`
import typings.babelTraverse.anon.`173`
import typings.babelTraverse.anon.`174`
import typings.babelTraverse.anon.`175`
import typings.babelTraverse.anon.`176`
import typings.babelTraverse.anon.`177`
import typings.babelTraverse.anon.`178`
import typings.babelTraverse.anon.`179`
import typings.babelTraverse.anon.`17`
import typings.babelTraverse.anon.`180`
import typings.babelTraverse.anon.`181`
import typings.babelTraverse.anon.`182`
import typings.babelTraverse.anon.`183`
import typings.babelTraverse.anon.`184`
import typings.babelTraverse.anon.`185`
import typings.babelTraverse.anon.`186`
import typings.babelTraverse.anon.`187`
import typings.babelTraverse.anon.`188`
import typings.babelTraverse.anon.`189`
import typings.babelTraverse.anon.`18`
import typings.babelTraverse.anon.`190`
import typings.babelTraverse.anon.`191`
import typings.babelTraverse.anon.`192`
import typings.babelTraverse.anon.`193`
import typings.babelTraverse.anon.`194`
import typings.babelTraverse.anon.`195`
import typings.babelTraverse.anon.`196`
import typings.babelTraverse.anon.`197`
import typings.babelTraverse.anon.`198`
import typings.babelTraverse.anon.`199`
import typings.babelTraverse.anon.`19`
import typings.babelTraverse.anon.`1`
import typings.babelTraverse.anon.`200`
import typings.babelTraverse.anon.`201`
import typings.babelTraverse.anon.`202`
import typings.babelTraverse.anon.`203`
import typings.babelTraverse.anon.`204`
import typings.babelTraverse.anon.`205`
import typings.babelTraverse.anon.`206`
import typings.babelTraverse.anon.`207`
import typings.babelTraverse.anon.`208`
import typings.babelTraverse.anon.`209`
import typings.babelTraverse.anon.`20`
import typings.babelTraverse.anon.`210`
import typings.babelTraverse.anon.`211`
import typings.babelTraverse.anon.`212`
import typings.babelTraverse.anon.`213`
import typings.babelTraverse.anon.`214`
import typings.babelTraverse.anon.`215`
import typings.babelTraverse.anon.`216`
import typings.babelTraverse.anon.`217`
import typings.babelTraverse.anon.`218`
import typings.babelTraverse.anon.`219`
import typings.babelTraverse.anon.`21`
import typings.babelTraverse.anon.`220`
import typings.babelTraverse.anon.`221`
import typings.babelTraverse.anon.`222`
import typings.babelTraverse.anon.`223`
import typings.babelTraverse.anon.`224`
import typings.babelTraverse.anon.`225`
import typings.babelTraverse.anon.`226`
import typings.babelTraverse.anon.`227`
import typings.babelTraverse.anon.`228`
import typings.babelTraverse.anon.`229`
import typings.babelTraverse.anon.`22`
import typings.babelTraverse.anon.`230`
import typings.babelTraverse.anon.`231`
import typings.babelTraverse.anon.`232`
import typings.babelTraverse.anon.`233`
import typings.babelTraverse.anon.`234`
import typings.babelTraverse.anon.`235`
import typings.babelTraverse.anon.`236`
import typings.babelTraverse.anon.`237`
import typings.babelTraverse.anon.`238`
import typings.babelTraverse.anon.`239`
import typings.babelTraverse.anon.`23`
import typings.babelTraverse.anon.`240`
import typings.babelTraverse.anon.`24`
import typings.babelTraverse.anon.`25`
import typings.babelTraverse.anon.`26`
import typings.babelTraverse.anon.`27`
import typings.babelTraverse.anon.`28`
import typings.babelTraverse.anon.`29`
import typings.babelTraverse.anon.`2`
import typings.babelTraverse.anon.`30`
import typings.babelTraverse.anon.`31`
import typings.babelTraverse.anon.`32`
import typings.babelTraverse.anon.`33`
import typings.babelTraverse.anon.`34`
import typings.babelTraverse.anon.`35`
import typings.babelTraverse.anon.`36`
import typings.babelTraverse.anon.`37`
import typings.babelTraverse.anon.`38`
import typings.babelTraverse.anon.`39`
import typings.babelTraverse.anon.`3`
import typings.babelTraverse.anon.`40`
import typings.babelTraverse.anon.`41`
import typings.babelTraverse.anon.`42`
import typings.babelTraverse.anon.`43`
import typings.babelTraverse.anon.`44`
import typings.babelTraverse.anon.`45`
import typings.babelTraverse.anon.`46`
import typings.babelTraverse.anon.`47`
import typings.babelTraverse.anon.`48`
import typings.babelTraverse.anon.`49`
import typings.babelTraverse.anon.`4`
import typings.babelTraverse.anon.`50`
import typings.babelTraverse.anon.`51`
import typings.babelTraverse.anon.`52`
import typings.babelTraverse.anon.`53`
import typings.babelTraverse.anon.`54`
import typings.babelTraverse.anon.`55`
import typings.babelTraverse.anon.`56`
import typings.babelTraverse.anon.`57`
import typings.babelTraverse.anon.`58`
import typings.babelTraverse.anon.`59`
import typings.babelTraverse.anon.`5`
import typings.babelTraverse.anon.`60`
import typings.babelTraverse.anon.`61`
import typings.babelTraverse.anon.`62`
import typings.babelTraverse.anon.`63`
import typings.babelTraverse.anon.`64`
import typings.babelTraverse.anon.`65`
import typings.babelTraverse.anon.`66`
import typings.babelTraverse.anon.`67`
import typings.babelTraverse.anon.`68`
import typings.babelTraverse.anon.`69`
import typings.babelTraverse.anon.`6`
import typings.babelTraverse.anon.`70`
import typings.babelTraverse.anon.`71`
import typings.babelTraverse.anon.`72`
import typings.babelTraverse.anon.`73`
import typings.babelTraverse.anon.`74`
import typings.babelTraverse.anon.`75`
import typings.babelTraverse.anon.`76`
import typings.babelTraverse.anon.`77`
import typings.babelTraverse.anon.`78`
import typings.babelTraverse.anon.`79`
import typings.babelTraverse.anon.`7`
import typings.babelTraverse.anon.`80`
import typings.babelTraverse.anon.`81`
import typings.babelTraverse.anon.`82`
import typings.babelTraverse.anon.`83`
import typings.babelTraverse.anon.`84`
import typings.babelTraverse.anon.`85`
import typings.babelTraverse.anon.`86`
import typings.babelTraverse.anon.`87`
import typings.babelTraverse.anon.`88`
import typings.babelTraverse.anon.`89`
import typings.babelTraverse.anon.`8`
import typings.babelTraverse.anon.`90`
import typings.babelTraverse.anon.`91`
import typings.babelTraverse.anon.`92`
import typings.babelTraverse.anon.`93`
import typings.babelTraverse.anon.`94`
import typings.babelTraverse.anon.`95`
import typings.babelTraverse.anon.`96`
import typings.babelTraverse.anon.`97`
import typings.babelTraverse.anon.`98`
import typings.babelTraverse.anon.`99`
import typings.babelTraverse.anon.`9`
import typings.babelTraverse.babelTraverseStrings.`var`
import typings.babelTraverse.babelTraverseStrings.const
import typings.babelTraverse.babelTraverseStrings.let
import typings.babelTraverse.babelTraverseStrings.module
import typings.babelTypes.mod.Binary
import typings.babelTypes.mod.Block
import typings.babelTypes.mod.BlockParent
import typings.babelTypes.mod.Class
import typings.babelTypes.mod.CompletionStatement
import typings.babelTypes.mod.Conditional
import typings.babelTypes.mod.Declaration
import typings.babelTypes.mod.EnumBody
import typings.babelTypes.mod.EnumMember
import typings.babelTypes.mod.ExportDeclaration
import typings.babelTypes.mod.Expression
import typings.babelTypes.mod.ExpressionWrapper
import typings.babelTypes.mod.Flow
import typings.babelTypes.mod.FlowBaseAnnotation
import typings.babelTypes.mod.FlowDeclaration
import typings.babelTypes.mod.FlowPredicate
import typings.babelTypes.mod.FlowType
import typings.babelTypes.mod.For
import typings.babelTypes.mod.ForXStatement
import typings.babelTypes.mod.Function
import typings.babelTypes.mod.FunctionParent
import typings.babelTypes.mod.Identifier_
import typings.babelTypes.mod.Immutable
import typings.babelTypes.mod.JSX
import typings.babelTypes.mod.LVal
import typings.babelTypes.mod.Literal
import typings.babelTypes.mod.Loop
import typings.babelTypes.mod.Method
import typings.babelTypes.mod.ModuleDeclaration
import typings.babelTypes.mod.ModuleSpecifier
import typings.babelTypes.mod.Node
import typings.babelTypes.mod.ObjectMember
import typings.babelTypes.mod.Pattern
import typings.babelTypes.mod.PatternLike
import typings.babelTypes.mod.Private
import typings.babelTypes.mod.Property
import typings.babelTypes.mod.Pureish
import typings.babelTypes.mod.Scopable
import typings.babelTypes.mod.Statement
import typings.babelTypes.mod.TSBaseType
import typings.babelTypes.mod.TSEntityName
import typings.babelTypes.mod.TSType
import typings.babelTypes.mod.TSTypeElement
import typings.babelTypes.mod.Terminatorless
import typings.babelTypes.mod.UnaryLike
import typings.babelTypes.mod.UserWhitespacable
import typings.babelTypes.mod.While
import typings.std.Error
import typings.std.Extract
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  object default {
    
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply(
      parent: js.UndefOr[Node | js.Array[Node] | Null],
      opts: js.UndefOr[TraverseOptions[Node]],
      scope: js.UndefOr[Scope],
      state: js.UndefOr[js.Any],
      parentPath: js.UndefOr[NodePath[Node]]
    ): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply[S](parent: js.UndefOr[Node], opts: TraverseOptions[S], scope: js.UndefOr[scala.Nothing], state: S): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply[S](
      parent: js.UndefOr[Node],
      opts: TraverseOptions[S],
      scope: js.UndefOr[scala.Nothing],
      state: S,
      parentPath: NodePath[Node]
    ): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply[S](parent: js.UndefOr[Node], opts: TraverseOptions[S], scope: Scope, state: S): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply[S](
      parent: js.UndefOr[Node],
      opts: TraverseOptions[S],
      scope: Scope,
      state: S,
      parentPath: NodePath[Node]
    ): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply[S](parent: js.Array[Node], opts: TraverseOptions[S], scope: js.UndefOr[scala.Nothing], state: S): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply[S](
      parent: js.Array[Node],
      opts: TraverseOptions[S],
      scope: js.UndefOr[scala.Nothing],
      state: S,
      parentPath: NodePath[Node]
    ): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply[S](parent: js.Array[Node], opts: TraverseOptions[S], scope: Scope, state: S): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply[S](
      parent: js.Array[Node],
      opts: TraverseOptions[S],
      scope: Scope,
      state: S,
      parentPath: NodePath[Node]
    ): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply[S](parent: Null, opts: TraverseOptions[S], scope: js.UndefOr[scala.Nothing], state: S): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply[S](
      parent: Null,
      opts: TraverseOptions[S],
      scope: js.UndefOr[scala.Nothing],
      state: S,
      parentPath: NodePath[Node]
    ): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply[S](parent: Null, opts: TraverseOptions[S], scope: Scope, state: S): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    def apply[S](parent: Null, opts: TraverseOptions[S], scope: Scope, state: S, parentPath: NodePath[Node]): Unit = js.native
    @JSImport("@babel/traverse", JSImport.Default)
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("@babel/traverse", "default.explode")
    @js.native
    def explode: FnCall = js.native
    @JSImport("@babel/traverse", "default.explode")
    @js.native
    def explode[S](visitor: Visitor[S]): /* import warning: importer.ImportType#apply c Unsupported type mapping: 
    {[ Type in 'AnyTypeAnnotation' | 'ArgumentPlaceholder' | 'ArrayExpression' | 'ArrayPattern' | 'ArrayTypeAnnotation' | 'ArrowFunctionExpression' | 'AssignmentExpression' | 'AssignmentPattern' | 'AwaitExpression' | 'BigIntLiteral' | 'BinaryExpression' | 'LogicalExpression' | 'BindExpression' | 'BlockStatement' | 'Program' | 'TSModuleBlock' | 'CatchClause' | 'DoWhileStatement' | 'ForInStatement' | 'ForStatement' | 'FunctionDeclaration' | 'FunctionExpression' | 'ObjectMethod' | 'SwitchStatement' | 'WhileStatement' | 'ForOfStatement' | 'ClassMethod' | 'ClassPrivateMethod' | 'StaticBlock' | 'BooleanLiteral' | 'BooleanLiteralTypeAnnotation' | 'BooleanTypeAnnotation' | 'BreakStatement' | 'CallExpression' | 'ClassExpression' | 'ClassDeclaration' | 'ClassBody' | 'ClassImplements' | 'ClassPrivateProperty' | 'ClassProperty' | 'ContinueStatement' | 'ReturnStatement' | 'ThrowStatement' | 'ConditionalExpression' | 'IfStatement' | 'DebuggerStatement' | 'DecimalLiteral' | 'VariableDeclaration' | 'ExportAllDeclaration' | 'ExportDefaultDeclaration' | 'ExportNamedDeclaration' | 'ImportDeclaration' | 'DeclareClass' | 'DeclareFunction' | 'DeclareInterface' | 'DeclareModule' | 'DeclareModuleExports' | 'DeclareTypeAlias' | 'DeclareOpaqueType' | 'DeclareVariable' | 'DeclareExportDeclaration' | 'DeclareExportAllDeclaration' | 'InterfaceDeclaration' | 'OpaqueType' | 'TypeAlias' | 'EnumDeclaration' | 'TSDeclareFunction' | 'TSInterfaceDeclaration' | 'TSTypeAliasDeclaration' | 'TSEnumDeclaration' | 'TSModuleDeclaration' | 'DeclaredPredicate' | 'Decorator' | 'Directive' | 'DirectiveLiteral' | 'DoExpression' | 'EmptyStatement' | 'EmptyTypeAnnotation' | 'EnumBooleanBody' | 'EnumNumberBody' | 'EnumStringBody' | 'EnumSymbolBody' | 'EnumBooleanMember' | 'EnumDefaultedMember' | 'EnumNumberMember' | 'EnumStringMember' | 'ExistsTypeAnnotation' | 'ExportDefaultSpecifier' | 'ExportNamespaceSpecifier' | 'ExportSpecifier' | 'Identifier' | 'StringLiteral' | 'NumericLiteral' | 'NullLiteral' | 'RegExpLiteral' | 'MemberExpression' | 'NewExpression' | 'ObjectExpression' | 'SequenceExpression' | 'ParenthesizedExpression' | 'ThisExpression' | 'UnaryExpression' | 'UpdateExpression' | 'MetaProperty' | 'Super' | 'TaggedTemplateExpression' | 'TemplateLiteral' | 'YieldExpression' | 'Import' | 'OptionalMemberExpression' | 'OptionalCallExpression' | 'TypeCastExpression' | 'JSXElement' | 'JSXFragment' | 'PipelinePrimaryTopicReference' | 'RecordExpression' | 'TupleExpression' | 'TSAsExpression' | 'TSTypeAssertion' | 'TSNonNullExpression' | 'ExpressionStatement' | 'File' | 'NullLiteralTypeAnnotation' | 'FunctionTypeAnnotation' | 'FunctionTypeParam' | 'GenericTypeAnnotation' | 'InferredPredicate' | 'InterfaceExtends' | 'InterfaceTypeAnnotation' | 'IntersectionTypeAnnotation' | 'MixedTypeAnnotation' | 'NullableTypeAnnotation' | 'NumberLiteralTypeAnnotation' | 'NumberTypeAnnotation' | 'ObjectTypeAnnotation' | 'ObjectTypeInternalSlot' | 'ObjectTypeCallProperty' | 'ObjectTypeIndexer' | 'ObjectTypeProperty' | 'ObjectTypeSpreadProperty' | 'QualifiedTypeIdentifier' | 'StringLiteralTypeAnnotation' | 'StringTypeAnnotation' | 'SymbolTypeAnnotation' | 'ThisTypeAnnotation' | 'TupleTypeAnnotation' | 'TypeofTypeAnnotation' | 'TypeAnnotation' | 'TypeParameter' | 'TypeParameterDeclaration' | 'TypeParameterInstantiation' | 'UnionTypeAnnotation' | 'Variance' | 'VoidTypeAnnotation' | 'JSXAttribute' | 'JSXClosingElement' | 'JSXExpressionContainer' | 'JSXSpreadChild' | 'JSXOpeningElement' | 'JSXText' | 'JSXOpeningFragment' | 'JSXClosingFragment' | 'ImportAttribute' | 'ImportDefaultSpecifier' | 'ImportNamespaceSpecifier' | 'ImportSpecifier' | 'InterpreterDirective' | 'JSXEmptyExpression' | 'JSXIdentifier' | 'JSXMemberExpression' | 'JSXNamespacedName' | 'JSXSpreadAttribute' | 'RestElement' | 'ObjectPattern' | 'TSParameterProperty' | 'LabeledStatement' | 'Noop' | 'ObjectProperty' | 'PipelineBareFunction' | 'PipelineTopicExpression' | 'Placeholder' | 'PrivateName' | 'SpreadElement' | 'TryStatement' | 'WithStatement' | 'TSImportEqualsDeclaration' | 'TSExportAssignment' | 'TSNamespaceExportDeclaration' | 'SwitchCase' | 'TSAnyKeyword' | 'TSArrayType' | 'TSBooleanKeyword' | 'TSBigIntKeyword' | 'TSIntrinsicKeyword' | 'TSNeverKeyword' | 'TSNullKeyword' | 'TSNumberKeyword' | 'TSObjectKeyword' | 'TSStringKeyword' | 'TSSymbolKeyword' | 'TSUndefinedKeyword' | 'TSUnknownKeyword' | 'TSVoidKeyword' | 'TSThisType' | 'TSLiteralType' | 'TSCallSignatureDeclaration' | 'TSConditionalType' | 'TSConstructSignatureDeclaration' | 'TSConstructorType' | 'TSDeclareMethod' | 'TSQualifiedName' | 'TSEnumMember' | 'TSExpressionWithTypeArguments' | 'TSExternalModuleReference' | 'TSFunctionType' | 'TSImportType' | 'TSIndexSignature' | 'TSIndexedAccessType' | 'TSInferType' | 'TSInterfaceBody' | 'TSIntersectionType' | 'TSMappedType' | 'TSMethodSignature' | 'TSNamedTupleMember' | 'TSOptionalType' | 'TSParenthesizedType' | 'TSPropertySignature' | 'TSRestType' | 'TSTupleType' | 'TSTypeReference' | 'TSTypePredicate' | 'TSTypeQuery' | 'TSTypeLiteral' | 'TSUnionType' | 'TSTypeOperator' | 'TSTypeAnnotation' | 'TSTypeParameter' | 'TSTypeParameterDeclaration' | 'TSTypeParameterInstantiation' | 'TemplateElement' | 'V8IntrinsicIdentifier' | 'VariableDeclarator' ]:? @babel/traverse.@babel/traverse.VisitNodeObject<S, std.Extract<@babel/types.@babel/types.Node, {  type :Type}>>}
      */ typings.babelTraverse.babelTraverseStrings.explode with TopLevel[js.Any] = js.native
    @scala.inline
    def explode_=(x: FnCall): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("explode")(x.asInstanceOf[js.Any])
    
    @JSImport("@babel/traverse", "default.verify")
    @js.native
    def verify: js.Function1[/* visitor */ Visitor[js.Object], Unit] = js.native
    @JSImport("@babel/traverse", "default.verify")
    @js.native
    def verify(visitor: Visitor[js.Object]): Unit = js.native
    @scala.inline
    def verify_=(x: js.Function1[/* visitor */ Visitor[js.Object], Unit]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("verify")(x.asInstanceOf[js.Any])
    
    @JSImport("@babel/traverse", "default.visitors")
    @js.native
    def visitors: Typeofvisitors = js.native
    @scala.inline
    def visitors_=(x: Typeofvisitors): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("visitors")(x.asInstanceOf[js.Any])
  }
  
  @JSImport("@babel/traverse", "Binding")
  @js.native
  class Binding protected () extends StObject {
    def this(opts: Existing) = this()
    
    var constant: Boolean = js.native
    
    var constantViolations: js.Array[NodePath[Node]] = js.native
    
    var identifier: Identifier_ = js.native
    
    var kind: `var` | let | const | module = js.native
    
    var path: NodePath[Node] = js.native
    
    var referencePaths: js.Array[NodePath[Node]] = js.native
    
    var referenced: Boolean = js.native
    
    var references: Double = js.native
    
    var scope: Scope = js.native
  }
  
  @JSImport("@babel/traverse", "Hub")
  @js.native
  class Hub () extends HubInterface
  
  @JSImport("@babel/traverse", "NodePath")
  @js.native
  class NodePath[T] protected () extends StObject {
    def this(hub: Hub, parent: Node) = this()
    
    def addComment(`type`: String, content: String): Unit = js.native
    def addComment(`type`: String, content: String, line: Boolean): Unit = js.native
    
    /** Give node `comments` of the specified `type`. */
    def addComments(`type`: String, comments: js.Array[_]): Unit = js.native
    
    //#endregion
    //#region ------------------------- assertXXX -------------------------
    def assertAnyTypeAnnotation(): Unit = js.native
    def assertAnyTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertArrayExpression(): Unit = js.native
    def assertArrayExpression(props: js.Object): Unit = js.native
    
    def assertArrayPattern(): Unit = js.native
    def assertArrayPattern(props: js.Object): Unit = js.native
    
    def assertArrayTypeAnnotation(): Unit = js.native
    def assertArrayTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertArrowFunctionExpression(): Unit = js.native
    def assertArrowFunctionExpression(props: js.Object): Unit = js.native
    
    def assertAssignmentExpression(): Unit = js.native
    def assertAssignmentExpression(props: js.Object): Unit = js.native
    
    def assertAssignmentPattern(): Unit = js.native
    def assertAssignmentPattern(props: js.Object): Unit = js.native
    
    def assertAwaitExpression(): Unit = js.native
    def assertAwaitExpression(props: js.Object): Unit = js.native
    
    def assertBigIntLiteral(): Unit = js.native
    def assertBigIntLiteral(props: js.Object): Unit = js.native
    
    def assertBinary(): Unit = js.native
    def assertBinary(props: js.Object): Unit = js.native
    
    def assertBinaryExpression(): Unit = js.native
    def assertBinaryExpression(props: js.Object): Unit = js.native
    
    def assertBindExpression(): Unit = js.native
    def assertBindExpression(props: js.Object): Unit = js.native
    
    def assertBindingIdentifier(): Unit = js.native
    def assertBindingIdentifier(props: js.Object): Unit = js.native
    
    def assertBlock(): Unit = js.native
    def assertBlock(props: js.Object): Unit = js.native
    
    def assertBlockParent(): Unit = js.native
    def assertBlockParent(props: js.Object): Unit = js.native
    
    def assertBlockScoped(): Unit = js.native
    def assertBlockScoped(props: js.Object): Unit = js.native
    
    def assertBlockStatement(): Unit = js.native
    def assertBlockStatement(props: js.Object): Unit = js.native
    
    def assertBooleanLiteral(): Unit = js.native
    def assertBooleanLiteral(props: js.Object): Unit = js.native
    
    def assertBooleanLiteralTypeAnnotation(): Unit = js.native
    def assertBooleanLiteralTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertBooleanTypeAnnotation(): Unit = js.native
    def assertBooleanTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertBreakStatement(): Unit = js.native
    def assertBreakStatement(props: js.Object): Unit = js.native
    
    def assertCallExpression(): Unit = js.native
    def assertCallExpression(props: js.Object): Unit = js.native
    
    def assertCatchClause(): Unit = js.native
    def assertCatchClause(props: js.Object): Unit = js.native
    
    def assertClass(): Unit = js.native
    def assertClass(props: js.Object): Unit = js.native
    
    def assertClassBody(): Unit = js.native
    def assertClassBody(props: js.Object): Unit = js.native
    
    def assertClassDeclaration(): Unit = js.native
    def assertClassDeclaration(props: js.Object): Unit = js.native
    
    def assertClassExpression(): Unit = js.native
    def assertClassExpression(props: js.Object): Unit = js.native
    
    def assertClassImplements(): Unit = js.native
    def assertClassImplements(props: js.Object): Unit = js.native
    
    def assertClassMethod(): Unit = js.native
    def assertClassMethod(props: js.Object): Unit = js.native
    
    def assertClassPrivateMethod(): Unit = js.native
    def assertClassPrivateMethod(props: js.Object): Unit = js.native
    
    def assertClassPrivateProperty(): Unit = js.native
    def assertClassPrivateProperty(props: js.Object): Unit = js.native
    
    def assertClassProperty(): Unit = js.native
    def assertClassProperty(props: js.Object): Unit = js.native
    
    def assertCompletionStatement(): Unit = js.native
    def assertCompletionStatement(props: js.Object): Unit = js.native
    
    def assertConditional(): Unit = js.native
    def assertConditional(props: js.Object): Unit = js.native
    
    def assertConditionalExpression(): Unit = js.native
    def assertConditionalExpression(props: js.Object): Unit = js.native
    
    def assertContinueStatement(): Unit = js.native
    def assertContinueStatement(props: js.Object): Unit = js.native
    
    def assertDebuggerStatement(): Unit = js.native
    def assertDebuggerStatement(props: js.Object): Unit = js.native
    
    def assertDeclaration(): Unit = js.native
    def assertDeclaration(props: js.Object): Unit = js.native
    
    def assertDeclareClass(): Unit = js.native
    def assertDeclareClass(props: js.Object): Unit = js.native
    
    def assertDeclareExportAllDeclaration(): Unit = js.native
    def assertDeclareExportAllDeclaration(props: js.Object): Unit = js.native
    
    def assertDeclareExportDeclaration(): Unit = js.native
    def assertDeclareExportDeclaration(props: js.Object): Unit = js.native
    
    def assertDeclareFunction(): Unit = js.native
    def assertDeclareFunction(props: js.Object): Unit = js.native
    
    def assertDeclareInterface(): Unit = js.native
    def assertDeclareInterface(props: js.Object): Unit = js.native
    
    def assertDeclareModule(): Unit = js.native
    def assertDeclareModule(props: js.Object): Unit = js.native
    
    def assertDeclareModuleExports(): Unit = js.native
    def assertDeclareModuleExports(props: js.Object): Unit = js.native
    
    def assertDeclareOpaqueType(): Unit = js.native
    def assertDeclareOpaqueType(props: js.Object): Unit = js.native
    
    def assertDeclareTypeAlias(): Unit = js.native
    def assertDeclareTypeAlias(props: js.Object): Unit = js.native
    
    def assertDeclareVariable(): Unit = js.native
    def assertDeclareVariable(props: js.Object): Unit = js.native
    
    def assertDeclaredPredicate(): Unit = js.native
    def assertDeclaredPredicate(props: js.Object): Unit = js.native
    
    def assertDecorator(): Unit = js.native
    def assertDecorator(props: js.Object): Unit = js.native
    
    def assertDirective(): Unit = js.native
    def assertDirective(props: js.Object): Unit = js.native
    
    def assertDirectiveLiteral(): Unit = js.native
    def assertDirectiveLiteral(props: js.Object): Unit = js.native
    
    def assertDoExpression(): Unit = js.native
    def assertDoExpression(props: js.Object): Unit = js.native
    
    def assertDoWhileStatement(): Unit = js.native
    def assertDoWhileStatement(props: js.Object): Unit = js.native
    
    def assertEmptyStatement(): Unit = js.native
    def assertEmptyStatement(props: js.Object): Unit = js.native
    
    def assertEmptyTypeAnnotation(): Unit = js.native
    def assertEmptyTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertExistsTypeAnnotation(): Unit = js.native
    def assertExistsTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertExportAllDeclaration(): Unit = js.native
    def assertExportAllDeclaration(props: js.Object): Unit = js.native
    
    def assertExportDeclaration(): Unit = js.native
    def assertExportDeclaration(props: js.Object): Unit = js.native
    
    def assertExportDefaultDeclaration(): Unit = js.native
    def assertExportDefaultDeclaration(props: js.Object): Unit = js.native
    
    def assertExportDefaultSpecifier(): Unit = js.native
    def assertExportDefaultSpecifier(props: js.Object): Unit = js.native
    
    def assertExportNamedDeclaration(): Unit = js.native
    def assertExportNamedDeclaration(props: js.Object): Unit = js.native
    
    def assertExportNamespaceSpecifier(): Unit = js.native
    def assertExportNamespaceSpecifier(props: js.Object): Unit = js.native
    
    def assertExportSpecifier(): Unit = js.native
    def assertExportSpecifier(props: js.Object): Unit = js.native
    
    def assertExpression(): Unit = js.native
    def assertExpression(props: js.Object): Unit = js.native
    
    def assertExpressionStatement(): Unit = js.native
    def assertExpressionStatement(props: js.Object): Unit = js.native
    
    def assertExpressionWrapper(): Unit = js.native
    def assertExpressionWrapper(props: js.Object): Unit = js.native
    
    def assertFile(): Unit = js.native
    def assertFile(props: js.Object): Unit = js.native
    
    def assertFlow(): Unit = js.native
    def assertFlow(props: js.Object): Unit = js.native
    
    def assertFlowBaseAnnotation(): Unit = js.native
    def assertFlowBaseAnnotation(props: js.Object): Unit = js.native
    
    def assertFlowDeclaration(): Unit = js.native
    def assertFlowDeclaration(props: js.Object): Unit = js.native
    
    def assertFlowPredicate(): Unit = js.native
    def assertFlowPredicate(props: js.Object): Unit = js.native
    
    def assertFlowType(): Unit = js.native
    def assertFlowType(props: js.Object): Unit = js.native
    
    def assertFor(): Unit = js.native
    def assertFor(props: js.Object): Unit = js.native
    
    def assertForInStatement(): Unit = js.native
    def assertForInStatement(props: js.Object): Unit = js.native
    
    def assertForOfStatement(): Unit = js.native
    def assertForOfStatement(props: js.Object): Unit = js.native
    
    def assertForStatement(): Unit = js.native
    def assertForStatement(props: js.Object): Unit = js.native
    
    def assertForXStatement(): Unit = js.native
    def assertForXStatement(props: js.Object): Unit = js.native
    
    def assertFunction(): Unit = js.native
    def assertFunction(props: js.Object): Unit = js.native
    
    def assertFunctionDeclaration(): Unit = js.native
    def assertFunctionDeclaration(props: js.Object): Unit = js.native
    
    def assertFunctionExpression(): Unit = js.native
    def assertFunctionExpression(props: js.Object): Unit = js.native
    
    def assertFunctionParent(): Unit = js.native
    def assertFunctionParent(props: js.Object): Unit = js.native
    
    def assertFunctionTypeAnnotation(): Unit = js.native
    def assertFunctionTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertFunctionTypeParam(): Unit = js.native
    def assertFunctionTypeParam(props: js.Object): Unit = js.native
    
    def assertGenerated(): Unit = js.native
    def assertGenerated(props: js.Object): Unit = js.native
    
    def assertGenericTypeAnnotation(): Unit = js.native
    def assertGenericTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertIdentifier(): Unit = js.native
    def assertIdentifier(props: js.Object): Unit = js.native
    
    def assertIfStatement(): Unit = js.native
    def assertIfStatement(props: js.Object): Unit = js.native
    
    def assertImmutable(): Unit = js.native
    def assertImmutable(props: js.Object): Unit = js.native
    
    def assertImport(): Unit = js.native
    def assertImport(props: js.Object): Unit = js.native
    
    def assertImportDeclaration(): Unit = js.native
    def assertImportDeclaration(props: js.Object): Unit = js.native
    
    def assertImportDefaultSpecifier(): Unit = js.native
    def assertImportDefaultSpecifier(props: js.Object): Unit = js.native
    
    def assertImportNamespaceSpecifier(): Unit = js.native
    def assertImportNamespaceSpecifier(props: js.Object): Unit = js.native
    
    def assertImportSpecifier(): Unit = js.native
    def assertImportSpecifier(props: js.Object): Unit = js.native
    
    def assertInferredPredicate(): Unit = js.native
    def assertInferredPredicate(props: js.Object): Unit = js.native
    
    def assertInterfaceDeclaration(): Unit = js.native
    def assertInterfaceDeclaration(props: js.Object): Unit = js.native
    
    def assertInterfaceExtends(): Unit = js.native
    def assertInterfaceExtends(props: js.Object): Unit = js.native
    
    def assertInterfaceTypeAnnotation(): Unit = js.native
    def assertInterfaceTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertInterpreterDirective(): Unit = js.native
    def assertInterpreterDirective(props: js.Object): Unit = js.native
    
    def assertIntersectionTypeAnnotation(): Unit = js.native
    def assertIntersectionTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertJSX(): Unit = js.native
    def assertJSX(props: js.Object): Unit = js.native
    
    def assertJSXAttribute(): Unit = js.native
    def assertJSXAttribute(props: js.Object): Unit = js.native
    
    def assertJSXClosingElement(): Unit = js.native
    def assertJSXClosingElement(props: js.Object): Unit = js.native
    
    def assertJSXClosingFragment(): Unit = js.native
    def assertJSXClosingFragment(props: js.Object): Unit = js.native
    
    def assertJSXElement(): Unit = js.native
    def assertJSXElement(props: js.Object): Unit = js.native
    
    def assertJSXEmptyExpression(): Unit = js.native
    def assertJSXEmptyExpression(props: js.Object): Unit = js.native
    
    def assertJSXExpressionContainer(): Unit = js.native
    def assertJSXExpressionContainer(props: js.Object): Unit = js.native
    
    def assertJSXFragment(): Unit = js.native
    def assertJSXFragment(props: js.Object): Unit = js.native
    
    def assertJSXIdentifier(): Unit = js.native
    def assertJSXIdentifier(props: js.Object): Unit = js.native
    
    def assertJSXMemberExpression(): Unit = js.native
    def assertJSXMemberExpression(props: js.Object): Unit = js.native
    
    def assertJSXNamespacedName(): Unit = js.native
    def assertJSXNamespacedName(props: js.Object): Unit = js.native
    
    def assertJSXOpeningElement(): Unit = js.native
    def assertJSXOpeningElement(props: js.Object): Unit = js.native
    
    def assertJSXOpeningFragment(): Unit = js.native
    def assertJSXOpeningFragment(props: js.Object): Unit = js.native
    
    def assertJSXSpreadAttribute(): Unit = js.native
    def assertJSXSpreadAttribute(props: js.Object): Unit = js.native
    
    def assertJSXSpreadChild(): Unit = js.native
    def assertJSXSpreadChild(props: js.Object): Unit = js.native
    
    def assertJSXText(): Unit = js.native
    def assertJSXText(props: js.Object): Unit = js.native
    
    def assertLVal(): Unit = js.native
    def assertLVal(props: js.Object): Unit = js.native
    
    def assertLabeledStatement(): Unit = js.native
    def assertLabeledStatement(props: js.Object): Unit = js.native
    
    def assertLiteral(): Unit = js.native
    def assertLiteral(props: js.Object): Unit = js.native
    
    def assertLogicalExpression(): Unit = js.native
    def assertLogicalExpression(props: js.Object): Unit = js.native
    
    def assertLoop(): Unit = js.native
    def assertLoop(props: js.Object): Unit = js.native
    
    def assertMemberExpression(): Unit = js.native
    def assertMemberExpression(props: js.Object): Unit = js.native
    
    def assertMetaProperty(): Unit = js.native
    def assertMetaProperty(props: js.Object): Unit = js.native
    
    def assertMethod(): Unit = js.native
    def assertMethod(props: js.Object): Unit = js.native
    
    def assertMixedTypeAnnotation(): Unit = js.native
    def assertMixedTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertModuleDeclaration(): Unit = js.native
    def assertModuleDeclaration(props: js.Object): Unit = js.native
    
    def assertModuleSpecifier(): Unit = js.native
    def assertModuleSpecifier(props: js.Object): Unit = js.native
    
    def assertNewExpression(): Unit = js.native
    def assertNewExpression(props: js.Object): Unit = js.native
    
    def assertNoop(): Unit = js.native
    def assertNoop(props: js.Object): Unit = js.native
    
    def assertNullLiteral(): Unit = js.native
    def assertNullLiteral(props: js.Object): Unit = js.native
    
    def assertNullLiteralTypeAnnotation(): Unit = js.native
    def assertNullLiteralTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertNullableTypeAnnotation(): Unit = js.native
    def assertNullableTypeAnnotation(props: js.Object): Unit = js.native
    
    /** @deprecated Use `assertNumericLiteral` */
    def assertNumberLiteral(): Unit = js.native
    def assertNumberLiteral(props: js.Object): Unit = js.native
    
    def assertNumberLiteralTypeAnnotation(): Unit = js.native
    def assertNumberLiteralTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertNumberTypeAnnotation(): Unit = js.native
    def assertNumberTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertNumericLiteral(): Unit = js.native
    def assertNumericLiteral(props: js.Object): Unit = js.native
    
    def assertObjectExpression(): Unit = js.native
    def assertObjectExpression(props: js.Object): Unit = js.native
    
    def assertObjectMember(): Unit = js.native
    def assertObjectMember(props: js.Object): Unit = js.native
    
    def assertObjectMethod(): Unit = js.native
    def assertObjectMethod(props: js.Object): Unit = js.native
    
    def assertObjectPattern(): Unit = js.native
    def assertObjectPattern(props: js.Object): Unit = js.native
    
    def assertObjectProperty(): Unit = js.native
    def assertObjectProperty(props: js.Object): Unit = js.native
    
    def assertObjectTypeAnnotation(): Unit = js.native
    def assertObjectTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertObjectTypeCallProperty(): Unit = js.native
    def assertObjectTypeCallProperty(props: js.Object): Unit = js.native
    
    def assertObjectTypeIndexer(): Unit = js.native
    def assertObjectTypeIndexer(props: js.Object): Unit = js.native
    
    def assertObjectTypeInternalSlot(): Unit = js.native
    def assertObjectTypeInternalSlot(props: js.Object): Unit = js.native
    
    def assertObjectTypeProperty(): Unit = js.native
    def assertObjectTypeProperty(props: js.Object): Unit = js.native
    
    def assertObjectTypeSpreadProperty(): Unit = js.native
    def assertObjectTypeSpreadProperty(props: js.Object): Unit = js.native
    
    def assertOpaqueType(): Unit = js.native
    def assertOpaqueType(props: js.Object): Unit = js.native
    
    def assertOptionalCallExpression(): Unit = js.native
    def assertOptionalCallExpression(props: js.Object): Unit = js.native
    
    def assertOptionalMemberExpression(): Unit = js.native
    def assertOptionalMemberExpression(props: js.Object): Unit = js.native
    
    def assertParenthesizedExpression(): Unit = js.native
    def assertParenthesizedExpression(props: js.Object): Unit = js.native
    
    def assertPattern(): Unit = js.native
    def assertPattern(props: js.Object): Unit = js.native
    
    def assertPatternLike(): Unit = js.native
    def assertPatternLike(props: js.Object): Unit = js.native
    
    def assertPipelineBareFunction(): Unit = js.native
    def assertPipelineBareFunction(props: js.Object): Unit = js.native
    
    def assertPipelinePrimaryTopicReference(): Unit = js.native
    def assertPipelinePrimaryTopicReference(props: js.Object): Unit = js.native
    
    def assertPipelineTopicExpression(): Unit = js.native
    def assertPipelineTopicExpression(props: js.Object): Unit = js.native
    
    def assertPrivate(): Unit = js.native
    def assertPrivate(props: js.Object): Unit = js.native
    
    def assertPrivateName(): Unit = js.native
    def assertPrivateName(props: js.Object): Unit = js.native
    
    def assertProgram(): Unit = js.native
    def assertProgram(props: js.Object): Unit = js.native
    
    def assertProperty(): Unit = js.native
    def assertProperty(props: js.Object): Unit = js.native
    
    def assertPure(): Unit = js.native
    def assertPure(props: js.Object): Unit = js.native
    
    def assertPureish(): Unit = js.native
    def assertPureish(props: js.Object): Unit = js.native
    
    def assertQualifiedTypeIdentifier(): Unit = js.native
    def assertQualifiedTypeIdentifier(props: js.Object): Unit = js.native
    
    def assertReferenced(): Unit = js.native
    def assertReferenced(props: js.Object): Unit = js.native
    
    def assertReferencedIdentifier(): Unit = js.native
    def assertReferencedIdentifier(props: js.Object): Unit = js.native
    
    def assertReferencedMemberExpression(): Unit = js.native
    def assertReferencedMemberExpression(props: js.Object): Unit = js.native
    
    def assertRegExpLiteral(): Unit = js.native
    def assertRegExpLiteral(props: js.Object): Unit = js.native
    
    /** @deprecated Use `assertRegExpLiteral` */
    def assertRegexLiteral(): Unit = js.native
    def assertRegexLiteral(props: js.Object): Unit = js.native
    
    def assertRestElement(): Unit = js.native
    def assertRestElement(props: js.Object): Unit = js.native
    
    /** @deprecated Use `assertRestElement` */
    def assertRestProperty(): Unit = js.native
    def assertRestProperty(props: js.Object): Unit = js.native
    
    def assertReturnStatement(): Unit = js.native
    def assertReturnStatement(props: js.Object): Unit = js.native
    
    def assertScopable(): Unit = js.native
    def assertScopable(props: js.Object): Unit = js.native
    
    def assertScope(): Unit = js.native
    def assertScope(props: js.Object): Unit = js.native
    
    def assertSequenceExpression(): Unit = js.native
    def assertSequenceExpression(props: js.Object): Unit = js.native
    
    def assertSpreadElement(): Unit = js.native
    def assertSpreadElement(props: js.Object): Unit = js.native
    
    /** @deprecated Use `assertSpreadElement` */
    def assertSpreadProperty(): Unit = js.native
    def assertSpreadProperty(props: js.Object): Unit = js.native
    
    def assertStatement(): Unit = js.native
    def assertStatement(props: js.Object): Unit = js.native
    
    def assertStringLiteral(): Unit = js.native
    def assertStringLiteral(props: js.Object): Unit = js.native
    
    def assertStringLiteralTypeAnnotation(): Unit = js.native
    def assertStringLiteralTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertStringTypeAnnotation(): Unit = js.native
    def assertStringTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertSuper(): Unit = js.native
    def assertSuper(props: js.Object): Unit = js.native
    
    def assertSwitchCase(): Unit = js.native
    def assertSwitchCase(props: js.Object): Unit = js.native
    
    def assertSwitchStatement(): Unit = js.native
    def assertSwitchStatement(props: js.Object): Unit = js.native
    
    def assertTSAnyKeyword(): Unit = js.native
    def assertTSAnyKeyword(props: js.Object): Unit = js.native
    
    def assertTSArrayType(): Unit = js.native
    def assertTSArrayType(props: js.Object): Unit = js.native
    
    def assertTSAsExpression(): Unit = js.native
    def assertTSAsExpression(props: js.Object): Unit = js.native
    
    def assertTSBooleanKeyword(): Unit = js.native
    def assertTSBooleanKeyword(props: js.Object): Unit = js.native
    
    def assertTSCallSignatureDeclaration(): Unit = js.native
    def assertTSCallSignatureDeclaration(props: js.Object): Unit = js.native
    
    def assertTSConditionalType(): Unit = js.native
    def assertTSConditionalType(props: js.Object): Unit = js.native
    
    def assertTSConstructSignatureDeclaration(): Unit = js.native
    def assertTSConstructSignatureDeclaration(props: js.Object): Unit = js.native
    
    def assertTSConstructorType(): Unit = js.native
    def assertTSConstructorType(props: js.Object): Unit = js.native
    
    def assertTSDeclareFunction(): Unit = js.native
    def assertTSDeclareFunction(props: js.Object): Unit = js.native
    
    def assertTSDeclareMethod(): Unit = js.native
    def assertTSDeclareMethod(props: js.Object): Unit = js.native
    
    def assertTSEntityName(): Unit = js.native
    def assertTSEntityName(props: js.Object): Unit = js.native
    
    def assertTSEnumDeclaration(): Unit = js.native
    def assertTSEnumDeclaration(props: js.Object): Unit = js.native
    
    def assertTSEnumMember(): Unit = js.native
    def assertTSEnumMember(props: js.Object): Unit = js.native
    
    def assertTSExportAssignment(): Unit = js.native
    def assertTSExportAssignment(props: js.Object): Unit = js.native
    
    def assertTSExpressionWithTypeArguments(): Unit = js.native
    def assertTSExpressionWithTypeArguments(props: js.Object): Unit = js.native
    
    def assertTSExternalModuleReference(): Unit = js.native
    def assertTSExternalModuleReference(props: js.Object): Unit = js.native
    
    def assertTSFunctionType(): Unit = js.native
    def assertTSFunctionType(props: js.Object): Unit = js.native
    
    def assertTSImportEqualsDeclaration(): Unit = js.native
    def assertTSImportEqualsDeclaration(props: js.Object): Unit = js.native
    
    def assertTSImportType(): Unit = js.native
    def assertTSImportType(props: js.Object): Unit = js.native
    
    def assertTSIndexSignature(): Unit = js.native
    def assertTSIndexSignature(props: js.Object): Unit = js.native
    
    def assertTSIndexedAccessType(): Unit = js.native
    def assertTSIndexedAccessType(props: js.Object): Unit = js.native
    
    def assertTSInferType(): Unit = js.native
    def assertTSInferType(props: js.Object): Unit = js.native
    
    def assertTSInterfaceBody(): Unit = js.native
    def assertTSInterfaceBody(props: js.Object): Unit = js.native
    
    def assertTSInterfaceDeclaration(): Unit = js.native
    def assertTSInterfaceDeclaration(props: js.Object): Unit = js.native
    
    def assertTSIntersectionType(): Unit = js.native
    def assertTSIntersectionType(props: js.Object): Unit = js.native
    
    def assertTSLiteralType(): Unit = js.native
    def assertTSLiteralType(props: js.Object): Unit = js.native
    
    def assertTSMappedType(): Unit = js.native
    def assertTSMappedType(props: js.Object): Unit = js.native
    
    def assertTSMethodSignature(): Unit = js.native
    def assertTSMethodSignature(props: js.Object): Unit = js.native
    
    def assertTSModuleBlock(): Unit = js.native
    def assertTSModuleBlock(props: js.Object): Unit = js.native
    
    def assertTSModuleDeclaration(): Unit = js.native
    def assertTSModuleDeclaration(props: js.Object): Unit = js.native
    
    def assertTSNamespaceExportDeclaration(): Unit = js.native
    def assertTSNamespaceExportDeclaration(props: js.Object): Unit = js.native
    
    def assertTSNeverKeyword(): Unit = js.native
    def assertTSNeverKeyword(props: js.Object): Unit = js.native
    
    def assertTSNonNullExpression(): Unit = js.native
    def assertTSNonNullExpression(props: js.Object): Unit = js.native
    
    def assertTSNullKeyword(): Unit = js.native
    def assertTSNullKeyword(props: js.Object): Unit = js.native
    
    def assertTSNumberKeyword(): Unit = js.native
    def assertTSNumberKeyword(props: js.Object): Unit = js.native
    
    def assertTSObjectKeyword(): Unit = js.native
    def assertTSObjectKeyword(props: js.Object): Unit = js.native
    
    def assertTSOptionalType(): Unit = js.native
    def assertTSOptionalType(props: js.Object): Unit = js.native
    
    def assertTSParameterProperty(): Unit = js.native
    def assertTSParameterProperty(props: js.Object): Unit = js.native
    
    def assertTSParenthesizedType(): Unit = js.native
    def assertTSParenthesizedType(props: js.Object): Unit = js.native
    
    def assertTSPropertySignature(): Unit = js.native
    def assertTSPropertySignature(props: js.Object): Unit = js.native
    
    def assertTSQualifiedName(): Unit = js.native
    def assertTSQualifiedName(props: js.Object): Unit = js.native
    
    def assertTSRestType(): Unit = js.native
    def assertTSRestType(props: js.Object): Unit = js.native
    
    def assertTSStringKeyword(): Unit = js.native
    def assertTSStringKeyword(props: js.Object): Unit = js.native
    
    def assertTSSymbolKeyword(): Unit = js.native
    def assertTSSymbolKeyword(props: js.Object): Unit = js.native
    
    def assertTSThisType(): Unit = js.native
    def assertTSThisType(props: js.Object): Unit = js.native
    
    def assertTSTupleType(): Unit = js.native
    def assertTSTupleType(props: js.Object): Unit = js.native
    
    def assertTSType(): Unit = js.native
    def assertTSType(props: js.Object): Unit = js.native
    
    def assertTSTypeAliasDeclaration(): Unit = js.native
    def assertTSTypeAliasDeclaration(props: js.Object): Unit = js.native
    
    def assertTSTypeAnnotation(): Unit = js.native
    def assertTSTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertTSTypeAssertion(): Unit = js.native
    def assertTSTypeAssertion(props: js.Object): Unit = js.native
    
    def assertTSTypeElement(): Unit = js.native
    def assertTSTypeElement(props: js.Object): Unit = js.native
    
    def assertTSTypeLiteral(): Unit = js.native
    def assertTSTypeLiteral(props: js.Object): Unit = js.native
    
    def assertTSTypeOperator(): Unit = js.native
    def assertTSTypeOperator(props: js.Object): Unit = js.native
    
    def assertTSTypeParameter(): Unit = js.native
    def assertTSTypeParameter(props: js.Object): Unit = js.native
    
    def assertTSTypeParameterDeclaration(): Unit = js.native
    def assertTSTypeParameterDeclaration(props: js.Object): Unit = js.native
    
    def assertTSTypeParameterInstantiation(): Unit = js.native
    def assertTSTypeParameterInstantiation(props: js.Object): Unit = js.native
    
    def assertTSTypePredicate(): Unit = js.native
    def assertTSTypePredicate(props: js.Object): Unit = js.native
    
    def assertTSTypeQuery(): Unit = js.native
    def assertTSTypeQuery(props: js.Object): Unit = js.native
    
    def assertTSTypeReference(): Unit = js.native
    def assertTSTypeReference(props: js.Object): Unit = js.native
    
    def assertTSUndefinedKeyword(): Unit = js.native
    def assertTSUndefinedKeyword(props: js.Object): Unit = js.native
    
    def assertTSUnionType(): Unit = js.native
    def assertTSUnionType(props: js.Object): Unit = js.native
    
    def assertTSUnknownKeyword(): Unit = js.native
    def assertTSUnknownKeyword(props: js.Object): Unit = js.native
    
    def assertTSVoidKeyword(): Unit = js.native
    def assertTSVoidKeyword(props: js.Object): Unit = js.native
    
    def assertTaggedTemplateExpression(): Unit = js.native
    def assertTaggedTemplateExpression(props: js.Object): Unit = js.native
    
    def assertTemplateElement(): Unit = js.native
    def assertTemplateElement(props: js.Object): Unit = js.native
    
    def assertTemplateLiteral(): Unit = js.native
    def assertTemplateLiteral(props: js.Object): Unit = js.native
    
    def assertTerminatorless(): Unit = js.native
    def assertTerminatorless(props: js.Object): Unit = js.native
    
    def assertThisExpression(): Unit = js.native
    def assertThisExpression(props: js.Object): Unit = js.native
    
    def assertThisTypeAnnotation(): Unit = js.native
    def assertThisTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertThrowStatement(): Unit = js.native
    def assertThrowStatement(props: js.Object): Unit = js.native
    
    def assertTryStatement(): Unit = js.native
    def assertTryStatement(props: js.Object): Unit = js.native
    
    def assertTupleTypeAnnotation(): Unit = js.native
    def assertTupleTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertTypeAlias(): Unit = js.native
    def assertTypeAlias(props: js.Object): Unit = js.native
    
    def assertTypeAnnotation(): Unit = js.native
    def assertTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertTypeCastExpression(): Unit = js.native
    def assertTypeCastExpression(props: js.Object): Unit = js.native
    
    def assertTypeParameter(): Unit = js.native
    def assertTypeParameter(props: js.Object): Unit = js.native
    
    def assertTypeParameterDeclaration(): Unit = js.native
    def assertTypeParameterDeclaration(props: js.Object): Unit = js.native
    
    def assertTypeParameterInstantiation(): Unit = js.native
    def assertTypeParameterInstantiation(props: js.Object): Unit = js.native
    
    def assertTypeofTypeAnnotation(): Unit = js.native
    def assertTypeofTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertUnaryExpression(): Unit = js.native
    def assertUnaryExpression(props: js.Object): Unit = js.native
    
    def assertUnaryLike(): Unit = js.native
    def assertUnaryLike(props: js.Object): Unit = js.native
    
    def assertUnionTypeAnnotation(): Unit = js.native
    def assertUnionTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertUpdateExpression(): Unit = js.native
    def assertUpdateExpression(props: js.Object): Unit = js.native
    
    def assertUser(): Unit = js.native
    def assertUser(props: js.Object): Unit = js.native
    
    def assertUserWhitespacable(): Unit = js.native
    def assertUserWhitespacable(props: js.Object): Unit = js.native
    
    def assertVar(): Unit = js.native
    def assertVar(props: js.Object): Unit = js.native
    
    def assertVariableDeclaration(): Unit = js.native
    def assertVariableDeclaration(props: js.Object): Unit = js.native
    
    def assertVariableDeclarator(): Unit = js.native
    def assertVariableDeclarator(props: js.Object): Unit = js.native
    
    def assertVariance(): Unit = js.native
    def assertVariance(props: js.Object): Unit = js.native
    
    def assertVoidTypeAnnotation(): Unit = js.native
    def assertVoidTypeAnnotation(props: js.Object): Unit = js.native
    
    def assertWhile(): Unit = js.native
    def assertWhile(props: js.Object): Unit = js.native
    
    def assertWhileStatement(): Unit = js.native
    def assertWhileStatement(props: js.Object): Unit = js.native
    
    def assertWithStatement(): Unit = js.native
    def assertWithStatement(props: js.Object): Unit = js.native
    
    def assertYieldExpression(): Unit = js.native
    def assertYieldExpression(props: js.Object): Unit = js.native
    
    def baseTypeStrictlyMatches(right: NodePath[Node]): Boolean = js.native
    
    def buildCodeFrameError[TError /* <: Error */](msg: String): TError = js.native
    def buildCodeFrameError[TError /* <: Error */](msg: String, Error: Instantiable1[/* msg */ String, TError]): TError = js.native
    
    //#endregion
    //#region ------------------------- context -------------------------
    def call(key: String): Boolean = js.native
    
    /**
      * This checks whether or not we're in one of the following positions:
      *
      *   for (KEY in right);
      *   for (KEY;;);
      *
      * This is because these spots allow VariableDeclarations AND normal expressions so we need
      * to tell the path replacement that it's ok to replace this with an expression.
      */
    def canHaveVariableDeclarationOrExpression(): Boolean = js.native
    
    /**
      * This checks whether we are swapping an arrow function's body between an
      * expression and a block statement (or vice versa).
      *
      * This is because arrow functions may implicitly return an expression, which
      * is the same as containing a block statement.
      */
    def canSwapBetweenExpressionAndStatement(replacement: Node): Boolean = js.native
    
    var container: js.Object | js.Array[js.Object] = js.native
    
    var context: TraversalContext = js.native
    
    var contexts: js.Array[TraversalContext] = js.native
    
    def couldBeBaseType(name: String): Boolean = js.native
    
    var data: js.Object = js.native
    
    // Example: https://github.com/babel/babel/blob/63204ae51e020d84a5b246312f5eeb4d981ab952/packages/babel-traverse/src/path/modification.js#L83
    def debug(buildMessage: js.Function0[String]): Unit = js.native
    
    /** Check whether the path node `key` strict equals `value`. */
    def equals(key: String, value: js.Any): Boolean = js.native
    
    /**
      * Walk the input `node` and statically evaluate it.
      *
      * Returns an object in the form `{ confident, value }`. `confident` indicates
      * whether or not we had to drop out of evaluating the expression because of
      * hitting an unknown node that we couldn't confidently find the value of.
      *
      * Example:
      *
      *   t.evaluate(parse("5 + 5")) // { confident: true, value: 10 }
      *   t.evaluate(parse("!true")) // { confident: true, value: false }
      *   t.evaluate(parse("foo + foo")) // { confident: false, value: undefined }
      */
    def evaluate(): Confident = js.native
    
    //#endregion
    //#region ------------------------- evaluation -------------------------
    /**
      * Walk the input `node` and statically evaluate if it's truthy.
      *
      * Returning `true` when we're sure that the expression will evaluate to a
      * truthy value, `false` if we're sure that it will evaluate to a falsy
      * value and `undefined` if we aren't sure. Because of this please do not
      * rely on coercion when using this method and check with === if it's false.
      */
    def evaluateTruthy(): Boolean = js.native
    
    /**
      * Starting at current `NodePath` and going up the tree, return the first
      * `NodePath` that causes the provided `callback` to return a truthy value,
      * or `null` if the `callback` never returns a truthy value.
      */
    def find(callback: js.Function1[/* path */ NodePath[Node], Boolean]): NodePath[Node] | Null = js.native
    
    //#region ------------------------- ancestry -------------------------
    /**
      * Starting at the parent path of the current `NodePath` and going up the
      * tree, return the first `NodePath` that causes the provided `callback`
      * to return a truthy value, or `null` if the `callback` never returns a
      * truthy value.
      */
    def findParent(callback: js.Function1[/* path */ NodePath[Node], Boolean]): NodePath[Node] | Null = js.native
    
    def get(key: String): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get(key: String, context: Boolean): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get(key: String, context: TraversalContext): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get[K /* <: /* keyof T */ String */](key: K): (NodePath[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ]) | (js.Array[
        NodePath[
          /* import warning: importer.ImportType#apply Failed type conversion: T[K][number] */ js.Any
        ]
      ]) = js.native
    def get[K /* <: /* keyof T */ String */](key: K, context: Boolean): (NodePath[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ]) | (js.Array[
        NodePath[
          /* import warning: importer.ImportType#apply Failed type conversion: T[K][number] */ js.Any
        ]
      ]) = js.native
    def get[K /* <: /* keyof T */ String */](key: K, context: TraversalContext): (NodePath[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ]) | (js.Array[
        NodePath[
          /* import warning: importer.ImportType#apply Failed type conversion: T[K][number] */ js.Any
        ]
      ]) = js.native
    
    def getAllNextSiblings(): js.Array[NodePath[Node]] = js.native
    
    def getAllPrevSiblings(): js.Array[NodePath[Node]] = js.native
    
    /**
      * Build an array of node paths containing the entire ancestry of the current node path.
      *
      * NOTE: The current node path is included in this.
      */
    def getAncestry(): Array[this.type | NodePath[Node]] = js.native
    
    def getBindingIdentifiers(): js.Array[Node] = js.native
    def getBindingIdentifiers(duplicates: Boolean): js.Array[Node] = js.native
    
    def getCompletionRecords(): js.Array[NodePath[Node]] = js.native
    
    def getData(key: String): js.Any = js.native
    def getData(key: String, `def`: js.Any): js.Any = js.native
    
    /** Get the earliest path in the tree where the provided `paths` intersect. */
    def getDeepestCommonAncestorFrom(paths: js.Array[NodePath[Node]]): NodePath[Node] = js.native
    def getDeepestCommonAncestorFrom(
      paths: js.Array[NodePath[Node]],
      filter: js.Function3[
          /* deepest */ Node, 
          /* i */ Double, 
          /* ancestries */ js.Array[NodePath[Node]], 
          NodePath[Node]
        ]
    ): NodePath[Node] = js.native
    
    /**
      * Get the deepest common ancestor and then from it, get the earliest relationship path
      * to that ancestor.
      *
      * Earliest is defined as being "before" all the other nodes in terms of list container
      * position and visiting key.
      */
    def getEarliestCommonAncestorFrom(paths: js.Array[NodePath[Node]]): NodePath[Node] = js.native
    
    /** Get the parent function of the current path. */
    def getFunctionParent(): NodePath[Function] | Null = js.native
    
    //#endregion
    //#region ------------------------- family -------------------------
    def getOpposite(): NodePath[Node] = js.native
    
    def getOuterBindingIdentifiers(): js.Array[Node] = js.native
    def getOuterBindingIdentifiers(duplicates: Boolean): js.Array[Node] = js.native
    
    def getPathLocation(): String = js.native
    
    def getScope(scope: Scope): Scope = js.native
    
    def getSibling(key: String): NodePath[Node] = js.native
    def getSibling(key: Double): NodePath[Node] = js.native
    
    /** Get the source code associated with this node. */
    def getSource(): String = js.native
    
    /** Walk up the tree until we hit a parent node path in a list. */
    def getStatementParent(): NodePath[Statement] | Null = js.native
    
    //#endregion
    //#region ------------------------- inference -------------------------
    /** Infer the type of the current `NodePath`. */
    def getTypeAnnotation(): FlowType = js.native
    
    /**
      * Check whether we have the input `key`. If the `key` references an array then we check
      * if the array has any items, otherwise we just check if it's falsy.
      */
    def has(key: String): Boolean = js.native
    
    /** Hoist the current node to the highest scope possible and return a UID referencing it. */
    def hoist(scope: Scope): Unit = js.native
    
    var hub: Hub = js.native
    
    var inList: Boolean = js.native
    
    def inType(candidateTypes: String*): Boolean = js.native
    
    /**
      * Insert the provided nodes after the current one. When inserting nodes after an
      * expression, ensure that the completion record is correct by pushing the current node.
      */
    def insertAfter[Nodes /* <: Node | js.Array[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    //#endregion
    //#region ------------------------- modification -------------------------
    /** Insert the provided nodes before the current one. */
    def insertBefore[Nodes /* <: Node | js.Array[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    /** Alias of `has`. */
    def is(key: String): Boolean = js.native
    
    /**
      * A helper to find if `this` path is an ancestor of `maybeDescendant`
      */
    def isAncestor(maybeDescendant: NodePath[Node]): Boolean = js.native
    
    //#endregion
    //#region ------------------------- isXXX -------------------------
    def isAnyTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AnyTypeAnnotation> */ Boolean = js.native
    def isAnyTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AnyTypeAnnotation> */ Boolean = js.native
    
    def isArrayExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayExpression> */ Boolean = js.native
    def isArrayExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayExpression> */ Boolean = js.native
    
    def isArrayPattern(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayPattern> */ Boolean = js.native
    def isArrayPattern(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayPattern> */ Boolean = js.native
    
    def isArrayTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayTypeAnnotation> */ Boolean = js.native
    def isArrayTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrayTypeAnnotation> */ Boolean = js.native
    
    def isArrowFunctionExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrowFunctionExpression> */ Boolean = js.native
    def isArrowFunctionExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ArrowFunctionExpression> */ Boolean = js.native
    
    def isAssignmentExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AssignmentExpression> */ Boolean = js.native
    def isAssignmentExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AssignmentExpression> */ Boolean = js.native
    
    def isAssignmentPattern(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AssignmentPattern> */ Boolean = js.native
    def isAssignmentPattern(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AssignmentPattern> */ Boolean = js.native
    
    def isAwaitExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AwaitExpression> */ Boolean = js.native
    def isAwaitExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.AwaitExpression> */ Boolean = js.native
    
    def isBaseType(baseName: String): Boolean = js.native
    def isBaseType(baseName: String, soft: Boolean): Boolean = js.native
    
    def isBigIntLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BigIntLiteral> */ Boolean = js.native
    def isBigIntLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BigIntLiteral> */ Boolean = js.native
    
    def isBinary(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Binary> */ Boolean = js.native
    def isBinary(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Binary> */ Boolean = js.native
    
    def isBinaryExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BinaryExpression> */ Boolean = js.native
    def isBinaryExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BinaryExpression> */ Boolean = js.native
    
    def isBindExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BindExpression> */ Boolean = js.native
    def isBindExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BindExpression> */ Boolean = js.native
    
    def isBindingIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier> */ Boolean = js.native
    def isBindingIdentifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier> */ Boolean = js.native
    
    def isBlacklisted(): Boolean = js.native
    
    def isBlock(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Block> */ Boolean = js.native
    def isBlock(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Block> */ Boolean = js.native
    
    def isBlockParent(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BlockParent> */ Boolean = js.native
    def isBlockParent(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BlockParent> */ Boolean = js.native
    
    def isBlockScoped(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionDeclaration | @babel/types.@babel/types.ClassDeclaration | @babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    def isBlockScoped(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionDeclaration | @babel/types.@babel/types.ClassDeclaration | @babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    
    def isBlockStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BlockStatement> */ Boolean = js.native
    def isBlockStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BlockStatement> */ Boolean = js.native
    
    def isBooleanLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanLiteral> */ Boolean = js.native
    def isBooleanLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanLiteral> */ Boolean = js.native
    
    def isBooleanLiteralTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanLiteralTypeAnnotation> */ Boolean = js.native
    def isBooleanLiteralTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanLiteralTypeAnnotation> */ Boolean = js.native
    
    def isBooleanTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanTypeAnnotation> */ Boolean = js.native
    def isBooleanTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BooleanTypeAnnotation> */ Boolean = js.native
    
    def isBreakStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BreakStatement> */ Boolean = js.native
    def isBreakStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.BreakStatement> */ Boolean = js.native
    
    def isCallExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CallExpression> */ Boolean = js.native
    def isCallExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CallExpression> */ Boolean = js.native
    
    def isCatchClause(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CatchClause> */ Boolean = js.native
    def isCatchClause(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CatchClause> */ Boolean = js.native
    
    def isClass(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Class> */ Boolean = js.native
    def isClass(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Class> */ Boolean = js.native
    
    def isClassBody(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassBody> */ Boolean = js.native
    def isClassBody(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassBody> */ Boolean = js.native
    
    def isClassDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassDeclaration> */ Boolean = js.native
    def isClassDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassDeclaration> */ Boolean = js.native
    
    def isClassExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassExpression> */ Boolean = js.native
    def isClassExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassExpression> */ Boolean = js.native
    
    def isClassImplements(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassImplements> */ Boolean = js.native
    def isClassImplements(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassImplements> */ Boolean = js.native
    
    def isClassMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassMethod> */ Boolean = js.native
    def isClassMethod(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassMethod> */ Boolean = js.native
    
    def isClassPrivateMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassPrivateMethod> */ Boolean = js.native
    def isClassPrivateMethod(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassPrivateMethod> */ Boolean = js.native
    
    def isClassPrivateProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassPrivateProperty> */ Boolean = js.native
    def isClassPrivateProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassPrivateProperty> */ Boolean = js.native
    
    def isClassProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassProperty> */ Boolean = js.native
    def isClassProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ClassProperty> */ Boolean = js.native
    
    /** Check whether the current path references a completion record */
    def isCompletionRecord(): Boolean = js.native
    def isCompletionRecord(allowInsideFunction: Boolean): Boolean = js.native
    
    def isCompletionStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CompletionStatement> */ Boolean = js.native
    def isCompletionStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.CompletionStatement> */ Boolean = js.native
    
    def isConditional(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Conditional> */ Boolean = js.native
    def isConditional(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Conditional> */ Boolean = js.native
    
    def isConditionalExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ConditionalExpression> */ Boolean = js.native
    def isConditionalExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ConditionalExpression> */ Boolean = js.native
    
    def isContinueStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ContinueStatement> */ Boolean = js.native
    def isContinueStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ContinueStatement> */ Boolean = js.native
    
    def isDebuggerStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DebuggerStatement> */ Boolean = js.native
    def isDebuggerStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DebuggerStatement> */ Boolean = js.native
    
    def isDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Declaration> */ Boolean = js.native
    def isDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Declaration> */ Boolean = js.native
    
    def isDeclareClass(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareClass> */ Boolean = js.native
    def isDeclareClass(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareClass> */ Boolean = js.native
    
    def isDeclareExportAllDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareExportAllDeclaration> */ Boolean = js.native
    def isDeclareExportAllDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareExportAllDeclaration> */ Boolean = js.native
    
    def isDeclareExportDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareExportDeclaration> */ Boolean = js.native
    def isDeclareExportDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareExportDeclaration> */ Boolean = js.native
    
    def isDeclareFunction(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareFunction> */ Boolean = js.native
    def isDeclareFunction(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareFunction> */ Boolean = js.native
    
    def isDeclareInterface(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareInterface> */ Boolean = js.native
    def isDeclareInterface(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareInterface> */ Boolean = js.native
    
    def isDeclareModule(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareModule> */ Boolean = js.native
    def isDeclareModule(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareModule> */ Boolean = js.native
    
    def isDeclareModuleExports(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareModuleExports> */ Boolean = js.native
    def isDeclareModuleExports(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareModuleExports> */ Boolean = js.native
    
    def isDeclareOpaqueType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareOpaqueType> */ Boolean = js.native
    def isDeclareOpaqueType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareOpaqueType> */ Boolean = js.native
    
    def isDeclareTypeAlias(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareTypeAlias> */ Boolean = js.native
    def isDeclareTypeAlias(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareTypeAlias> */ Boolean = js.native
    
    def isDeclareVariable(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareVariable> */ Boolean = js.native
    def isDeclareVariable(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclareVariable> */ Boolean = js.native
    
    def isDeclaredPredicate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclaredPredicate> */ Boolean = js.native
    def isDeclaredPredicate(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DeclaredPredicate> */ Boolean = js.native
    
    def isDecorator(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Decorator> */ Boolean = js.native
    def isDecorator(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Decorator> */ Boolean = js.native
    
    /**
      * A helper to find if `this` path is a descendant of `maybeAncestor`
      */
    def isDescendant(maybeAncestor: NodePath[Node]): Boolean = js.native
    
    def isDirective(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Directive> */ Boolean = js.native
    def isDirective(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Directive> */ Boolean = js.native
    
    def isDirectiveLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DirectiveLiteral> */ Boolean = js.native
    def isDirectiveLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DirectiveLiteral> */ Boolean = js.native
    
    def isDoExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DoExpression> */ Boolean = js.native
    def isDoExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DoExpression> */ Boolean = js.native
    
    def isDoWhileStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DoWhileStatement> */ Boolean = js.native
    def isDoWhileStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.DoWhileStatement> */ Boolean = js.native
    
    def isEmptyStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EmptyStatement> */ Boolean = js.native
    def isEmptyStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EmptyStatement> */ Boolean = js.native
    
    def isEmptyTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EmptyTypeAnnotation> */ Boolean = js.native
    def isEmptyTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.EmptyTypeAnnotation> */ Boolean = js.native
    
    def isExistsTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExistsTypeAnnotation> */ Boolean = js.native
    def isExistsTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExistsTypeAnnotation> */ Boolean = js.native
    
    def isExportAllDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportAllDeclaration> */ Boolean = js.native
    def isExportAllDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportAllDeclaration> */ Boolean = js.native
    
    def isExportDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDeclaration> */ Boolean = js.native
    def isExportDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDeclaration> */ Boolean = js.native
    
    def isExportDefaultDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDefaultDeclaration> */ Boolean = js.native
    def isExportDefaultDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDefaultDeclaration> */ Boolean = js.native
    
    def isExportDefaultSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDefaultSpecifier> */ Boolean = js.native
    def isExportDefaultSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportDefaultSpecifier> */ Boolean = js.native
    
    def isExportNamedDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportNamedDeclaration> */ Boolean = js.native
    def isExportNamedDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportNamedDeclaration> */ Boolean = js.native
    
    def isExportNamespaceSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportNamespaceSpecifier> */ Boolean = js.native
    def isExportNamespaceSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportNamespaceSpecifier> */ Boolean = js.native
    
    def isExportSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportSpecifier> */ Boolean = js.native
    def isExportSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExportSpecifier> */ Boolean = js.native
    
    def isExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Expression> */ Boolean = js.native
    def isExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Expression> */ Boolean = js.native
    
    def isExpressionStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExpressionStatement> */ Boolean = js.native
    def isExpressionStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExpressionStatement> */ Boolean = js.native
    
    def isExpressionWrapper(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExpressionWrapper> */ Boolean = js.native
    def isExpressionWrapper(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ExpressionWrapper> */ Boolean = js.native
    
    def isFile(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.File> */ Boolean = js.native
    def isFile(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.File> */ Boolean = js.native
    
    def isFlow(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Flow> */ Boolean = js.native
    def isFlow(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Flow> */ Boolean = js.native
    
    def isFlowBaseAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowBaseAnnotation> */ Boolean = js.native
    def isFlowBaseAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowBaseAnnotation> */ Boolean = js.native
    
    def isFlowDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowDeclaration> */ Boolean = js.native
    def isFlowDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowDeclaration> */ Boolean = js.native
    
    def isFlowPredicate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowPredicate> */ Boolean = js.native
    def isFlowPredicate(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowPredicate> */ Boolean = js.native
    
    def isFlowType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowType> */ Boolean = js.native
    def isFlowType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FlowType> */ Boolean = js.native
    
    def isFor(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.For> */ Boolean = js.native
    def isFor(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.For> */ Boolean = js.native
    
    def isForInStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForInStatement> */ Boolean = js.native
    def isForInStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForInStatement> */ Boolean = js.native
    
    def isForOfStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForOfStatement> */ Boolean = js.native
    def isForOfStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForOfStatement> */ Boolean = js.native
    
    def isForStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForStatement> */ Boolean = js.native
    def isForStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForStatement> */ Boolean = js.native
    
    def isForXStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForXStatement> */ Boolean = js.native
    def isForXStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ForXStatement> */ Boolean = js.native
    
    def isFunction(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Function> */ Boolean = js.native
    def isFunction(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Function> */ Boolean = js.native
    
    def isFunctionDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionDeclaration> */ Boolean = js.native
    def isFunctionDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionDeclaration> */ Boolean = js.native
    
    def isFunctionExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionExpression> */ Boolean = js.native
    def isFunctionExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionExpression> */ Boolean = js.native
    
    def isFunctionParent(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionParent> */ Boolean = js.native
    def isFunctionParent(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionParent> */ Boolean = js.native
    
    def isFunctionTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionTypeAnnotation> */ Boolean = js.native
    def isFunctionTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionTypeAnnotation> */ Boolean = js.native
    
    def isFunctionTypeParam(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionTypeParam> */ Boolean = js.native
    def isFunctionTypeParam(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.FunctionTypeParam> */ Boolean = js.native
    
    def isGenerated(): Boolean = js.native
    def isGenerated(props: js.Object): Boolean = js.native
    
    def isGenericType(genericName: String): Boolean = js.native
    
    def isGenericTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.GenericTypeAnnotation> */ Boolean = js.native
    def isGenericTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.GenericTypeAnnotation> */ Boolean = js.native
    
    def isIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier> */ Boolean = js.native
    def isIdentifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier> */ Boolean = js.native
    
    def isIfStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IfStatement> */ Boolean = js.native
    def isIfStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IfStatement> */ Boolean = js.native
    
    def isImmutable(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Immutable> */ Boolean = js.native
    def isImmutable(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Immutable> */ Boolean = js.native
    
    def isImport(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Import> */ Boolean = js.native
    def isImport(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Import> */ Boolean = js.native
    
    def isImportDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportDeclaration> */ Boolean = js.native
    def isImportDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportDeclaration> */ Boolean = js.native
    
    def isImportDefaultSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportDefaultSpecifier> */ Boolean = js.native
    def isImportDefaultSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportDefaultSpecifier> */ Boolean = js.native
    
    def isImportNamespaceSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportNamespaceSpecifier> */ Boolean = js.native
    def isImportNamespaceSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportNamespaceSpecifier> */ Boolean = js.native
    
    def isImportSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportSpecifier> */ Boolean = js.native
    def isImportSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ImportSpecifier> */ Boolean = js.native
    
    def isInferredPredicate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InferredPredicate> */ Boolean = js.native
    def isInferredPredicate(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InferredPredicate> */ Boolean = js.native
    
    def isInterfaceDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceDeclaration> */ Boolean = js.native
    def isInterfaceDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceDeclaration> */ Boolean = js.native
    
    def isInterfaceExtends(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceExtends> */ Boolean = js.native
    def isInterfaceExtends(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceExtends> */ Boolean = js.native
    
    def isInterfaceTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceTypeAnnotation> */ Boolean = js.native
    def isInterfaceTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterfaceTypeAnnotation> */ Boolean = js.native
    
    def isInterpreterDirective(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterpreterDirective> */ Boolean = js.native
    def isInterpreterDirective(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.InterpreterDirective> */ Boolean = js.native
    
    def isIntersectionTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IntersectionTypeAnnotation> */ Boolean = js.native
    def isIntersectionTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.IntersectionTypeAnnotation> */ Boolean = js.native
    
    def isJSX(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSX> */ Boolean = js.native
    def isJSX(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSX> */ Boolean = js.native
    
    def isJSXAttribute(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXAttribute> */ Boolean = js.native
    def isJSXAttribute(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXAttribute> */ Boolean = js.native
    
    def isJSXClosingElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXClosingElement> */ Boolean = js.native
    def isJSXClosingElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXClosingElement> */ Boolean = js.native
    
    def isJSXClosingFragment(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXClosingFragment> */ Boolean = js.native
    def isJSXClosingFragment(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXClosingFragment> */ Boolean = js.native
    
    def isJSXElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXElement> */ Boolean = js.native
    def isJSXElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXElement> */ Boolean = js.native
    
    def isJSXEmptyExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXEmptyExpression> */ Boolean = js.native
    def isJSXEmptyExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXEmptyExpression> */ Boolean = js.native
    
    def isJSXExpressionContainer(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXExpressionContainer> */ Boolean = js.native
    def isJSXExpressionContainer(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXExpressionContainer> */ Boolean = js.native
    
    def isJSXFragment(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXFragment> */ Boolean = js.native
    def isJSXFragment(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXFragment> */ Boolean = js.native
    
    def isJSXIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXIdentifier> */ Boolean = js.native
    def isJSXIdentifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXIdentifier> */ Boolean = js.native
    
    def isJSXMemberExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXMemberExpression> */ Boolean = js.native
    def isJSXMemberExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXMemberExpression> */ Boolean = js.native
    
    def isJSXNamespacedName(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXNamespacedName> */ Boolean = js.native
    def isJSXNamespacedName(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXNamespacedName> */ Boolean = js.native
    
    def isJSXOpeningElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXOpeningElement> */ Boolean = js.native
    def isJSXOpeningElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXOpeningElement> */ Boolean = js.native
    
    def isJSXOpeningFragment(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXOpeningFragment> */ Boolean = js.native
    def isJSXOpeningFragment(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXOpeningFragment> */ Boolean = js.native
    
    def isJSXSpreadAttribute(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXSpreadAttribute> */ Boolean = js.native
    def isJSXSpreadAttribute(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXSpreadAttribute> */ Boolean = js.native
    
    def isJSXSpreadChild(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXSpreadChild> */ Boolean = js.native
    def isJSXSpreadChild(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXSpreadChild> */ Boolean = js.native
    
    def isJSXText(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXText> */ Boolean = js.native
    def isJSXText(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.JSXText> */ Boolean = js.native
    
    def isLVal(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LVal> */ Boolean = js.native
    def isLVal(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LVal> */ Boolean = js.native
    
    def isLabeledStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LabeledStatement> */ Boolean = js.native
    def isLabeledStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LabeledStatement> */ Boolean = js.native
    
    def isLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Literal> */ Boolean = js.native
    def isLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Literal> */ Boolean = js.native
    
    def isLogicalExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LogicalExpression> */ Boolean = js.native
    def isLogicalExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.LogicalExpression> */ Boolean = js.native
    
    def isLoop(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Loop> */ Boolean = js.native
    def isLoop(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Loop> */ Boolean = js.native
    
    def isMemberExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MemberExpression> */ Boolean = js.native
    def isMemberExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MemberExpression> */ Boolean = js.native
    
    def isMetaProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MetaProperty> */ Boolean = js.native
    def isMetaProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MetaProperty> */ Boolean = js.native
    
    def isMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Method> */ Boolean = js.native
    def isMethod(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Method> */ Boolean = js.native
    
    def isMixedTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MixedTypeAnnotation> */ Boolean = js.native
    def isMixedTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MixedTypeAnnotation> */ Boolean = js.native
    
    def isModuleDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleDeclaration> */ Boolean = js.native
    def isModuleDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleDeclaration> */ Boolean = js.native
    
    def isModuleSpecifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleSpecifier> */ Boolean = js.native
    def isModuleSpecifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ModuleSpecifier> */ Boolean = js.native
    
    def isNewExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NewExpression> */ Boolean = js.native
    def isNewExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NewExpression> */ Boolean = js.native
    
    /**
      * Check the type against our stored internal type of the node. This is handy when a node has
      * been removed yet we still internally know the type and need it to calculate node replacement.
      */
    def isNodeType(`type`: String): Boolean = js.native
    
    def isNoop(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Noop> */ Boolean = js.native
    def isNoop(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Noop> */ Boolean = js.native
    
    def isNullLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullLiteral> */ Boolean = js.native
    def isNullLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullLiteral> */ Boolean = js.native
    
    def isNullLiteralTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullLiteralTypeAnnotation> */ Boolean = js.native
    def isNullLiteralTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullLiteralTypeAnnotation> */ Boolean = js.native
    
    def isNullableTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullableTypeAnnotation> */ Boolean = js.native
    def isNullableTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NullableTypeAnnotation> */ Boolean = js.native
    
    /** @deprecated Use `isNumericLiteral` */
    def isNumberLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumericLiteral> */ Boolean = js.native
    def isNumberLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumericLiteral> */ Boolean = js.native
    
    def isNumberLiteralTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberLiteralTypeAnnotation> */ Boolean = js.native
    def isNumberLiteralTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberLiteralTypeAnnotation> */ Boolean = js.native
    
    def isNumberTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberTypeAnnotation> */ Boolean = js.native
    def isNumberTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumberTypeAnnotation> */ Boolean = js.native
    
    def isNumericLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumericLiteral> */ Boolean = js.native
    def isNumericLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.NumericLiteral> */ Boolean = js.native
    
    def isObjectExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectExpression> */ Boolean = js.native
    def isObjectExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectExpression> */ Boolean = js.native
    
    def isObjectMember(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectMember> */ Boolean = js.native
    def isObjectMember(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectMember> */ Boolean = js.native
    
    def isObjectMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectMethod> */ Boolean = js.native
    def isObjectMethod(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectMethod> */ Boolean = js.native
    
    def isObjectPattern(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectPattern> */ Boolean = js.native
    def isObjectPattern(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectPattern> */ Boolean = js.native
    
    def isObjectProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectProperty> */ Boolean = js.native
    def isObjectProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectProperty> */ Boolean = js.native
    
    def isObjectTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeAnnotation> */ Boolean = js.native
    def isObjectTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeAnnotation> */ Boolean = js.native
    
    def isObjectTypeCallProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeCallProperty> */ Boolean = js.native
    def isObjectTypeCallProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeCallProperty> */ Boolean = js.native
    
    def isObjectTypeIndexer(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeIndexer> */ Boolean = js.native
    def isObjectTypeIndexer(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeIndexer> */ Boolean = js.native
    
    def isObjectTypeInternalSlot(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeInternalSlot> */ Boolean = js.native
    def isObjectTypeInternalSlot(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeInternalSlot> */ Boolean = js.native
    
    def isObjectTypeProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeProperty> */ Boolean = js.native
    def isObjectTypeProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeProperty> */ Boolean = js.native
    
    def isObjectTypeSpreadProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeSpreadProperty> */ Boolean = js.native
    def isObjectTypeSpreadProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ObjectTypeSpreadProperty> */ Boolean = js.native
    
    def isOpaqueType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OpaqueType> */ Boolean = js.native
    def isOpaqueType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OpaqueType> */ Boolean = js.native
    
    def isOptionalCallExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalCallExpression> */ Boolean = js.native
    def isOptionalCallExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalCallExpression> */ Boolean = js.native
    
    def isOptionalMemberExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalMemberExpression> */ Boolean = js.native
    def isOptionalMemberExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.OptionalMemberExpression> */ Boolean = js.native
    
    def isParenthesizedExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ParenthesizedExpression> */ Boolean = js.native
    def isParenthesizedExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ParenthesizedExpression> */ Boolean = js.native
    
    def isPattern(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Pattern> */ Boolean = js.native
    def isPattern(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Pattern> */ Boolean = js.native
    
    def isPatternLike(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PatternLike> */ Boolean = js.native
    def isPatternLike(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PatternLike> */ Boolean = js.native
    
    def isPipelineBareFunction(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelineBareFunction> */ Boolean = js.native
    def isPipelineBareFunction(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelineBareFunction> */ Boolean = js.native
    
    def isPipelinePrimaryTopicReference(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelinePrimaryTopicReference> */ Boolean = js.native
    def isPipelinePrimaryTopicReference(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelinePrimaryTopicReference> */ Boolean = js.native
    
    def isPipelineTopicExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelineTopicExpression> */ Boolean = js.native
    def isPipelineTopicExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PipelineTopicExpression> */ Boolean = js.native
    
    def isPrivate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Private> */ Boolean = js.native
    def isPrivate(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Private> */ Boolean = js.native
    
    def isPrivateName(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PrivateName> */ Boolean = js.native
    def isPrivateName(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.PrivateName> */ Boolean = js.native
    
    def isProgram(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Program> */ Boolean = js.native
    def isProgram(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Program> */ Boolean = js.native
    
    def isProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Property> */ Boolean = js.native
    def isProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Property> */ Boolean = js.native
    
    def isPure(): Boolean = js.native
    def isPure(props: js.Object): Boolean = js.native
    
    def isPureish(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Pureish> */ Boolean = js.native
    def isPureish(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Pureish> */ Boolean = js.native
    
    def isQualifiedTypeIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.QualifiedTypeIdentifier> */ Boolean = js.native
    def isQualifiedTypeIdentifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.QualifiedTypeIdentifier> */ Boolean = js.native
    
    def isReferenced(): Boolean = js.native
    def isReferenced(props: js.Object): Boolean = js.native
    
    def isReferencedIdentifier(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier | @babel/types.@babel/types.JSXIdentifier> */ Boolean = js.native
    def isReferencedIdentifier(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Identifier | @babel/types.@babel/types.JSXIdentifier> */ Boolean = js.native
    
    def isReferencedMemberExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MemberExpression> */ Boolean = js.native
    def isReferencedMemberExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.MemberExpression> */ Boolean = js.native
    
    def isRegExpLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RegExpLiteral> */ Boolean = js.native
    def isRegExpLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RegExpLiteral> */ Boolean = js.native
    
    /** @deprecated Use `isRegExpLiteral` */
    def isRegexLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RegExpLiteral> */ Boolean = js.native
    def isRegexLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RegExpLiteral> */ Boolean = js.native
    
    def isRestElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RestElement> */ Boolean = js.native
    def isRestElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RestElement> */ Boolean = js.native
    
    /** @deprecated Use `isRestElement` */
    def isRestProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RestElement> */ Boolean = js.native
    def isRestProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.RestElement> */ Boolean = js.native
    
    def isReturnStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ReturnStatement> */ Boolean = js.native
    def isReturnStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ReturnStatement> */ Boolean = js.native
    
    def isScopable(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Scopable> */ Boolean = js.native
    def isScopable(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Scopable> */ Boolean = js.native
    
    def isScope(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Scopable> */ Boolean = js.native
    def isScope(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Scopable> */ Boolean = js.native
    
    def isSequenceExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SequenceExpression> */ Boolean = js.native
    def isSequenceExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SequenceExpression> */ Boolean = js.native
    
    def isSpreadElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SpreadElement> */ Boolean = js.native
    def isSpreadElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SpreadElement> */ Boolean = js.native
    
    /** @deprecated Use `isSpreadElement` */
    def isSpreadProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SpreadElement> */ Boolean = js.native
    def isSpreadProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SpreadElement> */ Boolean = js.native
    
    def isStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Statement> */ Boolean = js.native
    def isStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Statement> */ Boolean = js.native
    
    /**
      * Check whether or not the current `key` allows either a single statement or block statement
      * so we can explode it if necessary.
      */
    def isStatementOrBlock(): Boolean = js.native
    
    def isStatic(): Boolean = js.native
    
    def isStringLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringLiteral> */ Boolean = js.native
    def isStringLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringLiteral> */ Boolean = js.native
    
    def isStringLiteralTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringLiteralTypeAnnotation> */ Boolean = js.native
    def isStringLiteralTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringLiteralTypeAnnotation> */ Boolean = js.native
    
    def isStringTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringTypeAnnotation> */ Boolean = js.native
    def isStringTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.StringTypeAnnotation> */ Boolean = js.native
    
    def isSuper(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Super> */ Boolean = js.native
    def isSuper(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Super> */ Boolean = js.native
    
    def isSwitchCase(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SwitchCase> */ Boolean = js.native
    def isSwitchCase(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SwitchCase> */ Boolean = js.native
    
    def isSwitchStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SwitchStatement> */ Boolean = js.native
    def isSwitchStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.SwitchStatement> */ Boolean = js.native
    
    def isTSAnyKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSAnyKeyword> */ Boolean = js.native
    def isTSAnyKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSAnyKeyword> */ Boolean = js.native
    
    def isTSArrayType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSArrayType> */ Boolean = js.native
    def isTSArrayType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSArrayType> */ Boolean = js.native
    
    def isTSAsExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSAsExpression> */ Boolean = js.native
    def isTSAsExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSAsExpression> */ Boolean = js.native
    
    def isTSBooleanKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSBooleanKeyword> */ Boolean = js.native
    def isTSBooleanKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSBooleanKeyword> */ Boolean = js.native
    
    def isTSCallSignatureDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSCallSignatureDeclaration> */ Boolean = js.native
    def isTSCallSignatureDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSCallSignatureDeclaration> */ Boolean = js.native
    
    def isTSConditionalType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConditionalType> */ Boolean = js.native
    def isTSConditionalType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConditionalType> */ Boolean = js.native
    
    def isTSConstructSignatureDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConstructSignatureDeclaration> */ Boolean = js.native
    def isTSConstructSignatureDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConstructSignatureDeclaration> */ Boolean = js.native
    
    def isTSConstructorType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConstructorType> */ Boolean = js.native
    def isTSConstructorType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSConstructorType> */ Boolean = js.native
    
    def isTSDeclareFunction(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSDeclareFunction> */ Boolean = js.native
    def isTSDeclareFunction(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSDeclareFunction> */ Boolean = js.native
    
    def isTSDeclareMethod(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSDeclareMethod> */ Boolean = js.native
    def isTSDeclareMethod(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSDeclareMethod> */ Boolean = js.native
    
    def isTSEntityName(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEntityName> */ Boolean = js.native
    def isTSEntityName(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEntityName> */ Boolean = js.native
    
    def isTSEnumDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEnumDeclaration> */ Boolean = js.native
    def isTSEnumDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEnumDeclaration> */ Boolean = js.native
    
    def isTSEnumMember(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEnumMember> */ Boolean = js.native
    def isTSEnumMember(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSEnumMember> */ Boolean = js.native
    
    def isTSExportAssignment(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExportAssignment> */ Boolean = js.native
    def isTSExportAssignment(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExportAssignment> */ Boolean = js.native
    
    def isTSExpressionWithTypeArguments(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExpressionWithTypeArguments> */ Boolean = js.native
    def isTSExpressionWithTypeArguments(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExpressionWithTypeArguments> */ Boolean = js.native
    
    def isTSExternalModuleReference(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExternalModuleReference> */ Boolean = js.native
    def isTSExternalModuleReference(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSExternalModuleReference> */ Boolean = js.native
    
    def isTSFunctionType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSFunctionType> */ Boolean = js.native
    def isTSFunctionType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSFunctionType> */ Boolean = js.native
    
    def isTSImportEqualsDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSImportEqualsDeclaration> */ Boolean = js.native
    def isTSImportEqualsDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSImportEqualsDeclaration> */ Boolean = js.native
    
    def isTSImportType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSImportType> */ Boolean = js.native
    def isTSImportType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSImportType> */ Boolean = js.native
    
    def isTSIndexSignature(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIndexSignature> */ Boolean = js.native
    def isTSIndexSignature(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIndexSignature> */ Boolean = js.native
    
    def isTSIndexedAccessType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIndexedAccessType> */ Boolean = js.native
    def isTSIndexedAccessType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIndexedAccessType> */ Boolean = js.native
    
    def isTSInferType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInferType> */ Boolean = js.native
    def isTSInferType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInferType> */ Boolean = js.native
    
    def isTSInterfaceBody(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInterfaceBody> */ Boolean = js.native
    def isTSInterfaceBody(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInterfaceBody> */ Boolean = js.native
    
    def isTSInterfaceDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInterfaceDeclaration> */ Boolean = js.native
    def isTSInterfaceDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSInterfaceDeclaration> */ Boolean = js.native
    
    def isTSIntersectionType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIntersectionType> */ Boolean = js.native
    def isTSIntersectionType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSIntersectionType> */ Boolean = js.native
    
    def isTSLiteralType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSLiteralType> */ Boolean = js.native
    def isTSLiteralType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSLiteralType> */ Boolean = js.native
    
    def isTSMappedType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSMappedType> */ Boolean = js.native
    def isTSMappedType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSMappedType> */ Boolean = js.native
    
    def isTSMethodSignature(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSMethodSignature> */ Boolean = js.native
    def isTSMethodSignature(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSMethodSignature> */ Boolean = js.native
    
    def isTSModuleBlock(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSModuleBlock> */ Boolean = js.native
    def isTSModuleBlock(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSModuleBlock> */ Boolean = js.native
    
    def isTSModuleDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSModuleDeclaration> */ Boolean = js.native
    def isTSModuleDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSModuleDeclaration> */ Boolean = js.native
    
    def isTSNamespaceExportDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNamespaceExportDeclaration> */ Boolean = js.native
    def isTSNamespaceExportDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNamespaceExportDeclaration> */ Boolean = js.native
    
    def isTSNeverKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNeverKeyword> */ Boolean = js.native
    def isTSNeverKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNeverKeyword> */ Boolean = js.native
    
    def isTSNonNullExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNonNullExpression> */ Boolean = js.native
    def isTSNonNullExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNonNullExpression> */ Boolean = js.native
    
    def isTSNullKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNullKeyword> */ Boolean = js.native
    def isTSNullKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNullKeyword> */ Boolean = js.native
    
    def isTSNumberKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNumberKeyword> */ Boolean = js.native
    def isTSNumberKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSNumberKeyword> */ Boolean = js.native
    
    def isTSObjectKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSObjectKeyword> */ Boolean = js.native
    def isTSObjectKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSObjectKeyword> */ Boolean = js.native
    
    def isTSOptionalType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSOptionalType> */ Boolean = js.native
    def isTSOptionalType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSOptionalType> */ Boolean = js.native
    
    def isTSParameterProperty(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSParameterProperty> */ Boolean = js.native
    def isTSParameterProperty(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSParameterProperty> */ Boolean = js.native
    
    def isTSParenthesizedType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSParenthesizedType> */ Boolean = js.native
    def isTSParenthesizedType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSParenthesizedType> */ Boolean = js.native
    
    def isTSPropertySignature(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSPropertySignature> */ Boolean = js.native
    def isTSPropertySignature(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSPropertySignature> */ Boolean = js.native
    
    def isTSQualifiedName(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSQualifiedName> */ Boolean = js.native
    def isTSQualifiedName(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSQualifiedName> */ Boolean = js.native
    
    def isTSRestType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSRestType> */ Boolean = js.native
    def isTSRestType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSRestType> */ Boolean = js.native
    
    def isTSStringKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSStringKeyword> */ Boolean = js.native
    def isTSStringKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSStringKeyword> */ Boolean = js.native
    
    def isTSSymbolKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSSymbolKeyword> */ Boolean = js.native
    def isTSSymbolKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSSymbolKeyword> */ Boolean = js.native
    
    def isTSThisType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSThisType> */ Boolean = js.native
    def isTSThisType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSThisType> */ Boolean = js.native
    
    def isTSTupleType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTupleType> */ Boolean = js.native
    def isTSTupleType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTupleType> */ Boolean = js.native
    
    def isTSType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSType> */ Boolean = js.native
    def isTSType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSType> */ Boolean = js.native
    
    def isTSTypeAliasDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAliasDeclaration> */ Boolean = js.native
    def isTSTypeAliasDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAliasDeclaration> */ Boolean = js.native
    
    def isTSTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAnnotation> */ Boolean = js.native
    def isTSTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAnnotation> */ Boolean = js.native
    
    def isTSTypeAssertion(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAssertion> */ Boolean = js.native
    def isTSTypeAssertion(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeAssertion> */ Boolean = js.native
    
    def isTSTypeElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeElement> */ Boolean = js.native
    def isTSTypeElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeElement> */ Boolean = js.native
    
    def isTSTypeLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeLiteral> */ Boolean = js.native
    def isTSTypeLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeLiteral> */ Boolean = js.native
    
    def isTSTypeOperator(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeOperator> */ Boolean = js.native
    def isTSTypeOperator(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeOperator> */ Boolean = js.native
    
    def isTSTypeParameter(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameter> */ Boolean = js.native
    def isTSTypeParameter(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameter> */ Boolean = js.native
    
    def isTSTypeParameterDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameterDeclaration> */ Boolean = js.native
    def isTSTypeParameterDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameterDeclaration> */ Boolean = js.native
    
    def isTSTypeParameterInstantiation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameterInstantiation> */ Boolean = js.native
    def isTSTypeParameterInstantiation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeParameterInstantiation> */ Boolean = js.native
    
    def isTSTypePredicate(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypePredicate> */ Boolean = js.native
    def isTSTypePredicate(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypePredicate> */ Boolean = js.native
    
    def isTSTypeQuery(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeQuery> */ Boolean = js.native
    def isTSTypeQuery(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeQuery> */ Boolean = js.native
    
    def isTSTypeReference(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeReference> */ Boolean = js.native
    def isTSTypeReference(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSTypeReference> */ Boolean = js.native
    
    def isTSUndefinedKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUndefinedKeyword> */ Boolean = js.native
    def isTSUndefinedKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUndefinedKeyword> */ Boolean = js.native
    
    def isTSUnionType(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUnionType> */ Boolean = js.native
    def isTSUnionType(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUnionType> */ Boolean = js.native
    
    def isTSUnknownKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUnknownKeyword> */ Boolean = js.native
    def isTSUnknownKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSUnknownKeyword> */ Boolean = js.native
    
    def isTSVoidKeyword(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSVoidKeyword> */ Boolean = js.native
    def isTSVoidKeyword(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TSVoidKeyword> */ Boolean = js.native
    
    def isTaggedTemplateExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TaggedTemplateExpression> */ Boolean = js.native
    def isTaggedTemplateExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TaggedTemplateExpression> */ Boolean = js.native
    
    def isTemplateElement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TemplateElement> */ Boolean = js.native
    def isTemplateElement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TemplateElement> */ Boolean = js.native
    
    def isTemplateLiteral(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TemplateLiteral> */ Boolean = js.native
    def isTemplateLiteral(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TemplateLiteral> */ Boolean = js.native
    
    def isTerminatorless(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Terminatorless> */ Boolean = js.native
    def isTerminatorless(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Terminatorless> */ Boolean = js.native
    
    def isThisExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThisExpression> */ Boolean = js.native
    def isThisExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThisExpression> */ Boolean = js.native
    
    def isThisTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThisTypeAnnotation> */ Boolean = js.native
    def isThisTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThisTypeAnnotation> */ Boolean = js.native
    
    def isThrowStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThrowStatement> */ Boolean = js.native
    def isThrowStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.ThrowStatement> */ Boolean = js.native
    
    def isTryStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TryStatement> */ Boolean = js.native
    def isTryStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TryStatement> */ Boolean = js.native
    
    def isTupleTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TupleTypeAnnotation> */ Boolean = js.native
    def isTupleTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TupleTypeAnnotation> */ Boolean = js.native
    
    def isTypeAlias(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeAlias> */ Boolean = js.native
    def isTypeAlias(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeAlias> */ Boolean = js.native
    
    def isTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeAnnotation> */ Boolean = js.native
    def isTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeAnnotation> */ Boolean = js.native
    
    def isTypeCastExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeCastExpression> */ Boolean = js.native
    def isTypeCastExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeCastExpression> */ Boolean = js.native
    
    def isTypeParameter(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameter> */ Boolean = js.native
    def isTypeParameter(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameter> */ Boolean = js.native
    
    def isTypeParameterDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameterDeclaration> */ Boolean = js.native
    def isTypeParameterDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameterDeclaration> */ Boolean = js.native
    
    def isTypeParameterInstantiation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameterInstantiation> */ Boolean = js.native
    def isTypeParameterInstantiation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeParameterInstantiation> */ Boolean = js.native
    
    def isTypeofTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeofTypeAnnotation> */ Boolean = js.native
    def isTypeofTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.TypeofTypeAnnotation> */ Boolean = js.native
    
    def isUnaryExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnaryExpression> */ Boolean = js.native
    def isUnaryExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnaryExpression> */ Boolean = js.native
    
    def isUnaryLike(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnaryLike> */ Boolean = js.native
    def isUnaryLike(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnaryLike> */ Boolean = js.native
    
    def isUnionTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnionTypeAnnotation> */ Boolean = js.native
    def isUnionTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UnionTypeAnnotation> */ Boolean = js.native
    
    def isUpdateExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UpdateExpression> */ Boolean = js.native
    def isUpdateExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UpdateExpression> */ Boolean = js.native
    
    def isUser(): Boolean = js.native
    def isUser(props: js.Object): Boolean = js.native
    
    def isUserWhitespacable(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UserWhitespacable> */ Boolean = js.native
    def isUserWhitespacable(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.UserWhitespacable> */ Boolean = js.native
    
    def isVar(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    def isVar(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    
    def isVariableDeclaration(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    def isVariableDeclaration(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclaration> */ Boolean = js.native
    
    def isVariableDeclarator(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclarator> */ Boolean = js.native
    def isVariableDeclarator(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VariableDeclarator> */ Boolean = js.native
    
    def isVariance(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Variance> */ Boolean = js.native
    def isVariance(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.Variance> */ Boolean = js.native
    
    def isVoidTypeAnnotation(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VoidTypeAnnotation> */ Boolean = js.native
    def isVoidTypeAnnotation(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.VoidTypeAnnotation> */ Boolean = js.native
    
    def isWhile(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.While> */ Boolean = js.native
    def isWhile(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.While> */ Boolean = js.native
    
    def isWhileStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.WhileStatement> */ Boolean = js.native
    def isWhileStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.WhileStatement> */ Boolean = js.native
    
    def isWithStatement(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.WithStatement> */ Boolean = js.native
    def isWithStatement(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.WithStatement> */ Boolean = js.native
    
    def isYieldExpression(): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.YieldExpression> */ Boolean = js.native
    def isYieldExpression(props: js.Object): /* is @babel/traverse.@babel/traverse.NodePath<@babel/types.@babel/types.YieldExpression> */ Boolean = js.native
    
    /** Opposite of `has`. */
    def isnt(key: String): Boolean = js.native
    
    var key: String | Double = js.native
    
    var listKey: String = js.native
    
    //#endregion
    //#region ------------------------- introspection -------------------------
    /**
      * Match the current node if it matches the provided `pattern`.
      *
      * For example, given the match `React.createClass` it would match the
      * parsed nodes of `React.createClass` and `React["createClass"]`.
      */
    def matchesPattern(pattern: String): Boolean = js.native
    def matchesPattern(pattern: String, allowPartial: Boolean): Boolean = js.native
    
    var node: T = js.native
    
    var opts: js.Object = js.native
    
    var parent: Node = js.native
    
    var parentKey: String = js.native
    
    var parentPath: NodePath[Node] = js.native
    
    def popContext(): Unit = js.native
    
    /**
      * Insert child nodes at the end of the current node.
      * @param listKey - The key at which the child nodes are stored (usually body).
      * @param nodes - the nodes to insert.
      */
    def pushContainer[Nodes /* <: Node | js.Array[Node] */](listKey: ArrayKeys[T], nodes: Nodes): NodePaths[Nodes] = js.native
    
    def pushContext(context: TraversalContext): Unit = js.native
    
    /** Check if the currently assigned path references the `importName` of `moduleSource`. */
    def referencesImport(moduleSource: String, importName: String): Boolean = js.native
    
    //#endregion
    //#region ------------------------- removal -------------------------
    def remove(): Unit = js.native
    
    var removed: Boolean = js.native
    
    /**
      * This method takes an array of statements nodes and then explodes it
      * into expressions. This method retains completion records which is
      * extremely important to retain original semantics.
      */
    def replaceExpressionWithStatements[Nodes /* <: js.Array[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    def replaceInline[Nodes /* <: Node | js.Array[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    /** Replace the current node with another. */
    def replaceWith[T /* <: Node */](replacement: T): js.Array[NodePath[T]] = js.native
    def replaceWith[T /* <: Node */](replacement: NodePath[T]): js.Array[NodePath[T]] = js.native
    
    //#endregion
    //#region ------------------------- replacement -------------------------
    /**
      * Replace a node with an array of multiple. This method performs the following steps:
      *
      *  - Inherit the comments of first provided node with that of the current node.
      *  - Insert the provided nodes after the current node.
      *  - Remove the current node.
      */
    def replaceWithMultiple[Nodes /* <: js.Array[Node] */](nodes: Nodes): NodePaths[Nodes] = js.native
    
    /**
      * Parse a string as an expression and replace the current node with the result.
      *
      * NOTE: This is typically not a good idea to use. Building source strings when
      * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's
      * easier to use, your transforms will be extremely brittle.
      */
    def replaceWithSourceString(replacement: js.Any): js.Array[NodePath[Node]] = js.native
    
    var scope: Scope = js.native
    
    def set(key: String, node: Node): Unit = js.native
    
    def setContext(context: TraversalContext): NodePath[T] = js.native
    
    def setData(key: String, `val`: js.Any): js.Any = js.native
    
    def setScope(): Unit = js.native
    
    //#endregion
    //#region ------------------------- comments -------------------------
    /** Share comments amongst siblings. */
    def shareCommentsWithSiblings(): Unit = js.native
    
    var shouldSkip: Boolean = js.native
    
    var shouldStop: Boolean = js.native
    
    def skip(): Unit = js.native
    
    def skipKey(key: String): Unit = js.native
    
    var skipKeys: js.Object = js.native
    
    var state: js.Any = js.native
    
    def stop(): Unit = js.native
    
    def traverse(visitor: Visitor[js.Object]): Unit = js.native
    def traverse[T](visitor: Visitor[T], state: T): Unit = js.native
    
    var `type`: js.UndefOr[
        String | (/* import warning: importer.ImportType#apply Failed type conversion: T['type'] */ js.Any)
      ] = js.native
    
    var typeAnnotation: js.Object = js.native
    
    /**
      * Insert child nodes at the start of the current node.
      * @param listKey - The key at which the child nodes are stored (usually body).
      * @param nodes - the nodes to insert.
      */
    def unshiftContainer[Nodes /* <: Node | js.Array[Node] */](listKey: ArrayKeys[T], nodes: Nodes): NodePaths[Nodes] = js.native
    
    /** Update all sibling node paths after `fromIndex` by `incrementBy`. */
    def updateSiblingKeys(fromIndex: Double, incrementBy: Double): Unit = js.native
    
    def visit(): Boolean = js.native
    
    /** Check if the current path will maybe execute before another path */
    def willIMaybeExecuteBefore(path: NodePath[Node]): Boolean = js.native
  }
  /* static members */
  object NodePath {
    
    @JSImport("@babel/traverse", "NodePath.get")
    @js.native
    def get[C /* <: Node */, K /* <: /* keyof C */ String */](opts: Container[C, K]): NodePath[
        /* import warning: importer.ImportType#apply Failed type conversion: C[K] */ js.Any
      ] = js.native
  }
  
  @JSImport("@babel/traverse", "Scope")
  @js.native
  class Scope protected () extends StObject {
    def this(path: NodePath[Node]) = this()
    def this(path: NodePath[Node], parentScope: Scope) = this()
    
    def addGlobal(node: Node): Unit = js.native
    
    def bindingIdentifierEquals(name: String, node: Node): Boolean = js.native
    
    var bindings: StringDictionary[Binding] = js.native
    
    var block: Node = js.native
    
    def buildUndefinedNode(): Node = js.native
    
    def checkBlockScopedCollisions(local: Node, kind: String, name: String, id: js.Object): Unit = js.native
    
    def dump(): Unit = js.native
    
    /** Generate a unique identifier and add it to the current scope. */
    def generateDeclaredUidIdentifier(): Identifier_ = js.native
    def generateDeclaredUidIdentifier(name: String): Identifier_ = js.native
    
    /** Generate a unique `_id1` binding. */
    def generateUid(): String = js.native
    def generateUid(name: String): String = js.native
    
    /** Generate a unique identifier. */
    def generateUidIdentifier(): Identifier_ = js.native
    def generateUidIdentifier(name: String): Identifier_ = js.native
    
    /** Generate a unique identifier based on a node. */
    def generateUidIdentifierBasedOnNode(parent: Node): Identifier_ = js.native
    def generateUidIdentifierBasedOnNode(parent: Node, defaultName: String): Identifier_ = js.native
    
    /** Walks the scope tree and gathers **all** bindings. */
    def getAllBindings(kinds: String*): js.Object = js.native
    
    def getBinding(name: String): js.UndefOr[Binding] = js.native
    
    def getBindingIdentifier(name: String): Identifier_ = js.native
    
    def getBlockParent(): Scope = js.native
    
    def getData(key: String): js.Any = js.native
    
    def getFunctionParent(): Scope | Null = js.native
    
    def getOwnBinding(name: String): js.UndefOr[Binding] = js.native
    
    def getOwnBindingIdentifier(name: String): Identifier_ = js.native
    
    def getProgramParent(): Scope = js.native
    
    def hasBinding(name: String): Boolean = js.native
    def hasBinding(name: String, noGlobals: Boolean): Boolean = js.native
    
    def hasGlobal(name: String): Boolean = js.native
    
    def hasOwnBinding(name: String): Boolean = js.native
    
    def hasReference(name: String): Boolean = js.native
    
    def hasUid(name: String): Boolean = js.native
    
    var hub: HubInterface = js.native
    
    def isPure(node: Node): Boolean = js.native
    def isPure(node: Node, constantsOnly: Boolean): Boolean = js.native
    
    /**
      * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.
      * evaluating it wont result in potentially arbitrary code from being ran. The following are
      * whitelisted and determined not to cause side effects:
      *
      *  - `this` expressions
      *  - `super` expressions
      *  - Bound identifiers
      */
    def isStatic(node: Node): Boolean = js.native
    
    /** Possibly generate a memoised identifier if it is not static and has consequences. */
    def maybeGenerateMemoised(node: Node): Identifier_ = js.native
    def maybeGenerateMemoised(node: Node, dontPush: Boolean): Identifier_ = js.native
    
    /** Move a binding of `name` to another `scope`. */
    def moveBindingTo(name: String, scope: Scope): Unit = js.native
    
    var parent: Scope = js.native
    
    var parentBlock: Node = js.native
    
    def parentHasBinding(name: String): Boolean = js.native
    def parentHasBinding(name: String, noGlobals: Boolean): Boolean = js.native
    
    var path: NodePath[Node] = js.native
    
    def push(opts: Id): Unit = js.native
    
    def registerBinding(kind: String, path: NodePath[Node]): Unit = js.native
    def registerBinding(kind: String, path: NodePath[Node], bindingPath: NodePath[Node]): Unit = js.native
    
    def registerConstantViolation(path: NodePath[Node]): Unit = js.native
    
    def registerDeclaration(path: NodePath[Node]): Unit = js.native
    
    def removeBinding(name: String): Unit = js.native
    
    def removeData(key: String): Unit = js.native
    
    def removeOwnBinding(name: String): Unit = js.native
    
    def rename(oldName: String): Unit = js.native
    def rename(oldName: String, newName: js.UndefOr[scala.Nothing], block: Node): Unit = js.native
    def rename(oldName: String, newName: String): Unit = js.native
    def rename(oldName: String, newName: String, block: Node): Unit = js.native
    
    def setData(key: String, `val`: js.Any): js.Any = js.native
    
    def toArray(node: Node): Node = js.native
    def toArray(node: Node, i: Double): Node = js.native
    
    def traverse(node: js.Array[Node]): Unit = js.native
    def traverse(node: js.Array[Node], opts: js.UndefOr[scala.Nothing], state: js.Any): Unit = js.native
    def traverse(node: js.Array[Node], opts: TraverseOptions[Node]): Unit = js.native
    def traverse(node: js.Array[Node], opts: TraverseOptions[Node], state: js.Any): Unit = js.native
    def traverse(node: Node): Unit = js.native
    def traverse(node: Node, opts: js.UndefOr[scala.Nothing], state: js.Any): Unit = js.native
    def traverse(node: Node, opts: TraverseOptions[Node]): Unit = js.native
    def traverse(node: Node, opts: TraverseOptions[Node], state: js.Any): Unit = js.native
    def traverse[S](node: js.Array[Node], opts: TraverseOptions[S], state: S): Unit = js.native
    /** Traverse node with current scope and path. */
    def traverse[S](node: Node, opts: TraverseOptions[S], state: S): Unit = js.native
  }
  
  object visitors {
    
    /**
      * `explode()` will take a `Visitor` object with all of the various shorthands
      * that we support, and validates & normalizes it into a common format, ready
      * to be used in traversal.
      *
      * The various shorthands are:
      * - `Identifier() { ... }` -> `Identifier: { enter() { ... } }`
      * - `"Identifier|NumericLiteral": { ... }` -> `Identifier: { ... }, NumericLiteral: { ... }`
      * - Aliases in `@babel/types`: e.g. `Property: { ... }` -> `ObjectProperty: { ... }, ClassProperty: { ... }`
      *
      * Other normalizations are:
      * - Visitors of virtual types are wrapped, so that they are only visited when their dynamic check passes
      * - `enter` and `exit` functions are wrapped in arrays, to ease merging of visitors
      */
    @JSImport("@babel/traverse", "visitors.explode")
    @js.native
    def explode[S](visitor: Visitor[S]): /* import warning: importer.ImportType#apply c Unsupported type mapping: 
    {[ Type in 'AnyTypeAnnotation' | 'ArgumentPlaceholder' | 'ArrayExpression' | 'ArrayPattern' | 'ArrayTypeAnnotation' | 'ArrowFunctionExpression' | 'AssignmentExpression' | 'AssignmentPattern' | 'AwaitExpression' | 'BigIntLiteral' | 'BinaryExpression' | 'LogicalExpression' | 'BindExpression' | 'BlockStatement' | 'Program' | 'TSModuleBlock' | 'CatchClause' | 'DoWhileStatement' | 'ForInStatement' | 'ForStatement' | 'FunctionDeclaration' | 'FunctionExpression' | 'ObjectMethod' | 'SwitchStatement' | 'WhileStatement' | 'ForOfStatement' | 'ClassMethod' | 'ClassPrivateMethod' | 'StaticBlock' | 'BooleanLiteral' | 'BooleanLiteralTypeAnnotation' | 'BooleanTypeAnnotation' | 'BreakStatement' | 'CallExpression' | 'ClassExpression' | 'ClassDeclaration' | 'ClassBody' | 'ClassImplements' | 'ClassPrivateProperty' | 'ClassProperty' | 'ContinueStatement' | 'ReturnStatement' | 'ThrowStatement' | 'ConditionalExpression' | 'IfStatement' | 'DebuggerStatement' | 'DecimalLiteral' | 'VariableDeclaration' | 'ExportAllDeclaration' | 'ExportDefaultDeclaration' | 'ExportNamedDeclaration' | 'ImportDeclaration' | 'DeclareClass' | 'DeclareFunction' | 'DeclareInterface' | 'DeclareModule' | 'DeclareModuleExports' | 'DeclareTypeAlias' | 'DeclareOpaqueType' | 'DeclareVariable' | 'DeclareExportDeclaration' | 'DeclareExportAllDeclaration' | 'InterfaceDeclaration' | 'OpaqueType' | 'TypeAlias' | 'EnumDeclaration' | 'TSDeclareFunction' | 'TSInterfaceDeclaration' | 'TSTypeAliasDeclaration' | 'TSEnumDeclaration' | 'TSModuleDeclaration' | 'DeclaredPredicate' | 'Decorator' | 'Directive' | 'DirectiveLiteral' | 'DoExpression' | 'EmptyStatement' | 'EmptyTypeAnnotation' | 'EnumBooleanBody' | 'EnumNumberBody' | 'EnumStringBody' | 'EnumSymbolBody' | 'EnumBooleanMember' | 'EnumDefaultedMember' | 'EnumNumberMember' | 'EnumStringMember' | 'ExistsTypeAnnotation' | 'ExportDefaultSpecifier' | 'ExportNamespaceSpecifier' | 'ExportSpecifier' | 'Identifier' | 'StringLiteral' | 'NumericLiteral' | 'NullLiteral' | 'RegExpLiteral' | 'MemberExpression' | 'NewExpression' | 'ObjectExpression' | 'SequenceExpression' | 'ParenthesizedExpression' | 'ThisExpression' | 'UnaryExpression' | 'UpdateExpression' | 'MetaProperty' | 'Super' | 'TaggedTemplateExpression' | 'TemplateLiteral' | 'YieldExpression' | 'Import' | 'OptionalMemberExpression' | 'OptionalCallExpression' | 'TypeCastExpression' | 'JSXElement' | 'JSXFragment' | 'PipelinePrimaryTopicReference' | 'RecordExpression' | 'TupleExpression' | 'TSAsExpression' | 'TSTypeAssertion' | 'TSNonNullExpression' | 'ExpressionStatement' | 'File' | 'NullLiteralTypeAnnotation' | 'FunctionTypeAnnotation' | 'FunctionTypeParam' | 'GenericTypeAnnotation' | 'InferredPredicate' | 'InterfaceExtends' | 'InterfaceTypeAnnotation' | 'IntersectionTypeAnnotation' | 'MixedTypeAnnotation' | 'NullableTypeAnnotation' | 'NumberLiteralTypeAnnotation' | 'NumberTypeAnnotation' | 'ObjectTypeAnnotation' | 'ObjectTypeInternalSlot' | 'ObjectTypeCallProperty' | 'ObjectTypeIndexer' | 'ObjectTypeProperty' | 'ObjectTypeSpreadProperty' | 'QualifiedTypeIdentifier' | 'StringLiteralTypeAnnotation' | 'StringTypeAnnotation' | 'SymbolTypeAnnotation' | 'ThisTypeAnnotation' | 'TupleTypeAnnotation' | 'TypeofTypeAnnotation' | 'TypeAnnotation' | 'TypeParameter' | 'TypeParameterDeclaration' | 'TypeParameterInstantiation' | 'UnionTypeAnnotation' | 'Variance' | 'VoidTypeAnnotation' | 'JSXAttribute' | 'JSXClosingElement' | 'JSXExpressionContainer' | 'JSXSpreadChild' | 'JSXOpeningElement' | 'JSXText' | 'JSXOpeningFragment' | 'JSXClosingFragment' | 'ImportAttribute' | 'ImportDefaultSpecifier' | 'ImportNamespaceSpecifier' | 'ImportSpecifier' | 'InterpreterDirective' | 'JSXEmptyExpression' | 'JSXIdentifier' | 'JSXMemberExpression' | 'JSXNamespacedName' | 'JSXSpreadAttribute' | 'RestElement' | 'ObjectPattern' | 'TSParameterProperty' | 'LabeledStatement' | 'Noop' | 'ObjectProperty' | 'PipelineBareFunction' | 'PipelineTopicExpression' | 'Placeholder' | 'PrivateName' | 'SpreadElement' | 'TryStatement' | 'WithStatement' | 'TSImportEqualsDeclaration' | 'TSExportAssignment' | 'TSNamespaceExportDeclaration' | 'SwitchCase' | 'TSAnyKeyword' | 'TSArrayType' | 'TSBooleanKeyword' | 'TSBigIntKeyword' | 'TSIntrinsicKeyword' | 'TSNeverKeyword' | 'TSNullKeyword' | 'TSNumberKeyword' | 'TSObjectKeyword' | 'TSStringKeyword' | 'TSSymbolKeyword' | 'TSUndefinedKeyword' | 'TSUnknownKeyword' | 'TSVoidKeyword' | 'TSThisType' | 'TSLiteralType' | 'TSCallSignatureDeclaration' | 'TSConditionalType' | 'TSConstructSignatureDeclaration' | 'TSConstructorType' | 'TSDeclareMethod' | 'TSQualifiedName' | 'TSEnumMember' | 'TSExpressionWithTypeArguments' | 'TSExternalModuleReference' | 'TSFunctionType' | 'TSImportType' | 'TSIndexSignature' | 'TSIndexedAccessType' | 'TSInferType' | 'TSInterfaceBody' | 'TSIntersectionType' | 'TSMappedType' | 'TSMethodSignature' | 'TSNamedTupleMember' | 'TSOptionalType' | 'TSParenthesizedType' | 'TSPropertySignature' | 'TSRestType' | 'TSTupleType' | 'TSTypeReference' | 'TSTypePredicate' | 'TSTypeQuery' | 'TSTypeLiteral' | 'TSUnionType' | 'TSTypeOperator' | 'TSTypeAnnotation' | 'TSTypeParameter' | 'TSTypeParameterDeclaration' | 'TSTypeParameterInstantiation' | 'TemplateElement' | 'V8IntrinsicIdentifier' | 'VariableDeclarator' ]:? @babel/traverse.@babel/traverse.VisitNodeObject<S, std.Extract<@babel/types.@babel/types.Node, {  type :Type}>>}
      */ typings.babelTraverse.babelTraverseStrings.explode with TopLevel[js.Any] = js.native
    
    @JSImport("@babel/traverse", "visitors.merge")
    @js.native
    def merge[S](visitors: js.Array[Visitor[S]]): Visitor[_] = js.native
    @JSImport("@babel/traverse", "visitors.merge")
    @js.native
    def merge[S](visitors: js.Array[Visitor[S]], states: js.Array[S]): Visitor[_] = js.native
    
    @JSImport("@babel/traverse", "visitors.verify")
    @js.native
    def verify(visitor: Visitor[js.Object]): Unit = js.native
  }
  
  type ArrayKeys[T] = /* import warning: importer.ImportType#apply Failed type conversion: {[ P in keyof T ]: T[P] extends std.Array<any>? P : never}[keyof T] */ js.Any
  
  @js.native
  trait HubInterface extends StObject {
    
    def addHelper(name: String): js.Any = js.native
    
    def buildError[E /* <: Error */](node: Node, msg: String, Error: Instantiable1[/* message */ js.UndefOr[String], E]): E = js.native
    
    def getCode(): js.UndefOr[String] = js.native
    
    def getScope(): js.UndefOr[Scope] = js.native
  }
  object HubInterface {
    
    @scala.inline
    def apply(
      addHelper: String => js.Any,
      buildError: (Node, String, Instantiable1[/* message */ js.UndefOr[String], js.Any]) => js.Any,
      getCode: () => js.UndefOr[String],
      getScope: () => js.UndefOr[Scope]
    ): HubInterface = {
      val __obj = js.Dynamic.literal(addHelper = js.Any.fromFunction1(addHelper), buildError = js.Any.fromFunction3(buildError), getCode = js.Any.fromFunction0(getCode), getScope = js.Any.fromFunction0(getScope))
      __obj.asInstanceOf[HubInterface]
    }
    
    @scala.inline
    implicit class HubInterfaceMutableBuilder[Self <: HubInterface] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setAddHelper(value: String => js.Any): Self = StObject.set(x, "addHelper", js.Any.fromFunction1(value))
      
      @scala.inline
      def setBuildError(value: (Node, String, Instantiable1[/* message */ js.UndefOr[String], js.Any]) => js.Any): Self = StObject.set(x, "buildError", js.Any.fromFunction3(value))
      
      @scala.inline
      def setGetCode(value: () => js.UndefOr[String]): Self = StObject.set(x, "getCode", js.Any.fromFunction0(value))
      
      @scala.inline
      def setGetScope(value: () => js.UndefOr[Scope]): Self = StObject.set(x, "getScope", js.Any.fromFunction0(value))
    }
  }
  
  type NodePaths[T /* <: Node | js.Array[Node] */] = js.Array[NodePath[T]] | (/* import warning: importer.ImportType#apply c Unsupported type mapping: 
  {-readonly [ K in keyof T ]: @babel/traverse.@babel/traverse.NodePath<std.Extract<T[K], @babel/types.@babel/types.Node>>}
    */ typings.babelTraverse.babelTraverseStrings.NodePaths with TopLevel[T])
  
  @js.native
  trait TraversalContext extends StObject {
    
    var opts: js.Any = js.native
    
    var parentPath: NodePath[Node] = js.native
    
    var scope: Scope = js.native
    
    var state: js.Any = js.native
  }
  object TraversalContext {
    
    @scala.inline
    def apply(opts: js.Any, parentPath: NodePath[Node], scope: Scope, state: js.Any): TraversalContext = {
      val __obj = js.Dynamic.literal(opts = opts.asInstanceOf[js.Any], parentPath = parentPath.asInstanceOf[js.Any], scope = scope.asInstanceOf[js.Any], state = state.asInstanceOf[js.Any])
      __obj.asInstanceOf[TraversalContext]
    }
    
    @scala.inline
    implicit class TraversalContextMutableBuilder[Self <: TraversalContext] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setOpts(value: js.Any): Self = StObject.set(x, "opts", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setParentPath(value: NodePath[Node]): Self = StObject.set(x, "parentPath", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScope(value: Scope): Self = StObject.set(x, "scope", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setState(value: js.Any): Self = StObject.set(x, "state", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait TraverseOptions[S] extends Visitor[S] {
    
    var noScope: js.UndefOr[Boolean] = js.native
    
    var scope: js.UndefOr[Scope] = js.native
  }
  object TraverseOptions {
    
    @scala.inline
    def apply[S](): TraverseOptions[S] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[TraverseOptions[S]]
    }
    
    @scala.inline
    implicit class TraverseOptionsMutableBuilder[Self <: TraverseOptions[_], S] (val x: Self with TraverseOptions[S]) extends AnyVal {
      
      @scala.inline
      def setNoScope(value: Boolean): Self = StObject.set(x, "noScope", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNoScopeUndefined: Self = StObject.set(x, "noScope", js.undefined)
      
      @scala.inline
      def setScope(value: Scope): Self = StObject.set(x, "scope", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScopeUndefined: Self = StObject.set(x, "scope", js.undefined)
    }
  }
  
  type VisitNode[S, P /* <: Node */] = (VisitNodeFunction[S, P]) | (VisitNodeObject[S, P])
  
  type VisitNodeFunction[S, P /* <: Node */] = js.ThisFunction2[/* this */ S, /* path */ NodePath[P], /* state */ S, Unit]
  
  @js.native
  trait VisitNodeObject[S, P /* <: Node */] extends StObject {
    
    var enter: js.UndefOr[VisitNodeFunction[S, P]] = js.native
    
    var exit: js.UndefOr[VisitNodeFunction[S, P]] = js.native
  }
  object VisitNodeObject {
    
    @scala.inline
    def apply[S, P /* <: Node */](): VisitNodeObject[S, P] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[VisitNodeObject[S, P]]
    }
    
    @scala.inline
    implicit class VisitNodeObjectMutableBuilder[Self <: VisitNodeObject[_, _], S, P /* <: Node */] (val x: Self with (VisitNodeObject[S, P])) extends AnyVal {
      
      @scala.inline
      def setEnter(value: VisitNodeFunction[S, P]): Self = StObject.set(x, "enter", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnterUndefined: Self = StObject.set(x, "enter", js.undefined)
      
      @scala.inline
      def setExit(value: VisitNodeFunction[S, P]): Self = StObject.set(x, "exit", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExitUndefined: Self = StObject.set(x, "exit", js.undefined)
    }
  }
  
  /* Inlined @babel/traverse.@babel/traverse.VisitNodeObject<S, @babel/traverse.@babel/traverse.Node> & {[ Type in @babel/traverse.@babel/traverse.Node['type'] ]:? @babel/traverse.@babel/traverse.VisitNode<S, std.Extract<@babel/traverse.@babel/traverse.Node, {  type :Type}>>} & {[ K in keyof @babel/types.@babel/types.Aliases ]:? @babel/traverse.@babel/traverse.VisitNode<S, @babel/types.@babel/types.Aliases[K]>} */
  @js.native
  trait Visitor[S] extends StObject {
    
    var AnyTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `64`]]] = js.native
    
    var ArgumentPlaceholder: js.UndefOr[VisitNode[S, Extract[Node, `232`]]] = js.native
    
    var ArrayExpression: js.UndefOr[VisitNode[S, Extract[Node, `55`]]] = js.native
    
    var ArrayPattern: js.UndefOr[VisitNode[S, Extract[Node, `112`]]] = js.native
    
    var ArrayTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `84`]]] = js.native
    
    var ArrowFunctionExpression: js.UndefOr[VisitNode[S, Extract[Node, `143`]]] = js.native
    
    var AssignmentExpression: js.UndefOr[VisitNode[S, Extract[Node, `132`]]] = js.native
    
    var AssignmentPattern: js.UndefOr[VisitNode[S, Extract[Node, `63`]]] = js.native
    
    var AwaitExpression: js.UndefOr[VisitNode[S, Extract[Node, `110`]]] = js.native
    
    var BigIntLiteral: js.UndefOr[VisitNode[S, Extract[Node, `179`]]] = js.native
    
    var Binary: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Binary]] = js.native
    
    var BinaryExpression: js.UndefOr[VisitNode[S, Extract[Node, `87`]]] = js.native
    
    var BindExpression: js.UndefOr[VisitNode[S, Extract[Node, `77`]]] = js.native
    
    var Block: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Block]] = js.native
    
    var BlockParent: js.UndefOr[VisitNode[S, typings.babelTypes.mod.BlockParent]] = js.native
    
    var BlockStatement: js.UndefOr[VisitNode[S, Extract[Node, `24`]]] = js.native
    
    var BooleanLiteral: js.UndefOr[VisitNode[S, Extract[Node, `129`]]] = js.native
    
    var BooleanLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `173`]]] = js.native
    
    var BooleanTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `178`]]] = js.native
    
    var BreakStatement: js.UndefOr[VisitNode[S, Extract[Node, `1`]]] = js.native
    
    var CallExpression: js.UndefOr[VisitNode[S, Extract[Node, `46`]]] = js.native
    
    var CatchClause: js.UndefOr[VisitNode[S, Extract[Node, `171`]]] = js.native
    
    var Class: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Class]] = js.native
    
    var ClassBody: js.UndefOr[VisitNode[S, Extract[Node, `225`]]] = js.native
    
    var ClassDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `106`]]] = js.native
    
    var ClassExpression: js.UndefOr[VisitNode[S, Extract[Node, Type]]] = js.native
    
    var ClassImplements: js.UndefOr[VisitNode[S, Extract[Node, `207`]]] = js.native
    
    var ClassMethod: js.UndefOr[VisitNode[S, Extract[Node, `184`]]] = js.native
    
    var ClassPrivateMethod: js.UndefOr[VisitNode[S, Extract[Node, `228`]]] = js.native
    
    var ClassPrivateProperty: js.UndefOr[VisitNode[S, Extract[Node, `223`]]] = js.native
    
    var ClassProperty: js.UndefOr[VisitNode[S, Extract[Node, `187`]]] = js.native
    
    var CompletionStatement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.CompletionStatement]] = js.native
    
    var Conditional: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Conditional]] = js.native
    
    var ConditionalExpression: js.UndefOr[VisitNode[S, Extract[Node, `165`]]] = js.native
    
    var ContinueStatement: js.UndefOr[VisitNode[S, Extract[Node, `39`]]] = js.native
    
    var DebuggerStatement: js.UndefOr[VisitNode[S, Extract[Node, `135`]]] = js.native
    
    var DecimalLiteral: js.UndefOr[VisitNode[S, Extract[Node, `201`]]] = js.native
    
    var Declaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Declaration]] = js.native
    
    var DeclareClass: js.UndefOr[VisitNode[S, Extract[Node, `235`]]] = js.native
    
    var DeclareExportAllDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `107`]]] = js.native
    
    var DeclareExportDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `153`]]] = js.native
    
    var DeclareFunction: js.UndefOr[VisitNode[S, Extract[Node, `102`]]] = js.native
    
    var DeclareInterface: js.UndefOr[VisitNode[S, Extract[Node, `156`]]] = js.native
    
    var DeclareModule: js.UndefOr[VisitNode[S, Extract[Node, `34`]]] = js.native
    
    var DeclareModuleExports: js.UndefOr[VisitNode[S, Extract[Node, `216`]]] = js.native
    
    var DeclareOpaqueType: js.UndefOr[VisitNode[S, Extract[Node, `222`]]] = js.native
    
    var DeclareTypeAlias: js.UndefOr[VisitNode[S, Extract[Node, `162`]]] = js.native
    
    var DeclareVariable: js.UndefOr[VisitNode[S, Extract[Node, `177`]]] = js.native
    
    var DeclaredPredicate: js.UndefOr[VisitNode[S, Extract[Node, `183`]]] = js.native
    
    var Decorator: js.UndefOr[VisitNode[S, Extract[Node, `80`]]] = js.native
    
    var Directive: js.UndefOr[VisitNode[S, Extract[Node, `62`]]] = js.native
    
    var DirectiveLiteral: js.UndefOr[VisitNode[S, Extract[Node, `140`]]] = js.native
    
    var DoExpression: js.UndefOr[VisitNode[S, Extract[Node, `212`]]] = js.native
    
    var DoWhileStatement: js.UndefOr[VisitNode[S, Extract[Node, `195`]]] = js.native
    
    var EmptyStatement: js.UndefOr[VisitNode[S, Extract[Node, `105`]]] = js.native
    
    var EmptyTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `139`]]] = js.native
    
    var EnumBody: js.UndefOr[VisitNode[S, typings.babelTypes.mod.EnumBody]] = js.native
    
    var EnumBooleanBody: js.UndefOr[VisitNode[S, Extract[Node, `134`]]] = js.native
    
    var EnumBooleanMember: js.UndefOr[VisitNode[S, Extract[Node, `114`]]] = js.native
    
    var EnumDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `66`]]] = js.native
    
    var EnumDefaultedMember: js.UndefOr[VisitNode[S, Extract[Node, `186`]]] = js.native
    
    var EnumMember: js.UndefOr[VisitNode[S, typings.babelTypes.mod.EnumMember]] = js.native
    
    var EnumNumberBody: js.UndefOr[VisitNode[S, Extract[Node, `233`]]] = js.native
    
    var EnumNumberMember: js.UndefOr[VisitNode[S, Extract[Node, `200`]]] = js.native
    
    var EnumStringBody: js.UndefOr[VisitNode[S, Extract[Node, `158`]]] = js.native
    
    var EnumStringMember: js.UndefOr[VisitNode[S, Extract[Node, `4`]]] = js.native
    
    var EnumSymbolBody: js.UndefOr[VisitNode[S, Extract[Node, `193`]]] = js.native
    
    var ExistsTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `116`]]] = js.native
    
    var ExportAllDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `36`]]] = js.native
    
    var ExportDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ExportDeclaration]] = js.native
    
    var ExportDefaultDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `78`]]] = js.native
    
    var ExportDefaultSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `3`]]] = js.native
    
    var ExportNamedDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `45`]]] = js.native
    
    var ExportNamespaceSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `174`]]] = js.native
    
    var ExportSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `113`]]] = js.native
    
    var Expression: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Expression]] = js.native
    
    var ExpressionStatement: js.UndefOr[VisitNode[S, Extract[Node, `61`]]] = js.native
    
    var ExpressionWrapper: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ExpressionWrapper]] = js.native
    
    var File: js.UndefOr[VisitNode[S, Extract[Node, `27`]]] = js.native
    
    var Flow: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Flow]] = js.native
    
    var FlowBaseAnnotation: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowBaseAnnotation]] = js.native
    
    var FlowDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowDeclaration]] = js.native
    
    var FlowPredicate: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowPredicate]] = js.native
    
    var FlowType: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowType]] = js.native
    
    var For: js.UndefOr[VisitNode[S, typings.babelTypes.mod.For]] = js.native
    
    var ForInStatement: js.UndefOr[VisitNode[S, Extract[Node, `16`]]] = js.native
    
    var ForOfStatement: js.UndefOr[VisitNode[S, Extract[Node, `161`]]] = js.native
    
    var ForStatement: js.UndefOr[VisitNode[S, Extract[Node, `185`]]] = js.native
    
    var ForXStatement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ForXStatement]] = js.native
    
    var Function: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Function]] = js.native
    
    var FunctionDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `133`]]] = js.native
    
    var FunctionExpression: js.UndefOr[VisitNode[S, Extract[Node, `188`]]] = js.native
    
    var FunctionParent: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FunctionParent]] = js.native
    
    var FunctionTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `40`]]] = js.native
    
    var FunctionTypeParam: js.UndefOr[VisitNode[S, Extract[Node, `221`]]] = js.native
    
    var GenericTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `237`]]] = js.native
    
    var Identifier: js.UndefOr[VisitNode[S, Extract[Node, `97`]]] = js.native
    
    var IfStatement: js.UndefOr[VisitNode[S, Extract[Node, `83`]]] = js.native
    
    var Immutable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Immutable]] = js.native
    
    var Import: js.UndefOr[VisitNode[S, Extract[Node, `167`]]] = js.native
    
    var ImportAttribute: js.UndefOr[VisitNode[S, Extract[Node, `120`]]] = js.native
    
    var ImportDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `236`]]] = js.native
    
    var ImportDefaultSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `18`]]] = js.native
    
    var ImportNamespaceSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `197`]]] = js.native
    
    var ImportSpecifier: js.UndefOr[VisitNode[S, Extract[Node, `111`]]] = js.native
    
    var InferredPredicate: js.UndefOr[VisitNode[S, Extract[Node, `131`]]] = js.native
    
    var InterfaceDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `47`]]] = js.native
    
    var InterfaceExtends: js.UndefOr[VisitNode[S, Extract[Node, `136`]]] = js.native
    
    var InterfaceTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `8`]]] = js.native
    
    var InterpreterDirective: js.UndefOr[VisitNode[S, Extract[Node, `86`]]] = js.native
    
    var IntersectionTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `209`]]] = js.native
    
    var JSX: js.UndefOr[VisitNode[S, typings.babelTypes.mod.JSX]] = js.native
    
    var JSXAttribute: js.UndefOr[VisitNode[S, Extract[Node, `100`]]] = js.native
    
    var JSXClosingElement: js.UndefOr[VisitNode[S, Extract[Node, `126`]]] = js.native
    
    var JSXClosingFragment: js.UndefOr[VisitNode[S, Extract[Node, `206`]]] = js.native
    
    var JSXElement: js.UndefOr[VisitNode[S, Extract[Node, `169`]]] = js.native
    
    var JSXEmptyExpression: js.UndefOr[VisitNode[S, Extract[Node, `122`]]] = js.native
    
    var JSXExpressionContainer: js.UndefOr[VisitNode[S, Extract[Node, `31`]]] = js.native
    
    var JSXFragment: js.UndefOr[VisitNode[S, Extract[Node, `147`]]] = js.native
    
    var JSXIdentifier: js.UndefOr[VisitNode[S, Extract[Node, `85`]]] = js.native
    
    var JSXMemberExpression: js.UndefOr[VisitNode[S, Extract[Node, `192`]]] = js.native
    
    var JSXNamespacedName: js.UndefOr[VisitNode[S, Extract[Node, `149`]]] = js.native
    
    var JSXOpeningElement: js.UndefOr[VisitNode[S, Extract[Node, `72`]]] = js.native
    
    var JSXOpeningFragment: js.UndefOr[VisitNode[S, Extract[Node, `213`]]] = js.native
    
    var JSXSpreadAttribute: js.UndefOr[VisitNode[S, Extract[Node, `48`]]] = js.native
    
    var JSXSpreadChild: js.UndefOr[VisitNode[S, Extract[Node, `71`]]] = js.native
    
    var JSXText: js.UndefOr[VisitNode[S, Extract[Node, `190`]]] = js.native
    
    var LVal: js.UndefOr[VisitNode[S, typings.babelTypes.mod.LVal]] = js.native
    
    var LabeledStatement: js.UndefOr[VisitNode[S, Extract[Node, `35`]]] = js.native
    
    var Literal: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Literal]] = js.native
    
    var LogicalExpression: js.UndefOr[VisitNode[S, Extract[Node, `68`]]] = js.native
    
    var Loop: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Loop]] = js.native
    
    var MemberExpression: js.UndefOr[VisitNode[S, Extract[Node, `59`]]] = js.native
    
    var MetaProperty: js.UndefOr[VisitNode[S, Extract[Node, `81`]]] = js.native
    
    var Method: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Method]] = js.native
    
    var MixedTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `56`]]] = js.native
    
    var ModuleDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ModuleDeclaration]] = js.native
    
    var ModuleSpecifier: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ModuleSpecifier]] = js.native
    
    var NewExpression: js.UndefOr[VisitNode[S, Extract[Node, `58`]]] = js.native
    
    var Noop: js.UndefOr[VisitNode[S, Extract[Node, `33`]]] = js.native
    
    var NullLiteral: js.UndefOr[VisitNode[S, Extract[Node, `238`]]] = js.native
    
    var NullLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `42`]]] = js.native
    
    var NullableTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `96`]]] = js.native
    
    var NumberLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `152`]]] = js.native
    
    var NumberTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `159`]]] = js.native
    
    var NumericLiteral: js.UndefOr[VisitNode[S, Extract[Node, `210`]]] = js.native
    
    var ObjectExpression: js.UndefOr[VisitNode[S, Extract[Node, `121`]]] = js.native
    
    var ObjectMember: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ObjectMember]] = js.native
    
    var ObjectMethod: js.UndefOr[VisitNode[S, Extract[Node, `123`]]] = js.native
    
    var ObjectPattern: js.UndefOr[VisitNode[S, Extract[Node, `217`]]] = js.native
    
    var ObjectProperty: js.UndefOr[VisitNode[S, Extract[Node, `141`]]] = js.native
    
    var ObjectTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `82`]]] = js.native
    
    var ObjectTypeCallProperty: js.UndefOr[VisitNode[S, Extract[Node, `12`]]] = js.native
    
    var ObjectTypeIndexer: js.UndefOr[VisitNode[S, Extract[Node, `170`]]] = js.native
    
    var ObjectTypeInternalSlot: js.UndefOr[VisitNode[S, Extract[Node, `226`]]] = js.native
    
    var ObjectTypeProperty: js.UndefOr[VisitNode[S, Extract[Node, `154`]]] = js.native
    
    var ObjectTypeSpreadProperty: js.UndefOr[VisitNode[S, Extract[Node, `79`]]] = js.native
    
    var OpaqueType: js.UndefOr[VisitNode[S, Extract[Node, `69`]]] = js.native
    
    var OptionalCallExpression: js.UndefOr[VisitNode[S, Extract[Node, `44`]]] = js.native
    
    var OptionalMemberExpression: js.UndefOr[VisitNode[S, Extract[Node, `26`]]] = js.native
    
    var ParenthesizedExpression: js.UndefOr[VisitNode[S, Extract[Node, `199`]]] = js.native
    
    var Pattern: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Pattern]] = js.native
    
    var PatternLike: js.UndefOr[VisitNode[S, typings.babelTypes.mod.PatternLike]] = js.native
    
    var PipelineBareFunction: js.UndefOr[VisitNode[S, Extract[Node, `157`]]] = js.native
    
    var PipelinePrimaryTopicReference: js.UndefOr[VisitNode[S, Extract[Node, `30`]]] = js.native
    
    var PipelineTopicExpression: js.UndefOr[VisitNode[S, Extract[Node, `103`]]] = js.native
    
    var Placeholder: js.UndefOr[VisitNode[S, Extract[Node, `163`]]] = js.native
    
    var Private: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Private]] = js.native
    
    var PrivateName: js.UndefOr[VisitNode[S, Extract[Node, `93`]]] = js.native
    
    var Program: js.UndefOr[VisitNode[S, Extract[Node, `150`]]] = js.native
    
    var Property: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Property]] = js.native
    
    var Pureish: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Pureish]] = js.native
    
    var QualifiedTypeIdentifier: js.UndefOr[VisitNode[S, Extract[Node, `73`]]] = js.native
    
    var RecordExpression: js.UndefOr[VisitNode[S, Extract[Node, `60`]]] = js.native
    
    var RegExpLiteral: js.UndefOr[VisitNode[S, Extract[Node, `37`]]] = js.native
    
    var RestElement: js.UndefOr[VisitNode[S, Extract[Node, `25`]]] = js.native
    
    var ReturnStatement: js.UndefOr[VisitNode[S, Extract[Node, `5`]]] = js.native
    
    var Scopable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Scopable]] = js.native
    
    var SequenceExpression: js.UndefOr[VisitNode[S, Extract[Node, `166`]]] = js.native
    
    var SpreadElement: js.UndefOr[VisitNode[S, Extract[Node, `22`]]] = js.native
    
    var Statement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Statement]] = js.native
    
    var StaticBlock: js.UndefOr[VisitNode[S, Extract[Node, `108`]]] = js.native
    
    var StringLiteral: js.UndefOr[VisitNode[S, Extract[Node, `128`]]] = js.native
    
    var StringLiteralTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `219`]]] = js.native
    
    var StringTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `2`]]] = js.native
    
    var Super: js.UndefOr[VisitNode[S, Extract[Node, `160`]]] = js.native
    
    var SwitchCase: js.UndefOr[VisitNode[S, Extract[Node, `53`]]] = js.native
    
    var SwitchStatement: js.UndefOr[VisitNode[S, Extract[Node, `43`]]] = js.native
    
    var SymbolTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `49`]]] = js.native
    
    var TSAnyKeyword: js.UndefOr[VisitNode[S, Extract[Node, `9`]]] = js.native
    
    var TSArrayType: js.UndefOr[VisitNode[S, Extract[Node, `0`]]] = js.native
    
    var TSAsExpression: js.UndefOr[VisitNode[S, Extract[Node, `7`]]] = js.native
    
    var TSBaseType: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSBaseType]] = js.native
    
    var TSBigIntKeyword: js.UndefOr[VisitNode[S, Extract[Node, `52`]]] = js.native
    
    var TSBooleanKeyword: js.UndefOr[VisitNode[S, Extract[Node, `218`]]] = js.native
    
    var TSCallSignatureDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `146`]]] = js.native
    
    var TSConditionalType: js.UndefOr[VisitNode[S, Extract[Node, `17`]]] = js.native
    
    var TSConstructSignatureDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `119`]]] = js.native
    
    var TSConstructorType: js.UndefOr[VisitNode[S, Extract[Node, `208`]]] = js.native
    
    var TSDeclareFunction: js.UndefOr[VisitNode[S, Extract[Node, `196`]]] = js.native
    
    var TSDeclareMethod: js.UndefOr[VisitNode[S, Extract[Node, `75`]]] = js.native
    
    var TSEntityName: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSEntityName]] = js.native
    
    var TSEnumDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `89`]]] = js.native
    
    var TSEnumMember: js.UndefOr[VisitNode[S, Extract[Node, `130`]]] = js.native
    
    var TSExportAssignment: js.UndefOr[VisitNode[S, Extract[Node, `142`]]] = js.native
    
    var TSExpressionWithTypeArguments: js.UndefOr[VisitNode[S, Extract[Node, `144`]]] = js.native
    
    var TSExternalModuleReference: js.UndefOr[VisitNode[S, Extract[Node, `118`]]] = js.native
    
    var TSFunctionType: js.UndefOr[VisitNode[S, Extract[Node, `41`]]] = js.native
    
    var TSImportEqualsDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `155`]]] = js.native
    
    var TSImportType: js.UndefOr[VisitNode[S, Extract[Node, `234`]]] = js.native
    
    var TSIndexSignature: js.UndefOr[VisitNode[S, Extract[Node, `202`]]] = js.native
    
    var TSIndexedAccessType: js.UndefOr[VisitNode[S, Extract[Node, `28`]]] = js.native
    
    var TSInferType: js.UndefOr[VisitNode[S, Extract[Node, `101`]]] = js.native
    
    var TSInterfaceBody: js.UndefOr[VisitNode[S, Extract[Node, `6`]]] = js.native
    
    var TSInterfaceDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `182`]]] = js.native
    
    var TSIntersectionType: js.UndefOr[VisitNode[S, Extract[Node, `231`]]] = js.native
    
    var TSIntrinsicKeyword: js.UndefOr[VisitNode[S, Extract[Node, `65`]]] = js.native
    
    var TSLiteralType: js.UndefOr[VisitNode[S, Extract[Node, `19`]]] = js.native
    
    var TSMappedType: js.UndefOr[VisitNode[S, Extract[Node, `125`]]] = js.native
    
    var TSMethodSignature: js.UndefOr[VisitNode[S, Extract[Node, `198`]]] = js.native
    
    var TSModuleBlock: js.UndefOr[VisitNode[S, Extract[Node, `224`]]] = js.native
    
    var TSModuleDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `15`]]] = js.native
    
    var TSNamedTupleMember: js.UndefOr[VisitNode[S, Extract[Node, `215`]]] = js.native
    
    var TSNamespaceExportDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `88`]]] = js.native
    
    var TSNeverKeyword: js.UndefOr[VisitNode[S, Extract[Node, `230`]]] = js.native
    
    var TSNonNullExpression: js.UndefOr[VisitNode[S, Extract[Node, `95`]]] = js.native
    
    var TSNullKeyword: js.UndefOr[VisitNode[S, Extract[Node, `32`]]] = js.native
    
    var TSNumberKeyword: js.UndefOr[VisitNode[S, Extract[Node, `176`]]] = js.native
    
    var TSObjectKeyword: js.UndefOr[VisitNode[S, Extract[Node, `211`]]] = js.native
    
    var TSOptionalType: js.UndefOr[VisitNode[S, Extract[Node, `180`]]] = js.native
    
    var TSParameterProperty: js.UndefOr[VisitNode[S, Extract[Node, `191`]]] = js.native
    
    var TSParenthesizedType: js.UndefOr[VisitNode[S, Extract[Node, `220`]]] = js.native
    
    var TSPropertySignature: js.UndefOr[VisitNode[S, Extract[Node, `115`]]] = js.native
    
    var TSQualifiedName: js.UndefOr[VisitNode[S, Extract[Node, `29`]]] = js.native
    
    var TSRestType: js.UndefOr[VisitNode[S, Extract[Node, `205`]]] = js.native
    
    var TSStringKeyword: js.UndefOr[VisitNode[S, Extract[Node, `99`]]] = js.native
    
    var TSSymbolKeyword: js.UndefOr[VisitNode[S, Extract[Node, `124`]]] = js.native
    
    var TSThisType: js.UndefOr[VisitNode[S, Extract[Node, `203`]]] = js.native
    
    var TSTupleType: js.UndefOr[VisitNode[S, Extract[Node, `194`]]] = js.native
    
    var TSType: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSType]] = js.native
    
    var TSTypeAliasDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `90`]]] = js.native
    
    var TSTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `109`]]] = js.native
    
    var TSTypeAssertion: js.UndefOr[VisitNode[S, Extract[Node, `229`]]] = js.native
    
    var TSTypeElement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.TSTypeElement]] = js.native
    
    var TSTypeLiteral: js.UndefOr[VisitNode[S, Extract[Node, `151`]]] = js.native
    
    var TSTypeOperator: js.UndefOr[VisitNode[S, Extract[Node, `51`]]] = js.native
    
    var TSTypeParameter: js.UndefOr[VisitNode[S, Extract[Node, `92`]]] = js.native
    
    var TSTypeParameterDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `20`]]] = js.native
    
    var TSTypeParameterInstantiation: js.UndefOr[VisitNode[S, Extract[Node, `74`]]] = js.native
    
    var TSTypePredicate: js.UndefOr[VisitNode[S, Extract[Node, `181`]]] = js.native
    
    var TSTypeQuery: js.UndefOr[VisitNode[S, Extract[Node, `117`]]] = js.native
    
    var TSTypeReference: js.UndefOr[VisitNode[S, Extract[Node, `240`]]] = js.native
    
    var TSUndefinedKeyword: js.UndefOr[VisitNode[S, Extract[Node, `164`]]] = js.native
    
    var TSUnionType: js.UndefOr[VisitNode[S, Extract[Node, `91`]]] = js.native
    
    var TSUnknownKeyword: js.UndefOr[VisitNode[S, Extract[Node, `54`]]] = js.native
    
    var TSVoidKeyword: js.UndefOr[VisitNode[S, Extract[Node, `57`]]] = js.native
    
    var TaggedTemplateExpression: js.UndefOr[VisitNode[S, Extract[Node, `70`]]] = js.native
    
    var TemplateElement: js.UndefOr[VisitNode[S, Extract[Node, `189`]]] = js.native
    
    var TemplateLiteral: js.UndefOr[VisitNode[S, Extract[Node, `76`]]] = js.native
    
    var Terminatorless: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Terminatorless]] = js.native
    
    var ThisExpression: js.UndefOr[VisitNode[S, Extract[Node, `227`]]] = js.native
    
    var ThisTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `50`]]] = js.native
    
    var ThrowStatement: js.UndefOr[VisitNode[S, Extract[Node, `137`]]] = js.native
    
    var TryStatement: js.UndefOr[VisitNode[S, Extract[Node, `23`]]] = js.native
    
    var TupleExpression: js.UndefOr[VisitNode[S, Extract[Node, `204`]]] = js.native
    
    var TupleTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `13`]]] = js.native
    
    var TypeAlias: js.UndefOr[VisitNode[S, Extract[Node, `175`]]] = js.native
    
    var TypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `21`]]] = js.native
    
    var TypeCastExpression: js.UndefOr[VisitNode[S, Extract[Node, `10`]]] = js.native
    
    var TypeParameter: js.UndefOr[VisitNode[S, Extract[Node, `168`]]] = js.native
    
    var TypeParameterDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `14`]]] = js.native
    
    var TypeParameterInstantiation: js.UndefOr[VisitNode[S, Extract[Node, `239`]]] = js.native
    
    var TypeofTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `145`]]] = js.native
    
    var UnaryExpression: js.UndefOr[VisitNode[S, Extract[Node, `172`]]] = js.native
    
    var UnaryLike: js.UndefOr[VisitNode[S, typings.babelTypes.mod.UnaryLike]] = js.native
    
    var UnionTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `214`]]] = js.native
    
    var UpdateExpression: js.UndefOr[VisitNode[S, Extract[Node, `98`]]] = js.native
    
    var UserWhitespacable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.UserWhitespacable]] = js.native
    
    var V8IntrinsicIdentifier: js.UndefOr[VisitNode[S, Extract[Node, `138`]]] = js.native
    
    var VariableDeclaration: js.UndefOr[VisitNode[S, Extract[Node, `67`]]] = js.native
    
    var VariableDeclarator: js.UndefOr[VisitNode[S, Extract[Node, `127`]]] = js.native
    
    var Variance: js.UndefOr[VisitNode[S, Extract[Node, `148`]]] = js.native
    
    var VoidTypeAnnotation: js.UndefOr[VisitNode[S, Extract[Node, `104`]]] = js.native
    
    var While: js.UndefOr[VisitNode[S, typings.babelTypes.mod.While]] = js.native
    
    var WhileStatement: js.UndefOr[VisitNode[S, Extract[Node, `38`]]] = js.native
    
    var WithStatement: js.UndefOr[VisitNode[S, Extract[Node, `94`]]] = js.native
    
    var YieldExpression: js.UndefOr[VisitNode[S, Extract[Node, `11`]]] = js.native
    
    var enter: js.UndefOr[VisitNodeFunction[S, Node]] = js.native
    
    var exit: js.UndefOr[VisitNodeFunction[S, Node]] = js.native
  }
  object Visitor {
    
    @scala.inline
    def apply[S](): Visitor[S] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Visitor[S]]
    }
    
    @scala.inline
    implicit class VisitorMutableBuilder[Self <: Visitor[_], S] (val x: Self with Visitor[S]) extends AnyVal {
      
      @scala.inline
      def setAnyTypeAnnotation(value: VisitNode[S, Extract[Node, `64`]]): Self = StObject.set(x, "AnyTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAnyTypeAnnotationUndefined: Self = StObject.set(x, "AnyTypeAnnotation", js.undefined)
      
      @scala.inline
      def setArgumentPlaceholder(value: VisitNode[S, Extract[Node, `232`]]): Self = StObject.set(x, "ArgumentPlaceholder", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArgumentPlaceholderUndefined: Self = StObject.set(x, "ArgumentPlaceholder", js.undefined)
      
      @scala.inline
      def setArrayExpression(value: VisitNode[S, Extract[Node, `55`]]): Self = StObject.set(x, "ArrayExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArrayExpressionUndefined: Self = StObject.set(x, "ArrayExpression", js.undefined)
      
      @scala.inline
      def setArrayPattern(value: VisitNode[S, Extract[Node, `112`]]): Self = StObject.set(x, "ArrayPattern", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArrayPatternUndefined: Self = StObject.set(x, "ArrayPattern", js.undefined)
      
      @scala.inline
      def setArrayTypeAnnotation(value: VisitNode[S, Extract[Node, `84`]]): Self = StObject.set(x, "ArrayTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArrayTypeAnnotationUndefined: Self = StObject.set(x, "ArrayTypeAnnotation", js.undefined)
      
      @scala.inline
      def setArrowFunctionExpression(value: VisitNode[S, Extract[Node, `143`]]): Self = StObject.set(x, "ArrowFunctionExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArrowFunctionExpressionUndefined: Self = StObject.set(x, "ArrowFunctionExpression", js.undefined)
      
      @scala.inline
      def setAssignmentExpression(value: VisitNode[S, Extract[Node, `132`]]): Self = StObject.set(x, "AssignmentExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAssignmentExpressionUndefined: Self = StObject.set(x, "AssignmentExpression", js.undefined)
      
      @scala.inline
      def setAssignmentPattern(value: VisitNode[S, Extract[Node, `63`]]): Self = StObject.set(x, "AssignmentPattern", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAssignmentPatternUndefined: Self = StObject.set(x, "AssignmentPattern", js.undefined)
      
      @scala.inline
      def setAwaitExpression(value: VisitNode[S, Extract[Node, `110`]]): Self = StObject.set(x, "AwaitExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAwaitExpressionUndefined: Self = StObject.set(x, "AwaitExpression", js.undefined)
      
      @scala.inline
      def setBigIntLiteral(value: VisitNode[S, Extract[Node, `179`]]): Self = StObject.set(x, "BigIntLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBigIntLiteralUndefined: Self = StObject.set(x, "BigIntLiteral", js.undefined)
      
      @scala.inline
      def setBinary(value: VisitNode[S, Binary]): Self = StObject.set(x, "Binary", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBinaryExpression(value: VisitNode[S, Extract[Node, `87`]]): Self = StObject.set(x, "BinaryExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBinaryExpressionUndefined: Self = StObject.set(x, "BinaryExpression", js.undefined)
      
      @scala.inline
      def setBinaryUndefined: Self = StObject.set(x, "Binary", js.undefined)
      
      @scala.inline
      def setBindExpression(value: VisitNode[S, Extract[Node, `77`]]): Self = StObject.set(x, "BindExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBindExpressionUndefined: Self = StObject.set(x, "BindExpression", js.undefined)
      
      @scala.inline
      def setBlock(value: VisitNode[S, Block]): Self = StObject.set(x, "Block", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBlockParent(value: VisitNode[S, BlockParent]): Self = StObject.set(x, "BlockParent", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBlockParentUndefined: Self = StObject.set(x, "BlockParent", js.undefined)
      
      @scala.inline
      def setBlockStatement(value: VisitNode[S, Extract[Node, `24`]]): Self = StObject.set(x, "BlockStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBlockStatementUndefined: Self = StObject.set(x, "BlockStatement", js.undefined)
      
      @scala.inline
      def setBlockUndefined: Self = StObject.set(x, "Block", js.undefined)
      
      @scala.inline
      def setBooleanLiteral(value: VisitNode[S, Extract[Node, `129`]]): Self = StObject.set(x, "BooleanLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBooleanLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `173`]]): Self = StObject.set(x, "BooleanLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBooleanLiteralTypeAnnotationUndefined: Self = StObject.set(x, "BooleanLiteralTypeAnnotation", js.undefined)
      
      @scala.inline
      def setBooleanLiteralUndefined: Self = StObject.set(x, "BooleanLiteral", js.undefined)
      
      @scala.inline
      def setBooleanTypeAnnotation(value: VisitNode[S, Extract[Node, `178`]]): Self = StObject.set(x, "BooleanTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBooleanTypeAnnotationUndefined: Self = StObject.set(x, "BooleanTypeAnnotation", js.undefined)
      
      @scala.inline
      def setBreakStatement(value: VisitNode[S, Extract[Node, `1`]]): Self = StObject.set(x, "BreakStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBreakStatementUndefined: Self = StObject.set(x, "BreakStatement", js.undefined)
      
      @scala.inline
      def setCallExpression(value: VisitNode[S, Extract[Node, `46`]]): Self = StObject.set(x, "CallExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCallExpressionUndefined: Self = StObject.set(x, "CallExpression", js.undefined)
      
      @scala.inline
      def setCatchClause(value: VisitNode[S, Extract[Node, `171`]]): Self = StObject.set(x, "CatchClause", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCatchClauseUndefined: Self = StObject.set(x, "CatchClause", js.undefined)
      
      @scala.inline
      def setClass(value: VisitNode[S, Class]): Self = StObject.set(x, "Class", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassBody(value: VisitNode[S, Extract[Node, `225`]]): Self = StObject.set(x, "ClassBody", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassBodyUndefined: Self = StObject.set(x, "ClassBody", js.undefined)
      
      @scala.inline
      def setClassDeclaration(value: VisitNode[S, Extract[Node, `106`]]): Self = StObject.set(x, "ClassDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassDeclarationUndefined: Self = StObject.set(x, "ClassDeclaration", js.undefined)
      
      @scala.inline
      def setClassExpression(value: VisitNode[S, Extract[Node, Type]]): Self = StObject.set(x, "ClassExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassExpressionUndefined: Self = StObject.set(x, "ClassExpression", js.undefined)
      
      @scala.inline
      def setClassImplements(value: VisitNode[S, Extract[Node, `207`]]): Self = StObject.set(x, "ClassImplements", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassImplementsUndefined: Self = StObject.set(x, "ClassImplements", js.undefined)
      
      @scala.inline
      def setClassMethod(value: VisitNode[S, Extract[Node, `184`]]): Self = StObject.set(x, "ClassMethod", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassMethodUndefined: Self = StObject.set(x, "ClassMethod", js.undefined)
      
      @scala.inline
      def setClassPrivateMethod(value: VisitNode[S, Extract[Node, `228`]]): Self = StObject.set(x, "ClassPrivateMethod", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassPrivateMethodUndefined: Self = StObject.set(x, "ClassPrivateMethod", js.undefined)
      
      @scala.inline
      def setClassPrivateProperty(value: VisitNode[S, Extract[Node, `223`]]): Self = StObject.set(x, "ClassPrivateProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassPrivatePropertyUndefined: Self = StObject.set(x, "ClassPrivateProperty", js.undefined)
      
      @scala.inline
      def setClassProperty(value: VisitNode[S, Extract[Node, `187`]]): Self = StObject.set(x, "ClassProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassPropertyUndefined: Self = StObject.set(x, "ClassProperty", js.undefined)
      
      @scala.inline
      def setClassUndefined: Self = StObject.set(x, "Class", js.undefined)
      
      @scala.inline
      def setCompletionStatement(value: VisitNode[S, CompletionStatement]): Self = StObject.set(x, "CompletionStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCompletionStatementUndefined: Self = StObject.set(x, "CompletionStatement", js.undefined)
      
      @scala.inline
      def setConditional(value: VisitNode[S, Conditional]): Self = StObject.set(x, "Conditional", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setConditionalExpression(value: VisitNode[S, Extract[Node, `165`]]): Self = StObject.set(x, "ConditionalExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setConditionalExpressionUndefined: Self = StObject.set(x, "ConditionalExpression", js.undefined)
      
      @scala.inline
      def setConditionalUndefined: Self = StObject.set(x, "Conditional", js.undefined)
      
      @scala.inline
      def setContinueStatement(value: VisitNode[S, Extract[Node, `39`]]): Self = StObject.set(x, "ContinueStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setContinueStatementUndefined: Self = StObject.set(x, "ContinueStatement", js.undefined)
      
      @scala.inline
      def setDebuggerStatement(value: VisitNode[S, Extract[Node, `135`]]): Self = StObject.set(x, "DebuggerStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDebuggerStatementUndefined: Self = StObject.set(x, "DebuggerStatement", js.undefined)
      
      @scala.inline
      def setDecimalLiteral(value: VisitNode[S, Extract[Node, `201`]]): Self = StObject.set(x, "DecimalLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDecimalLiteralUndefined: Self = StObject.set(x, "DecimalLiteral", js.undefined)
      
      @scala.inline
      def setDeclaration(value: VisitNode[S, Declaration]): Self = StObject.set(x, "Declaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclarationUndefined: Self = StObject.set(x, "Declaration", js.undefined)
      
      @scala.inline
      def setDeclareClass(value: VisitNode[S, Extract[Node, `235`]]): Self = StObject.set(x, "DeclareClass", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareClassUndefined: Self = StObject.set(x, "DeclareClass", js.undefined)
      
      @scala.inline
      def setDeclareExportAllDeclaration(value: VisitNode[S, Extract[Node, `107`]]): Self = StObject.set(x, "DeclareExportAllDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareExportAllDeclarationUndefined: Self = StObject.set(x, "DeclareExportAllDeclaration", js.undefined)
      
      @scala.inline
      def setDeclareExportDeclaration(value: VisitNode[S, Extract[Node, `153`]]): Self = StObject.set(x, "DeclareExportDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareExportDeclarationUndefined: Self = StObject.set(x, "DeclareExportDeclaration", js.undefined)
      
      @scala.inline
      def setDeclareFunction(value: VisitNode[S, Extract[Node, `102`]]): Self = StObject.set(x, "DeclareFunction", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareFunctionUndefined: Self = StObject.set(x, "DeclareFunction", js.undefined)
      
      @scala.inline
      def setDeclareInterface(value: VisitNode[S, Extract[Node, `156`]]): Self = StObject.set(x, "DeclareInterface", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareInterfaceUndefined: Self = StObject.set(x, "DeclareInterface", js.undefined)
      
      @scala.inline
      def setDeclareModule(value: VisitNode[S, Extract[Node, `34`]]): Self = StObject.set(x, "DeclareModule", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareModuleExports(value: VisitNode[S, Extract[Node, `216`]]): Self = StObject.set(x, "DeclareModuleExports", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareModuleExportsUndefined: Self = StObject.set(x, "DeclareModuleExports", js.undefined)
      
      @scala.inline
      def setDeclareModuleUndefined: Self = StObject.set(x, "DeclareModule", js.undefined)
      
      @scala.inline
      def setDeclareOpaqueType(value: VisitNode[S, Extract[Node, `222`]]): Self = StObject.set(x, "DeclareOpaqueType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareOpaqueTypeUndefined: Self = StObject.set(x, "DeclareOpaqueType", js.undefined)
      
      @scala.inline
      def setDeclareTypeAlias(value: VisitNode[S, Extract[Node, `162`]]): Self = StObject.set(x, "DeclareTypeAlias", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareTypeAliasUndefined: Self = StObject.set(x, "DeclareTypeAlias", js.undefined)
      
      @scala.inline
      def setDeclareVariable(value: VisitNode[S, Extract[Node, `177`]]): Self = StObject.set(x, "DeclareVariable", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareVariableUndefined: Self = StObject.set(x, "DeclareVariable", js.undefined)
      
      @scala.inline
      def setDeclaredPredicate(value: VisitNode[S, Extract[Node, `183`]]): Self = StObject.set(x, "DeclaredPredicate", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclaredPredicateUndefined: Self = StObject.set(x, "DeclaredPredicate", js.undefined)
      
      @scala.inline
      def setDecorator(value: VisitNode[S, Extract[Node, `80`]]): Self = StObject.set(x, "Decorator", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDecoratorUndefined: Self = StObject.set(x, "Decorator", js.undefined)
      
      @scala.inline
      def setDirective(value: VisitNode[S, Extract[Node, `62`]]): Self = StObject.set(x, "Directive", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDirectiveLiteral(value: VisitNode[S, Extract[Node, `140`]]): Self = StObject.set(x, "DirectiveLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDirectiveLiteralUndefined: Self = StObject.set(x, "DirectiveLiteral", js.undefined)
      
      @scala.inline
      def setDirectiveUndefined: Self = StObject.set(x, "Directive", js.undefined)
      
      @scala.inline
      def setDoExpression(value: VisitNode[S, Extract[Node, `212`]]): Self = StObject.set(x, "DoExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDoExpressionUndefined: Self = StObject.set(x, "DoExpression", js.undefined)
      
      @scala.inline
      def setDoWhileStatement(value: VisitNode[S, Extract[Node, `195`]]): Self = StObject.set(x, "DoWhileStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDoWhileStatementUndefined: Self = StObject.set(x, "DoWhileStatement", js.undefined)
      
      @scala.inline
      def setEmptyStatement(value: VisitNode[S, Extract[Node, `105`]]): Self = StObject.set(x, "EmptyStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEmptyStatementUndefined: Self = StObject.set(x, "EmptyStatement", js.undefined)
      
      @scala.inline
      def setEmptyTypeAnnotation(value: VisitNode[S, Extract[Node, `139`]]): Self = StObject.set(x, "EmptyTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEmptyTypeAnnotationUndefined: Self = StObject.set(x, "EmptyTypeAnnotation", js.undefined)
      
      @scala.inline
      def setEnter(value: VisitNodeFunction[S, Node]): Self = StObject.set(x, "enter", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnterUndefined: Self = StObject.set(x, "enter", js.undefined)
      
      @scala.inline
      def setEnumBody(value: VisitNode[S, EnumBody]): Self = StObject.set(x, "EnumBody", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnumBodyUndefined: Self = StObject.set(x, "EnumBody", js.undefined)
      
      @scala.inline
      def setEnumBooleanBody(value: VisitNode[S, Extract[Node, `134`]]): Self = StObject.set(x, "EnumBooleanBody", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnumBooleanBodyUndefined: Self = StObject.set(x, "EnumBooleanBody", js.undefined)
      
      @scala.inline
      def setEnumBooleanMember(value: VisitNode[S, Extract[Node, `114`]]): Self = StObject.set(x, "EnumBooleanMember", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnumBooleanMemberUndefined: Self = StObject.set(x, "EnumBooleanMember", js.undefined)
      
      @scala.inline
      def setEnumDeclaration(value: VisitNode[S, Extract[Node, `66`]]): Self = StObject.set(x, "EnumDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnumDeclarationUndefined: Self = StObject.set(x, "EnumDeclaration", js.undefined)
      
      @scala.inline
      def setEnumDefaultedMember(value: VisitNode[S, Extract[Node, `186`]]): Self = StObject.set(x, "EnumDefaultedMember", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnumDefaultedMemberUndefined: Self = StObject.set(x, "EnumDefaultedMember", js.undefined)
      
      @scala.inline
      def setEnumMember(value: VisitNode[S, EnumMember]): Self = StObject.set(x, "EnumMember", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnumMemberUndefined: Self = StObject.set(x, "EnumMember", js.undefined)
      
      @scala.inline
      def setEnumNumberBody(value: VisitNode[S, Extract[Node, `233`]]): Self = StObject.set(x, "EnumNumberBody", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnumNumberBodyUndefined: Self = StObject.set(x, "EnumNumberBody", js.undefined)
      
      @scala.inline
      def setEnumNumberMember(value: VisitNode[S, Extract[Node, `200`]]): Self = StObject.set(x, "EnumNumberMember", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnumNumberMemberUndefined: Self = StObject.set(x, "EnumNumberMember", js.undefined)
      
      @scala.inline
      def setEnumStringBody(value: VisitNode[S, Extract[Node, `158`]]): Self = StObject.set(x, "EnumStringBody", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnumStringBodyUndefined: Self = StObject.set(x, "EnumStringBody", js.undefined)
      
      @scala.inline
      def setEnumStringMember(value: VisitNode[S, Extract[Node, `4`]]): Self = StObject.set(x, "EnumStringMember", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnumStringMemberUndefined: Self = StObject.set(x, "EnumStringMember", js.undefined)
      
      @scala.inline
      def setEnumSymbolBody(value: VisitNode[S, Extract[Node, `193`]]): Self = StObject.set(x, "EnumSymbolBody", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEnumSymbolBodyUndefined: Self = StObject.set(x, "EnumSymbolBody", js.undefined)
      
      @scala.inline
      def setExistsTypeAnnotation(value: VisitNode[S, Extract[Node, `116`]]): Self = StObject.set(x, "ExistsTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExistsTypeAnnotationUndefined: Self = StObject.set(x, "ExistsTypeAnnotation", js.undefined)
      
      @scala.inline
      def setExit(value: VisitNodeFunction[S, Node]): Self = StObject.set(x, "exit", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExitUndefined: Self = StObject.set(x, "exit", js.undefined)
      
      @scala.inline
      def setExportAllDeclaration(value: VisitNode[S, Extract[Node, `36`]]): Self = StObject.set(x, "ExportAllDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportAllDeclarationUndefined: Self = StObject.set(x, "ExportAllDeclaration", js.undefined)
      
      @scala.inline
      def setExportDeclaration(value: VisitNode[S, ExportDeclaration]): Self = StObject.set(x, "ExportDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportDeclarationUndefined: Self = StObject.set(x, "ExportDeclaration", js.undefined)
      
      @scala.inline
      def setExportDefaultDeclaration(value: VisitNode[S, Extract[Node, `78`]]): Self = StObject.set(x, "ExportDefaultDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportDefaultDeclarationUndefined: Self = StObject.set(x, "ExportDefaultDeclaration", js.undefined)
      
      @scala.inline
      def setExportDefaultSpecifier(value: VisitNode[S, Extract[Node, `3`]]): Self = StObject.set(x, "ExportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportDefaultSpecifierUndefined: Self = StObject.set(x, "ExportDefaultSpecifier", js.undefined)
      
      @scala.inline
      def setExportNamedDeclaration(value: VisitNode[S, Extract[Node, `45`]]): Self = StObject.set(x, "ExportNamedDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportNamedDeclarationUndefined: Self = StObject.set(x, "ExportNamedDeclaration", js.undefined)
      
      @scala.inline
      def setExportNamespaceSpecifier(value: VisitNode[S, Extract[Node, `174`]]): Self = StObject.set(x, "ExportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportNamespaceSpecifierUndefined: Self = StObject.set(x, "ExportNamespaceSpecifier", js.undefined)
      
      @scala.inline
      def setExportSpecifier(value: VisitNode[S, Extract[Node, `113`]]): Self = StObject.set(x, "ExportSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportSpecifierUndefined: Self = StObject.set(x, "ExportSpecifier", js.undefined)
      
      @scala.inline
      def setExpression(value: VisitNode[S, Expression]): Self = StObject.set(x, "Expression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExpressionStatement(value: VisitNode[S, Extract[Node, `61`]]): Self = StObject.set(x, "ExpressionStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExpressionStatementUndefined: Self = StObject.set(x, "ExpressionStatement", js.undefined)
      
      @scala.inline
      def setExpressionUndefined: Self = StObject.set(x, "Expression", js.undefined)
      
      @scala.inline
      def setExpressionWrapper(value: VisitNode[S, ExpressionWrapper]): Self = StObject.set(x, "ExpressionWrapper", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExpressionWrapperUndefined: Self = StObject.set(x, "ExpressionWrapper", js.undefined)
      
      @scala.inline
      def setFile(value: VisitNode[S, Extract[Node, `27`]]): Self = StObject.set(x, "File", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFileUndefined: Self = StObject.set(x, "File", js.undefined)
      
      @scala.inline
      def setFlow(value: VisitNode[S, Flow]): Self = StObject.set(x, "Flow", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFlowBaseAnnotation(value: VisitNode[S, FlowBaseAnnotation]): Self = StObject.set(x, "FlowBaseAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFlowBaseAnnotationUndefined: Self = StObject.set(x, "FlowBaseAnnotation", js.undefined)
      
      @scala.inline
      def setFlowDeclaration(value: VisitNode[S, FlowDeclaration]): Self = StObject.set(x, "FlowDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFlowDeclarationUndefined: Self = StObject.set(x, "FlowDeclaration", js.undefined)
      
      @scala.inline
      def setFlowPredicate(value: VisitNode[S, FlowPredicate]): Self = StObject.set(x, "FlowPredicate", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFlowPredicateUndefined: Self = StObject.set(x, "FlowPredicate", js.undefined)
      
      @scala.inline
      def setFlowType(value: VisitNode[S, FlowType]): Self = StObject.set(x, "FlowType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFlowTypeUndefined: Self = StObject.set(x, "FlowType", js.undefined)
      
      @scala.inline
      def setFlowUndefined: Self = StObject.set(x, "Flow", js.undefined)
      
      @scala.inline
      def setFor(value: VisitNode[S, For]): Self = StObject.set(x, "For", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForInStatement(value: VisitNode[S, Extract[Node, `16`]]): Self = StObject.set(x, "ForInStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForInStatementUndefined: Self = StObject.set(x, "ForInStatement", js.undefined)
      
      @scala.inline
      def setForOfStatement(value: VisitNode[S, Extract[Node, `161`]]): Self = StObject.set(x, "ForOfStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForOfStatementUndefined: Self = StObject.set(x, "ForOfStatement", js.undefined)
      
      @scala.inline
      def setForStatement(value: VisitNode[S, Extract[Node, `185`]]): Self = StObject.set(x, "ForStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForStatementUndefined: Self = StObject.set(x, "ForStatement", js.undefined)
      
      @scala.inline
      def setForUndefined: Self = StObject.set(x, "For", js.undefined)
      
      @scala.inline
      def setForXStatement(value: VisitNode[S, ForXStatement]): Self = StObject.set(x, "ForXStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForXStatementUndefined: Self = StObject.set(x, "ForXStatement", js.undefined)
      
      @scala.inline
      def setFunction(value: VisitNode[S, Function]): Self = StObject.set(x, "Function", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionDeclaration(value: VisitNode[S, Extract[Node, `133`]]): Self = StObject.set(x, "FunctionDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionDeclarationUndefined: Self = StObject.set(x, "FunctionDeclaration", js.undefined)
      
      @scala.inline
      def setFunctionExpression(value: VisitNode[S, Extract[Node, `188`]]): Self = StObject.set(x, "FunctionExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionExpressionUndefined: Self = StObject.set(x, "FunctionExpression", js.undefined)
      
      @scala.inline
      def setFunctionParent(value: VisitNode[S, FunctionParent]): Self = StObject.set(x, "FunctionParent", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionParentUndefined: Self = StObject.set(x, "FunctionParent", js.undefined)
      
      @scala.inline
      def setFunctionTypeAnnotation(value: VisitNode[S, Extract[Node, `40`]]): Self = StObject.set(x, "FunctionTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionTypeAnnotationUndefined: Self = StObject.set(x, "FunctionTypeAnnotation", js.undefined)
      
      @scala.inline
      def setFunctionTypeParam(value: VisitNode[S, Extract[Node, `221`]]): Self = StObject.set(x, "FunctionTypeParam", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionTypeParamUndefined: Self = StObject.set(x, "FunctionTypeParam", js.undefined)
      
      @scala.inline
      def setFunctionUndefined: Self = StObject.set(x, "Function", js.undefined)
      
      @scala.inline
      def setGenericTypeAnnotation(value: VisitNode[S, Extract[Node, `237`]]): Self = StObject.set(x, "GenericTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setGenericTypeAnnotationUndefined: Self = StObject.set(x, "GenericTypeAnnotation", js.undefined)
      
      @scala.inline
      def setIdentifier(value: VisitNode[S, Extract[Node, `97`]]): Self = StObject.set(x, "Identifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIdentifierUndefined: Self = StObject.set(x, "Identifier", js.undefined)
      
      @scala.inline
      def setIfStatement(value: VisitNode[S, Extract[Node, `83`]]): Self = StObject.set(x, "IfStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIfStatementUndefined: Self = StObject.set(x, "IfStatement", js.undefined)
      
      @scala.inline
      def setImmutable(value: VisitNode[S, Immutable]): Self = StObject.set(x, "Immutable", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImmutableUndefined: Self = StObject.set(x, "Immutable", js.undefined)
      
      @scala.inline
      def setImport(value: VisitNode[S, Extract[Node, `167`]]): Self = StObject.set(x, "Import", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportAttribute(value: VisitNode[S, Extract[Node, `120`]]): Self = StObject.set(x, "ImportAttribute", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportAttributeUndefined: Self = StObject.set(x, "ImportAttribute", js.undefined)
      
      @scala.inline
      def setImportDeclaration(value: VisitNode[S, Extract[Node, `236`]]): Self = StObject.set(x, "ImportDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportDeclarationUndefined: Self = StObject.set(x, "ImportDeclaration", js.undefined)
      
      @scala.inline
      def setImportDefaultSpecifier(value: VisitNode[S, Extract[Node, `18`]]): Self = StObject.set(x, "ImportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportDefaultSpecifierUndefined: Self = StObject.set(x, "ImportDefaultSpecifier", js.undefined)
      
      @scala.inline
      def setImportNamespaceSpecifier(value: VisitNode[S, Extract[Node, `197`]]): Self = StObject.set(x, "ImportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportNamespaceSpecifierUndefined: Self = StObject.set(x, "ImportNamespaceSpecifier", js.undefined)
      
      @scala.inline
      def setImportSpecifier(value: VisitNode[S, Extract[Node, `111`]]): Self = StObject.set(x, "ImportSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportSpecifierUndefined: Self = StObject.set(x, "ImportSpecifier", js.undefined)
      
      @scala.inline
      def setImportUndefined: Self = StObject.set(x, "Import", js.undefined)
      
      @scala.inline
      def setInferredPredicate(value: VisitNode[S, Extract[Node, `131`]]): Self = StObject.set(x, "InferredPredicate", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setInferredPredicateUndefined: Self = StObject.set(x, "InferredPredicate", js.undefined)
      
      @scala.inline
      def setInterfaceDeclaration(value: VisitNode[S, Extract[Node, `47`]]): Self = StObject.set(x, "InterfaceDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setInterfaceDeclarationUndefined: Self = StObject.set(x, "InterfaceDeclaration", js.undefined)
      
      @scala.inline
      def setInterfaceExtends(value: VisitNode[S, Extract[Node, `136`]]): Self = StObject.set(x, "InterfaceExtends", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setInterfaceExtendsUndefined: Self = StObject.set(x, "InterfaceExtends", js.undefined)
      
      @scala.inline
      def setInterfaceTypeAnnotation(value: VisitNode[S, Extract[Node, `8`]]): Self = StObject.set(x, "InterfaceTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setInterfaceTypeAnnotationUndefined: Self = StObject.set(x, "InterfaceTypeAnnotation", js.undefined)
      
      @scala.inline
      def setInterpreterDirective(value: VisitNode[S, Extract[Node, `86`]]): Self = StObject.set(x, "InterpreterDirective", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setInterpreterDirectiveUndefined: Self = StObject.set(x, "InterpreterDirective", js.undefined)
      
      @scala.inline
      def setIntersectionTypeAnnotation(value: VisitNode[S, Extract[Node, `209`]]): Self = StObject.set(x, "IntersectionTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIntersectionTypeAnnotationUndefined: Self = StObject.set(x, "IntersectionTypeAnnotation", js.undefined)
      
      @scala.inline
      def setJSX(value: VisitNode[S, JSX]): Self = StObject.set(x, "JSX", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXAttribute(value: VisitNode[S, Extract[Node, `100`]]): Self = StObject.set(x, "JSXAttribute", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXAttributeUndefined: Self = StObject.set(x, "JSXAttribute", js.undefined)
      
      @scala.inline
      def setJSXClosingElement(value: VisitNode[S, Extract[Node, `126`]]): Self = StObject.set(x, "JSXClosingElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXClosingElementUndefined: Self = StObject.set(x, "JSXClosingElement", js.undefined)
      
      @scala.inline
      def setJSXClosingFragment(value: VisitNode[S, Extract[Node, `206`]]): Self = StObject.set(x, "JSXClosingFragment", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXClosingFragmentUndefined: Self = StObject.set(x, "JSXClosingFragment", js.undefined)
      
      @scala.inline
      def setJSXElement(value: VisitNode[S, Extract[Node, `169`]]): Self = StObject.set(x, "JSXElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXElementUndefined: Self = StObject.set(x, "JSXElement", js.undefined)
      
      @scala.inline
      def setJSXEmptyExpression(value: VisitNode[S, Extract[Node, `122`]]): Self = StObject.set(x, "JSXEmptyExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXEmptyExpressionUndefined: Self = StObject.set(x, "JSXEmptyExpression", js.undefined)
      
      @scala.inline
      def setJSXExpressionContainer(value: VisitNode[S, Extract[Node, `31`]]): Self = StObject.set(x, "JSXExpressionContainer", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXExpressionContainerUndefined: Self = StObject.set(x, "JSXExpressionContainer", js.undefined)
      
      @scala.inline
      def setJSXFragment(value: VisitNode[S, Extract[Node, `147`]]): Self = StObject.set(x, "JSXFragment", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXFragmentUndefined: Self = StObject.set(x, "JSXFragment", js.undefined)
      
      @scala.inline
      def setJSXIdentifier(value: VisitNode[S, Extract[Node, `85`]]): Self = StObject.set(x, "JSXIdentifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXIdentifierUndefined: Self = StObject.set(x, "JSXIdentifier", js.undefined)
      
      @scala.inline
      def setJSXMemberExpression(value: VisitNode[S, Extract[Node, `192`]]): Self = StObject.set(x, "JSXMemberExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXMemberExpressionUndefined: Self = StObject.set(x, "JSXMemberExpression", js.undefined)
      
      @scala.inline
      def setJSXNamespacedName(value: VisitNode[S, Extract[Node, `149`]]): Self = StObject.set(x, "JSXNamespacedName", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXNamespacedNameUndefined: Self = StObject.set(x, "JSXNamespacedName", js.undefined)
      
      @scala.inline
      def setJSXOpeningElement(value: VisitNode[S, Extract[Node, `72`]]): Self = StObject.set(x, "JSXOpeningElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXOpeningElementUndefined: Self = StObject.set(x, "JSXOpeningElement", js.undefined)
      
      @scala.inline
      def setJSXOpeningFragment(value: VisitNode[S, Extract[Node, `213`]]): Self = StObject.set(x, "JSXOpeningFragment", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXOpeningFragmentUndefined: Self = StObject.set(x, "JSXOpeningFragment", js.undefined)
      
      @scala.inline
      def setJSXSpreadAttribute(value: VisitNode[S, Extract[Node, `48`]]): Self = StObject.set(x, "JSXSpreadAttribute", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXSpreadAttributeUndefined: Self = StObject.set(x, "JSXSpreadAttribute", js.undefined)
      
      @scala.inline
      def setJSXSpreadChild(value: VisitNode[S, Extract[Node, `71`]]): Self = StObject.set(x, "JSXSpreadChild", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXSpreadChildUndefined: Self = StObject.set(x, "JSXSpreadChild", js.undefined)
      
      @scala.inline
      def setJSXText(value: VisitNode[S, Extract[Node, `190`]]): Self = StObject.set(x, "JSXText", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXTextUndefined: Self = StObject.set(x, "JSXText", js.undefined)
      
      @scala.inline
      def setJSXUndefined: Self = StObject.set(x, "JSX", js.undefined)
      
      @scala.inline
      def setLVal(value: VisitNode[S, LVal]): Self = StObject.set(x, "LVal", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLValUndefined: Self = StObject.set(x, "LVal", js.undefined)
      
      @scala.inline
      def setLabeledStatement(value: VisitNode[S, Extract[Node, `35`]]): Self = StObject.set(x, "LabeledStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLabeledStatementUndefined: Self = StObject.set(x, "LabeledStatement", js.undefined)
      
      @scala.inline
      def setLiteral(value: VisitNode[S, Literal]): Self = StObject.set(x, "Literal", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLiteralUndefined: Self = StObject.set(x, "Literal", js.undefined)
      
      @scala.inline
      def setLogicalExpression(value: VisitNode[S, Extract[Node, `68`]]): Self = StObject.set(x, "LogicalExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLogicalExpressionUndefined: Self = StObject.set(x, "LogicalExpression", js.undefined)
      
      @scala.inline
      def setLoop(value: VisitNode[S, Loop]): Self = StObject.set(x, "Loop", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLoopUndefined: Self = StObject.set(x, "Loop", js.undefined)
      
      @scala.inline
      def setMemberExpression(value: VisitNode[S, Extract[Node, `59`]]): Self = StObject.set(x, "MemberExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMemberExpressionUndefined: Self = StObject.set(x, "MemberExpression", js.undefined)
      
      @scala.inline
      def setMetaProperty(value: VisitNode[S, Extract[Node, `81`]]): Self = StObject.set(x, "MetaProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMetaPropertyUndefined: Self = StObject.set(x, "MetaProperty", js.undefined)
      
      @scala.inline
      def setMethod(value: VisitNode[S, Method]): Self = StObject.set(x, "Method", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMethodUndefined: Self = StObject.set(x, "Method", js.undefined)
      
      @scala.inline
      def setMixedTypeAnnotation(value: VisitNode[S, Extract[Node, `56`]]): Self = StObject.set(x, "MixedTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMixedTypeAnnotationUndefined: Self = StObject.set(x, "MixedTypeAnnotation", js.undefined)
      
      @scala.inline
      def setModuleDeclaration(value: VisitNode[S, ModuleDeclaration]): Self = StObject.set(x, "ModuleDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setModuleDeclarationUndefined: Self = StObject.set(x, "ModuleDeclaration", js.undefined)
      
      @scala.inline
      def setModuleSpecifier(value: VisitNode[S, ModuleSpecifier]): Self = StObject.set(x, "ModuleSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setModuleSpecifierUndefined: Self = StObject.set(x, "ModuleSpecifier", js.undefined)
      
      @scala.inline
      def setNewExpression(value: VisitNode[S, Extract[Node, `58`]]): Self = StObject.set(x, "NewExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNewExpressionUndefined: Self = StObject.set(x, "NewExpression", js.undefined)
      
      @scala.inline
      def setNoop(value: VisitNode[S, Extract[Node, `33`]]): Self = StObject.set(x, "Noop", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNoopUndefined: Self = StObject.set(x, "Noop", js.undefined)
      
      @scala.inline
      def setNullLiteral(value: VisitNode[S, Extract[Node, `238`]]): Self = StObject.set(x, "NullLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNullLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `42`]]): Self = StObject.set(x, "NullLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNullLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NullLiteralTypeAnnotation", js.undefined)
      
      @scala.inline
      def setNullLiteralUndefined: Self = StObject.set(x, "NullLiteral", js.undefined)
      
      @scala.inline
      def setNullableTypeAnnotation(value: VisitNode[S, Extract[Node, `96`]]): Self = StObject.set(x, "NullableTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNullableTypeAnnotationUndefined: Self = StObject.set(x, "NullableTypeAnnotation", js.undefined)
      
      @scala.inline
      def setNumberLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `152`]]): Self = StObject.set(x, "NumberLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNumberLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NumberLiteralTypeAnnotation", js.undefined)
      
      @scala.inline
      def setNumberTypeAnnotation(value: VisitNode[S, Extract[Node, `159`]]): Self = StObject.set(x, "NumberTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNumberTypeAnnotationUndefined: Self = StObject.set(x, "NumberTypeAnnotation", js.undefined)
      
      @scala.inline
      def setNumericLiteral(value: VisitNode[S, Extract[Node, `210`]]): Self = StObject.set(x, "NumericLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNumericLiteralUndefined: Self = StObject.set(x, "NumericLiteral", js.undefined)
      
      @scala.inline
      def setObjectExpression(value: VisitNode[S, Extract[Node, `121`]]): Self = StObject.set(x, "ObjectExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectExpressionUndefined: Self = StObject.set(x, "ObjectExpression", js.undefined)
      
      @scala.inline
      def setObjectMember(value: VisitNode[S, ObjectMember]): Self = StObject.set(x, "ObjectMember", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectMemberUndefined: Self = StObject.set(x, "ObjectMember", js.undefined)
      
      @scala.inline
      def setObjectMethod(value: VisitNode[S, Extract[Node, `123`]]): Self = StObject.set(x, "ObjectMethod", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectMethodUndefined: Self = StObject.set(x, "ObjectMethod", js.undefined)
      
      @scala.inline
      def setObjectPattern(value: VisitNode[S, Extract[Node, `217`]]): Self = StObject.set(x, "ObjectPattern", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectPatternUndefined: Self = StObject.set(x, "ObjectPattern", js.undefined)
      
      @scala.inline
      def setObjectProperty(value: VisitNode[S, Extract[Node, `141`]]): Self = StObject.set(x, "ObjectProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectPropertyUndefined: Self = StObject.set(x, "ObjectProperty", js.undefined)
      
      @scala.inline
      def setObjectTypeAnnotation(value: VisitNode[S, Extract[Node, `82`]]): Self = StObject.set(x, "ObjectTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypeAnnotationUndefined: Self = StObject.set(x, "ObjectTypeAnnotation", js.undefined)
      
      @scala.inline
      def setObjectTypeCallProperty(value: VisitNode[S, Extract[Node, `12`]]): Self = StObject.set(x, "ObjectTypeCallProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypeCallPropertyUndefined: Self = StObject.set(x, "ObjectTypeCallProperty", js.undefined)
      
      @scala.inline
      def setObjectTypeIndexer(value: VisitNode[S, Extract[Node, `170`]]): Self = StObject.set(x, "ObjectTypeIndexer", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypeIndexerUndefined: Self = StObject.set(x, "ObjectTypeIndexer", js.undefined)
      
      @scala.inline
      def setObjectTypeInternalSlot(value: VisitNode[S, Extract[Node, `226`]]): Self = StObject.set(x, "ObjectTypeInternalSlot", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypeInternalSlotUndefined: Self = StObject.set(x, "ObjectTypeInternalSlot", js.undefined)
      
      @scala.inline
      def setObjectTypeProperty(value: VisitNode[S, Extract[Node, `154`]]): Self = StObject.set(x, "ObjectTypeProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypePropertyUndefined: Self = StObject.set(x, "ObjectTypeProperty", js.undefined)
      
      @scala.inline
      def setObjectTypeSpreadProperty(value: VisitNode[S, Extract[Node, `79`]]): Self = StObject.set(x, "ObjectTypeSpreadProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypeSpreadPropertyUndefined: Self = StObject.set(x, "ObjectTypeSpreadProperty", js.undefined)
      
      @scala.inline
      def setOpaqueType(value: VisitNode[S, Extract[Node, `69`]]): Self = StObject.set(x, "OpaqueType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOpaqueTypeUndefined: Self = StObject.set(x, "OpaqueType", js.undefined)
      
      @scala.inline
      def setOptionalCallExpression(value: VisitNode[S, Extract[Node, `44`]]): Self = StObject.set(x, "OptionalCallExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOptionalCallExpressionUndefined: Self = StObject.set(x, "OptionalCallExpression", js.undefined)
      
      @scala.inline
      def setOptionalMemberExpression(value: VisitNode[S, Extract[Node, `26`]]): Self = StObject.set(x, "OptionalMemberExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setOptionalMemberExpressionUndefined: Self = StObject.set(x, "OptionalMemberExpression", js.undefined)
      
      @scala.inline
      def setParenthesizedExpression(value: VisitNode[S, Extract[Node, `199`]]): Self = StObject.set(x, "ParenthesizedExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setParenthesizedExpressionUndefined: Self = StObject.set(x, "ParenthesizedExpression", js.undefined)
      
      @scala.inline
      def setPattern(value: VisitNode[S, Pattern]): Self = StObject.set(x, "Pattern", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPatternLike(value: VisitNode[S, PatternLike]): Self = StObject.set(x, "PatternLike", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPatternLikeUndefined: Self = StObject.set(x, "PatternLike", js.undefined)
      
      @scala.inline
      def setPatternUndefined: Self = StObject.set(x, "Pattern", js.undefined)
      
      @scala.inline
      def setPipelineBareFunction(value: VisitNode[S, Extract[Node, `157`]]): Self = StObject.set(x, "PipelineBareFunction", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPipelineBareFunctionUndefined: Self = StObject.set(x, "PipelineBareFunction", js.undefined)
      
      @scala.inline
      def setPipelinePrimaryTopicReference(value: VisitNode[S, Extract[Node, `30`]]): Self = StObject.set(x, "PipelinePrimaryTopicReference", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPipelinePrimaryTopicReferenceUndefined: Self = StObject.set(x, "PipelinePrimaryTopicReference", js.undefined)
      
      @scala.inline
      def setPipelineTopicExpression(value: VisitNode[S, Extract[Node, `103`]]): Self = StObject.set(x, "PipelineTopicExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPipelineTopicExpressionUndefined: Self = StObject.set(x, "PipelineTopicExpression", js.undefined)
      
      @scala.inline
      def setPlaceholder(value: VisitNode[S, Extract[Node, `163`]]): Self = StObject.set(x, "Placeholder", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPlaceholderUndefined: Self = StObject.set(x, "Placeholder", js.undefined)
      
      @scala.inline
      def setPrivate(value: VisitNode[S, Private]): Self = StObject.set(x, "Private", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPrivateName(value: VisitNode[S, Extract[Node, `93`]]): Self = StObject.set(x, "PrivateName", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPrivateNameUndefined: Self = StObject.set(x, "PrivateName", js.undefined)
      
      @scala.inline
      def setPrivateUndefined: Self = StObject.set(x, "Private", js.undefined)
      
      @scala.inline
      def setProgram(value: VisitNode[S, Extract[Node, `150`]]): Self = StObject.set(x, "Program", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setProgramUndefined: Self = StObject.set(x, "Program", js.undefined)
      
      @scala.inline
      def setProperty(value: VisitNode[S, Property]): Self = StObject.set(x, "Property", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPropertyUndefined: Self = StObject.set(x, "Property", js.undefined)
      
      @scala.inline
      def setPureish(value: VisitNode[S, Pureish]): Self = StObject.set(x, "Pureish", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPureishUndefined: Self = StObject.set(x, "Pureish", js.undefined)
      
      @scala.inline
      def setQualifiedTypeIdentifier(value: VisitNode[S, Extract[Node, `73`]]): Self = StObject.set(x, "QualifiedTypeIdentifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setQualifiedTypeIdentifierUndefined: Self = StObject.set(x, "QualifiedTypeIdentifier", js.undefined)
      
      @scala.inline
      def setRecordExpression(value: VisitNode[S, Extract[Node, `60`]]): Self = StObject.set(x, "RecordExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRecordExpressionUndefined: Self = StObject.set(x, "RecordExpression", js.undefined)
      
      @scala.inline
      def setRegExpLiteral(value: VisitNode[S, Extract[Node, `37`]]): Self = StObject.set(x, "RegExpLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRegExpLiteralUndefined: Self = StObject.set(x, "RegExpLiteral", js.undefined)
      
      @scala.inline
      def setRestElement(value: VisitNode[S, Extract[Node, `25`]]): Self = StObject.set(x, "RestElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRestElementUndefined: Self = StObject.set(x, "RestElement", js.undefined)
      
      @scala.inline
      def setReturnStatement(value: VisitNode[S, Extract[Node, `5`]]): Self = StObject.set(x, "ReturnStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setReturnStatementUndefined: Self = StObject.set(x, "ReturnStatement", js.undefined)
      
      @scala.inline
      def setScopable(value: VisitNode[S, Scopable]): Self = StObject.set(x, "Scopable", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScopableUndefined: Self = StObject.set(x, "Scopable", js.undefined)
      
      @scala.inline
      def setSequenceExpression(value: VisitNode[S, Extract[Node, `166`]]): Self = StObject.set(x, "SequenceExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSequenceExpressionUndefined: Self = StObject.set(x, "SequenceExpression", js.undefined)
      
      @scala.inline
      def setSpreadElement(value: VisitNode[S, Extract[Node, `22`]]): Self = StObject.set(x, "SpreadElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSpreadElementUndefined: Self = StObject.set(x, "SpreadElement", js.undefined)
      
      @scala.inline
      def setStatement(value: VisitNode[S, Statement]): Self = StObject.set(x, "Statement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStatementUndefined: Self = StObject.set(x, "Statement", js.undefined)
      
      @scala.inline
      def setStaticBlock(value: VisitNode[S, Extract[Node, `108`]]): Self = StObject.set(x, "StaticBlock", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStaticBlockUndefined: Self = StObject.set(x, "StaticBlock", js.undefined)
      
      @scala.inline
      def setStringLiteral(value: VisitNode[S, Extract[Node, `128`]]): Self = StObject.set(x, "StringLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStringLiteralTypeAnnotation(value: VisitNode[S, Extract[Node, `219`]]): Self = StObject.set(x, "StringLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStringLiteralTypeAnnotationUndefined: Self = StObject.set(x, "StringLiteralTypeAnnotation", js.undefined)
      
      @scala.inline
      def setStringLiteralUndefined: Self = StObject.set(x, "StringLiteral", js.undefined)
      
      @scala.inline
      def setStringTypeAnnotation(value: VisitNode[S, Extract[Node, `2`]]): Self = StObject.set(x, "StringTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStringTypeAnnotationUndefined: Self = StObject.set(x, "StringTypeAnnotation", js.undefined)
      
      @scala.inline
      def setSuper(value: VisitNode[S, Extract[Node, `160`]]): Self = StObject.set(x, "Super", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSuperUndefined: Self = StObject.set(x, "Super", js.undefined)
      
      @scala.inline
      def setSwitchCase(value: VisitNode[S, Extract[Node, `53`]]): Self = StObject.set(x, "SwitchCase", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSwitchCaseUndefined: Self = StObject.set(x, "SwitchCase", js.undefined)
      
      @scala.inline
      def setSwitchStatement(value: VisitNode[S, Extract[Node, `43`]]): Self = StObject.set(x, "SwitchStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSwitchStatementUndefined: Self = StObject.set(x, "SwitchStatement", js.undefined)
      
      @scala.inline
      def setSymbolTypeAnnotation(value: VisitNode[S, Extract[Node, `49`]]): Self = StObject.set(x, "SymbolTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSymbolTypeAnnotationUndefined: Self = StObject.set(x, "SymbolTypeAnnotation", js.undefined)
      
      @scala.inline
      def setTSAnyKeyword(value: VisitNode[S, Extract[Node, `9`]]): Self = StObject.set(x, "TSAnyKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSAnyKeywordUndefined: Self = StObject.set(x, "TSAnyKeyword", js.undefined)
      
      @scala.inline
      def setTSArrayType(value: VisitNode[S, Extract[Node, `0`]]): Self = StObject.set(x, "TSArrayType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSArrayTypeUndefined: Self = StObject.set(x, "TSArrayType", js.undefined)
      
      @scala.inline
      def setTSAsExpression(value: VisitNode[S, Extract[Node, `7`]]): Self = StObject.set(x, "TSAsExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSAsExpressionUndefined: Self = StObject.set(x, "TSAsExpression", js.undefined)
      
      @scala.inline
      def setTSBaseType(value: VisitNode[S, TSBaseType]): Self = StObject.set(x, "TSBaseType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSBaseTypeUndefined: Self = StObject.set(x, "TSBaseType", js.undefined)
      
      @scala.inline
      def setTSBigIntKeyword(value: VisitNode[S, Extract[Node, `52`]]): Self = StObject.set(x, "TSBigIntKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSBigIntKeywordUndefined: Self = StObject.set(x, "TSBigIntKeyword", js.undefined)
      
      @scala.inline
      def setTSBooleanKeyword(value: VisitNode[S, Extract[Node, `218`]]): Self = StObject.set(x, "TSBooleanKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSBooleanKeywordUndefined: Self = StObject.set(x, "TSBooleanKeyword", js.undefined)
      
      @scala.inline
      def setTSCallSignatureDeclaration(value: VisitNode[S, Extract[Node, `146`]]): Self = StObject.set(x, "TSCallSignatureDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSCallSignatureDeclarationUndefined: Self = StObject.set(x, "TSCallSignatureDeclaration", js.undefined)
      
      @scala.inline
      def setTSConditionalType(value: VisitNode[S, Extract[Node, `17`]]): Self = StObject.set(x, "TSConditionalType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSConditionalTypeUndefined: Self = StObject.set(x, "TSConditionalType", js.undefined)
      
      @scala.inline
      def setTSConstructSignatureDeclaration(value: VisitNode[S, Extract[Node, `119`]]): Self = StObject.set(x, "TSConstructSignatureDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSConstructSignatureDeclarationUndefined: Self = StObject.set(x, "TSConstructSignatureDeclaration", js.undefined)
      
      @scala.inline
      def setTSConstructorType(value: VisitNode[S, Extract[Node, `208`]]): Self = StObject.set(x, "TSConstructorType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSConstructorTypeUndefined: Self = StObject.set(x, "TSConstructorType", js.undefined)
      
      @scala.inline
      def setTSDeclareFunction(value: VisitNode[S, Extract[Node, `196`]]): Self = StObject.set(x, "TSDeclareFunction", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSDeclareFunctionUndefined: Self = StObject.set(x, "TSDeclareFunction", js.undefined)
      
      @scala.inline
      def setTSDeclareMethod(value: VisitNode[S, Extract[Node, `75`]]): Self = StObject.set(x, "TSDeclareMethod", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSDeclareMethodUndefined: Self = StObject.set(x, "TSDeclareMethod", js.undefined)
      
      @scala.inline
      def setTSEntityName(value: VisitNode[S, TSEntityName]): Self = StObject.set(x, "TSEntityName", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSEntityNameUndefined: Self = StObject.set(x, "TSEntityName", js.undefined)
      
      @scala.inline
      def setTSEnumDeclaration(value: VisitNode[S, Extract[Node, `89`]]): Self = StObject.set(x, "TSEnumDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSEnumDeclarationUndefined: Self = StObject.set(x, "TSEnumDeclaration", js.undefined)
      
      @scala.inline
      def setTSEnumMember(value: VisitNode[S, Extract[Node, `130`]]): Self = StObject.set(x, "TSEnumMember", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSEnumMemberUndefined: Self = StObject.set(x, "TSEnumMember", js.undefined)
      
      @scala.inline
      def setTSExportAssignment(value: VisitNode[S, Extract[Node, `142`]]): Self = StObject.set(x, "TSExportAssignment", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSExportAssignmentUndefined: Self = StObject.set(x, "TSExportAssignment", js.undefined)
      
      @scala.inline
      def setTSExpressionWithTypeArguments(value: VisitNode[S, Extract[Node, `144`]]): Self = StObject.set(x, "TSExpressionWithTypeArguments", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSExpressionWithTypeArgumentsUndefined: Self = StObject.set(x, "TSExpressionWithTypeArguments", js.undefined)
      
      @scala.inline
      def setTSExternalModuleReference(value: VisitNode[S, Extract[Node, `118`]]): Self = StObject.set(x, "TSExternalModuleReference", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSExternalModuleReferenceUndefined: Self = StObject.set(x, "TSExternalModuleReference", js.undefined)
      
      @scala.inline
      def setTSFunctionType(value: VisitNode[S, Extract[Node, `41`]]): Self = StObject.set(x, "TSFunctionType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSFunctionTypeUndefined: Self = StObject.set(x, "TSFunctionType", js.undefined)
      
      @scala.inline
      def setTSImportEqualsDeclaration(value: VisitNode[S, Extract[Node, `155`]]): Self = StObject.set(x, "TSImportEqualsDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSImportEqualsDeclarationUndefined: Self = StObject.set(x, "TSImportEqualsDeclaration", js.undefined)
      
      @scala.inline
      def setTSImportType(value: VisitNode[S, Extract[Node, `234`]]): Self = StObject.set(x, "TSImportType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSImportTypeUndefined: Self = StObject.set(x, "TSImportType", js.undefined)
      
      @scala.inline
      def setTSIndexSignature(value: VisitNode[S, Extract[Node, `202`]]): Self = StObject.set(x, "TSIndexSignature", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSIndexSignatureUndefined: Self = StObject.set(x, "TSIndexSignature", js.undefined)
      
      @scala.inline
      def setTSIndexedAccessType(value: VisitNode[S, Extract[Node, `28`]]): Self = StObject.set(x, "TSIndexedAccessType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSIndexedAccessTypeUndefined: Self = StObject.set(x, "TSIndexedAccessType", js.undefined)
      
      @scala.inline
      def setTSInferType(value: VisitNode[S, Extract[Node, `101`]]): Self = StObject.set(x, "TSInferType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSInferTypeUndefined: Self = StObject.set(x, "TSInferType", js.undefined)
      
      @scala.inline
      def setTSInterfaceBody(value: VisitNode[S, Extract[Node, `6`]]): Self = StObject.set(x, "TSInterfaceBody", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSInterfaceBodyUndefined: Self = StObject.set(x, "TSInterfaceBody", js.undefined)
      
      @scala.inline
      def setTSInterfaceDeclaration(value: VisitNode[S, Extract[Node, `182`]]): Self = StObject.set(x, "TSInterfaceDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSInterfaceDeclarationUndefined: Self = StObject.set(x, "TSInterfaceDeclaration", js.undefined)
      
      @scala.inline
      def setTSIntersectionType(value: VisitNode[S, Extract[Node, `231`]]): Self = StObject.set(x, "TSIntersectionType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSIntersectionTypeUndefined: Self = StObject.set(x, "TSIntersectionType", js.undefined)
      
      @scala.inline
      def setTSIntrinsicKeyword(value: VisitNode[S, Extract[Node, `65`]]): Self = StObject.set(x, "TSIntrinsicKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSIntrinsicKeywordUndefined: Self = StObject.set(x, "TSIntrinsicKeyword", js.undefined)
      
      @scala.inline
      def setTSLiteralType(value: VisitNode[S, Extract[Node, `19`]]): Self = StObject.set(x, "TSLiteralType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSLiteralTypeUndefined: Self = StObject.set(x, "TSLiteralType", js.undefined)
      
      @scala.inline
      def setTSMappedType(value: VisitNode[S, Extract[Node, `125`]]): Self = StObject.set(x, "TSMappedType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSMappedTypeUndefined: Self = StObject.set(x, "TSMappedType", js.undefined)
      
      @scala.inline
      def setTSMethodSignature(value: VisitNode[S, Extract[Node, `198`]]): Self = StObject.set(x, "TSMethodSignature", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSMethodSignatureUndefined: Self = StObject.set(x, "TSMethodSignature", js.undefined)
      
      @scala.inline
      def setTSModuleBlock(value: VisitNode[S, Extract[Node, `224`]]): Self = StObject.set(x, "TSModuleBlock", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSModuleBlockUndefined: Self = StObject.set(x, "TSModuleBlock", js.undefined)
      
      @scala.inline
      def setTSModuleDeclaration(value: VisitNode[S, Extract[Node, `15`]]): Self = StObject.set(x, "TSModuleDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSModuleDeclarationUndefined: Self = StObject.set(x, "TSModuleDeclaration", js.undefined)
      
      @scala.inline
      def setTSNamedTupleMember(value: VisitNode[S, Extract[Node, `215`]]): Self = StObject.set(x, "TSNamedTupleMember", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSNamedTupleMemberUndefined: Self = StObject.set(x, "TSNamedTupleMember", js.undefined)
      
      @scala.inline
      def setTSNamespaceExportDeclaration(value: VisitNode[S, Extract[Node, `88`]]): Self = StObject.set(x, "TSNamespaceExportDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSNamespaceExportDeclarationUndefined: Self = StObject.set(x, "TSNamespaceExportDeclaration", js.undefined)
      
      @scala.inline
      def setTSNeverKeyword(value: VisitNode[S, Extract[Node, `230`]]): Self = StObject.set(x, "TSNeverKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSNeverKeywordUndefined: Self = StObject.set(x, "TSNeverKeyword", js.undefined)
      
      @scala.inline
      def setTSNonNullExpression(value: VisitNode[S, Extract[Node, `95`]]): Self = StObject.set(x, "TSNonNullExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSNonNullExpressionUndefined: Self = StObject.set(x, "TSNonNullExpression", js.undefined)
      
      @scala.inline
      def setTSNullKeyword(value: VisitNode[S, Extract[Node, `32`]]): Self = StObject.set(x, "TSNullKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSNullKeywordUndefined: Self = StObject.set(x, "TSNullKeyword", js.undefined)
      
      @scala.inline
      def setTSNumberKeyword(value: VisitNode[S, Extract[Node, `176`]]): Self = StObject.set(x, "TSNumberKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSNumberKeywordUndefined: Self = StObject.set(x, "TSNumberKeyword", js.undefined)
      
      @scala.inline
      def setTSObjectKeyword(value: VisitNode[S, Extract[Node, `211`]]): Self = StObject.set(x, "TSObjectKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSObjectKeywordUndefined: Self = StObject.set(x, "TSObjectKeyword", js.undefined)
      
      @scala.inline
      def setTSOptionalType(value: VisitNode[S, Extract[Node, `180`]]): Self = StObject.set(x, "TSOptionalType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSOptionalTypeUndefined: Self = StObject.set(x, "TSOptionalType", js.undefined)
      
      @scala.inline
      def setTSParameterProperty(value: VisitNode[S, Extract[Node, `191`]]): Self = StObject.set(x, "TSParameterProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSParameterPropertyUndefined: Self = StObject.set(x, "TSParameterProperty", js.undefined)
      
      @scala.inline
      def setTSParenthesizedType(value: VisitNode[S, Extract[Node, `220`]]): Self = StObject.set(x, "TSParenthesizedType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSParenthesizedTypeUndefined: Self = StObject.set(x, "TSParenthesizedType", js.undefined)
      
      @scala.inline
      def setTSPropertySignature(value: VisitNode[S, Extract[Node, `115`]]): Self = StObject.set(x, "TSPropertySignature", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSPropertySignatureUndefined: Self = StObject.set(x, "TSPropertySignature", js.undefined)
      
      @scala.inline
      def setTSQualifiedName(value: VisitNode[S, Extract[Node, `29`]]): Self = StObject.set(x, "TSQualifiedName", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSQualifiedNameUndefined: Self = StObject.set(x, "TSQualifiedName", js.undefined)
      
      @scala.inline
      def setTSRestType(value: VisitNode[S, Extract[Node, `205`]]): Self = StObject.set(x, "TSRestType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSRestTypeUndefined: Self = StObject.set(x, "TSRestType", js.undefined)
      
      @scala.inline
      def setTSStringKeyword(value: VisitNode[S, Extract[Node, `99`]]): Self = StObject.set(x, "TSStringKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSStringKeywordUndefined: Self = StObject.set(x, "TSStringKeyword", js.undefined)
      
      @scala.inline
      def setTSSymbolKeyword(value: VisitNode[S, Extract[Node, `124`]]): Self = StObject.set(x, "TSSymbolKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSSymbolKeywordUndefined: Self = StObject.set(x, "TSSymbolKeyword", js.undefined)
      
      @scala.inline
      def setTSThisType(value: VisitNode[S, Extract[Node, `203`]]): Self = StObject.set(x, "TSThisType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSThisTypeUndefined: Self = StObject.set(x, "TSThisType", js.undefined)
      
      @scala.inline
      def setTSTupleType(value: VisitNode[S, Extract[Node, `194`]]): Self = StObject.set(x, "TSTupleType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTupleTypeUndefined: Self = StObject.set(x, "TSTupleType", js.undefined)
      
      @scala.inline
      def setTSType(value: VisitNode[S, TSType]): Self = StObject.set(x, "TSType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypeAliasDeclaration(value: VisitNode[S, Extract[Node, `90`]]): Self = StObject.set(x, "TSTypeAliasDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypeAliasDeclarationUndefined: Self = StObject.set(x, "TSTypeAliasDeclaration", js.undefined)
      
      @scala.inline
      def setTSTypeAnnotation(value: VisitNode[S, Extract[Node, `109`]]): Self = StObject.set(x, "TSTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypeAnnotationUndefined: Self = StObject.set(x, "TSTypeAnnotation", js.undefined)
      
      @scala.inline
      def setTSTypeAssertion(value: VisitNode[S, Extract[Node, `229`]]): Self = StObject.set(x, "TSTypeAssertion", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypeAssertionUndefined: Self = StObject.set(x, "TSTypeAssertion", js.undefined)
      
      @scala.inline
      def setTSTypeElement(value: VisitNode[S, TSTypeElement]): Self = StObject.set(x, "TSTypeElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypeElementUndefined: Self = StObject.set(x, "TSTypeElement", js.undefined)
      
      @scala.inline
      def setTSTypeLiteral(value: VisitNode[S, Extract[Node, `151`]]): Self = StObject.set(x, "TSTypeLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypeLiteralUndefined: Self = StObject.set(x, "TSTypeLiteral", js.undefined)
      
      @scala.inline
      def setTSTypeOperator(value: VisitNode[S, Extract[Node, `51`]]): Self = StObject.set(x, "TSTypeOperator", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypeOperatorUndefined: Self = StObject.set(x, "TSTypeOperator", js.undefined)
      
      @scala.inline
      def setTSTypeParameter(value: VisitNode[S, Extract[Node, `92`]]): Self = StObject.set(x, "TSTypeParameter", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypeParameterDeclaration(value: VisitNode[S, Extract[Node, `20`]]): Self = StObject.set(x, "TSTypeParameterDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypeParameterDeclarationUndefined: Self = StObject.set(x, "TSTypeParameterDeclaration", js.undefined)
      
      @scala.inline
      def setTSTypeParameterInstantiation(value: VisitNode[S, Extract[Node, `74`]]): Self = StObject.set(x, "TSTypeParameterInstantiation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypeParameterInstantiationUndefined: Self = StObject.set(x, "TSTypeParameterInstantiation", js.undefined)
      
      @scala.inline
      def setTSTypeParameterUndefined: Self = StObject.set(x, "TSTypeParameter", js.undefined)
      
      @scala.inline
      def setTSTypePredicate(value: VisitNode[S, Extract[Node, `181`]]): Self = StObject.set(x, "TSTypePredicate", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypePredicateUndefined: Self = StObject.set(x, "TSTypePredicate", js.undefined)
      
      @scala.inline
      def setTSTypeQuery(value: VisitNode[S, Extract[Node, `117`]]): Self = StObject.set(x, "TSTypeQuery", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypeQueryUndefined: Self = StObject.set(x, "TSTypeQuery", js.undefined)
      
      @scala.inline
      def setTSTypeReference(value: VisitNode[S, Extract[Node, `240`]]): Self = StObject.set(x, "TSTypeReference", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSTypeReferenceUndefined: Self = StObject.set(x, "TSTypeReference", js.undefined)
      
      @scala.inline
      def setTSTypeUndefined: Self = StObject.set(x, "TSType", js.undefined)
      
      @scala.inline
      def setTSUndefinedKeyword(value: VisitNode[S, Extract[Node, `164`]]): Self = StObject.set(x, "TSUndefinedKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSUndefinedKeywordUndefined: Self = StObject.set(x, "TSUndefinedKeyword", js.undefined)
      
      @scala.inline
      def setTSUnionType(value: VisitNode[S, Extract[Node, `91`]]): Self = StObject.set(x, "TSUnionType", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSUnionTypeUndefined: Self = StObject.set(x, "TSUnionType", js.undefined)
      
      @scala.inline
      def setTSUnknownKeyword(value: VisitNode[S, Extract[Node, `54`]]): Self = StObject.set(x, "TSUnknownKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSUnknownKeywordUndefined: Self = StObject.set(x, "TSUnknownKeyword", js.undefined)
      
      @scala.inline
      def setTSVoidKeyword(value: VisitNode[S, Extract[Node, `57`]]): Self = StObject.set(x, "TSVoidKeyword", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTSVoidKeywordUndefined: Self = StObject.set(x, "TSVoidKeyword", js.undefined)
      
      @scala.inline
      def setTaggedTemplateExpression(value: VisitNode[S, Extract[Node, `70`]]): Self = StObject.set(x, "TaggedTemplateExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTaggedTemplateExpressionUndefined: Self = StObject.set(x, "TaggedTemplateExpression", js.undefined)
      
      @scala.inline
      def setTemplateElement(value: VisitNode[S, Extract[Node, `189`]]): Self = StObject.set(x, "TemplateElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTemplateElementUndefined: Self = StObject.set(x, "TemplateElement", js.undefined)
      
      @scala.inline
      def setTemplateLiteral(value: VisitNode[S, Extract[Node, `76`]]): Self = StObject.set(x, "TemplateLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTemplateLiteralUndefined: Self = StObject.set(x, "TemplateLiteral", js.undefined)
      
      @scala.inline
      def setTerminatorless(value: VisitNode[S, Terminatorless]): Self = StObject.set(x, "Terminatorless", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTerminatorlessUndefined: Self = StObject.set(x, "Terminatorless", js.undefined)
      
      @scala.inline
      def setThisExpression(value: VisitNode[S, Extract[Node, `227`]]): Self = StObject.set(x, "ThisExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setThisExpressionUndefined: Self = StObject.set(x, "ThisExpression", js.undefined)
      
      @scala.inline
      def setThisTypeAnnotation(value: VisitNode[S, Extract[Node, `50`]]): Self = StObject.set(x, "ThisTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setThisTypeAnnotationUndefined: Self = StObject.set(x, "ThisTypeAnnotation", js.undefined)
      
      @scala.inline
      def setThrowStatement(value: VisitNode[S, Extract[Node, `137`]]): Self = StObject.set(x, "ThrowStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setThrowStatementUndefined: Self = StObject.set(x, "ThrowStatement", js.undefined)
      
      @scala.inline
      def setTryStatement(value: VisitNode[S, Extract[Node, `23`]]): Self = StObject.set(x, "TryStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTryStatementUndefined: Self = StObject.set(x, "TryStatement", js.undefined)
      
      @scala.inline
      def setTupleExpression(value: VisitNode[S, Extract[Node, `204`]]): Self = StObject.set(x, "TupleExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTupleExpressionUndefined: Self = StObject.set(x, "TupleExpression", js.undefined)
      
      @scala.inline
      def setTupleTypeAnnotation(value: VisitNode[S, Extract[Node, `13`]]): Self = StObject.set(x, "TupleTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTupleTypeAnnotationUndefined: Self = StObject.set(x, "TupleTypeAnnotation", js.undefined)
      
      @scala.inline
      def setTypeAlias(value: VisitNode[S, Extract[Node, `175`]]): Self = StObject.set(x, "TypeAlias", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeAliasUndefined: Self = StObject.set(x, "TypeAlias", js.undefined)
      
      @scala.inline
      def setTypeAnnotation(value: VisitNode[S, Extract[Node, `21`]]): Self = StObject.set(x, "TypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeAnnotationUndefined: Self = StObject.set(x, "TypeAnnotation", js.undefined)
      
      @scala.inline
      def setTypeCastExpression(value: VisitNode[S, Extract[Node, `10`]]): Self = StObject.set(x, "TypeCastExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeCastExpressionUndefined: Self = StObject.set(x, "TypeCastExpression", js.undefined)
      
      @scala.inline
      def setTypeParameter(value: VisitNode[S, Extract[Node, `168`]]): Self = StObject.set(x, "TypeParameter", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeParameterDeclaration(value: VisitNode[S, Extract[Node, `14`]]): Self = StObject.set(x, "TypeParameterDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeParameterDeclarationUndefined: Self = StObject.set(x, "TypeParameterDeclaration", js.undefined)
      
      @scala.inline
      def setTypeParameterInstantiation(value: VisitNode[S, Extract[Node, `239`]]): Self = StObject.set(x, "TypeParameterInstantiation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeParameterInstantiationUndefined: Self = StObject.set(x, "TypeParameterInstantiation", js.undefined)
      
      @scala.inline
      def setTypeParameterUndefined: Self = StObject.set(x, "TypeParameter", js.undefined)
      
      @scala.inline
      def setTypeofTypeAnnotation(value: VisitNode[S, Extract[Node, `145`]]): Self = StObject.set(x, "TypeofTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeofTypeAnnotationUndefined: Self = StObject.set(x, "TypeofTypeAnnotation", js.undefined)
      
      @scala.inline
      def setUnaryExpression(value: VisitNode[S, Extract[Node, `172`]]): Self = StObject.set(x, "UnaryExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUnaryExpressionUndefined: Self = StObject.set(x, "UnaryExpression", js.undefined)
      
      @scala.inline
      def setUnaryLike(value: VisitNode[S, UnaryLike]): Self = StObject.set(x, "UnaryLike", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUnaryLikeUndefined: Self = StObject.set(x, "UnaryLike", js.undefined)
      
      @scala.inline
      def setUnionTypeAnnotation(value: VisitNode[S, Extract[Node, `214`]]): Self = StObject.set(x, "UnionTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUnionTypeAnnotationUndefined: Self = StObject.set(x, "UnionTypeAnnotation", js.undefined)
      
      @scala.inline
      def setUpdateExpression(value: VisitNode[S, Extract[Node, `98`]]): Self = StObject.set(x, "UpdateExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUpdateExpressionUndefined: Self = StObject.set(x, "UpdateExpression", js.undefined)
      
      @scala.inline
      def setUserWhitespacable(value: VisitNode[S, UserWhitespacable]): Self = StObject.set(x, "UserWhitespacable", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUserWhitespacableUndefined: Self = StObject.set(x, "UserWhitespacable", js.undefined)
      
      @scala.inline
      def setV8IntrinsicIdentifier(value: VisitNode[S, Extract[Node, `138`]]): Self = StObject.set(x, "V8IntrinsicIdentifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setV8IntrinsicIdentifierUndefined: Self = StObject.set(x, "V8IntrinsicIdentifier", js.undefined)
      
      @scala.inline
      def setVariableDeclaration(value: VisitNode[S, Extract[Node, `67`]]): Self = StObject.set(x, "VariableDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVariableDeclarationUndefined: Self = StObject.set(x, "VariableDeclaration", js.undefined)
      
      @scala.inline
      def setVariableDeclarator(value: VisitNode[S, Extract[Node, `127`]]): Self = StObject.set(x, "VariableDeclarator", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVariableDeclaratorUndefined: Self = StObject.set(x, "VariableDeclarator", js.undefined)
      
      @scala.inline
      def setVariance(value: VisitNode[S, Extract[Node, `148`]]): Self = StObject.set(x, "Variance", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVarianceUndefined: Self = StObject.set(x, "Variance", js.undefined)
      
      @scala.inline
      def setVoidTypeAnnotation(value: VisitNode[S, Extract[Node, `104`]]): Self = StObject.set(x, "VoidTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVoidTypeAnnotationUndefined: Self = StObject.set(x, "VoidTypeAnnotation", js.undefined)
      
      @scala.inline
      def setWhile(value: VisitNode[S, While]): Self = StObject.set(x, "While", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setWhileStatement(value: VisitNode[S, Extract[Node, `38`]]): Self = StObject.set(x, "WhileStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setWhileStatementUndefined: Self = StObject.set(x, "WhileStatement", js.undefined)
      
      @scala.inline
      def setWhileUndefined: Self = StObject.set(x, "While", js.undefined)
      
      @scala.inline
      def setWithStatement(value: VisitNode[S, Extract[Node, `94`]]): Self = StObject.set(x, "WithStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setWithStatementUndefined: Self = StObject.set(x, "WithStatement", js.undefined)
      
      @scala.inline
      def setYieldExpression(value: VisitNode[S, Extract[Node, `11`]]): Self = StObject.set(x, "YieldExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setYieldExpressionUndefined: Self = StObject.set(x, "YieldExpression", js.undefined)
    }
  }
}
