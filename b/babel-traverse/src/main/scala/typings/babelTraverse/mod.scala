package typings.babelTraverse

import org.scalablytyped.runtime.Instantiable1
import org.scalablytyped.runtime.StringDictionary
import typings.babelTraverse.anon.Confident
import typings.babelTraverse.anon.Existing
import typings.babelTraverse.babelTraverseStrings.`var`
import typings.babelTraverse.babelTraverseStrings.const
import typings.babelTraverse.babelTraverseStrings.let
import typings.babelTraverse.babelTraverseStrings.module
import typings.babelTypes.ts36Mod.AnyTypeAnnotation_
import typings.babelTypes.ts36Mod.ArrayExpression_
import typings.babelTypes.ts36Mod.ArrayPattern_
import typings.babelTypes.ts36Mod.ArrayTypeAnnotation_
import typings.babelTypes.ts36Mod.ArrowFunctionExpression_
import typings.babelTypes.ts36Mod.AssignmentExpression_
import typings.babelTypes.ts36Mod.AssignmentPattern_
import typings.babelTypes.ts36Mod.AwaitExpression_
import typings.babelTypes.ts36Mod.Binary
import typings.babelTypes.ts36Mod.BinaryExpression_
import typings.babelTypes.ts36Mod.BindExpression_
import typings.babelTypes.ts36Mod.Block
import typings.babelTypes.ts36Mod.BlockParent
import typings.babelTypes.ts36Mod.BlockStatement_
import typings.babelTypes.ts36Mod.BooleanLiteralTypeAnnotation_
import typings.babelTypes.ts36Mod.BooleanLiteral_
import typings.babelTypes.ts36Mod.BooleanTypeAnnotation_
import typings.babelTypes.ts36Mod.BreakStatement_
import typings.babelTypes.ts36Mod.CallExpression_
import typings.babelTypes.ts36Mod.CatchClause_
import typings.babelTypes.ts36Mod.Class
import typings.babelTypes.ts36Mod.ClassBody_
import typings.babelTypes.ts36Mod.ClassDeclaration_
import typings.babelTypes.ts36Mod.ClassExpression_
import typings.babelTypes.ts36Mod.ClassImplements_
import typings.babelTypes.ts36Mod.ClassMethod_
import typings.babelTypes.ts36Mod.ClassProperty_
import typings.babelTypes.ts36Mod.CompletionStatement
import typings.babelTypes.ts36Mod.Conditional
import typings.babelTypes.ts36Mod.ConditionalExpression_
import typings.babelTypes.ts36Mod.ContinueStatement_
import typings.babelTypes.ts36Mod.DebuggerStatement_
import typings.babelTypes.ts36Mod.Declaration
import typings.babelTypes.ts36Mod.DeclareClass_
import typings.babelTypes.ts36Mod.DeclareFunction_
import typings.babelTypes.ts36Mod.DeclareInterface_
import typings.babelTypes.ts36Mod.DeclareModule_
import typings.babelTypes.ts36Mod.DeclareTypeAlias_
import typings.babelTypes.ts36Mod.DeclareVariable_
import typings.babelTypes.ts36Mod.Decorator_
import typings.babelTypes.ts36Mod.DirectiveLiteral_
import typings.babelTypes.ts36Mod.Directive_
import typings.babelTypes.ts36Mod.DoExpression_
import typings.babelTypes.ts36Mod.DoWhileStatement_
import typings.babelTypes.ts36Mod.EmptyStatement_
import typings.babelTypes.ts36Mod.ExistentialTypeParam_
import typings.babelTypes.ts36Mod.ExportAllDeclaration_
import typings.babelTypes.ts36Mod.ExportDeclaration
import typings.babelTypes.ts36Mod.ExportDefaultDeclaration_
import typings.babelTypes.ts36Mod.ExportDefaultSpecifier_
import typings.babelTypes.ts36Mod.ExportNamedDeclaration_
import typings.babelTypes.ts36Mod.ExportNamespaceSpecifier_
import typings.babelTypes.ts36Mod.ExportSpecifier_
import typings.babelTypes.ts36Mod.Expression
import typings.babelTypes.ts36Mod.ExpressionStatement_
import typings.babelTypes.ts36Mod.ExpressionWrapper
import typings.babelTypes.ts36Mod.File_
import typings.babelTypes.ts36Mod.Flow
import typings.babelTypes.ts36Mod.FlowBaseAnnotation
import typings.babelTypes.ts36Mod.FlowDeclaration
import typings.babelTypes.ts36Mod.FlowTypeAnnotation
import typings.babelTypes.ts36Mod.For
import typings.babelTypes.ts36Mod.ForInStatement_
import typings.babelTypes.ts36Mod.ForOfStatement_
import typings.babelTypes.ts36Mod.ForStatement_
import typings.babelTypes.ts36Mod.ForXStatement
import typings.babelTypes.ts36Mod.Function
import typings.babelTypes.ts36Mod.FunctionDeclaration_
import typings.babelTypes.ts36Mod.FunctionExpression_
import typings.babelTypes.ts36Mod.FunctionParent
import typings.babelTypes.ts36Mod.FunctionTypeAnnotation_
import typings.babelTypes.ts36Mod.FunctionTypeParam_
import typings.babelTypes.ts36Mod.GenericTypeAnnotation_
import typings.babelTypes.ts36Mod.Identifier_
import typings.babelTypes.ts36Mod.IfStatement_
import typings.babelTypes.ts36Mod.Immutable
import typings.babelTypes.ts36Mod.ImportDeclaration_
import typings.babelTypes.ts36Mod.ImportDefaultSpecifier_
import typings.babelTypes.ts36Mod.ImportNamespaceSpecifier_
import typings.babelTypes.ts36Mod.ImportSpecifier_
import typings.babelTypes.ts36Mod.InterfaceDeclaration_
import typings.babelTypes.ts36Mod.InterfaceExtends_
import typings.babelTypes.ts36Mod.IntersectionTypeAnnotation_
import typings.babelTypes.ts36Mod.JSX
import typings.babelTypes.ts36Mod.JSXAttribute_
import typings.babelTypes.ts36Mod.JSXClosingElement_
import typings.babelTypes.ts36Mod.JSXElement_
import typings.babelTypes.ts36Mod.JSXEmptyExpression_
import typings.babelTypes.ts36Mod.JSXExpressionContainer_
import typings.babelTypes.ts36Mod.JSXIdentifier_
import typings.babelTypes.ts36Mod.JSXMemberExpression_
import typings.babelTypes.ts36Mod.JSXNamespacedName_
import typings.babelTypes.ts36Mod.JSXOpeningElement_
import typings.babelTypes.ts36Mod.JSXSpreadAttribute_
import typings.babelTypes.ts36Mod.JSXText_
import typings.babelTypes.ts36Mod.LVal
import typings.babelTypes.ts36Mod.LabeledStatement_
import typings.babelTypes.ts36Mod.Literal
import typings.babelTypes.ts36Mod.LogicalExpression_
import typings.babelTypes.ts36Mod.Loop
import typings.babelTypes.ts36Mod.MemberExpression_
import typings.babelTypes.ts36Mod.MetaProperty_
import typings.babelTypes.ts36Mod.Method
import typings.babelTypes.ts36Mod.MixedTypeAnnotation_
import typings.babelTypes.ts36Mod.ModuleDeclaration
import typings.babelTypes.ts36Mod.ModuleSpecifier
import typings.babelTypes.ts36Mod.NewExpression_
import typings.babelTypes.ts36Mod.Noop_
import typings.babelTypes.ts36Mod.NullLiteralTypeAnnotation_
import typings.babelTypes.ts36Mod.NullLiteral_
import typings.babelTypes.ts36Mod.NullableTypeAnnotation_
import typings.babelTypes.ts36Mod.NumberTypeAnnotation_
import typings.babelTypes.ts36Mod.NumericLiteralTypeAnnotation_
import typings.babelTypes.ts36Mod.NumericLiteral_
import typings.babelTypes.ts36Mod.ObjectExpression_
import typings.babelTypes.ts36Mod.ObjectMember
import typings.babelTypes.ts36Mod.ObjectMethod_
import typings.babelTypes.ts36Mod.ObjectPattern_
import typings.babelTypes.ts36Mod.ObjectProperty_
import typings.babelTypes.ts36Mod.ObjectTypeAnnotation_
import typings.babelTypes.ts36Mod.ObjectTypeCallProperty_
import typings.babelTypes.ts36Mod.ObjectTypeIndexer_
import typings.babelTypes.ts36Mod.ObjectTypeProperty_
import typings.babelTypes.ts36Mod.ParenthesizedExpression_
import typings.babelTypes.ts36Mod.Pattern
import typings.babelTypes.ts36Mod.Program_
import typings.babelTypes.ts36Mod.Property
import typings.babelTypes.ts36Mod.Pureish
import typings.babelTypes.ts36Mod.QualifiedTypeIdentifier_
import typings.babelTypes.ts36Mod.RegExpLiteral_
import typings.babelTypes.ts36Mod.RestElement_
import typings.babelTypes.ts36Mod.RestProperty_
import typings.babelTypes.ts36Mod.ReturnStatement_
import typings.babelTypes.ts36Mod.Scopable
import typings.babelTypes.ts36Mod.SequenceExpression_
import typings.babelTypes.ts36Mod.SpreadElement_
import typings.babelTypes.ts36Mod.SpreadProperty_
import typings.babelTypes.ts36Mod.Statement
import typings.babelTypes.ts36Mod.StringLiteralTypeAnnotation_
import typings.babelTypes.ts36Mod.StringLiteral_
import typings.babelTypes.ts36Mod.StringTypeAnnotation_
import typings.babelTypes.ts36Mod.Super
import typings.babelTypes.ts36Mod.SwitchCase_
import typings.babelTypes.ts36Mod.SwitchStatement_
import typings.babelTypes.ts36Mod.TaggedTemplateExpression_
import typings.babelTypes.ts36Mod.TemplateElement_
import typings.babelTypes.ts36Mod.TemplateLiteral_
import typings.babelTypes.ts36Mod.Terminatorless
import typings.babelTypes.ts36Mod.ThisExpression_
import typings.babelTypes.ts36Mod.ThisTypeAnnotation_
import typings.babelTypes.ts36Mod.ThrowStatement_
import typings.babelTypes.ts36Mod.TryStatement_
import typings.babelTypes.ts36Mod.TupleTypeAnnotation_
import typings.babelTypes.ts36Mod.TypeAlias_
import typings.babelTypes.ts36Mod.TypeAnnotation_
import typings.babelTypes.ts36Mod.TypeCastExpression_
import typings.babelTypes.ts36Mod.TypeParameterDeclaration_
import typings.babelTypes.ts36Mod.TypeParameterInstantiation_
import typings.babelTypes.ts36Mod.TypeofTypeAnnotation_
import typings.babelTypes.ts36Mod.UnaryExpression_
import typings.babelTypes.ts36Mod.UnaryLike
import typings.babelTypes.ts36Mod.UnionTypeAnnotation_
import typings.babelTypes.ts36Mod.UpdateExpression_
import typings.babelTypes.ts36Mod.UserWhitespacable
import typings.babelTypes.ts36Mod.VariableDeclaration_
import typings.babelTypes.ts36Mod.VariableDeclarator_
import typings.babelTypes.ts36Mod.VoidTypeAnnotation_
import typings.babelTypes.ts36Mod.While
import typings.babelTypes.ts36Mod.WhileStatement_
import typings.babelTypes.ts36Mod.WithStatement_
import typings.babelTypes.ts36Mod.YieldExpression_
import typings.std.Error
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(parent: js.Array[Node], opts: TraverseOptions[Node]): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(
    parent: js.Array[Node],
    opts: TraverseOptions[Node],
    scope: js.UndefOr[scala.Nothing],
    state: js.UndefOr[scala.Nothing],
    parentPath: NodePath[Node]
  ): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(
    parent: js.Array[Node],
    opts: TraverseOptions[Node],
    scope: js.UndefOr[scala.Nothing],
    state: js.Any
  ): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(
    parent: js.Array[Node],
    opts: TraverseOptions[Node],
    scope: js.UndefOr[scala.Nothing],
    state: js.Any,
    parentPath: NodePath[Node]
  ): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(parent: js.Array[Node], opts: TraverseOptions[Node], scope: Scope): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(
    parent: js.Array[Node],
    opts: TraverseOptions[Node],
    scope: Scope,
    state: js.UndefOr[scala.Nothing],
    parentPath: NodePath[Node]
  ): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(parent: js.Array[Node], opts: TraverseOptions[Node], scope: Scope, state: js.Any): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(
    parent: js.Array[Node],
    opts: TraverseOptions[Node],
    scope: Scope,
    state: js.Any,
    parentPath: NodePath[Node]
  ): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(parent: Node, opts: TraverseOptions[Node]): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(
    parent: Node,
    opts: TraverseOptions[Node],
    scope: js.UndefOr[scala.Nothing],
    state: js.UndefOr[scala.Nothing],
    parentPath: NodePath[Node]
  ): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(parent: Node, opts: TraverseOptions[Node], scope: js.UndefOr[scala.Nothing], state: js.Any): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(
    parent: Node,
    opts: TraverseOptions[Node],
    scope: js.UndefOr[scala.Nothing],
    state: js.Any,
    parentPath: NodePath[Node]
  ): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(parent: Node, opts: TraverseOptions[Node], scope: Scope): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(
    parent: Node,
    opts: TraverseOptions[Node],
    scope: Scope,
    state: js.UndefOr[scala.Nothing],
    parentPath: NodePath[Node]
  ): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(parent: Node, opts: TraverseOptions[Node], scope: Scope, state: js.Any): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default(parent: Node, opts: TraverseOptions[Node], scope: Scope, state: js.Any, parentPath: NodePath[Node]): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default[S](parent: js.Array[Node], opts: TraverseOptions[S], scope: Scope, state: S): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default[S](
    parent: js.Array[Node],
    opts: TraverseOptions[S],
    scope: Scope,
    state: S,
    parentPath: NodePath[Node]
  ): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default[S](parent: Node, opts: TraverseOptions[S], scope: Scope, state: S): Unit = js.native
  @JSImport("babel-traverse", JSImport.Default)
  @js.native
  def default[S](parent: Node, opts: TraverseOptions[S], scope: Scope, state: S, parentPath: NodePath[Node]): Unit = js.native
  
  @JSImport("babel-traverse", "Binding")
  @js.native
  class Binding protected () extends StObject {
    def this(opts: Existing) = this()
    
    var constant: Boolean = js.native
    
    var constantViolations: js.Array[NodePath[Node]] = js.native
    
    var identifier: Identifier_ = js.native
    
    var kind: `var` | let | const | module = js.native
    
    var path: NodePath[Node] = js.native
    
    var referencePaths: js.Array[NodePath[Node]] = js.native
    
    var referenced: Boolean = js.native
    
    var references: Double = js.native
    
    var scope: Scope = js.native
  }
  
  @JSImport("babel-traverse", "Hub")
  @js.native
  class Hub protected () extends StObject {
    def this(file: js.Any, options: js.Any) = this()
    
    var file: js.Any = js.native
    
    var options: js.Any = js.native
  }
  
  @JSImport("babel-traverse", "NodePath")
  @js.native
  class NodePath[T] protected () extends StObject {
    def this(hub: Hub, parent: Node) = this()
    
    def addComment(`type`: String, content: String): Unit = js.native
    def addComment(`type`: String, content: String, line: Boolean): Unit = js.native
    
    /** Give node `comments` of the specified `type`. */
    def addComments(`type`: String, comments: js.Array[_]): Unit = js.native
    
    def assertAnyTypeAnnotation(): Unit = js.native
    def assertAnyTypeAnnotation(opts: js.Object): Unit = js.native
    
    // ------------------------- assertXXX -------------------------
    def assertArrayExpression(): Unit = js.native
    def assertArrayExpression(opts: js.Object): Unit = js.native
    
    def assertArrayPattern(): Unit = js.native
    def assertArrayPattern(opts: js.Object): Unit = js.native
    
    def assertArrayTypeAnnotation(): Unit = js.native
    def assertArrayTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertArrowFunctionExpression(): Unit = js.native
    def assertArrowFunctionExpression(opts: js.Object): Unit = js.native
    
    def assertAssignmentExpression(): Unit = js.native
    def assertAssignmentExpression(opts: js.Object): Unit = js.native
    
    def assertAssignmentPattern(): Unit = js.native
    def assertAssignmentPattern(opts: js.Object): Unit = js.native
    
    def assertAwaitExpression(): Unit = js.native
    def assertAwaitExpression(opts: js.Object): Unit = js.native
    
    def assertBinary(): Unit = js.native
    def assertBinary(opts: js.Object): Unit = js.native
    
    def assertBinaryExpression(): Unit = js.native
    def assertBinaryExpression(opts: js.Object): Unit = js.native
    
    def assertBindExpression(): Unit = js.native
    def assertBindExpression(opts: js.Object): Unit = js.native
    
    def assertBlock(): Unit = js.native
    def assertBlock(opts: js.Object): Unit = js.native
    
    def assertBlockParent(): Unit = js.native
    def assertBlockParent(opts: js.Object): Unit = js.native
    
    def assertBlockStatement(): Unit = js.native
    def assertBlockStatement(opts: js.Object): Unit = js.native
    
    def assertBooleanLiteral(): Unit = js.native
    def assertBooleanLiteral(opts: js.Object): Unit = js.native
    
    def assertBooleanLiteralTypeAnnotation(): Unit = js.native
    def assertBooleanLiteralTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertBooleanTypeAnnotation(): Unit = js.native
    def assertBooleanTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertBreakStatement(): Unit = js.native
    def assertBreakStatement(opts: js.Object): Unit = js.native
    
    def assertCallExpression(): Unit = js.native
    def assertCallExpression(opts: js.Object): Unit = js.native
    
    def assertCatchClause(): Unit = js.native
    def assertCatchClause(opts: js.Object): Unit = js.native
    
    def assertClass(): Unit = js.native
    def assertClass(opts: js.Object): Unit = js.native
    
    def assertClassBody(): Unit = js.native
    def assertClassBody(opts: js.Object): Unit = js.native
    
    def assertClassDeclaration(): Unit = js.native
    def assertClassDeclaration(opts: js.Object): Unit = js.native
    
    def assertClassExpression(): Unit = js.native
    def assertClassExpression(opts: js.Object): Unit = js.native
    
    def assertClassImplements(): Unit = js.native
    def assertClassImplements(opts: js.Object): Unit = js.native
    
    def assertClassMethod(): Unit = js.native
    def assertClassMethod(opts: js.Object): Unit = js.native
    
    def assertClassProperty(): Unit = js.native
    def assertClassProperty(opts: js.Object): Unit = js.native
    
    def assertCompletionStatement(): Unit = js.native
    def assertCompletionStatement(opts: js.Object): Unit = js.native
    
    def assertConditional(): Unit = js.native
    def assertConditional(opts: js.Object): Unit = js.native
    
    def assertConditionalExpression(): Unit = js.native
    def assertConditionalExpression(opts: js.Object): Unit = js.native
    
    def assertContinueStatement(): Unit = js.native
    def assertContinueStatement(opts: js.Object): Unit = js.native
    
    def assertDebuggerStatement(): Unit = js.native
    def assertDebuggerStatement(opts: js.Object): Unit = js.native
    
    def assertDeclaration(): Unit = js.native
    def assertDeclaration(opts: js.Object): Unit = js.native
    
    def assertDeclareClass(): Unit = js.native
    def assertDeclareClass(opts: js.Object): Unit = js.native
    
    def assertDeclareFunction(): Unit = js.native
    def assertDeclareFunction(opts: js.Object): Unit = js.native
    
    def assertDeclareInterface(): Unit = js.native
    def assertDeclareInterface(opts: js.Object): Unit = js.native
    
    def assertDeclareModule(): Unit = js.native
    def assertDeclareModule(opts: js.Object): Unit = js.native
    
    def assertDeclareTypeAlias(): Unit = js.native
    def assertDeclareTypeAlias(opts: js.Object): Unit = js.native
    
    def assertDeclareVariable(): Unit = js.native
    def assertDeclareVariable(opts: js.Object): Unit = js.native
    
    def assertDecorator(): Unit = js.native
    def assertDecorator(opts: js.Object): Unit = js.native
    
    def assertDirective(): Unit = js.native
    def assertDirective(opts: js.Object): Unit = js.native
    
    def assertDirectiveLiteral(): Unit = js.native
    def assertDirectiveLiteral(opts: js.Object): Unit = js.native
    
    def assertDoExpression(): Unit = js.native
    def assertDoExpression(opts: js.Object): Unit = js.native
    
    def assertDoWhileStatement(): Unit = js.native
    def assertDoWhileStatement(opts: js.Object): Unit = js.native
    
    def assertEmptyStatement(): Unit = js.native
    def assertEmptyStatement(opts: js.Object): Unit = js.native
    
    def assertExistentialTypeParam(): Unit = js.native
    def assertExistentialTypeParam(opts: js.Object): Unit = js.native
    
    def assertExportAllDeclaration(): Unit = js.native
    def assertExportAllDeclaration(opts: js.Object): Unit = js.native
    
    def assertExportDeclaration(): Unit = js.native
    def assertExportDeclaration(opts: js.Object): Unit = js.native
    
    def assertExportDefaultDeclaration(): Unit = js.native
    def assertExportDefaultDeclaration(opts: js.Object): Unit = js.native
    
    def assertExportDefaultSpecifier(): Unit = js.native
    def assertExportDefaultSpecifier(opts: js.Object): Unit = js.native
    
    def assertExportNamedDeclaration(): Unit = js.native
    def assertExportNamedDeclaration(opts: js.Object): Unit = js.native
    
    def assertExportNamespaceSpecifier(): Unit = js.native
    def assertExportNamespaceSpecifier(opts: js.Object): Unit = js.native
    
    def assertExportSpecifier(): Unit = js.native
    def assertExportSpecifier(opts: js.Object): Unit = js.native
    
    def assertExpression(): Unit = js.native
    def assertExpression(opts: js.Object): Unit = js.native
    
    def assertExpressionStatement(): Unit = js.native
    def assertExpressionStatement(opts: js.Object): Unit = js.native
    
    def assertExpressionWrapper(): Unit = js.native
    def assertExpressionWrapper(opts: js.Object): Unit = js.native
    
    def assertFile(): Unit = js.native
    def assertFile(opts: js.Object): Unit = js.native
    
    def assertFlow(): Unit = js.native
    def assertFlow(opts: js.Object): Unit = js.native
    
    def assertFlowBaseAnnotation(): Unit = js.native
    def assertFlowBaseAnnotation(opts: js.Object): Unit = js.native
    
    def assertFlowDeclaration(): Unit = js.native
    def assertFlowDeclaration(opts: js.Object): Unit = js.native
    
    def assertFor(): Unit = js.native
    def assertFor(opts: js.Object): Unit = js.native
    
    def assertForInStatement(): Unit = js.native
    def assertForInStatement(opts: js.Object): Unit = js.native
    
    def assertForOfStatement(): Unit = js.native
    def assertForOfStatement(opts: js.Object): Unit = js.native
    
    def assertForStatement(): Unit = js.native
    def assertForStatement(opts: js.Object): Unit = js.native
    
    def assertForXStatement(): Unit = js.native
    def assertForXStatement(opts: js.Object): Unit = js.native
    
    def assertFunction(): Unit = js.native
    def assertFunction(opts: js.Object): Unit = js.native
    
    def assertFunctionDeclaration(): Unit = js.native
    def assertFunctionDeclaration(opts: js.Object): Unit = js.native
    
    def assertFunctionExpression(): Unit = js.native
    def assertFunctionExpression(opts: js.Object): Unit = js.native
    
    def assertFunctionParent(): Unit = js.native
    def assertFunctionParent(opts: js.Object): Unit = js.native
    
    def assertFunctionTypeAnnotation(): Unit = js.native
    def assertFunctionTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertFunctionTypeParam(): Unit = js.native
    def assertFunctionTypeParam(opts: js.Object): Unit = js.native
    
    def assertGenericTypeAnnotation(): Unit = js.native
    def assertGenericTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertIdentifier(): Unit = js.native
    def assertIdentifier(opts: js.Object): Unit = js.native
    
    def assertIfStatement(): Unit = js.native
    def assertIfStatement(opts: js.Object): Unit = js.native
    
    def assertImmutable(): Unit = js.native
    def assertImmutable(opts: js.Object): Unit = js.native
    
    def assertImportDeclaration(): Unit = js.native
    def assertImportDeclaration(opts: js.Object): Unit = js.native
    
    def assertImportDefaultSpecifier(): Unit = js.native
    def assertImportDefaultSpecifier(opts: js.Object): Unit = js.native
    
    def assertImportNamespaceSpecifier(): Unit = js.native
    def assertImportNamespaceSpecifier(opts: js.Object): Unit = js.native
    
    def assertImportSpecifier(): Unit = js.native
    def assertImportSpecifier(opts: js.Object): Unit = js.native
    
    def assertInterfaceDeclaration(): Unit = js.native
    def assertInterfaceDeclaration(opts: js.Object): Unit = js.native
    
    def assertInterfaceExtends(): Unit = js.native
    def assertInterfaceExtends(opts: js.Object): Unit = js.native
    
    def assertIntersectionTypeAnnotation(): Unit = js.native
    def assertIntersectionTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertJSX(): Unit = js.native
    def assertJSX(opts: js.Object): Unit = js.native
    
    def assertJSXAttribute(): Unit = js.native
    def assertJSXAttribute(opts: js.Object): Unit = js.native
    
    def assertJSXClosingElement(): Unit = js.native
    def assertJSXClosingElement(opts: js.Object): Unit = js.native
    
    def assertJSXElement(): Unit = js.native
    def assertJSXElement(opts: js.Object): Unit = js.native
    
    def assertJSXEmptyExpression(): Unit = js.native
    def assertJSXEmptyExpression(opts: js.Object): Unit = js.native
    
    def assertJSXExpressionContainer(): Unit = js.native
    def assertJSXExpressionContainer(opts: js.Object): Unit = js.native
    
    def assertJSXIdentifier(): Unit = js.native
    def assertJSXIdentifier(opts: js.Object): Unit = js.native
    
    def assertJSXMemberExpression(): Unit = js.native
    def assertJSXMemberExpression(opts: js.Object): Unit = js.native
    
    def assertJSXNamespacedName(): Unit = js.native
    def assertJSXNamespacedName(opts: js.Object): Unit = js.native
    
    def assertJSXOpeningElement(): Unit = js.native
    def assertJSXOpeningElement(opts: js.Object): Unit = js.native
    
    def assertJSXSpreadAttribute(): Unit = js.native
    def assertJSXSpreadAttribute(opts: js.Object): Unit = js.native
    
    def assertJSXText(): Unit = js.native
    def assertJSXText(opts: js.Object): Unit = js.native
    
    def assertLVal(): Unit = js.native
    def assertLVal(opts: js.Object): Unit = js.native
    
    def assertLabeledStatement(): Unit = js.native
    def assertLabeledStatement(opts: js.Object): Unit = js.native
    
    def assertLiteral(): Unit = js.native
    def assertLiteral(opts: js.Object): Unit = js.native
    
    def assertLogicalExpression(): Unit = js.native
    def assertLogicalExpression(opts: js.Object): Unit = js.native
    
    def assertLoop(): Unit = js.native
    def assertLoop(opts: js.Object): Unit = js.native
    
    def assertMemberExpression(): Unit = js.native
    def assertMemberExpression(opts: js.Object): Unit = js.native
    
    def assertMetaProperty(): Unit = js.native
    def assertMetaProperty(opts: js.Object): Unit = js.native
    
    def assertMethod(): Unit = js.native
    def assertMethod(opts: js.Object): Unit = js.native
    
    def assertMixedTypeAnnotation(): Unit = js.native
    def assertMixedTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertModuleDeclaration(): Unit = js.native
    def assertModuleDeclaration(opts: js.Object): Unit = js.native
    
    def assertModuleSpecifier(): Unit = js.native
    def assertModuleSpecifier(opts: js.Object): Unit = js.native
    
    def assertNewExpression(): Unit = js.native
    def assertNewExpression(opts: js.Object): Unit = js.native
    
    def assertNoop(): Unit = js.native
    def assertNoop(opts: js.Object): Unit = js.native
    
    def assertNullLiteral(): Unit = js.native
    def assertNullLiteral(opts: js.Object): Unit = js.native
    
    def assertNullLiteralTypeAnnotation(): Unit = js.native
    def assertNullLiteralTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertNullableTypeAnnotation(): Unit = js.native
    def assertNullableTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertNumberLiteral(): Unit = js.native
    def assertNumberLiteral(opts: js.Object): Unit = js.native
    
    def assertNumberTypeAnnotation(): Unit = js.native
    def assertNumberTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertNumericLiteral(): Unit = js.native
    def assertNumericLiteral(opts: js.Object): Unit = js.native
    
    def assertNumericLiteralTypeAnnotation(): Unit = js.native
    def assertNumericLiteralTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertObjectExpression(): Unit = js.native
    def assertObjectExpression(opts: js.Object): Unit = js.native
    
    def assertObjectMember(): Unit = js.native
    def assertObjectMember(opts: js.Object): Unit = js.native
    
    def assertObjectMethod(): Unit = js.native
    def assertObjectMethod(opts: js.Object): Unit = js.native
    
    def assertObjectPattern(): Unit = js.native
    def assertObjectPattern(opts: js.Object): Unit = js.native
    
    def assertObjectProperty(): Unit = js.native
    def assertObjectProperty(opts: js.Object): Unit = js.native
    
    def assertObjectTypeAnnotation(): Unit = js.native
    def assertObjectTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertObjectTypeCallProperty(): Unit = js.native
    def assertObjectTypeCallProperty(opts: js.Object): Unit = js.native
    
    def assertObjectTypeIndexer(): Unit = js.native
    def assertObjectTypeIndexer(opts: js.Object): Unit = js.native
    
    def assertObjectTypeProperty(): Unit = js.native
    def assertObjectTypeProperty(opts: js.Object): Unit = js.native
    
    def assertParenthesizedExpression(): Unit = js.native
    def assertParenthesizedExpression(opts: js.Object): Unit = js.native
    
    def assertPattern(): Unit = js.native
    def assertPattern(opts: js.Object): Unit = js.native
    
    def assertProgram(): Unit = js.native
    def assertProgram(opts: js.Object): Unit = js.native
    
    def assertProperty(): Unit = js.native
    def assertProperty(opts: js.Object): Unit = js.native
    
    def assertPureish(): Unit = js.native
    def assertPureish(opts: js.Object): Unit = js.native
    
    def assertQualifiedTypeIdentifier(): Unit = js.native
    def assertQualifiedTypeIdentifier(opts: js.Object): Unit = js.native
    
    def assertRegExpLiteral(): Unit = js.native
    def assertRegExpLiteral(opts: js.Object): Unit = js.native
    
    def assertRegexLiteral(): Unit = js.native
    def assertRegexLiteral(opts: js.Object): Unit = js.native
    
    def assertRestElement(): Unit = js.native
    def assertRestElement(opts: js.Object): Unit = js.native
    
    def assertRestProperty(): Unit = js.native
    def assertRestProperty(opts: js.Object): Unit = js.native
    
    def assertReturnStatement(): Unit = js.native
    def assertReturnStatement(opts: js.Object): Unit = js.native
    
    def assertScopable(): Unit = js.native
    def assertScopable(opts: js.Object): Unit = js.native
    
    def assertSequenceExpression(): Unit = js.native
    def assertSequenceExpression(opts: js.Object): Unit = js.native
    
    def assertSpreadElement(): Unit = js.native
    def assertSpreadElement(opts: js.Object): Unit = js.native
    
    def assertSpreadProperty(): Unit = js.native
    def assertSpreadProperty(opts: js.Object): Unit = js.native
    
    def assertStatement(): Unit = js.native
    def assertStatement(opts: js.Object): Unit = js.native
    
    def assertStringLiteral(): Unit = js.native
    def assertStringLiteral(opts: js.Object): Unit = js.native
    
    def assertStringLiteralTypeAnnotation(): Unit = js.native
    def assertStringLiteralTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertStringTypeAnnotation(): Unit = js.native
    def assertStringTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertSuper(): Unit = js.native
    def assertSuper(opts: js.Object): Unit = js.native
    
    def assertSwitchCase(): Unit = js.native
    def assertSwitchCase(opts: js.Object): Unit = js.native
    
    def assertSwitchStatement(): Unit = js.native
    def assertSwitchStatement(opts: js.Object): Unit = js.native
    
    def assertTaggedTemplateExpression(): Unit = js.native
    def assertTaggedTemplateExpression(opts: js.Object): Unit = js.native
    
    def assertTemplateElement(): Unit = js.native
    def assertTemplateElement(opts: js.Object): Unit = js.native
    
    def assertTemplateLiteral(): Unit = js.native
    def assertTemplateLiteral(opts: js.Object): Unit = js.native
    
    def assertTerminatorless(): Unit = js.native
    def assertTerminatorless(opts: js.Object): Unit = js.native
    
    def assertThisExpression(): Unit = js.native
    def assertThisExpression(opts: js.Object): Unit = js.native
    
    def assertThisTypeAnnotation(): Unit = js.native
    def assertThisTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertThrowStatement(): Unit = js.native
    def assertThrowStatement(opts: js.Object): Unit = js.native
    
    def assertTryStatement(): Unit = js.native
    def assertTryStatement(opts: js.Object): Unit = js.native
    
    def assertTupleTypeAnnotation(): Unit = js.native
    def assertTupleTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertTypeAlias(): Unit = js.native
    def assertTypeAlias(opts: js.Object): Unit = js.native
    
    def assertTypeAnnotation(): Unit = js.native
    def assertTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertTypeCastExpression(): Unit = js.native
    def assertTypeCastExpression(opts: js.Object): Unit = js.native
    
    def assertTypeParameterDeclaration(): Unit = js.native
    def assertTypeParameterDeclaration(opts: js.Object): Unit = js.native
    
    def assertTypeParameterInstantiation(): Unit = js.native
    def assertTypeParameterInstantiation(opts: js.Object): Unit = js.native
    
    def assertTypeofTypeAnnotation(): Unit = js.native
    def assertTypeofTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertUnaryExpression(): Unit = js.native
    def assertUnaryExpression(opts: js.Object): Unit = js.native
    
    def assertUnaryLike(): Unit = js.native
    def assertUnaryLike(opts: js.Object): Unit = js.native
    
    def assertUnionTypeAnnotation(): Unit = js.native
    def assertUnionTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertUpdateExpression(): Unit = js.native
    def assertUpdateExpression(opts: js.Object): Unit = js.native
    
    def assertUserWhitespacable(): Unit = js.native
    def assertUserWhitespacable(opts: js.Object): Unit = js.native
    
    def assertVariableDeclaration(): Unit = js.native
    def assertVariableDeclaration(opts: js.Object): Unit = js.native
    
    def assertVariableDeclarator(): Unit = js.native
    def assertVariableDeclarator(opts: js.Object): Unit = js.native
    
    def assertVoidTypeAnnotation(): Unit = js.native
    def assertVoidTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertWhile(): Unit = js.native
    def assertWhile(opts: js.Object): Unit = js.native
    
    def assertWhileStatement(): Unit = js.native
    def assertWhileStatement(opts: js.Object): Unit = js.native
    
    def assertWithStatement(): Unit = js.native
    def assertWithStatement(opts: js.Object): Unit = js.native
    
    def assertYieldExpression(): Unit = js.native
    def assertYieldExpression(opts: js.Object): Unit = js.native
    
    def baseTypeStrictlyMatches(right: NodePath[Node]): Boolean = js.native
    
    def buildCodeFrameError[TError /* <: Error */](msg: String): TError = js.native
    def buildCodeFrameError[TError /* <: Error */](msg: String, Error: Instantiable1[/* msg */ String, TError]): TError = js.native
    
    // ------------------------- context -------------------------
    def call(key: String): Boolean = js.native
    
    /**
      * This checks whether or not we're in one of the following positions:
      *
      *   for (KEY in right);
      *   for (KEY;;);
      *
      * This is because these spots allow VariableDeclarations AND normal expressions so we need
      * to tell the path replacement that it's ok to replace this with an expression.
      */
    def canHaveVariableDeclarationOrExpression(): Boolean = js.native
    
    /**
      * This checks whether we are swapping an arrow function's body between an
      * expression and a block statement (or vice versa).
      *
      * This is because arrow functions may implicitly return an expression, which
      * is the same as containing a block statement.
      */
    def canSwapBetweenExpressionAndStatement(replacement: Node): Boolean = js.native
    
    var container: js.Object | js.Array[js.Object] = js.native
    
    var context: TraversalContext = js.native
    
    var contexts: js.Array[TraversalContext] = js.native
    
    def couldBeBaseType(name: String): Boolean = js.native
    
    var data: js.Object = js.native
    
    // Example: https://github.com/babel/babel/blob/63204ae51e020d84a5b246312f5eeb4d981ab952/packages/babel-traverse/src/path/modification.js#L83
    def debug(buildMessage: js.Function0[String]): Unit = js.native
    
    /** Check whether the path node `key` strict equals `value`. */
    def equals(key: String, value: js.Any): Boolean = js.native
    
    /**
      * Walk the input `node` and statically evaluate it.
      *
      * Returns an object in the form `{ confident, value }`. `confident` indicates
      * whether or not we had to drop out of evaluating the expression because of
      * hitting an unknown node that we couldn't confidently find the value of.
      *
      * Example:
      *
      *   t.evaluate(parse("5 + 5")) // { confident: true, value: 10 }
      *   t.evaluate(parse("!true")) // { confident: true, value: false }
      *   t.evaluate(parse("foo + foo")) // { confident: false, value: undefined }
      */
    def evaluate(): Confident = js.native
    
    // ------------------------- evaluation -------------------------
    /**
      * Walk the input `node` and statically evaluate if it's truthy.
      *
      * Returning `true` when we're sure that the expression will evaluate to a
      * truthy value, `false` if we're sure that it will evaluate to a falsy
      * value and `undefined` if we aren't sure. Because of this please do not
      * rely on coercion when using this method and check with === if it's false.
      */
    def evaluateTruthy(): Boolean = js.native
    
    def find(callback: js.Function1[/* path */ NodePath[Node], Boolean]): NodePath[Node] = js.native
    
    // ------------------------- ancestry -------------------------
    /**
      * Call the provided `callback` with the `NodePath`s of all the parents.
      * When the `callback` returns a truthy value, we return that node path.
      */
    def findParent(callback: js.Function1[/* path */ NodePath[Node], Boolean]): NodePath[Node] = js.native
    
    def get(key: String): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get(key: String, context: Boolean): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get(key: String, context: TraversalContext): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get[K /* <: /* keyof T */ String */](key: K): (NodePath[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ]) | (js.Array[
        NodePath[
          /* import warning: importer.ImportType#apply Failed type conversion: T[K][number] */ js.Any
        ]
      ]) = js.native
    def get[K /* <: /* keyof T */ String */](key: K, context: Boolean): (NodePath[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ]) | (js.Array[
        NodePath[
          /* import warning: importer.ImportType#apply Failed type conversion: T[K][number] */ js.Any
        ]
      ]) = js.native
    def get[K /* <: /* keyof T */ String */](key: K, context: TraversalContext): (NodePath[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ]) | (js.Array[
        NodePath[
          /* import warning: importer.ImportType#apply Failed type conversion: T[K][number] */ js.Any
        ]
      ]) = js.native
    
    def getAllNextSiblings(): js.Array[NodePath[Node]] = js.native
    
    def getAllPrevSiblings(): js.Array[NodePath[Node]] = js.native
    
    /**
      * Build an array of node paths containing the entire ancestry of the current node path.
      *
      * NOTE: The current node path is included in this.
      */
    def getAncestry(): js.Array[NodePath[Node]] = js.native
    
    def getBindingIdentifiers(): js.Array[Node] = js.native
    def getBindingIdentifiers(duplicates: Boolean): js.Array[Node] = js.native
    
    def getCompletionRecords(): js.Array[NodePath[Node]] = js.native
    
    def getData(key: String): js.Any = js.native
    def getData(key: String, `def`: js.Any): js.Any = js.native
    
    /** Get the earliest path in the tree where the provided `paths` intersect. */
    def getDeepestCommonAncestorFrom(paths: js.Array[NodePath[Node]]): NodePath[Node] = js.native
    def getDeepestCommonAncestorFrom(
      paths: js.Array[NodePath[Node]],
      filter: js.Function3[
          /* deepest */ Node, 
          /* i */ Double, 
          /* ancestries */ js.Array[NodePath[Node]], 
          NodePath[Node]
        ]
    ): NodePath[Node] = js.native
    
    /**
      * Get the deepest common ancestor and then from it, get the earliest relationship path
      * to that ancestor.
      *
      * Earliest is defined as being "before" all the other nodes in terms of list container
      * position and visiting key.
      */
    def getEarliestCommonAncestorFrom(paths: js.Array[NodePath[Node]]): js.Array[NodePath[Node]] = js.native
    
    /** Get the parent function of the current path. */
    def getFunctionParent(): NodePath[Function] = js.native
    
    // ------------------------- family -------------------------
    def getOpposite(): NodePath[Node] = js.native
    
    def getOuterBindingIdentifiers(): js.Array[Node] = js.native
    def getOuterBindingIdentifiers(duplicates: Boolean): js.Array[Node] = js.native
    
    def getPathLocation(): String = js.native
    
    def getScope(scope: Scope): Scope = js.native
    
    def getSibling(key: String): NodePath[Node] = js.native
    def getSibling(key: Double): NodePath[Node] = js.native
    
    /** Get the source code associated with this node. */
    def getSource(): String = js.native
    
    /** Walk up the tree until we hit a parent node path in a list. */
    def getStatementParent(): NodePath[Statement] = js.native
    
    // ------------------------- inference -------------------------
    /** Infer the type of the current `NodePath`. */
    def getTypeAnnotation(): FlowTypeAnnotation = js.native
    
    /**
      * Check whether we have the input `key`. If the `key` references an array then we check
      * if the array has any items, otherwise we just check if it's falsy.
      */
    def has(key: String): Boolean = js.native
    
    /** Hoist the current node to the highest scope possible and return a UID referencing it. */
    def hoist(scope: Scope): Unit = js.native
    
    var hub: Hub = js.native
    
    var inList: Boolean = js.native
    
    def inType(candidateTypes: String*): Boolean = js.native
    
    def insertAfter(nodes: js.Array[Node]): js.Any = js.native
    /**
      * Insert the provided nodes after the current one. When inserting nodes after an
      * expression, ensure that the completion record is correct by pushing the current node.
      */
    def insertAfter(nodes: Node): js.Any = js.native
    
    def insertBefore(nodes: js.Array[Node]): js.Any = js.native
    // ------------------------- modification -------------------------
    /** Insert the provided nodes before the current one. */
    def insertBefore(nodes: Node): js.Any = js.native
    
    /** Alias of `has`. */
    def is(key: String): Boolean = js.native
    
    def isAnyTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.AnyTypeAnnotation> */ Boolean = js.native
    def isAnyTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.AnyTypeAnnotation> */ Boolean = js.native
    
    // ------------------------- isXXX -------------------------
    def isArrayExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ArrayExpression> */ Boolean = js.native
    def isArrayExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ArrayExpression> */ Boolean = js.native
    
    def isArrayPattern(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ArrayPattern> */ Boolean = js.native
    def isArrayPattern(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ArrayPattern> */ Boolean = js.native
    
    def isArrayTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ArrayTypeAnnotation> */ Boolean = js.native
    def isArrayTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ArrayTypeAnnotation> */ Boolean = js.native
    
    def isArrowFunctionExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ArrowFunctionExpression> */ Boolean = js.native
    def isArrowFunctionExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ArrowFunctionExpression> */ Boolean = js.native
    
    def isAssignmentExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.AssignmentExpression> */ Boolean = js.native
    def isAssignmentExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.AssignmentExpression> */ Boolean = js.native
    
    def isAssignmentPattern(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.AssignmentPattern> */ Boolean = js.native
    def isAssignmentPattern(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.AssignmentPattern> */ Boolean = js.native
    
    def isAwaitExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.AwaitExpression> */ Boolean = js.native
    def isAwaitExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.AwaitExpression> */ Boolean = js.native
    
    def isBaseType(baseName: String): Boolean = js.native
    def isBaseType(baseName: String, soft: Boolean): Boolean = js.native
    
    def isBinary(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Binary> */ Boolean = js.native
    def isBinary(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Binary> */ Boolean = js.native
    
    def isBinaryExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BinaryExpression> */ Boolean = js.native
    def isBinaryExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BinaryExpression> */ Boolean = js.native
    
    def isBindExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BindExpression> */ Boolean = js.native
    def isBindExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BindExpression> */ Boolean = js.native
    
    def isBindingIdentifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Identifier> */ Boolean = js.native
    def isBindingIdentifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Identifier> */ Boolean = js.native
    
    def isBlacklisted(): Boolean = js.native
    
    def isBlock(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Block> */ Boolean = js.native
    def isBlock(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Block> */ Boolean = js.native
    
    def isBlockParent(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BlockParent> */ Boolean = js.native
    def isBlockParent(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BlockParent> */ Boolean = js.native
    
    def isBlockScoped(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FunctionDeclaration | babel-types.babel-types/ts3.6.ClassDeclaration | babel-types.babel-types/ts3.6.VariableDeclaration> */ Boolean = js.native
    def isBlockScoped(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FunctionDeclaration | babel-types.babel-types/ts3.6.ClassDeclaration | babel-types.babel-types/ts3.6.VariableDeclaration> */ Boolean = js.native
    
    def isBlockStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BlockStatement> */ Boolean = js.native
    def isBlockStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BlockStatement> */ Boolean = js.native
    
    def isBooleanLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BooleanLiteral> */ Boolean = js.native
    def isBooleanLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BooleanLiteral> */ Boolean = js.native
    
    def isBooleanLiteralTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BooleanLiteralTypeAnnotation> */ Boolean = js.native
    def isBooleanLiteralTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BooleanLiteralTypeAnnotation> */ Boolean = js.native
    
    def isBooleanTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BooleanTypeAnnotation> */ Boolean = js.native
    def isBooleanTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BooleanTypeAnnotation> */ Boolean = js.native
    
    def isBreakStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BreakStatement> */ Boolean = js.native
    def isBreakStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.BreakStatement> */ Boolean = js.native
    
    def isCallExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.CallExpression> */ Boolean = js.native
    def isCallExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.CallExpression> */ Boolean = js.native
    
    def isCatchClause(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.CatchClause> */ Boolean = js.native
    def isCatchClause(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.CatchClause> */ Boolean = js.native
    
    def isClass(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Class> */ Boolean = js.native
    def isClass(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Class> */ Boolean = js.native
    
    def isClassBody(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ClassBody> */ Boolean = js.native
    def isClassBody(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ClassBody> */ Boolean = js.native
    
    def isClassDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ClassDeclaration> */ Boolean = js.native
    def isClassDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ClassDeclaration> */ Boolean = js.native
    
    def isClassExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ClassExpression> */ Boolean = js.native
    def isClassExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ClassExpression> */ Boolean = js.native
    
    def isClassImplements(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ClassImplements> */ Boolean = js.native
    def isClassImplements(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ClassImplements> */ Boolean = js.native
    
    def isClassMethod(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ClassMethod> */ Boolean = js.native
    def isClassMethod(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ClassMethod> */ Boolean = js.native
    
    def isClassProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ClassProperty> */ Boolean = js.native
    def isClassProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ClassProperty> */ Boolean = js.native
    
    /** Check whether the current path references a completion record */
    def isCompletionRecord(): Boolean = js.native
    def isCompletionRecord(allowInsideFunction: Boolean): Boolean = js.native
    
    def isCompletionStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.CompletionStatement> */ Boolean = js.native
    def isCompletionStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.CompletionStatement> */ Boolean = js.native
    
    def isConditional(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Conditional> */ Boolean = js.native
    def isConditional(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Conditional> */ Boolean = js.native
    
    def isConditionalExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ConditionalExpression> */ Boolean = js.native
    def isConditionalExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ConditionalExpression> */ Boolean = js.native
    
    def isContinueStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ContinueStatement> */ Boolean = js.native
    def isContinueStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ContinueStatement> */ Boolean = js.native
    
    def isDebuggerStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DebuggerStatement> */ Boolean = js.native
    def isDebuggerStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DebuggerStatement> */ Boolean = js.native
    
    def isDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Declaration> */ Boolean = js.native
    def isDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Declaration> */ Boolean = js.native
    
    def isDeclareClass(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DeclareClass> */ Boolean = js.native
    def isDeclareClass(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DeclareClass> */ Boolean = js.native
    
    def isDeclareFunction(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DeclareFunction> */ Boolean = js.native
    def isDeclareFunction(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DeclareFunction> */ Boolean = js.native
    
    def isDeclareInterface(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DeclareInterface> */ Boolean = js.native
    def isDeclareInterface(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DeclareInterface> */ Boolean = js.native
    
    def isDeclareModule(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DeclareModule> */ Boolean = js.native
    def isDeclareModule(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DeclareModule> */ Boolean = js.native
    
    def isDeclareTypeAlias(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DeclareTypeAlias> */ Boolean = js.native
    def isDeclareTypeAlias(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DeclareTypeAlias> */ Boolean = js.native
    
    def isDeclareVariable(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DeclareVariable> */ Boolean = js.native
    def isDeclareVariable(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DeclareVariable> */ Boolean = js.native
    
    def isDecorator(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Decorator> */ Boolean = js.native
    def isDecorator(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Decorator> */ Boolean = js.native
    
    def isDirective(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Directive> */ Boolean = js.native
    def isDirective(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Directive> */ Boolean = js.native
    
    def isDirectiveLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DirectiveLiteral> */ Boolean = js.native
    def isDirectiveLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DirectiveLiteral> */ Boolean = js.native
    
    def isDoExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DoExpression> */ Boolean = js.native
    def isDoExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DoExpression> */ Boolean = js.native
    
    def isDoWhileStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DoWhileStatement> */ Boolean = js.native
    def isDoWhileStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.DoWhileStatement> */ Boolean = js.native
    
    def isEmptyStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.EmptyStatement> */ Boolean = js.native
    def isEmptyStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.EmptyStatement> */ Boolean = js.native
    
    def isExistentialTypeParam(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExistentialTypeParam> */ Boolean = js.native
    def isExistentialTypeParam(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExistentialTypeParam> */ Boolean = js.native
    
    def isExportAllDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportAllDeclaration> */ Boolean = js.native
    def isExportAllDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportAllDeclaration> */ Boolean = js.native
    
    def isExportDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportDeclaration> */ Boolean = js.native
    def isExportDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportDeclaration> */ Boolean = js.native
    
    def isExportDefaultDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportDefaultDeclaration> */ Boolean = js.native
    def isExportDefaultDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportDefaultDeclaration> */ Boolean = js.native
    
    def isExportDefaultSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportDefaultSpecifier> */ Boolean = js.native
    def isExportDefaultSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportDefaultSpecifier> */ Boolean = js.native
    
    def isExportNamedDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportNamedDeclaration> */ Boolean = js.native
    def isExportNamedDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportNamedDeclaration> */ Boolean = js.native
    
    def isExportNamespaceSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportNamespaceSpecifier> */ Boolean = js.native
    def isExportNamespaceSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportNamespaceSpecifier> */ Boolean = js.native
    
    def isExportSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportSpecifier> */ Boolean = js.native
    def isExportSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExportSpecifier> */ Boolean = js.native
    
    def isExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Expression> */ Boolean = js.native
    def isExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Expression> */ Boolean = js.native
    
    def isExpressionStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExpressionStatement> */ Boolean = js.native
    def isExpressionStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExpressionStatement> */ Boolean = js.native
    
    def isExpressionWrapper(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExpressionWrapper> */ Boolean = js.native
    def isExpressionWrapper(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ExpressionWrapper> */ Boolean = js.native
    
    def isFile(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.File> */ Boolean = js.native
    def isFile(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.File> */ Boolean = js.native
    
    def isFlow(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Flow> */ Boolean = js.native
    def isFlow(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Flow> */ Boolean = js.native
    
    def isFlowBaseAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FlowBaseAnnotation> */ Boolean = js.native
    def isFlowBaseAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FlowBaseAnnotation> */ Boolean = js.native
    
    def isFlowDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FlowDeclaration> */ Boolean = js.native
    def isFlowDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FlowDeclaration> */ Boolean = js.native
    
    def isFor(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.For> */ Boolean = js.native
    def isFor(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.For> */ Boolean = js.native
    
    def isForInStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ForInStatement> */ Boolean = js.native
    def isForInStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ForInStatement> */ Boolean = js.native
    
    def isForOfStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ForOfStatement> */ Boolean = js.native
    def isForOfStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ForOfStatement> */ Boolean = js.native
    
    def isForStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ForStatement> */ Boolean = js.native
    def isForStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ForStatement> */ Boolean = js.native
    
    def isForXStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ForXStatement> */ Boolean = js.native
    def isForXStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ForXStatement> */ Boolean = js.native
    
    def isFunction(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Function> */ Boolean = js.native
    def isFunction(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Function> */ Boolean = js.native
    
    def isFunctionDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FunctionDeclaration> */ Boolean = js.native
    def isFunctionDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FunctionDeclaration> */ Boolean = js.native
    
    def isFunctionExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FunctionExpression> */ Boolean = js.native
    def isFunctionExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FunctionExpression> */ Boolean = js.native
    
    def isFunctionParent(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FunctionParent> */ Boolean = js.native
    def isFunctionParent(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FunctionParent> */ Boolean = js.native
    
    def isFunctionTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FunctionTypeAnnotation> */ Boolean = js.native
    def isFunctionTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FunctionTypeAnnotation> */ Boolean = js.native
    
    def isFunctionTypeParam(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FunctionTypeParam> */ Boolean = js.native
    def isFunctionTypeParam(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.FunctionTypeParam> */ Boolean = js.native
    
    def isGenerated(): Boolean = js.native
    def isGenerated(opts: js.Object): Boolean = js.native
    
    def isGenericType(genericName: String): Boolean = js.native
    
    def isGenericTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.GenericTypeAnnotation> */ Boolean = js.native
    def isGenericTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.GenericTypeAnnotation> */ Boolean = js.native
    
    def isIdentifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Identifier> */ Boolean = js.native
    def isIdentifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Identifier> */ Boolean = js.native
    
    def isIfStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.IfStatement> */ Boolean = js.native
    def isIfStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.IfStatement> */ Boolean = js.native
    
    def isImmutable(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Immutable> */ Boolean = js.native
    def isImmutable(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Immutable> */ Boolean = js.native
    
    def isImportDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ImportDeclaration> */ Boolean = js.native
    def isImportDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ImportDeclaration> */ Boolean = js.native
    
    def isImportDefaultSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ImportDefaultSpecifier> */ Boolean = js.native
    def isImportDefaultSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ImportDefaultSpecifier> */ Boolean = js.native
    
    def isImportNamespaceSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ImportNamespaceSpecifier> */ Boolean = js.native
    def isImportNamespaceSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ImportNamespaceSpecifier> */ Boolean = js.native
    
    def isImportSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ImportSpecifier> */ Boolean = js.native
    def isImportSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ImportSpecifier> */ Boolean = js.native
    
    def isInterfaceDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.InterfaceDeclaration> */ Boolean = js.native
    def isInterfaceDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.InterfaceDeclaration> */ Boolean = js.native
    
    def isInterfaceExtends(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.InterfaceExtends> */ Boolean = js.native
    def isInterfaceExtends(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.InterfaceExtends> */ Boolean = js.native
    
    def isIntersectionTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.IntersectionTypeAnnotation> */ Boolean = js.native
    def isIntersectionTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.IntersectionTypeAnnotation> */ Boolean = js.native
    
    def isJSX(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSX> */ Boolean = js.native
    def isJSX(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSX> */ Boolean = js.native
    
    def isJSXAttribute(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXAttribute> */ Boolean = js.native
    def isJSXAttribute(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXAttribute> */ Boolean = js.native
    
    def isJSXClosingElement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXClosingElement> */ Boolean = js.native
    def isJSXClosingElement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXClosingElement> */ Boolean = js.native
    
    def isJSXElement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXElement> */ Boolean = js.native
    def isJSXElement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXElement> */ Boolean = js.native
    
    def isJSXEmptyExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXEmptyExpression> */ Boolean = js.native
    def isJSXEmptyExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXEmptyExpression> */ Boolean = js.native
    
    def isJSXExpressionContainer(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXExpressionContainer> */ Boolean = js.native
    def isJSXExpressionContainer(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXExpressionContainer> */ Boolean = js.native
    
    def isJSXIdentifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXIdentifier> */ Boolean = js.native
    def isJSXIdentifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXIdentifier> */ Boolean = js.native
    
    def isJSXMemberExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXMemberExpression> */ Boolean = js.native
    def isJSXMemberExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXMemberExpression> */ Boolean = js.native
    
    def isJSXNamespacedName(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXNamespacedName> */ Boolean = js.native
    def isJSXNamespacedName(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXNamespacedName> */ Boolean = js.native
    
    def isJSXOpeningElement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXOpeningElement> */ Boolean = js.native
    def isJSXOpeningElement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXOpeningElement> */ Boolean = js.native
    
    def isJSXSpreadAttribute(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXSpreadAttribute> */ Boolean = js.native
    def isJSXSpreadAttribute(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXSpreadAttribute> */ Boolean = js.native
    
    def isJSXText(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXText> */ Boolean = js.native
    def isJSXText(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.JSXText> */ Boolean = js.native
    
    def isLVal(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.LVal> */ Boolean = js.native
    def isLVal(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.LVal> */ Boolean = js.native
    
    def isLabeledStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.LabeledStatement> */ Boolean = js.native
    def isLabeledStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.LabeledStatement> */ Boolean = js.native
    
    def isLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Literal> */ Boolean = js.native
    def isLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Literal> */ Boolean = js.native
    
    def isLogicalExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.LogicalExpression> */ Boolean = js.native
    def isLogicalExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.LogicalExpression> */ Boolean = js.native
    
    def isLoop(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Loop> */ Boolean = js.native
    def isLoop(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Loop> */ Boolean = js.native
    
    def isMemberExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.MemberExpression> */ Boolean = js.native
    def isMemberExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.MemberExpression> */ Boolean = js.native
    
    def isMetaProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.MetaProperty> */ Boolean = js.native
    def isMetaProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.MetaProperty> */ Boolean = js.native
    
    def isMethod(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Method> */ Boolean = js.native
    def isMethod(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Method> */ Boolean = js.native
    
    def isMixedTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.MixedTypeAnnotation> */ Boolean = js.native
    def isMixedTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.MixedTypeAnnotation> */ Boolean = js.native
    
    def isModuleDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ModuleDeclaration> */ Boolean = js.native
    def isModuleDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ModuleDeclaration> */ Boolean = js.native
    
    def isModuleSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ModuleSpecifier> */ Boolean = js.native
    def isModuleSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ModuleSpecifier> */ Boolean = js.native
    
    def isNewExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NewExpression> */ Boolean = js.native
    def isNewExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NewExpression> */ Boolean = js.native
    
    /**
      * Check the type against our stored internal type of the node. This is handy when a node has
      * been removed yet we still internally know the type and need it to calculate node replacement.
      */
    def isNodeType(`type`: String): Boolean = js.native
    
    def isNoop(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Noop> */ Boolean = js.native
    def isNoop(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Noop> */ Boolean = js.native
    
    def isNullLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NullLiteral> */ Boolean = js.native
    def isNullLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NullLiteral> */ Boolean = js.native
    
    def isNullLiteralTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NullLiteralTypeAnnotation> */ Boolean = js.native
    def isNullLiteralTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NullLiteralTypeAnnotation> */ Boolean = js.native
    
    def isNullableTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NullableTypeAnnotation> */ Boolean = js.native
    def isNullableTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NullableTypeAnnotation> */ Boolean = js.native
    
    def isNumberLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NumericLiteral> */ Boolean = js.native
    def isNumberLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NumericLiteral> */ Boolean = js.native
    
    def isNumberTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NumberTypeAnnotation> */ Boolean = js.native
    def isNumberTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NumberTypeAnnotation> */ Boolean = js.native
    
    def isNumericLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NumericLiteral> */ Boolean = js.native
    def isNumericLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NumericLiteral> */ Boolean = js.native
    
    def isNumericLiteralTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NumericLiteralTypeAnnotation> */ Boolean = js.native
    def isNumericLiteralTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.NumericLiteralTypeAnnotation> */ Boolean = js.native
    
    def isObjectExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectExpression> */ Boolean = js.native
    def isObjectExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectExpression> */ Boolean = js.native
    
    def isObjectMember(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectMember> */ Boolean = js.native
    def isObjectMember(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectMember> */ Boolean = js.native
    
    def isObjectMethod(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectMethod> */ Boolean = js.native
    def isObjectMethod(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectMethod> */ Boolean = js.native
    
    def isObjectPattern(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectPattern> */ Boolean = js.native
    def isObjectPattern(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectPattern> */ Boolean = js.native
    
    def isObjectProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectProperty> */ Boolean = js.native
    def isObjectProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectProperty> */ Boolean = js.native
    
    def isObjectTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectTypeAnnotation> */ Boolean = js.native
    def isObjectTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectTypeAnnotation> */ Boolean = js.native
    
    def isObjectTypeCallProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectTypeCallProperty> */ Boolean = js.native
    def isObjectTypeCallProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectTypeCallProperty> */ Boolean = js.native
    
    def isObjectTypeIndexer(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectTypeIndexer> */ Boolean = js.native
    def isObjectTypeIndexer(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectTypeIndexer> */ Boolean = js.native
    
    def isObjectTypeProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectTypeProperty> */ Boolean = js.native
    def isObjectTypeProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ObjectTypeProperty> */ Boolean = js.native
    
    def isParenthesizedExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ParenthesizedExpression> */ Boolean = js.native
    def isParenthesizedExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ParenthesizedExpression> */ Boolean = js.native
    
    def isPattern(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Pattern> */ Boolean = js.native
    def isPattern(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Pattern> */ Boolean = js.native
    
    def isProgram(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Program> */ Boolean = js.native
    def isProgram(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Program> */ Boolean = js.native
    
    def isProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Property> */ Boolean = js.native
    def isProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Property> */ Boolean = js.native
    
    def isPure(): Boolean = js.native
    def isPure(opts: js.Object): Boolean = js.native
    
    def isPureish(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Pureish> */ Boolean = js.native
    def isPureish(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Pureish> */ Boolean = js.native
    
    def isQualifiedTypeIdentifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.QualifiedTypeIdentifier> */ Boolean = js.native
    def isQualifiedTypeIdentifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.QualifiedTypeIdentifier> */ Boolean = js.native
    
    def isReferenced(): Boolean = js.native
    def isReferenced(opts: js.Object): Boolean = js.native
    
    def isReferencedIdentifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Identifier | babel-types.babel-types/ts3.6.JSXIdentifier> */ Boolean = js.native
    def isReferencedIdentifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Identifier | babel-types.babel-types/ts3.6.JSXIdentifier> */ Boolean = js.native
    
    def isReferencedMemberExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.MemberExpression> */ Boolean = js.native
    def isReferencedMemberExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.MemberExpression> */ Boolean = js.native
    
    def isRegExpLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.RegExpLiteral> */ Boolean = js.native
    def isRegExpLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.RegExpLiteral> */ Boolean = js.native
    
    def isRegexLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.RegExpLiteral> */ Boolean = js.native
    def isRegexLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.RegExpLiteral> */ Boolean = js.native
    
    def isRestElement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.RestElement> */ Boolean = js.native
    def isRestElement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.RestElement> */ Boolean = js.native
    
    def isRestProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.RestProperty> */ Boolean = js.native
    def isRestProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.RestProperty> */ Boolean = js.native
    
    def isReturnStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ReturnStatement> */ Boolean = js.native
    def isReturnStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ReturnStatement> */ Boolean = js.native
    
    def isScopable(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Scopable> */ Boolean = js.native
    def isScopable(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Scopable> */ Boolean = js.native
    
    def isScope(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Scopable> */ Boolean = js.native
    def isScope(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Scopable> */ Boolean = js.native
    
    def isSequenceExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.SequenceExpression> */ Boolean = js.native
    def isSequenceExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.SequenceExpression> */ Boolean = js.native
    
    def isSpreadElement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.SpreadElement> */ Boolean = js.native
    def isSpreadElement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.SpreadElement> */ Boolean = js.native
    
    def isSpreadProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.SpreadProperty> */ Boolean = js.native
    def isSpreadProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.SpreadProperty> */ Boolean = js.native
    
    def isStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Statement> */ Boolean = js.native
    def isStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Statement> */ Boolean = js.native
    
    /**
      * Check whether or not the current `key` allows either a single statement or block statement
      * so we can explode it if necessary.
      */
    def isStatementOrBlock(): Boolean = js.native
    
    def isStatic(): Boolean = js.native
    
    def isStringLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.StringLiteral> */ Boolean = js.native
    def isStringLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.StringLiteral> */ Boolean = js.native
    
    def isStringLiteralTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.StringLiteralTypeAnnotation> */ Boolean = js.native
    def isStringLiteralTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.StringLiteralTypeAnnotation> */ Boolean = js.native
    
    def isStringTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.StringTypeAnnotation> */ Boolean = js.native
    def isStringTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.StringTypeAnnotation> */ Boolean = js.native
    
    def isSuper(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Super> */ Boolean = js.native
    def isSuper(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Super> */ Boolean = js.native
    
    def isSwitchCase(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.SwitchCase> */ Boolean = js.native
    def isSwitchCase(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.SwitchCase> */ Boolean = js.native
    
    def isSwitchStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.SwitchStatement> */ Boolean = js.native
    def isSwitchStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.SwitchStatement> */ Boolean = js.native
    
    def isTaggedTemplateExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TaggedTemplateExpression> */ Boolean = js.native
    def isTaggedTemplateExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TaggedTemplateExpression> */ Boolean = js.native
    
    def isTemplateElement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TemplateElement> */ Boolean = js.native
    def isTemplateElement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TemplateElement> */ Boolean = js.native
    
    def isTemplateLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TemplateLiteral> */ Boolean = js.native
    def isTemplateLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TemplateLiteral> */ Boolean = js.native
    
    def isTerminatorless(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Terminatorless> */ Boolean = js.native
    def isTerminatorless(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.Terminatorless> */ Boolean = js.native
    
    def isThisExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ThisExpression> */ Boolean = js.native
    def isThisExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ThisExpression> */ Boolean = js.native
    
    def isThisTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ThisTypeAnnotation> */ Boolean = js.native
    def isThisTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ThisTypeAnnotation> */ Boolean = js.native
    
    def isThrowStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ThrowStatement> */ Boolean = js.native
    def isThrowStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.ThrowStatement> */ Boolean = js.native
    
    def isTryStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TryStatement> */ Boolean = js.native
    def isTryStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TryStatement> */ Boolean = js.native
    
    def isTupleTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TupleTypeAnnotation> */ Boolean = js.native
    def isTupleTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TupleTypeAnnotation> */ Boolean = js.native
    
    def isTypeAlias(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TypeAlias> */ Boolean = js.native
    def isTypeAlias(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TypeAlias> */ Boolean = js.native
    
    def isTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TypeAnnotation> */ Boolean = js.native
    def isTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TypeAnnotation> */ Boolean = js.native
    
    def isTypeCastExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TypeCastExpression> */ Boolean = js.native
    def isTypeCastExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TypeCastExpression> */ Boolean = js.native
    
    def isTypeParameterDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TypeParameterDeclaration> */ Boolean = js.native
    def isTypeParameterDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TypeParameterDeclaration> */ Boolean = js.native
    
    def isTypeParameterInstantiation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TypeParameterInstantiation> */ Boolean = js.native
    def isTypeParameterInstantiation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TypeParameterInstantiation> */ Boolean = js.native
    
    def isTypeofTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TypeofTypeAnnotation> */ Boolean = js.native
    def isTypeofTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.TypeofTypeAnnotation> */ Boolean = js.native
    
    def isUnaryExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.UnaryExpression> */ Boolean = js.native
    def isUnaryExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.UnaryExpression> */ Boolean = js.native
    
    def isUnaryLike(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.UnaryLike> */ Boolean = js.native
    def isUnaryLike(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.UnaryLike> */ Boolean = js.native
    
    def isUnionTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.UnionTypeAnnotation> */ Boolean = js.native
    def isUnionTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.UnionTypeAnnotation> */ Boolean = js.native
    
    def isUpdateExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.UpdateExpression> */ Boolean = js.native
    def isUpdateExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.UpdateExpression> */ Boolean = js.native
    
    def isUser(): Boolean = js.native
    def isUser(opts: js.Object): Boolean = js.native
    
    def isUserWhitespacable(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.UserWhitespacable> */ Boolean = js.native
    def isUserWhitespacable(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.UserWhitespacable> */ Boolean = js.native
    
    def isVar(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.VariableDeclaration> */ Boolean = js.native
    def isVar(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.VariableDeclaration> */ Boolean = js.native
    
    def isVariableDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.VariableDeclaration> */ Boolean = js.native
    def isVariableDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.VariableDeclaration> */ Boolean = js.native
    
    def isVariableDeclarator(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.VariableDeclarator> */ Boolean = js.native
    def isVariableDeclarator(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.VariableDeclarator> */ Boolean = js.native
    
    def isVoidTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.VoidTypeAnnotation> */ Boolean = js.native
    def isVoidTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.VoidTypeAnnotation> */ Boolean = js.native
    
    def isWhile(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.While> */ Boolean = js.native
    def isWhile(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.While> */ Boolean = js.native
    
    def isWhileStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.WhileStatement> */ Boolean = js.native
    def isWhileStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.WhileStatement> */ Boolean = js.native
    
    def isWithStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.WithStatement> */ Boolean = js.native
    def isWithStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.WithStatement> */ Boolean = js.native
    
    def isYieldExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.YieldExpression> */ Boolean = js.native
    def isYieldExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types/ts3.6.YieldExpression> */ Boolean = js.native
    
    /** Opposite of `has`. */
    def isnt(key: String): Boolean = js.native
    
    var key: String | Double = js.native
    
    var listKey: String = js.native
    
    // ------------------------- introspection -------------------------
    /**
      * Match the current node if it matches the provided `pattern`.
      *
      * For example, given the match `React.createClass` it would match the
      * parsed nodes of `React.createClass` and `React["createClass"]`.
      */
    def matchesPattern(pattern: String): Boolean = js.native
    def matchesPattern(pattern: String, allowPartial: Boolean): Boolean = js.native
    
    var node: T = js.native
    
    var opts: js.Object = js.native
    
    var parent: Node = js.native
    
    var parentKey: String = js.native
    
    var parentPath: NodePath[Node] = js.native
    
    def popContext(): Unit = js.native
    
    def pushContext(context: TraversalContext): Unit = js.native
    
    /** Check if the currently assigned path references the `importName` of `moduleSource`. */
    def referencesImport(moduleSource: String, importName: String): Boolean = js.native
    
    // ------------------------- removal -------------------------
    def remove(): Unit = js.native
    
    var removed: Boolean = js.native
    
    /**
      * This method takes an array of statements nodes and then explodes it
      * into expressions. This method retains completion records which is
      * extremely important to retain original semantics.
      */
    def replaceExpressionWithStatements(nodes: js.Array[Node]): Node = js.native
    
    def replaceInline(nodes: js.Array[Node]): Unit = js.native
    def replaceInline(nodes: Node): Unit = js.native
    
    /** Replace the current node with another. */
    def replaceWith(replacement: Node): Unit = js.native
    def replaceWith(replacement: NodePath[Node]): Unit = js.native
    
    // ------------------------- replacement -------------------------
    /**
      * Replace a node with an array of multiple. This method performs the following steps:
      *
      *  - Inherit the comments of first provided node with that of the current node.
      *  - Insert the provided nodes after the current node.
      *  - Remove the current node.
      */
    def replaceWithMultiple(nodes: js.Array[Node]): Unit = js.native
    
    /**
      * Parse a string as an expression and replace the current node with the result.
      *
      * NOTE: This is typically not a good idea to use. Building source strings when
      * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's
      * easier to use, your transforms will be extremely brittle.
      */
    def replaceWithSourceString(replacement: js.Any): Unit = js.native
    
    var scope: Scope = js.native
    
    def set(key: String, node: Node): Unit = js.native
    
    def setContext(context: TraversalContext): NodePath[T] = js.native
    
    def setData(key: String, `val`: js.Any): js.Any = js.native
    
    def setScope(): Unit = js.native
    
    // ------------------------- comments -------------------------
    /** Share comments amongst siblings. */
    def shareCommentsWithSiblings(): Unit = js.native
    
    var shouldSkip: Boolean = js.native
    
    var shouldStop: Boolean = js.native
    
    def skip(): Unit = js.native
    
    def skipKey(key: String): Unit = js.native
    
    var skipKeys: js.Object = js.native
    
    var state: js.Any = js.native
    
    def stop(): Unit = js.native
    
    def traverse(visitor: Visitor[Node]): Unit = js.native
    def traverse[T](visitor: Visitor[T], state: T): Unit = js.native
    
    var `type`: String | Null = js.native
    
    var typeAnnotation: js.Object = js.native
    
    /** Update all sibling node paths after `fromIndex` by `incrementBy`. */
    def updateSiblingKeys(fromIndex: Double, incrementBy: Double): Unit = js.native
    
    def visit(): Boolean = js.native
    
    /** Check if the current path will maybe execute before another path */
    def willIMaybeExecuteBefore(path: NodePath[Node]): Boolean = js.native
  }
  
  @JSImport("babel-traverse", "Scope")
  @js.native
  class Scope protected () extends StObject {
    def this(path: NodePath[Node]) = this()
    def this(path: NodePath[Node], parentScope: Scope) = this()
    
    def addGlobal(node: Node): Unit = js.native
    
    def bindingIdentifierEquals(name: String, node: Node): Boolean = js.native
    
    var bindings: StringDictionary[Binding] = js.native
    
    var block: Node = js.native
    
    def buildUndefinedNode(): Node = js.native
    
    def checkBlockScopedCollisions(local: Node, kind: String, name: String, id: js.Object): Unit = js.native
    
    def dump(): Unit = js.native
    
    /** Generate a unique identifier and add it to the current scope. */
    def generateDeclaredUidIdentifier(): Identifier_ = js.native
    def generateDeclaredUidIdentifier(name: String): Identifier_ = js.native
    
    /** Generate a unique `_id1` binding. */
    def generateUid(): String = js.native
    def generateUid(name: String): String = js.native
    
    /** Generate a unique identifier. */
    def generateUidIdentifier(): Identifier_ = js.native
    def generateUidIdentifier(name: String): Identifier_ = js.native
    
    /** Generate a unique identifier based on a node. */
    def generateUidIdentifierBasedOnNode(parent: Node): Identifier_ = js.native
    def generateUidIdentifierBasedOnNode(parent: Node, defaultName: String): Identifier_ = js.native
    
    /** Walks the scope tree and gathers **all** bindings. */
    def getAllBindings(kinds: String*): js.Object = js.native
    
    def getBinding(name: String): js.UndefOr[Binding] = js.native
    
    def getBindingIdentifier(name: String): Identifier_ = js.native
    
    def getBlockParent(): Scope = js.native
    
    def getData(key: String): js.Any = js.native
    
    def getFunctionParent(): Scope = js.native
    
    def getOwnBinding(name: String): js.UndefOr[Binding] = js.native
    
    def getOwnBindingIdentifier(name: String): Identifier_ = js.native
    
    def getProgramParent(): Scope = js.native
    
    def hasBinding(name: String): Boolean = js.native
    def hasBinding(name: String, noGlobals: Boolean): Boolean = js.native
    
    def hasGlobal(name: String): Boolean = js.native
    
    def hasOwnBinding(name: String): Boolean = js.native
    
    def hasReference(name: String): Boolean = js.native
    
    def hasUid(name: String): Boolean = js.native
    
    var hub: Hub = js.native
    
    def isPure(node: Node): Boolean = js.native
    def isPure(node: Node, constantsOnly: Boolean): Boolean = js.native
    
    /**
      * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.
      * evaluating it wont result in potentially arbitrary code from being ran. The following are
      * whitelisted and determined not to cause side effects:
      *
      *  - `this` expressions
      *  - `super` expressions
      *  - Bound identifiers
      */
    def isStatic(node: Node): Boolean = js.native
    
    /** Possibly generate a memoised identifier if it is not static and has consequences. */
    def maybeGenerateMemoised(node: Node): Identifier_ = js.native
    def maybeGenerateMemoised(node: Node, dontPush: Boolean): Identifier_ = js.native
    
    /** Move a binding of `name` to another `scope`. */
    def moveBindingTo(name: String, scope: Scope): Unit = js.native
    
    var parent: Scope = js.native
    
    var parentBlock: Node = js.native
    
    def parentHasBinding(name: String): Boolean = js.native
    def parentHasBinding(name: String, noGlobals: Boolean): Boolean = js.native
    
    var path: NodePath[Node] = js.native
    
    def push(opts: js.Any): Unit = js.native
    
    def registerBinding(kind: String, path: NodePath[Node]): Unit = js.native
    def registerBinding(kind: String, path: NodePath[Node], bindingPath: NodePath[Node]): Unit = js.native
    
    def registerConstantViolation(path: NodePath[Node]): Unit = js.native
    
    def registerDeclaration(path: NodePath[Node]): Unit = js.native
    
    def removeBinding(name: String): Unit = js.native
    
    def removeData(key: String): Unit = js.native
    
    def removeOwnBinding(name: String): Unit = js.native
    
    def rename(oldName: String): Unit = js.native
    def rename(oldName: String, newName: js.UndefOr[scala.Nothing], block: Node): Unit = js.native
    def rename(oldName: String, newName: String): Unit = js.native
    def rename(oldName: String, newName: String, block: Node): Unit = js.native
    
    def setData(key: String, `val`: js.Any): js.Any = js.native
    
    def toArray(node: Node): Node = js.native
    def toArray(node: Node, i: Double): Node = js.native
    
    def traverse(node: js.Array[Node]): Unit = js.native
    def traverse(node: js.Array[Node], opts: js.UndefOr[scala.Nothing], state: js.Any): Unit = js.native
    def traverse(node: js.Array[Node], opts: TraverseOptions[Node]): Unit = js.native
    def traverse(node: js.Array[Node], opts: TraverseOptions[Node], state: js.Any): Unit = js.native
    def traverse(node: Node): Unit = js.native
    def traverse(node: Node, opts: js.UndefOr[scala.Nothing], state: js.Any): Unit = js.native
    def traverse(node: Node, opts: TraverseOptions[Node]): Unit = js.native
    def traverse(node: Node, opts: TraverseOptions[Node], state: js.Any): Unit = js.native
    def traverse[S](node: js.Array[Node], opts: TraverseOptions[S], state: S): Unit = js.native
    /** Traverse node with current scope and path. */
    def traverse[S](node: Node, opts: TraverseOptions[S], state: S): Unit = js.native
  }
  
  type Node = typings.babelTypes.ts36Mod.Node
  
  @js.native
  trait TraversalContext extends StObject {
    
    var opts: js.Any = js.native
    
    var parentPath: NodePath[Node] = js.native
    
    var scope: Scope = js.native
    
    var state: js.Any = js.native
  }
  object TraversalContext {
    
    @scala.inline
    def apply(opts: js.Any, parentPath: NodePath[Node], scope: Scope, state: js.Any): TraversalContext = {
      val __obj = js.Dynamic.literal(opts = opts.asInstanceOf[js.Any], parentPath = parentPath.asInstanceOf[js.Any], scope = scope.asInstanceOf[js.Any], state = state.asInstanceOf[js.Any])
      __obj.asInstanceOf[TraversalContext]
    }
    
    @scala.inline
    implicit class TraversalContextMutableBuilder[Self <: TraversalContext] (val x: Self) extends AnyVal {
      
      @scala.inline
      def setOpts(value: js.Any): Self = StObject.set(x, "opts", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setParentPath(value: NodePath[Node]): Self = StObject.set(x, "parentPath", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScope(value: Scope): Self = StObject.set(x, "scope", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setState(value: js.Any): Self = StObject.set(x, "state", value.asInstanceOf[js.Any])
    }
  }
  
  @js.native
  trait TraverseOptions[S] extends Visitor[S] {
    
    var noScope: js.UndefOr[Boolean] = js.native
    
    var scope: js.UndefOr[Scope] = js.native
  }
  object TraverseOptions {
    
    @scala.inline
    def apply[S](): TraverseOptions[S] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[TraverseOptions[S]]
    }
    
    @scala.inline
    implicit class TraverseOptionsMutableBuilder[Self <: TraverseOptions[_], S] (val x: Self with TraverseOptions[S]) extends AnyVal {
      
      @scala.inline
      def setNoScope(value: Boolean): Self = StObject.set(x, "noScope", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNoScopeUndefined: Self = StObject.set(x, "noScope", js.undefined)
      
      @scala.inline
      def setScope(value: Scope): Self = StObject.set(x, "scope", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScopeUndefined: Self = StObject.set(x, "scope", js.undefined)
    }
  }
  
  type VisitNode[T, P] = (VisitNodeFunction[T, P]) | VisitNodeObject[T]
  
  type VisitNodeFunction[T, P] = js.ThisFunction2[/* this */ T, /* path */ NodePath[P], /* state */ js.Any, Unit]
  
  @js.native
  trait VisitNodeObject[T] extends StObject {
    
    var enter: js.UndefOr[js.Function2[/* path */ NodePath[T], /* state */ js.Any, Unit]] = js.native
    
    var exit: js.UndefOr[js.Function2[/* path */ NodePath[T], /* state */ js.Any, Unit]] = js.native
  }
  object VisitNodeObject {
    
    @scala.inline
    def apply[T](): VisitNodeObject[T] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[VisitNodeObject[T]]
    }
    
    @scala.inline
    implicit class VisitNodeObjectMutableBuilder[Self <: VisitNodeObject[_], T] (val x: Self with VisitNodeObject[T]) extends AnyVal {
      
      @scala.inline
      def setEnter(value: (/* path */ NodePath[T], /* state */ js.Any) => Unit): Self = StObject.set(x, "enter", js.Any.fromFunction2(value))
      
      @scala.inline
      def setEnterUndefined: Self = StObject.set(x, "enter", js.undefined)
      
      @scala.inline
      def setExit(value: (/* path */ NodePath[T], /* state */ js.Any) => Unit): Self = StObject.set(x, "exit", js.Any.fromFunction2(value))
      
      @scala.inline
      def setExitUndefined: Self = StObject.set(x, "exit", js.undefined)
    }
  }
  
  @js.native
  trait Visitor[S] extends VisitNodeObject[Node] {
    
    var AnyTypeAnnotation: js.UndefOr[VisitNode[S, AnyTypeAnnotation_]] = js.native
    
    var ArrayExpression: js.UndefOr[VisitNode[S, ArrayExpression_]] = js.native
    
    var ArrayPattern: js.UndefOr[VisitNode[S, ArrayPattern_]] = js.native
    
    var ArrayTypeAnnotation: js.UndefOr[VisitNode[S, ArrayTypeAnnotation_]] = js.native
    
    var ArrowFunctionExpression: js.UndefOr[VisitNode[S, ArrowFunctionExpression_]] = js.native
    
    var AssignmentExpression: js.UndefOr[VisitNode[S, AssignmentExpression_]] = js.native
    
    var AssignmentPattern: js.UndefOr[VisitNode[S, AssignmentPattern_]] = js.native
    
    var AwaitExpression: js.UndefOr[VisitNode[S, AwaitExpression_]] = js.native
    
    var Binary: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Binary]] = js.native
    
    var BinaryExpression: js.UndefOr[VisitNode[S, BinaryExpression_]] = js.native
    
    var BindExpression: js.UndefOr[VisitNode[S, BindExpression_]] = js.native
    
    var Block: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Block]] = js.native
    
    var BlockParent: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.BlockParent]] = js.native
    
    var BlockStatement: js.UndefOr[VisitNode[S, BlockStatement_]] = js.native
    
    var BooleanLiteral: js.UndefOr[VisitNode[S, BooleanLiteral_]] = js.native
    
    var BooleanLiteralTypeAnnotation: js.UndefOr[VisitNode[S, BooleanLiteralTypeAnnotation_]] = js.native
    
    var BooleanTypeAnnotation: js.UndefOr[VisitNode[S, BooleanTypeAnnotation_]] = js.native
    
    var BreakStatement: js.UndefOr[VisitNode[S, BreakStatement_]] = js.native
    
    var CallExpression: js.UndefOr[VisitNode[S, CallExpression_]] = js.native
    
    var CatchClause: js.UndefOr[VisitNode[S, CatchClause_]] = js.native
    
    var Class: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Class]] = js.native
    
    var ClassBody: js.UndefOr[VisitNode[S, ClassBody_]] = js.native
    
    var ClassDeclaration: js.UndefOr[VisitNode[S, ClassDeclaration_]] = js.native
    
    var ClassExpression: js.UndefOr[VisitNode[S, ClassExpression_]] = js.native
    
    var ClassImplements: js.UndefOr[VisitNode[S, ClassImplements_]] = js.native
    
    var ClassMethod: js.UndefOr[VisitNode[S, ClassMethod_]] = js.native
    
    var ClassProperty: js.UndefOr[VisitNode[S, ClassProperty_]] = js.native
    
    var CompletionStatement: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.CompletionStatement]] = js.native
    
    var Conditional: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Conditional]] = js.native
    
    var ConditionalExpression: js.UndefOr[VisitNode[S, ConditionalExpression_]] = js.native
    
    var ContinueStatement: js.UndefOr[VisitNode[S, ContinueStatement_]] = js.native
    
    var DebuggerStatement: js.UndefOr[VisitNode[S, DebuggerStatement_]] = js.native
    
    var Declaration: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Declaration]] = js.native
    
    var DeclareClass: js.UndefOr[VisitNode[S, DeclareClass_]] = js.native
    
    var DeclareFunction: js.UndefOr[VisitNode[S, DeclareFunction_]] = js.native
    
    var DeclareInterface: js.UndefOr[VisitNode[S, DeclareInterface_]] = js.native
    
    var DeclareModule: js.UndefOr[VisitNode[S, DeclareModule_]] = js.native
    
    var DeclareTypeAlias: js.UndefOr[VisitNode[S, DeclareTypeAlias_]] = js.native
    
    var DeclareVariable: js.UndefOr[VisitNode[S, DeclareVariable_]] = js.native
    
    var Decorator: js.UndefOr[VisitNode[S, Decorator_]] = js.native
    
    var Directive: js.UndefOr[VisitNode[S, Directive_]] = js.native
    
    var DirectiveLiteral: js.UndefOr[VisitNode[S, DirectiveLiteral_]] = js.native
    
    var DoExpression: js.UndefOr[VisitNode[S, DoExpression_]] = js.native
    
    var DoWhileStatement: js.UndefOr[VisitNode[S, DoWhileStatement_]] = js.native
    
    var EmptyStatement: js.UndefOr[VisitNode[S, EmptyStatement_]] = js.native
    
    var ExistentialTypeParam: js.UndefOr[VisitNode[S, ExistentialTypeParam_]] = js.native
    
    var ExportAllDeclaration: js.UndefOr[VisitNode[S, ExportAllDeclaration_]] = js.native
    
    var ExportDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.ExportDeclaration]] = js.native
    
    var ExportDefaultDeclaration: js.UndefOr[VisitNode[S, ExportDefaultDeclaration_]] = js.native
    
    var ExportDefaultSpecifier: js.UndefOr[VisitNode[S, ExportDefaultSpecifier_]] = js.native
    
    var ExportNamedDeclaration: js.UndefOr[VisitNode[S, ExportNamedDeclaration_]] = js.native
    
    var ExportNamespaceSpecifier: js.UndefOr[VisitNode[S, ExportNamespaceSpecifier_]] = js.native
    
    var ExportSpecifier: js.UndefOr[VisitNode[S, ExportSpecifier_]] = js.native
    
    var Expression: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Expression]] = js.native
    
    var ExpressionStatement: js.UndefOr[VisitNode[S, ExpressionStatement_]] = js.native
    
    var ExpressionWrapper: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.ExpressionWrapper]] = js.native
    
    var File: js.UndefOr[VisitNode[S, File_]] = js.native
    
    var Flow: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Flow]] = js.native
    
    var FlowBaseAnnotation: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.FlowBaseAnnotation]] = js.native
    
    var FlowDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.FlowDeclaration]] = js.native
    
    var For: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.For]] = js.native
    
    var ForInStatement: js.UndefOr[VisitNode[S, ForInStatement_]] = js.native
    
    var ForOfStatement: js.UndefOr[VisitNode[S, ForOfStatement_]] = js.native
    
    var ForStatement: js.UndefOr[VisitNode[S, ForStatement_]] = js.native
    
    var ForXStatement: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.ForXStatement]] = js.native
    
    var Function: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Function]] = js.native
    
    var FunctionDeclaration: js.UndefOr[VisitNode[S, FunctionDeclaration_]] = js.native
    
    var FunctionExpression: js.UndefOr[VisitNode[S, FunctionExpression_]] = js.native
    
    var FunctionParent: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.FunctionParent]] = js.native
    
    var FunctionTypeAnnotation: js.UndefOr[VisitNode[S, FunctionTypeAnnotation_]] = js.native
    
    var FunctionTypeParam: js.UndefOr[VisitNode[S, FunctionTypeParam_]] = js.native
    
    var GenericTypeAnnotation: js.UndefOr[VisitNode[S, GenericTypeAnnotation_]] = js.native
    
    var Identifier: js.UndefOr[VisitNode[S, Identifier_]] = js.native
    
    var IfStatement: js.UndefOr[VisitNode[S, IfStatement_]] = js.native
    
    var Immutable: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Immutable]] = js.native
    
    var ImportDeclaration: js.UndefOr[VisitNode[S, ImportDeclaration_]] = js.native
    
    var ImportDefaultSpecifier: js.UndefOr[VisitNode[S, ImportDefaultSpecifier_]] = js.native
    
    var ImportNamespaceSpecifier: js.UndefOr[VisitNode[S, ImportNamespaceSpecifier_]] = js.native
    
    var ImportSpecifier: js.UndefOr[VisitNode[S, ImportSpecifier_]] = js.native
    
    var InterfaceDeclaration: js.UndefOr[VisitNode[S, InterfaceDeclaration_]] = js.native
    
    var InterfaceExtends: js.UndefOr[VisitNode[S, InterfaceExtends_]] = js.native
    
    var IntersectionTypeAnnotation: js.UndefOr[VisitNode[S, IntersectionTypeAnnotation_]] = js.native
    
    var JSX: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.JSX]] = js.native
    
    var JSXAttribute: js.UndefOr[VisitNode[S, JSXAttribute_]] = js.native
    
    var JSXClosingElement: js.UndefOr[VisitNode[S, JSXClosingElement_]] = js.native
    
    var JSXElement: js.UndefOr[VisitNode[S, JSXElement_]] = js.native
    
    var JSXEmptyExpression: js.UndefOr[VisitNode[S, JSXEmptyExpression_]] = js.native
    
    var JSXExpressionContainer: js.UndefOr[VisitNode[S, JSXExpressionContainer_]] = js.native
    
    var JSXIdentifier: js.UndefOr[VisitNode[S, JSXIdentifier_]] = js.native
    
    var JSXMemberExpression: js.UndefOr[VisitNode[S, JSXMemberExpression_]] = js.native
    
    var JSXNamespacedName: js.UndefOr[VisitNode[S, JSXNamespacedName_]] = js.native
    
    var JSXOpeningElement: js.UndefOr[VisitNode[S, JSXOpeningElement_]] = js.native
    
    var JSXSpreadAttribute: js.UndefOr[VisitNode[S, JSXSpreadAttribute_]] = js.native
    
    var JSXText: js.UndefOr[VisitNode[S, JSXText_]] = js.native
    
    var LVal: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.LVal]] = js.native
    
    var LabeledStatement: js.UndefOr[VisitNode[S, LabeledStatement_]] = js.native
    
    var Literal: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Literal]] = js.native
    
    var LogicalExpression: js.UndefOr[VisitNode[S, LogicalExpression_]] = js.native
    
    var Loop: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Loop]] = js.native
    
    var MemberExpression: js.UndefOr[VisitNode[S, MemberExpression_]] = js.native
    
    var MetaProperty: js.UndefOr[VisitNode[S, MetaProperty_]] = js.native
    
    var Method: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Method]] = js.native
    
    var MixedTypeAnnotation: js.UndefOr[VisitNode[S, MixedTypeAnnotation_]] = js.native
    
    var ModuleDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.ModuleDeclaration]] = js.native
    
    var ModuleSpecifier: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.ModuleSpecifier]] = js.native
    
    var NewExpression: js.UndefOr[VisitNode[S, NewExpression_]] = js.native
    
    var Noop: js.UndefOr[VisitNode[S, Noop_]] = js.native
    
    var NullLiteral: js.UndefOr[VisitNode[S, NullLiteral_]] = js.native
    
    var NullLiteralTypeAnnotation: js.UndefOr[VisitNode[S, NullLiteralTypeAnnotation_]] = js.native
    
    var NullableTypeAnnotation: js.UndefOr[VisitNode[S, NullableTypeAnnotation_]] = js.native
    
    var NumberTypeAnnotation: js.UndefOr[VisitNode[S, NumberTypeAnnotation_]] = js.native
    
    var NumericLiteral: js.UndefOr[VisitNode[S, NumericLiteral_]] = js.native
    
    var NumericLiteralTypeAnnotation: js.UndefOr[VisitNode[S, NumericLiteralTypeAnnotation_]] = js.native
    
    var ObjectExpression: js.UndefOr[VisitNode[S, ObjectExpression_]] = js.native
    
    var ObjectMember: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.ObjectMember]] = js.native
    
    var ObjectMethod: js.UndefOr[VisitNode[S, ObjectMethod_]] = js.native
    
    var ObjectPattern: js.UndefOr[VisitNode[S, ObjectPattern_]] = js.native
    
    var ObjectProperty: js.UndefOr[VisitNode[S, ObjectProperty_]] = js.native
    
    var ObjectTypeAnnotation: js.UndefOr[VisitNode[S, ObjectTypeAnnotation_]] = js.native
    
    var ObjectTypeCallProperty: js.UndefOr[VisitNode[S, ObjectTypeCallProperty_]] = js.native
    
    var ObjectTypeIndexer: js.UndefOr[VisitNode[S, ObjectTypeIndexer_]] = js.native
    
    var ObjectTypeProperty: js.UndefOr[VisitNode[S, ObjectTypeProperty_]] = js.native
    
    var ParenthesizedExpression: js.UndefOr[VisitNode[S, ParenthesizedExpression_]] = js.native
    
    var Pattern: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Pattern]] = js.native
    
    var Program: js.UndefOr[VisitNode[S, Program_]] = js.native
    
    var Property: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Property]] = js.native
    
    var Pureish: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Pureish]] = js.native
    
    var QualifiedTypeIdentifier: js.UndefOr[VisitNode[S, QualifiedTypeIdentifier_]] = js.native
    
    var RegExpLiteral: js.UndefOr[VisitNode[S, RegExpLiteral_]] = js.native
    
    var RestElement: js.UndefOr[VisitNode[S, RestElement_]] = js.native
    
    var RestProperty: js.UndefOr[VisitNode[S, RestProperty_]] = js.native
    
    var ReturnStatement: js.UndefOr[VisitNode[S, ReturnStatement_]] = js.native
    
    var Scopable: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Scopable]] = js.native
    
    var Scope: js.UndefOr[VisitNode[S, Scopable]] = js.native
    
    var SequenceExpression: js.UndefOr[VisitNode[S, SequenceExpression_]] = js.native
    
    var SpreadElement: js.UndefOr[VisitNode[S, SpreadElement_]] = js.native
    
    var SpreadProperty: js.UndefOr[VisitNode[S, SpreadProperty_]] = js.native
    
    var Statement: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Statement]] = js.native
    
    var StringLiteral: js.UndefOr[VisitNode[S, StringLiteral_]] = js.native
    
    var StringLiteralTypeAnnotation: js.UndefOr[VisitNode[S, StringLiteralTypeAnnotation_]] = js.native
    
    var StringTypeAnnotation: js.UndefOr[VisitNode[S, StringTypeAnnotation_]] = js.native
    
    var Super: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Super]] = js.native
    
    var SwitchCase: js.UndefOr[VisitNode[S, SwitchCase_]] = js.native
    
    var SwitchStatement: js.UndefOr[VisitNode[S, SwitchStatement_]] = js.native
    
    var TaggedTemplateExpression: js.UndefOr[VisitNode[S, TaggedTemplateExpression_]] = js.native
    
    var TemplateElement: js.UndefOr[VisitNode[S, TemplateElement_]] = js.native
    
    var TemplateLiteral: js.UndefOr[VisitNode[S, TemplateLiteral_]] = js.native
    
    var Terminatorless: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.Terminatorless]] = js.native
    
    var ThisExpression: js.UndefOr[VisitNode[S, ThisExpression_]] = js.native
    
    var ThisTypeAnnotation: js.UndefOr[VisitNode[S, ThisTypeAnnotation_]] = js.native
    
    var ThrowStatement: js.UndefOr[VisitNode[S, ThrowStatement_]] = js.native
    
    var TryStatement: js.UndefOr[VisitNode[S, TryStatement_]] = js.native
    
    var TupleTypeAnnotation: js.UndefOr[VisitNode[S, TupleTypeAnnotation_]] = js.native
    
    var TypeAlias: js.UndefOr[VisitNode[S, TypeAlias_]] = js.native
    
    var TypeAnnotation: js.UndefOr[VisitNode[S, TypeAnnotation_]] = js.native
    
    var TypeCastExpression: js.UndefOr[VisitNode[S, TypeCastExpression_]] = js.native
    
    var TypeParameterDeclaration: js.UndefOr[VisitNode[S, TypeParameterDeclaration_]] = js.native
    
    var TypeParameterInstantiation: js.UndefOr[VisitNode[S, TypeParameterInstantiation_]] = js.native
    
    var TypeofTypeAnnotation: js.UndefOr[VisitNode[S, TypeofTypeAnnotation_]] = js.native
    
    var UnaryExpression: js.UndefOr[VisitNode[S, UnaryExpression_]] = js.native
    
    var UnaryLike: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.UnaryLike]] = js.native
    
    var UnionTypeAnnotation: js.UndefOr[VisitNode[S, UnionTypeAnnotation_]] = js.native
    
    var UpdateExpression: js.UndefOr[VisitNode[S, UpdateExpression_]] = js.native
    
    var UserWhitespacable: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.UserWhitespacable]] = js.native
    
    var VariableDeclaration: js.UndefOr[VisitNode[S, VariableDeclaration_]] = js.native
    
    var VariableDeclarator: js.UndefOr[VisitNode[S, VariableDeclarator_]] = js.native
    
    var VoidTypeAnnotation: js.UndefOr[VisitNode[S, VoidTypeAnnotation_]] = js.native
    
    var While: js.UndefOr[VisitNode[S, typings.babelTypes.ts36Mod.While]] = js.native
    
    var WhileStatement: js.UndefOr[VisitNode[S, WhileStatement_]] = js.native
    
    var WithStatement: js.UndefOr[VisitNode[S, WithStatement_]] = js.native
    
    var YieldExpression: js.UndefOr[VisitNode[S, YieldExpression_]] = js.native
  }
  object Visitor {
    
    @scala.inline
    def apply[S](): Visitor[S] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Visitor[S]]
    }
    
    @scala.inline
    implicit class VisitorMutableBuilder[Self <: Visitor[_], S] (val x: Self with Visitor[S]) extends AnyVal {
      
      @scala.inline
      def setAnyTypeAnnotation(value: VisitNode[S, AnyTypeAnnotation_]): Self = StObject.set(x, "AnyTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAnyTypeAnnotationUndefined: Self = StObject.set(x, "AnyTypeAnnotation", js.undefined)
      
      @scala.inline
      def setArrayExpression(value: VisitNode[S, ArrayExpression_]): Self = StObject.set(x, "ArrayExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArrayExpressionUndefined: Self = StObject.set(x, "ArrayExpression", js.undefined)
      
      @scala.inline
      def setArrayPattern(value: VisitNode[S, ArrayPattern_]): Self = StObject.set(x, "ArrayPattern", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArrayPatternUndefined: Self = StObject.set(x, "ArrayPattern", js.undefined)
      
      @scala.inline
      def setArrayTypeAnnotation(value: VisitNode[S, ArrayTypeAnnotation_]): Self = StObject.set(x, "ArrayTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArrayTypeAnnotationUndefined: Self = StObject.set(x, "ArrayTypeAnnotation", js.undefined)
      
      @scala.inline
      def setArrowFunctionExpression(value: VisitNode[S, ArrowFunctionExpression_]): Self = StObject.set(x, "ArrowFunctionExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setArrowFunctionExpressionUndefined: Self = StObject.set(x, "ArrowFunctionExpression", js.undefined)
      
      @scala.inline
      def setAssignmentExpression(value: VisitNode[S, AssignmentExpression_]): Self = StObject.set(x, "AssignmentExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAssignmentExpressionUndefined: Self = StObject.set(x, "AssignmentExpression", js.undefined)
      
      @scala.inline
      def setAssignmentPattern(value: VisitNode[S, AssignmentPattern_]): Self = StObject.set(x, "AssignmentPattern", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAssignmentPatternUndefined: Self = StObject.set(x, "AssignmentPattern", js.undefined)
      
      @scala.inline
      def setAwaitExpression(value: VisitNode[S, AwaitExpression_]): Self = StObject.set(x, "AwaitExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setAwaitExpressionUndefined: Self = StObject.set(x, "AwaitExpression", js.undefined)
      
      @scala.inline
      def setBinary(value: VisitNode[S, Binary]): Self = StObject.set(x, "Binary", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBinaryExpression(value: VisitNode[S, BinaryExpression_]): Self = StObject.set(x, "BinaryExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBinaryExpressionUndefined: Self = StObject.set(x, "BinaryExpression", js.undefined)
      
      @scala.inline
      def setBinaryUndefined: Self = StObject.set(x, "Binary", js.undefined)
      
      @scala.inline
      def setBindExpression(value: VisitNode[S, BindExpression_]): Self = StObject.set(x, "BindExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBindExpressionUndefined: Self = StObject.set(x, "BindExpression", js.undefined)
      
      @scala.inline
      def setBlock(value: VisitNode[S, Block]): Self = StObject.set(x, "Block", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBlockParent(value: VisitNode[S, BlockParent]): Self = StObject.set(x, "BlockParent", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBlockParentUndefined: Self = StObject.set(x, "BlockParent", js.undefined)
      
      @scala.inline
      def setBlockStatement(value: VisitNode[S, BlockStatement_]): Self = StObject.set(x, "BlockStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBlockStatementUndefined: Self = StObject.set(x, "BlockStatement", js.undefined)
      
      @scala.inline
      def setBlockUndefined: Self = StObject.set(x, "Block", js.undefined)
      
      @scala.inline
      def setBooleanLiteral(value: VisitNode[S, BooleanLiteral_]): Self = StObject.set(x, "BooleanLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBooleanLiteralTypeAnnotation(value: VisitNode[S, BooleanLiteralTypeAnnotation_]): Self = StObject.set(x, "BooleanLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBooleanLiteralTypeAnnotationUndefined: Self = StObject.set(x, "BooleanLiteralTypeAnnotation", js.undefined)
      
      @scala.inline
      def setBooleanLiteralUndefined: Self = StObject.set(x, "BooleanLiteral", js.undefined)
      
      @scala.inline
      def setBooleanTypeAnnotation(value: VisitNode[S, BooleanTypeAnnotation_]): Self = StObject.set(x, "BooleanTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBooleanTypeAnnotationUndefined: Self = StObject.set(x, "BooleanTypeAnnotation", js.undefined)
      
      @scala.inline
      def setBreakStatement(value: VisitNode[S, BreakStatement_]): Self = StObject.set(x, "BreakStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setBreakStatementUndefined: Self = StObject.set(x, "BreakStatement", js.undefined)
      
      @scala.inline
      def setCallExpression(value: VisitNode[S, CallExpression_]): Self = StObject.set(x, "CallExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCallExpressionUndefined: Self = StObject.set(x, "CallExpression", js.undefined)
      
      @scala.inline
      def setCatchClause(value: VisitNode[S, CatchClause_]): Self = StObject.set(x, "CatchClause", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCatchClauseUndefined: Self = StObject.set(x, "CatchClause", js.undefined)
      
      @scala.inline
      def setClass(value: VisitNode[S, Class]): Self = StObject.set(x, "Class", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassBody(value: VisitNode[S, ClassBody_]): Self = StObject.set(x, "ClassBody", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassBodyUndefined: Self = StObject.set(x, "ClassBody", js.undefined)
      
      @scala.inline
      def setClassDeclaration(value: VisitNode[S, ClassDeclaration_]): Self = StObject.set(x, "ClassDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassDeclarationUndefined: Self = StObject.set(x, "ClassDeclaration", js.undefined)
      
      @scala.inline
      def setClassExpression(value: VisitNode[S, ClassExpression_]): Self = StObject.set(x, "ClassExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassExpressionUndefined: Self = StObject.set(x, "ClassExpression", js.undefined)
      
      @scala.inline
      def setClassImplements(value: VisitNode[S, ClassImplements_]): Self = StObject.set(x, "ClassImplements", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassImplementsUndefined: Self = StObject.set(x, "ClassImplements", js.undefined)
      
      @scala.inline
      def setClassMethod(value: VisitNode[S, ClassMethod_]): Self = StObject.set(x, "ClassMethod", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassMethodUndefined: Self = StObject.set(x, "ClassMethod", js.undefined)
      
      @scala.inline
      def setClassProperty(value: VisitNode[S, ClassProperty_]): Self = StObject.set(x, "ClassProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setClassPropertyUndefined: Self = StObject.set(x, "ClassProperty", js.undefined)
      
      @scala.inline
      def setClassUndefined: Self = StObject.set(x, "Class", js.undefined)
      
      @scala.inline
      def setCompletionStatement(value: VisitNode[S, CompletionStatement]): Self = StObject.set(x, "CompletionStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setCompletionStatementUndefined: Self = StObject.set(x, "CompletionStatement", js.undefined)
      
      @scala.inline
      def setConditional(value: VisitNode[S, Conditional]): Self = StObject.set(x, "Conditional", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setConditionalExpression(value: VisitNode[S, ConditionalExpression_]): Self = StObject.set(x, "ConditionalExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setConditionalExpressionUndefined: Self = StObject.set(x, "ConditionalExpression", js.undefined)
      
      @scala.inline
      def setConditionalUndefined: Self = StObject.set(x, "Conditional", js.undefined)
      
      @scala.inline
      def setContinueStatement(value: VisitNode[S, ContinueStatement_]): Self = StObject.set(x, "ContinueStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setContinueStatementUndefined: Self = StObject.set(x, "ContinueStatement", js.undefined)
      
      @scala.inline
      def setDebuggerStatement(value: VisitNode[S, DebuggerStatement_]): Self = StObject.set(x, "DebuggerStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDebuggerStatementUndefined: Self = StObject.set(x, "DebuggerStatement", js.undefined)
      
      @scala.inline
      def setDeclaration(value: VisitNode[S, Declaration]): Self = StObject.set(x, "Declaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclarationUndefined: Self = StObject.set(x, "Declaration", js.undefined)
      
      @scala.inline
      def setDeclareClass(value: VisitNode[S, DeclareClass_]): Self = StObject.set(x, "DeclareClass", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareClassUndefined: Self = StObject.set(x, "DeclareClass", js.undefined)
      
      @scala.inline
      def setDeclareFunction(value: VisitNode[S, DeclareFunction_]): Self = StObject.set(x, "DeclareFunction", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareFunctionUndefined: Self = StObject.set(x, "DeclareFunction", js.undefined)
      
      @scala.inline
      def setDeclareInterface(value: VisitNode[S, DeclareInterface_]): Self = StObject.set(x, "DeclareInterface", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareInterfaceUndefined: Self = StObject.set(x, "DeclareInterface", js.undefined)
      
      @scala.inline
      def setDeclareModule(value: VisitNode[S, DeclareModule_]): Self = StObject.set(x, "DeclareModule", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareModuleUndefined: Self = StObject.set(x, "DeclareModule", js.undefined)
      
      @scala.inline
      def setDeclareTypeAlias(value: VisitNode[S, DeclareTypeAlias_]): Self = StObject.set(x, "DeclareTypeAlias", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareTypeAliasUndefined: Self = StObject.set(x, "DeclareTypeAlias", js.undefined)
      
      @scala.inline
      def setDeclareVariable(value: VisitNode[S, DeclareVariable_]): Self = StObject.set(x, "DeclareVariable", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDeclareVariableUndefined: Self = StObject.set(x, "DeclareVariable", js.undefined)
      
      @scala.inline
      def setDecorator(value: VisitNode[S, Decorator_]): Self = StObject.set(x, "Decorator", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDecoratorUndefined: Self = StObject.set(x, "Decorator", js.undefined)
      
      @scala.inline
      def setDirective(value: VisitNode[S, Directive_]): Self = StObject.set(x, "Directive", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDirectiveLiteral(value: VisitNode[S, DirectiveLiteral_]): Self = StObject.set(x, "DirectiveLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDirectiveLiteralUndefined: Self = StObject.set(x, "DirectiveLiteral", js.undefined)
      
      @scala.inline
      def setDirectiveUndefined: Self = StObject.set(x, "Directive", js.undefined)
      
      @scala.inline
      def setDoExpression(value: VisitNode[S, DoExpression_]): Self = StObject.set(x, "DoExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDoExpressionUndefined: Self = StObject.set(x, "DoExpression", js.undefined)
      
      @scala.inline
      def setDoWhileStatement(value: VisitNode[S, DoWhileStatement_]): Self = StObject.set(x, "DoWhileStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setDoWhileStatementUndefined: Self = StObject.set(x, "DoWhileStatement", js.undefined)
      
      @scala.inline
      def setEmptyStatement(value: VisitNode[S, EmptyStatement_]): Self = StObject.set(x, "EmptyStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setEmptyStatementUndefined: Self = StObject.set(x, "EmptyStatement", js.undefined)
      
      @scala.inline
      def setExistentialTypeParam(value: VisitNode[S, ExistentialTypeParam_]): Self = StObject.set(x, "ExistentialTypeParam", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExistentialTypeParamUndefined: Self = StObject.set(x, "ExistentialTypeParam", js.undefined)
      
      @scala.inline
      def setExportAllDeclaration(value: VisitNode[S, ExportAllDeclaration_]): Self = StObject.set(x, "ExportAllDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportAllDeclarationUndefined: Self = StObject.set(x, "ExportAllDeclaration", js.undefined)
      
      @scala.inline
      def setExportDeclaration(value: VisitNode[S, ExportDeclaration]): Self = StObject.set(x, "ExportDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportDeclarationUndefined: Self = StObject.set(x, "ExportDeclaration", js.undefined)
      
      @scala.inline
      def setExportDefaultDeclaration(value: VisitNode[S, ExportDefaultDeclaration_]): Self = StObject.set(x, "ExportDefaultDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportDefaultDeclarationUndefined: Self = StObject.set(x, "ExportDefaultDeclaration", js.undefined)
      
      @scala.inline
      def setExportDefaultSpecifier(value: VisitNode[S, ExportDefaultSpecifier_]): Self = StObject.set(x, "ExportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportDefaultSpecifierUndefined: Self = StObject.set(x, "ExportDefaultSpecifier", js.undefined)
      
      @scala.inline
      def setExportNamedDeclaration(value: VisitNode[S, ExportNamedDeclaration_]): Self = StObject.set(x, "ExportNamedDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportNamedDeclarationUndefined: Self = StObject.set(x, "ExportNamedDeclaration", js.undefined)
      
      @scala.inline
      def setExportNamespaceSpecifier(value: VisitNode[S, ExportNamespaceSpecifier_]): Self = StObject.set(x, "ExportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportNamespaceSpecifierUndefined: Self = StObject.set(x, "ExportNamespaceSpecifier", js.undefined)
      
      @scala.inline
      def setExportSpecifier(value: VisitNode[S, ExportSpecifier_]): Self = StObject.set(x, "ExportSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExportSpecifierUndefined: Self = StObject.set(x, "ExportSpecifier", js.undefined)
      
      @scala.inline
      def setExpression(value: VisitNode[S, Expression]): Self = StObject.set(x, "Expression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExpressionStatement(value: VisitNode[S, ExpressionStatement_]): Self = StObject.set(x, "ExpressionStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExpressionStatementUndefined: Self = StObject.set(x, "ExpressionStatement", js.undefined)
      
      @scala.inline
      def setExpressionUndefined: Self = StObject.set(x, "Expression", js.undefined)
      
      @scala.inline
      def setExpressionWrapper(value: VisitNode[S, ExpressionWrapper]): Self = StObject.set(x, "ExpressionWrapper", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setExpressionWrapperUndefined: Self = StObject.set(x, "ExpressionWrapper", js.undefined)
      
      @scala.inline
      def setFile(value: VisitNode[S, File_]): Self = StObject.set(x, "File", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFileUndefined: Self = StObject.set(x, "File", js.undefined)
      
      @scala.inline
      def setFlow(value: VisitNode[S, Flow]): Self = StObject.set(x, "Flow", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFlowBaseAnnotation(value: VisitNode[S, FlowBaseAnnotation]): Self = StObject.set(x, "FlowBaseAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFlowBaseAnnotationUndefined: Self = StObject.set(x, "FlowBaseAnnotation", js.undefined)
      
      @scala.inline
      def setFlowDeclaration(value: VisitNode[S, FlowDeclaration]): Self = StObject.set(x, "FlowDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFlowDeclarationUndefined: Self = StObject.set(x, "FlowDeclaration", js.undefined)
      
      @scala.inline
      def setFlowUndefined: Self = StObject.set(x, "Flow", js.undefined)
      
      @scala.inline
      def setFor(value: VisitNode[S, For]): Self = StObject.set(x, "For", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForInStatement(value: VisitNode[S, ForInStatement_]): Self = StObject.set(x, "ForInStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForInStatementUndefined: Self = StObject.set(x, "ForInStatement", js.undefined)
      
      @scala.inline
      def setForOfStatement(value: VisitNode[S, ForOfStatement_]): Self = StObject.set(x, "ForOfStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForOfStatementUndefined: Self = StObject.set(x, "ForOfStatement", js.undefined)
      
      @scala.inline
      def setForStatement(value: VisitNode[S, ForStatement_]): Self = StObject.set(x, "ForStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForStatementUndefined: Self = StObject.set(x, "ForStatement", js.undefined)
      
      @scala.inline
      def setForUndefined: Self = StObject.set(x, "For", js.undefined)
      
      @scala.inline
      def setForXStatement(value: VisitNode[S, ForXStatement]): Self = StObject.set(x, "ForXStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setForXStatementUndefined: Self = StObject.set(x, "ForXStatement", js.undefined)
      
      @scala.inline
      def setFunction(value: VisitNode[S, Function]): Self = StObject.set(x, "Function", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionDeclaration(value: VisitNode[S, FunctionDeclaration_]): Self = StObject.set(x, "FunctionDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionDeclarationUndefined: Self = StObject.set(x, "FunctionDeclaration", js.undefined)
      
      @scala.inline
      def setFunctionExpression(value: VisitNode[S, FunctionExpression_]): Self = StObject.set(x, "FunctionExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionExpressionUndefined: Self = StObject.set(x, "FunctionExpression", js.undefined)
      
      @scala.inline
      def setFunctionParent(value: VisitNode[S, FunctionParent]): Self = StObject.set(x, "FunctionParent", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionParentUndefined: Self = StObject.set(x, "FunctionParent", js.undefined)
      
      @scala.inline
      def setFunctionTypeAnnotation(value: VisitNode[S, FunctionTypeAnnotation_]): Self = StObject.set(x, "FunctionTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionTypeAnnotationUndefined: Self = StObject.set(x, "FunctionTypeAnnotation", js.undefined)
      
      @scala.inline
      def setFunctionTypeParam(value: VisitNode[S, FunctionTypeParam_]): Self = StObject.set(x, "FunctionTypeParam", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setFunctionTypeParamUndefined: Self = StObject.set(x, "FunctionTypeParam", js.undefined)
      
      @scala.inline
      def setFunctionUndefined: Self = StObject.set(x, "Function", js.undefined)
      
      @scala.inline
      def setGenericTypeAnnotation(value: VisitNode[S, GenericTypeAnnotation_]): Self = StObject.set(x, "GenericTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setGenericTypeAnnotationUndefined: Self = StObject.set(x, "GenericTypeAnnotation", js.undefined)
      
      @scala.inline
      def setIdentifier(value: VisitNode[S, Identifier_]): Self = StObject.set(x, "Identifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIdentifierUndefined: Self = StObject.set(x, "Identifier", js.undefined)
      
      @scala.inline
      def setIfStatement(value: VisitNode[S, IfStatement_]): Self = StObject.set(x, "IfStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIfStatementUndefined: Self = StObject.set(x, "IfStatement", js.undefined)
      
      @scala.inline
      def setImmutable(value: VisitNode[S, Immutable]): Self = StObject.set(x, "Immutable", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImmutableUndefined: Self = StObject.set(x, "Immutable", js.undefined)
      
      @scala.inline
      def setImportDeclaration(value: VisitNode[S, ImportDeclaration_]): Self = StObject.set(x, "ImportDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportDeclarationUndefined: Self = StObject.set(x, "ImportDeclaration", js.undefined)
      
      @scala.inline
      def setImportDefaultSpecifier(value: VisitNode[S, ImportDefaultSpecifier_]): Self = StObject.set(x, "ImportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportDefaultSpecifierUndefined: Self = StObject.set(x, "ImportDefaultSpecifier", js.undefined)
      
      @scala.inline
      def setImportNamespaceSpecifier(value: VisitNode[S, ImportNamespaceSpecifier_]): Self = StObject.set(x, "ImportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportNamespaceSpecifierUndefined: Self = StObject.set(x, "ImportNamespaceSpecifier", js.undefined)
      
      @scala.inline
      def setImportSpecifier(value: VisitNode[S, ImportSpecifier_]): Self = StObject.set(x, "ImportSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setImportSpecifierUndefined: Self = StObject.set(x, "ImportSpecifier", js.undefined)
      
      @scala.inline
      def setInterfaceDeclaration(value: VisitNode[S, InterfaceDeclaration_]): Self = StObject.set(x, "InterfaceDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setInterfaceDeclarationUndefined: Self = StObject.set(x, "InterfaceDeclaration", js.undefined)
      
      @scala.inline
      def setInterfaceExtends(value: VisitNode[S, InterfaceExtends_]): Self = StObject.set(x, "InterfaceExtends", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setInterfaceExtendsUndefined: Self = StObject.set(x, "InterfaceExtends", js.undefined)
      
      @scala.inline
      def setIntersectionTypeAnnotation(value: VisitNode[S, IntersectionTypeAnnotation_]): Self = StObject.set(x, "IntersectionTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setIntersectionTypeAnnotationUndefined: Self = StObject.set(x, "IntersectionTypeAnnotation", js.undefined)
      
      @scala.inline
      def setJSX(value: VisitNode[S, JSX]): Self = StObject.set(x, "JSX", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXAttribute(value: VisitNode[S, JSXAttribute_]): Self = StObject.set(x, "JSXAttribute", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXAttributeUndefined: Self = StObject.set(x, "JSXAttribute", js.undefined)
      
      @scala.inline
      def setJSXClosingElement(value: VisitNode[S, JSXClosingElement_]): Self = StObject.set(x, "JSXClosingElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXClosingElementUndefined: Self = StObject.set(x, "JSXClosingElement", js.undefined)
      
      @scala.inline
      def setJSXElement(value: VisitNode[S, JSXElement_]): Self = StObject.set(x, "JSXElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXElementUndefined: Self = StObject.set(x, "JSXElement", js.undefined)
      
      @scala.inline
      def setJSXEmptyExpression(value: VisitNode[S, JSXEmptyExpression_]): Self = StObject.set(x, "JSXEmptyExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXEmptyExpressionUndefined: Self = StObject.set(x, "JSXEmptyExpression", js.undefined)
      
      @scala.inline
      def setJSXExpressionContainer(value: VisitNode[S, JSXExpressionContainer_]): Self = StObject.set(x, "JSXExpressionContainer", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXExpressionContainerUndefined: Self = StObject.set(x, "JSXExpressionContainer", js.undefined)
      
      @scala.inline
      def setJSXIdentifier(value: VisitNode[S, JSXIdentifier_]): Self = StObject.set(x, "JSXIdentifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXIdentifierUndefined: Self = StObject.set(x, "JSXIdentifier", js.undefined)
      
      @scala.inline
      def setJSXMemberExpression(value: VisitNode[S, JSXMemberExpression_]): Self = StObject.set(x, "JSXMemberExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXMemberExpressionUndefined: Self = StObject.set(x, "JSXMemberExpression", js.undefined)
      
      @scala.inline
      def setJSXNamespacedName(value: VisitNode[S, JSXNamespacedName_]): Self = StObject.set(x, "JSXNamespacedName", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXNamespacedNameUndefined: Self = StObject.set(x, "JSXNamespacedName", js.undefined)
      
      @scala.inline
      def setJSXOpeningElement(value: VisitNode[S, JSXOpeningElement_]): Self = StObject.set(x, "JSXOpeningElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXOpeningElementUndefined: Self = StObject.set(x, "JSXOpeningElement", js.undefined)
      
      @scala.inline
      def setJSXSpreadAttribute(value: VisitNode[S, JSXSpreadAttribute_]): Self = StObject.set(x, "JSXSpreadAttribute", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXSpreadAttributeUndefined: Self = StObject.set(x, "JSXSpreadAttribute", js.undefined)
      
      @scala.inline
      def setJSXText(value: VisitNode[S, JSXText_]): Self = StObject.set(x, "JSXText", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setJSXTextUndefined: Self = StObject.set(x, "JSXText", js.undefined)
      
      @scala.inline
      def setJSXUndefined: Self = StObject.set(x, "JSX", js.undefined)
      
      @scala.inline
      def setLVal(value: VisitNode[S, LVal]): Self = StObject.set(x, "LVal", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLValUndefined: Self = StObject.set(x, "LVal", js.undefined)
      
      @scala.inline
      def setLabeledStatement(value: VisitNode[S, LabeledStatement_]): Self = StObject.set(x, "LabeledStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLabeledStatementUndefined: Self = StObject.set(x, "LabeledStatement", js.undefined)
      
      @scala.inline
      def setLiteral(value: VisitNode[S, Literal]): Self = StObject.set(x, "Literal", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLiteralUndefined: Self = StObject.set(x, "Literal", js.undefined)
      
      @scala.inline
      def setLogicalExpression(value: VisitNode[S, LogicalExpression_]): Self = StObject.set(x, "LogicalExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLogicalExpressionUndefined: Self = StObject.set(x, "LogicalExpression", js.undefined)
      
      @scala.inline
      def setLoop(value: VisitNode[S, Loop]): Self = StObject.set(x, "Loop", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setLoopUndefined: Self = StObject.set(x, "Loop", js.undefined)
      
      @scala.inline
      def setMemberExpression(value: VisitNode[S, MemberExpression_]): Self = StObject.set(x, "MemberExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMemberExpressionUndefined: Self = StObject.set(x, "MemberExpression", js.undefined)
      
      @scala.inline
      def setMetaProperty(value: VisitNode[S, MetaProperty_]): Self = StObject.set(x, "MetaProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMetaPropertyUndefined: Self = StObject.set(x, "MetaProperty", js.undefined)
      
      @scala.inline
      def setMethod(value: VisitNode[S, Method]): Self = StObject.set(x, "Method", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMethodUndefined: Self = StObject.set(x, "Method", js.undefined)
      
      @scala.inline
      def setMixedTypeAnnotation(value: VisitNode[S, MixedTypeAnnotation_]): Self = StObject.set(x, "MixedTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setMixedTypeAnnotationUndefined: Self = StObject.set(x, "MixedTypeAnnotation", js.undefined)
      
      @scala.inline
      def setModuleDeclaration(value: VisitNode[S, ModuleDeclaration]): Self = StObject.set(x, "ModuleDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setModuleDeclarationUndefined: Self = StObject.set(x, "ModuleDeclaration", js.undefined)
      
      @scala.inline
      def setModuleSpecifier(value: VisitNode[S, ModuleSpecifier]): Self = StObject.set(x, "ModuleSpecifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setModuleSpecifierUndefined: Self = StObject.set(x, "ModuleSpecifier", js.undefined)
      
      @scala.inline
      def setNewExpression(value: VisitNode[S, NewExpression_]): Self = StObject.set(x, "NewExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNewExpressionUndefined: Self = StObject.set(x, "NewExpression", js.undefined)
      
      @scala.inline
      def setNoop(value: VisitNode[S, Noop_]): Self = StObject.set(x, "Noop", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNoopUndefined: Self = StObject.set(x, "Noop", js.undefined)
      
      @scala.inline
      def setNullLiteral(value: VisitNode[S, NullLiteral_]): Self = StObject.set(x, "NullLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNullLiteralTypeAnnotation(value: VisitNode[S, NullLiteralTypeAnnotation_]): Self = StObject.set(x, "NullLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNullLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NullLiteralTypeAnnotation", js.undefined)
      
      @scala.inline
      def setNullLiteralUndefined: Self = StObject.set(x, "NullLiteral", js.undefined)
      
      @scala.inline
      def setNullableTypeAnnotation(value: VisitNode[S, NullableTypeAnnotation_]): Self = StObject.set(x, "NullableTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNullableTypeAnnotationUndefined: Self = StObject.set(x, "NullableTypeAnnotation", js.undefined)
      
      @scala.inline
      def setNumberTypeAnnotation(value: VisitNode[S, NumberTypeAnnotation_]): Self = StObject.set(x, "NumberTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNumberTypeAnnotationUndefined: Self = StObject.set(x, "NumberTypeAnnotation", js.undefined)
      
      @scala.inline
      def setNumericLiteral(value: VisitNode[S, NumericLiteral_]): Self = StObject.set(x, "NumericLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNumericLiteralTypeAnnotation(value: VisitNode[S, NumericLiteralTypeAnnotation_]): Self = StObject.set(x, "NumericLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setNumericLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NumericLiteralTypeAnnotation", js.undefined)
      
      @scala.inline
      def setNumericLiteralUndefined: Self = StObject.set(x, "NumericLiteral", js.undefined)
      
      @scala.inline
      def setObjectExpression(value: VisitNode[S, ObjectExpression_]): Self = StObject.set(x, "ObjectExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectExpressionUndefined: Self = StObject.set(x, "ObjectExpression", js.undefined)
      
      @scala.inline
      def setObjectMember(value: VisitNode[S, ObjectMember]): Self = StObject.set(x, "ObjectMember", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectMemberUndefined: Self = StObject.set(x, "ObjectMember", js.undefined)
      
      @scala.inline
      def setObjectMethod(value: VisitNode[S, ObjectMethod_]): Self = StObject.set(x, "ObjectMethod", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectMethodUndefined: Self = StObject.set(x, "ObjectMethod", js.undefined)
      
      @scala.inline
      def setObjectPattern(value: VisitNode[S, ObjectPattern_]): Self = StObject.set(x, "ObjectPattern", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectPatternUndefined: Self = StObject.set(x, "ObjectPattern", js.undefined)
      
      @scala.inline
      def setObjectProperty(value: VisitNode[S, ObjectProperty_]): Self = StObject.set(x, "ObjectProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectPropertyUndefined: Self = StObject.set(x, "ObjectProperty", js.undefined)
      
      @scala.inline
      def setObjectTypeAnnotation(value: VisitNode[S, ObjectTypeAnnotation_]): Self = StObject.set(x, "ObjectTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypeAnnotationUndefined: Self = StObject.set(x, "ObjectTypeAnnotation", js.undefined)
      
      @scala.inline
      def setObjectTypeCallProperty(value: VisitNode[S, ObjectTypeCallProperty_]): Self = StObject.set(x, "ObjectTypeCallProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypeCallPropertyUndefined: Self = StObject.set(x, "ObjectTypeCallProperty", js.undefined)
      
      @scala.inline
      def setObjectTypeIndexer(value: VisitNode[S, ObjectTypeIndexer_]): Self = StObject.set(x, "ObjectTypeIndexer", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypeIndexerUndefined: Self = StObject.set(x, "ObjectTypeIndexer", js.undefined)
      
      @scala.inline
      def setObjectTypeProperty(value: VisitNode[S, ObjectTypeProperty_]): Self = StObject.set(x, "ObjectTypeProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setObjectTypePropertyUndefined: Self = StObject.set(x, "ObjectTypeProperty", js.undefined)
      
      @scala.inline
      def setParenthesizedExpression(value: VisitNode[S, ParenthesizedExpression_]): Self = StObject.set(x, "ParenthesizedExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setParenthesizedExpressionUndefined: Self = StObject.set(x, "ParenthesizedExpression", js.undefined)
      
      @scala.inline
      def setPattern(value: VisitNode[S, Pattern]): Self = StObject.set(x, "Pattern", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPatternUndefined: Self = StObject.set(x, "Pattern", js.undefined)
      
      @scala.inline
      def setProgram(value: VisitNode[S, Program_]): Self = StObject.set(x, "Program", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setProgramUndefined: Self = StObject.set(x, "Program", js.undefined)
      
      @scala.inline
      def setProperty(value: VisitNode[S, Property]): Self = StObject.set(x, "Property", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPropertyUndefined: Self = StObject.set(x, "Property", js.undefined)
      
      @scala.inline
      def setPureish(value: VisitNode[S, Pureish]): Self = StObject.set(x, "Pureish", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setPureishUndefined: Self = StObject.set(x, "Pureish", js.undefined)
      
      @scala.inline
      def setQualifiedTypeIdentifier(value: VisitNode[S, QualifiedTypeIdentifier_]): Self = StObject.set(x, "QualifiedTypeIdentifier", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setQualifiedTypeIdentifierUndefined: Self = StObject.set(x, "QualifiedTypeIdentifier", js.undefined)
      
      @scala.inline
      def setRegExpLiteral(value: VisitNode[S, RegExpLiteral_]): Self = StObject.set(x, "RegExpLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRegExpLiteralUndefined: Self = StObject.set(x, "RegExpLiteral", js.undefined)
      
      @scala.inline
      def setRestElement(value: VisitNode[S, RestElement_]): Self = StObject.set(x, "RestElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRestElementUndefined: Self = StObject.set(x, "RestElement", js.undefined)
      
      @scala.inline
      def setRestProperty(value: VisitNode[S, RestProperty_]): Self = StObject.set(x, "RestProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setRestPropertyUndefined: Self = StObject.set(x, "RestProperty", js.undefined)
      
      @scala.inline
      def setReturnStatement(value: VisitNode[S, ReturnStatement_]): Self = StObject.set(x, "ReturnStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setReturnStatementUndefined: Self = StObject.set(x, "ReturnStatement", js.undefined)
      
      @scala.inline
      def setScopable(value: VisitNode[S, Scopable]): Self = StObject.set(x, "Scopable", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScopableUndefined: Self = StObject.set(x, "Scopable", js.undefined)
      
      @scala.inline
      def setScope(value: VisitNode[S, Scopable]): Self = StObject.set(x, "Scope", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setScopeUndefined: Self = StObject.set(x, "Scope", js.undefined)
      
      @scala.inline
      def setSequenceExpression(value: VisitNode[S, SequenceExpression_]): Self = StObject.set(x, "SequenceExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSequenceExpressionUndefined: Self = StObject.set(x, "SequenceExpression", js.undefined)
      
      @scala.inline
      def setSpreadElement(value: VisitNode[S, SpreadElement_]): Self = StObject.set(x, "SpreadElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSpreadElementUndefined: Self = StObject.set(x, "SpreadElement", js.undefined)
      
      @scala.inline
      def setSpreadProperty(value: VisitNode[S, SpreadProperty_]): Self = StObject.set(x, "SpreadProperty", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSpreadPropertyUndefined: Self = StObject.set(x, "SpreadProperty", js.undefined)
      
      @scala.inline
      def setStatement(value: VisitNode[S, Statement]): Self = StObject.set(x, "Statement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStatementUndefined: Self = StObject.set(x, "Statement", js.undefined)
      
      @scala.inline
      def setStringLiteral(value: VisitNode[S, StringLiteral_]): Self = StObject.set(x, "StringLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStringLiteralTypeAnnotation(value: VisitNode[S, StringLiteralTypeAnnotation_]): Self = StObject.set(x, "StringLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStringLiteralTypeAnnotationUndefined: Self = StObject.set(x, "StringLiteralTypeAnnotation", js.undefined)
      
      @scala.inline
      def setStringLiteralUndefined: Self = StObject.set(x, "StringLiteral", js.undefined)
      
      @scala.inline
      def setStringTypeAnnotation(value: VisitNode[S, StringTypeAnnotation_]): Self = StObject.set(x, "StringTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setStringTypeAnnotationUndefined: Self = StObject.set(x, "StringTypeAnnotation", js.undefined)
      
      @scala.inline
      def setSuper(value: VisitNode[S, Super]): Self = StObject.set(x, "Super", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSuperUndefined: Self = StObject.set(x, "Super", js.undefined)
      
      @scala.inline
      def setSwitchCase(value: VisitNode[S, SwitchCase_]): Self = StObject.set(x, "SwitchCase", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSwitchCaseUndefined: Self = StObject.set(x, "SwitchCase", js.undefined)
      
      @scala.inline
      def setSwitchStatement(value: VisitNode[S, SwitchStatement_]): Self = StObject.set(x, "SwitchStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setSwitchStatementUndefined: Self = StObject.set(x, "SwitchStatement", js.undefined)
      
      @scala.inline
      def setTaggedTemplateExpression(value: VisitNode[S, TaggedTemplateExpression_]): Self = StObject.set(x, "TaggedTemplateExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTaggedTemplateExpressionUndefined: Self = StObject.set(x, "TaggedTemplateExpression", js.undefined)
      
      @scala.inline
      def setTemplateElement(value: VisitNode[S, TemplateElement_]): Self = StObject.set(x, "TemplateElement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTemplateElementUndefined: Self = StObject.set(x, "TemplateElement", js.undefined)
      
      @scala.inline
      def setTemplateLiteral(value: VisitNode[S, TemplateLiteral_]): Self = StObject.set(x, "TemplateLiteral", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTemplateLiteralUndefined: Self = StObject.set(x, "TemplateLiteral", js.undefined)
      
      @scala.inline
      def setTerminatorless(value: VisitNode[S, Terminatorless]): Self = StObject.set(x, "Terminatorless", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTerminatorlessUndefined: Self = StObject.set(x, "Terminatorless", js.undefined)
      
      @scala.inline
      def setThisExpression(value: VisitNode[S, ThisExpression_]): Self = StObject.set(x, "ThisExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setThisExpressionUndefined: Self = StObject.set(x, "ThisExpression", js.undefined)
      
      @scala.inline
      def setThisTypeAnnotation(value: VisitNode[S, ThisTypeAnnotation_]): Self = StObject.set(x, "ThisTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setThisTypeAnnotationUndefined: Self = StObject.set(x, "ThisTypeAnnotation", js.undefined)
      
      @scala.inline
      def setThrowStatement(value: VisitNode[S, ThrowStatement_]): Self = StObject.set(x, "ThrowStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setThrowStatementUndefined: Self = StObject.set(x, "ThrowStatement", js.undefined)
      
      @scala.inline
      def setTryStatement(value: VisitNode[S, TryStatement_]): Self = StObject.set(x, "TryStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTryStatementUndefined: Self = StObject.set(x, "TryStatement", js.undefined)
      
      @scala.inline
      def setTupleTypeAnnotation(value: VisitNode[S, TupleTypeAnnotation_]): Self = StObject.set(x, "TupleTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTupleTypeAnnotationUndefined: Self = StObject.set(x, "TupleTypeAnnotation", js.undefined)
      
      @scala.inline
      def setTypeAlias(value: VisitNode[S, TypeAlias_]): Self = StObject.set(x, "TypeAlias", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeAliasUndefined: Self = StObject.set(x, "TypeAlias", js.undefined)
      
      @scala.inline
      def setTypeAnnotation(value: VisitNode[S, TypeAnnotation_]): Self = StObject.set(x, "TypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeAnnotationUndefined: Self = StObject.set(x, "TypeAnnotation", js.undefined)
      
      @scala.inline
      def setTypeCastExpression(value: VisitNode[S, TypeCastExpression_]): Self = StObject.set(x, "TypeCastExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeCastExpressionUndefined: Self = StObject.set(x, "TypeCastExpression", js.undefined)
      
      @scala.inline
      def setTypeParameterDeclaration(value: VisitNode[S, TypeParameterDeclaration_]): Self = StObject.set(x, "TypeParameterDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeParameterDeclarationUndefined: Self = StObject.set(x, "TypeParameterDeclaration", js.undefined)
      
      @scala.inline
      def setTypeParameterInstantiation(value: VisitNode[S, TypeParameterInstantiation_]): Self = StObject.set(x, "TypeParameterInstantiation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeParameterInstantiationUndefined: Self = StObject.set(x, "TypeParameterInstantiation", js.undefined)
      
      @scala.inline
      def setTypeofTypeAnnotation(value: VisitNode[S, TypeofTypeAnnotation_]): Self = StObject.set(x, "TypeofTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setTypeofTypeAnnotationUndefined: Self = StObject.set(x, "TypeofTypeAnnotation", js.undefined)
      
      @scala.inline
      def setUnaryExpression(value: VisitNode[S, UnaryExpression_]): Self = StObject.set(x, "UnaryExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUnaryExpressionUndefined: Self = StObject.set(x, "UnaryExpression", js.undefined)
      
      @scala.inline
      def setUnaryLike(value: VisitNode[S, UnaryLike]): Self = StObject.set(x, "UnaryLike", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUnaryLikeUndefined: Self = StObject.set(x, "UnaryLike", js.undefined)
      
      @scala.inline
      def setUnionTypeAnnotation(value: VisitNode[S, UnionTypeAnnotation_]): Self = StObject.set(x, "UnionTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUnionTypeAnnotationUndefined: Self = StObject.set(x, "UnionTypeAnnotation", js.undefined)
      
      @scala.inline
      def setUpdateExpression(value: VisitNode[S, UpdateExpression_]): Self = StObject.set(x, "UpdateExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUpdateExpressionUndefined: Self = StObject.set(x, "UpdateExpression", js.undefined)
      
      @scala.inline
      def setUserWhitespacable(value: VisitNode[S, UserWhitespacable]): Self = StObject.set(x, "UserWhitespacable", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setUserWhitespacableUndefined: Self = StObject.set(x, "UserWhitespacable", js.undefined)
      
      @scala.inline
      def setVariableDeclaration(value: VisitNode[S, VariableDeclaration_]): Self = StObject.set(x, "VariableDeclaration", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVariableDeclarationUndefined: Self = StObject.set(x, "VariableDeclaration", js.undefined)
      
      @scala.inline
      def setVariableDeclarator(value: VisitNode[S, VariableDeclarator_]): Self = StObject.set(x, "VariableDeclarator", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVariableDeclaratorUndefined: Self = StObject.set(x, "VariableDeclarator", js.undefined)
      
      @scala.inline
      def setVoidTypeAnnotation(value: VisitNode[S, VoidTypeAnnotation_]): Self = StObject.set(x, "VoidTypeAnnotation", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setVoidTypeAnnotationUndefined: Self = StObject.set(x, "VoidTypeAnnotation", js.undefined)
      
      @scala.inline
      def setWhile(value: VisitNode[S, While]): Self = StObject.set(x, "While", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setWhileStatement(value: VisitNode[S, WhileStatement_]): Self = StObject.set(x, "WhileStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setWhileStatementUndefined: Self = StObject.set(x, "WhileStatement", js.undefined)
      
      @scala.inline
      def setWhileUndefined: Self = StObject.set(x, "While", js.undefined)
      
      @scala.inline
      def setWithStatement(value: VisitNode[S, WithStatement_]): Self = StObject.set(x, "WithStatement", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setWithStatementUndefined: Self = StObject.set(x, "WithStatement", js.undefined)
      
      @scala.inline
      def setYieldExpression(value: VisitNode[S, YieldExpression_]): Self = StObject.set(x, "YieldExpression", value.asInstanceOf[js.Any])
      
      @scala.inline
      def setYieldExpressionUndefined: Self = StObject.set(x, "YieldExpression", js.undefined)
    }
  }
}
