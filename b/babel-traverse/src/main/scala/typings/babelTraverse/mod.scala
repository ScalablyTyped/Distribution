package typings.babelTraverse

import org.scalablytyped.runtime.Instantiable1
import org.scalablytyped.runtime.StringDictionary
import typings.babelTraverse.anon.Confident
import typings.babelTraverse.anon.Existing
import typings.babelTraverse.babelTraverseStrings.`var`
import typings.babelTraverse.babelTraverseStrings.const
import typings.babelTraverse.babelTraverseStrings.let
import typings.babelTraverse.babelTraverseStrings.module
import typings.babelTypes.mod.AnyTypeAnnotation_
import typings.babelTypes.mod.ArrayExpression_
import typings.babelTypes.mod.ArrayPattern_
import typings.babelTypes.mod.ArrayTypeAnnotation_
import typings.babelTypes.mod.ArrowFunctionExpression_
import typings.babelTypes.mod.AssignmentExpression_
import typings.babelTypes.mod.AssignmentPattern_
import typings.babelTypes.mod.AwaitExpression_
import typings.babelTypes.mod.Binary
import typings.babelTypes.mod.BinaryExpression_
import typings.babelTypes.mod.BindExpression_
import typings.babelTypes.mod.Block
import typings.babelTypes.mod.BlockParent
import typings.babelTypes.mod.BlockStatement_
import typings.babelTypes.mod.BooleanLiteralTypeAnnotation_
import typings.babelTypes.mod.BooleanLiteral_
import typings.babelTypes.mod.BooleanTypeAnnotation_
import typings.babelTypes.mod.BreakStatement_
import typings.babelTypes.mod.CallExpression_
import typings.babelTypes.mod.CatchClause_
import typings.babelTypes.mod.Class
import typings.babelTypes.mod.ClassBody_
import typings.babelTypes.mod.ClassDeclaration_
import typings.babelTypes.mod.ClassExpression_
import typings.babelTypes.mod.ClassImplements_
import typings.babelTypes.mod.ClassMethod_
import typings.babelTypes.mod.ClassProperty_
import typings.babelTypes.mod.CompletionStatement
import typings.babelTypes.mod.Conditional
import typings.babelTypes.mod.ConditionalExpression_
import typings.babelTypes.mod.ContinueStatement_
import typings.babelTypes.mod.DebuggerStatement_
import typings.babelTypes.mod.Declaration
import typings.babelTypes.mod.DeclareClass_
import typings.babelTypes.mod.DeclareFunction_
import typings.babelTypes.mod.DeclareInterface_
import typings.babelTypes.mod.DeclareModule_
import typings.babelTypes.mod.DeclareTypeAlias_
import typings.babelTypes.mod.DeclareVariable_
import typings.babelTypes.mod.Decorator_
import typings.babelTypes.mod.DirectiveLiteral_
import typings.babelTypes.mod.Directive_
import typings.babelTypes.mod.DoExpression_
import typings.babelTypes.mod.DoWhileStatement_
import typings.babelTypes.mod.EmptyStatement_
import typings.babelTypes.mod.ExistentialTypeParam_
import typings.babelTypes.mod.ExportAllDeclaration_
import typings.babelTypes.mod.ExportDeclaration
import typings.babelTypes.mod.ExportDefaultDeclaration_
import typings.babelTypes.mod.ExportDefaultSpecifier_
import typings.babelTypes.mod.ExportNamedDeclaration_
import typings.babelTypes.mod.ExportNamespaceSpecifier_
import typings.babelTypes.mod.ExportSpecifier_
import typings.babelTypes.mod.Expression
import typings.babelTypes.mod.ExpressionStatement_
import typings.babelTypes.mod.ExpressionWrapper
import typings.babelTypes.mod.File_
import typings.babelTypes.mod.Flow
import typings.babelTypes.mod.FlowBaseAnnotation
import typings.babelTypes.mod.FlowDeclaration
import typings.babelTypes.mod.FlowTypeAnnotation
import typings.babelTypes.mod.For
import typings.babelTypes.mod.ForInStatement_
import typings.babelTypes.mod.ForOfStatement_
import typings.babelTypes.mod.ForStatement_
import typings.babelTypes.mod.ForXStatement
import typings.babelTypes.mod.Function
import typings.babelTypes.mod.FunctionDeclaration_
import typings.babelTypes.mod.FunctionExpression_
import typings.babelTypes.mod.FunctionParent
import typings.babelTypes.mod.FunctionTypeAnnotation_
import typings.babelTypes.mod.FunctionTypeParam_
import typings.babelTypes.mod.GenericTypeAnnotation_
import typings.babelTypes.mod.Identifier_
import typings.babelTypes.mod.IfStatement_
import typings.babelTypes.mod.Immutable
import typings.babelTypes.mod.ImportDeclaration_
import typings.babelTypes.mod.ImportDefaultSpecifier_
import typings.babelTypes.mod.ImportNamespaceSpecifier_
import typings.babelTypes.mod.ImportSpecifier_
import typings.babelTypes.mod.InterfaceDeclaration_
import typings.babelTypes.mod.InterfaceExtends_
import typings.babelTypes.mod.IntersectionTypeAnnotation_
import typings.babelTypes.mod.JSX
import typings.babelTypes.mod.JSXAttribute_
import typings.babelTypes.mod.JSXClosingElement_
import typings.babelTypes.mod.JSXElement_
import typings.babelTypes.mod.JSXEmptyExpression_
import typings.babelTypes.mod.JSXExpressionContainer_
import typings.babelTypes.mod.JSXIdentifier_
import typings.babelTypes.mod.JSXMemberExpression_
import typings.babelTypes.mod.JSXNamespacedName_
import typings.babelTypes.mod.JSXOpeningElement_
import typings.babelTypes.mod.JSXSpreadAttribute_
import typings.babelTypes.mod.JSXText_
import typings.babelTypes.mod.LVal
import typings.babelTypes.mod.LabeledStatement_
import typings.babelTypes.mod.Literal
import typings.babelTypes.mod.LogicalExpression_
import typings.babelTypes.mod.Loop
import typings.babelTypes.mod.MemberExpression_
import typings.babelTypes.mod.MetaProperty_
import typings.babelTypes.mod.Method
import typings.babelTypes.mod.MixedTypeAnnotation_
import typings.babelTypes.mod.ModuleDeclaration
import typings.babelTypes.mod.ModuleSpecifier
import typings.babelTypes.mod.NewExpression_
import typings.babelTypes.mod.Noop_
import typings.babelTypes.mod.NullLiteralTypeAnnotation_
import typings.babelTypes.mod.NullLiteral_
import typings.babelTypes.mod.NullableTypeAnnotation_
import typings.babelTypes.mod.NumberTypeAnnotation_
import typings.babelTypes.mod.NumericLiteralTypeAnnotation_
import typings.babelTypes.mod.NumericLiteral_
import typings.babelTypes.mod.ObjectExpression_
import typings.babelTypes.mod.ObjectMember
import typings.babelTypes.mod.ObjectMethod_
import typings.babelTypes.mod.ObjectPattern_
import typings.babelTypes.mod.ObjectProperty_
import typings.babelTypes.mod.ObjectTypeAnnotation_
import typings.babelTypes.mod.ObjectTypeCallProperty_
import typings.babelTypes.mod.ObjectTypeIndexer_
import typings.babelTypes.mod.ObjectTypeProperty_
import typings.babelTypes.mod.ParenthesizedExpression_
import typings.babelTypes.mod.Pattern
import typings.babelTypes.mod.Program_
import typings.babelTypes.mod.Property
import typings.babelTypes.mod.Pureish
import typings.babelTypes.mod.QualifiedTypeIdentifier_
import typings.babelTypes.mod.RegExpLiteral_
import typings.babelTypes.mod.RestElement_
import typings.babelTypes.mod.RestProperty_
import typings.babelTypes.mod.ReturnStatement_
import typings.babelTypes.mod.Scopable
import typings.babelTypes.mod.SequenceExpression_
import typings.babelTypes.mod.SpreadElement_
import typings.babelTypes.mod.SpreadProperty_
import typings.babelTypes.mod.Statement
import typings.babelTypes.mod.StringLiteralTypeAnnotation_
import typings.babelTypes.mod.StringLiteral_
import typings.babelTypes.mod.StringTypeAnnotation_
import typings.babelTypes.mod.Super
import typings.babelTypes.mod.SwitchCase_
import typings.babelTypes.mod.SwitchStatement_
import typings.babelTypes.mod.TaggedTemplateExpression_
import typings.babelTypes.mod.TemplateElement_
import typings.babelTypes.mod.TemplateLiteral_
import typings.babelTypes.mod.Terminatorless
import typings.babelTypes.mod.ThisExpression_
import typings.babelTypes.mod.ThisTypeAnnotation_
import typings.babelTypes.mod.ThrowStatement_
import typings.babelTypes.mod.TryStatement_
import typings.babelTypes.mod.TupleTypeAnnotation_
import typings.babelTypes.mod.TypeAlias_
import typings.babelTypes.mod.TypeAnnotation_
import typings.babelTypes.mod.TypeCastExpression_
import typings.babelTypes.mod.TypeParameterDeclaration_
import typings.babelTypes.mod.TypeParameterInstantiation_
import typings.babelTypes.mod.TypeofTypeAnnotation_
import typings.babelTypes.mod.UnaryExpression_
import typings.babelTypes.mod.UnaryLike
import typings.babelTypes.mod.UnionTypeAnnotation_
import typings.babelTypes.mod.UpdateExpression_
import typings.babelTypes.mod.UserWhitespacable
import typings.babelTypes.mod.VariableDeclaration_
import typings.babelTypes.mod.VariableDeclarator_
import typings.babelTypes.mod.VoidTypeAnnotation_
import typings.babelTypes.mod.While
import typings.babelTypes.mod.WhileStatement_
import typings.babelTypes.mod.WithStatement_
import typings.babelTypes.mod.YieldExpression_
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  @JSImport("babel-traverse", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  inline def default(parent: js.Array[Node], opts: TraverseOptions[Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(parent: js.Array[Node], opts: TraverseOptions[Node], scope: Unit, state: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(
    parent: js.Array[Node],
    opts: TraverseOptions[Node],
    scope: Unit,
    state: Any,
    parentPath: NodePath[Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(
    parent: js.Array[Node],
    opts: TraverseOptions[Node],
    scope: Unit,
    state: Unit,
    parentPath: NodePath[Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(parent: js.Array[Node], opts: TraverseOptions[Node], scope: Scope): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(parent: js.Array[Node], opts: TraverseOptions[Node], scope: Scope, state: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(
    parent: js.Array[Node],
    opts: TraverseOptions[Node],
    scope: Scope,
    state: Any,
    parentPath: NodePath[Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(
    parent: js.Array[Node],
    opts: TraverseOptions[Node],
    scope: Scope,
    state: Unit,
    parentPath: NodePath[Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(parent: Node, opts: TraverseOptions[Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(parent: Node, opts: TraverseOptions[Node], scope: Unit, state: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(parent: Node, opts: TraverseOptions[Node], scope: Unit, state: Any, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(parent: Node, opts: TraverseOptions[Node], scope: Unit, state: Unit, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(parent: Node, opts: TraverseOptions[Node], scope: Scope): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(parent: Node, opts: TraverseOptions[Node], scope: Scope, state: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(parent: Node, opts: TraverseOptions[Node], scope: Scope, state: Any, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default(parent: Node, opts: TraverseOptions[Node], scope: Scope, state: Unit, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  @JSImport("babel-traverse", "Binding")
  @js.native
  open class Binding protected () extends StObject {
    def this(opts: Existing) = this()
    
    var constant: Boolean = js.native
    
    var constantViolations: js.Array[NodePath[Node]] = js.native
    
    var identifier: Identifier_ = js.native
    
    var kind: `var` | let | const | module = js.native
    
    var path: NodePath[Node] = js.native
    
    var referencePaths: js.Array[NodePath[Node]] = js.native
    
    var referenced: Boolean = js.native
    
    var references: Double = js.native
    
    var scope: Scope = js.native
  }
  
  @JSImport("babel-traverse", "Hub")
  @js.native
  open class Hub protected () extends StObject {
    def this(file: Any, options: Any) = this()
    
    var file: Any = js.native
    
    var options: Any = js.native
  }
  
  @JSImport("babel-traverse", "NodePath")
  @js.native
  open class NodePath[T] protected () extends StObject {
    def this(hub: Hub, parent: Node) = this()
    
    def addComment(`type`: String, content: String): Unit = js.native
    def addComment(`type`: String, content: String, line: Boolean): Unit = js.native
    
    /** Give node `comments` of the specified `type`. */
    def addComments(`type`: String, comments: js.Array[Any]): Unit = js.native
    
    def assertAnyTypeAnnotation(): Unit = js.native
    def assertAnyTypeAnnotation(opts: js.Object): Unit = js.native
    
    // ------------------------- assertXXX -------------------------
    def assertArrayExpression(): Unit = js.native
    def assertArrayExpression(opts: js.Object): Unit = js.native
    
    def assertArrayPattern(): Unit = js.native
    def assertArrayPattern(opts: js.Object): Unit = js.native
    
    def assertArrayTypeAnnotation(): Unit = js.native
    def assertArrayTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertArrowFunctionExpression(): Unit = js.native
    def assertArrowFunctionExpression(opts: js.Object): Unit = js.native
    
    def assertAssignmentExpression(): Unit = js.native
    def assertAssignmentExpression(opts: js.Object): Unit = js.native
    
    def assertAssignmentPattern(): Unit = js.native
    def assertAssignmentPattern(opts: js.Object): Unit = js.native
    
    def assertAwaitExpression(): Unit = js.native
    def assertAwaitExpression(opts: js.Object): Unit = js.native
    
    def assertBinary(): Unit = js.native
    def assertBinary(opts: js.Object): Unit = js.native
    
    def assertBinaryExpression(): Unit = js.native
    def assertBinaryExpression(opts: js.Object): Unit = js.native
    
    def assertBindExpression(): Unit = js.native
    def assertBindExpression(opts: js.Object): Unit = js.native
    
    def assertBlock(): Unit = js.native
    def assertBlock(opts: js.Object): Unit = js.native
    
    def assertBlockParent(): Unit = js.native
    def assertBlockParent(opts: js.Object): Unit = js.native
    
    def assertBlockStatement(): Unit = js.native
    def assertBlockStatement(opts: js.Object): Unit = js.native
    
    def assertBooleanLiteral(): Unit = js.native
    def assertBooleanLiteral(opts: js.Object): Unit = js.native
    
    def assertBooleanLiteralTypeAnnotation(): Unit = js.native
    def assertBooleanLiteralTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertBooleanTypeAnnotation(): Unit = js.native
    def assertBooleanTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertBreakStatement(): Unit = js.native
    def assertBreakStatement(opts: js.Object): Unit = js.native
    
    def assertCallExpression(): Unit = js.native
    def assertCallExpression(opts: js.Object): Unit = js.native
    
    def assertCatchClause(): Unit = js.native
    def assertCatchClause(opts: js.Object): Unit = js.native
    
    def assertClass(): Unit = js.native
    def assertClass(opts: js.Object): Unit = js.native
    
    def assertClassBody(): Unit = js.native
    def assertClassBody(opts: js.Object): Unit = js.native
    
    def assertClassDeclaration(): Unit = js.native
    def assertClassDeclaration(opts: js.Object): Unit = js.native
    
    def assertClassExpression(): Unit = js.native
    def assertClassExpression(opts: js.Object): Unit = js.native
    
    def assertClassImplements(): Unit = js.native
    def assertClassImplements(opts: js.Object): Unit = js.native
    
    def assertClassMethod(): Unit = js.native
    def assertClassMethod(opts: js.Object): Unit = js.native
    
    def assertClassProperty(): Unit = js.native
    def assertClassProperty(opts: js.Object): Unit = js.native
    
    def assertCompletionStatement(): Unit = js.native
    def assertCompletionStatement(opts: js.Object): Unit = js.native
    
    def assertConditional(): Unit = js.native
    def assertConditional(opts: js.Object): Unit = js.native
    
    def assertConditionalExpression(): Unit = js.native
    def assertConditionalExpression(opts: js.Object): Unit = js.native
    
    def assertContinueStatement(): Unit = js.native
    def assertContinueStatement(opts: js.Object): Unit = js.native
    
    def assertDebuggerStatement(): Unit = js.native
    def assertDebuggerStatement(opts: js.Object): Unit = js.native
    
    def assertDeclaration(): Unit = js.native
    def assertDeclaration(opts: js.Object): Unit = js.native
    
    def assertDeclareClass(): Unit = js.native
    def assertDeclareClass(opts: js.Object): Unit = js.native
    
    def assertDeclareFunction(): Unit = js.native
    def assertDeclareFunction(opts: js.Object): Unit = js.native
    
    def assertDeclareInterface(): Unit = js.native
    def assertDeclareInterface(opts: js.Object): Unit = js.native
    
    def assertDeclareModule(): Unit = js.native
    def assertDeclareModule(opts: js.Object): Unit = js.native
    
    def assertDeclareTypeAlias(): Unit = js.native
    def assertDeclareTypeAlias(opts: js.Object): Unit = js.native
    
    def assertDeclareVariable(): Unit = js.native
    def assertDeclareVariable(opts: js.Object): Unit = js.native
    
    def assertDecorator(): Unit = js.native
    def assertDecorator(opts: js.Object): Unit = js.native
    
    def assertDirective(): Unit = js.native
    def assertDirective(opts: js.Object): Unit = js.native
    
    def assertDirectiveLiteral(): Unit = js.native
    def assertDirectiveLiteral(opts: js.Object): Unit = js.native
    
    def assertDoExpression(): Unit = js.native
    def assertDoExpression(opts: js.Object): Unit = js.native
    
    def assertDoWhileStatement(): Unit = js.native
    def assertDoWhileStatement(opts: js.Object): Unit = js.native
    
    def assertEmptyStatement(): Unit = js.native
    def assertEmptyStatement(opts: js.Object): Unit = js.native
    
    def assertExistentialTypeParam(): Unit = js.native
    def assertExistentialTypeParam(opts: js.Object): Unit = js.native
    
    def assertExportAllDeclaration(): Unit = js.native
    def assertExportAllDeclaration(opts: js.Object): Unit = js.native
    
    def assertExportDeclaration(): Unit = js.native
    def assertExportDeclaration(opts: js.Object): Unit = js.native
    
    def assertExportDefaultDeclaration(): Unit = js.native
    def assertExportDefaultDeclaration(opts: js.Object): Unit = js.native
    
    def assertExportDefaultSpecifier(): Unit = js.native
    def assertExportDefaultSpecifier(opts: js.Object): Unit = js.native
    
    def assertExportNamedDeclaration(): Unit = js.native
    def assertExportNamedDeclaration(opts: js.Object): Unit = js.native
    
    def assertExportNamespaceSpecifier(): Unit = js.native
    def assertExportNamespaceSpecifier(opts: js.Object): Unit = js.native
    
    def assertExportSpecifier(): Unit = js.native
    def assertExportSpecifier(opts: js.Object): Unit = js.native
    
    def assertExpression(): Unit = js.native
    def assertExpression(opts: js.Object): Unit = js.native
    
    def assertExpressionStatement(): Unit = js.native
    def assertExpressionStatement(opts: js.Object): Unit = js.native
    
    def assertExpressionWrapper(): Unit = js.native
    def assertExpressionWrapper(opts: js.Object): Unit = js.native
    
    def assertFile(): Unit = js.native
    def assertFile(opts: js.Object): Unit = js.native
    
    def assertFlow(): Unit = js.native
    def assertFlow(opts: js.Object): Unit = js.native
    
    def assertFlowBaseAnnotation(): Unit = js.native
    def assertFlowBaseAnnotation(opts: js.Object): Unit = js.native
    
    def assertFlowDeclaration(): Unit = js.native
    def assertFlowDeclaration(opts: js.Object): Unit = js.native
    
    def assertFor(): Unit = js.native
    def assertFor(opts: js.Object): Unit = js.native
    
    def assertForInStatement(): Unit = js.native
    def assertForInStatement(opts: js.Object): Unit = js.native
    
    def assertForOfStatement(): Unit = js.native
    def assertForOfStatement(opts: js.Object): Unit = js.native
    
    def assertForStatement(): Unit = js.native
    def assertForStatement(opts: js.Object): Unit = js.native
    
    def assertForXStatement(): Unit = js.native
    def assertForXStatement(opts: js.Object): Unit = js.native
    
    def assertFunction(): Unit = js.native
    def assertFunction(opts: js.Object): Unit = js.native
    
    def assertFunctionDeclaration(): Unit = js.native
    def assertFunctionDeclaration(opts: js.Object): Unit = js.native
    
    def assertFunctionExpression(): Unit = js.native
    def assertFunctionExpression(opts: js.Object): Unit = js.native
    
    def assertFunctionParent(): Unit = js.native
    def assertFunctionParent(opts: js.Object): Unit = js.native
    
    def assertFunctionTypeAnnotation(): Unit = js.native
    def assertFunctionTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertFunctionTypeParam(): Unit = js.native
    def assertFunctionTypeParam(opts: js.Object): Unit = js.native
    
    def assertGenericTypeAnnotation(): Unit = js.native
    def assertGenericTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertIdentifier(): Unit = js.native
    def assertIdentifier(opts: js.Object): Unit = js.native
    
    def assertIfStatement(): Unit = js.native
    def assertIfStatement(opts: js.Object): Unit = js.native
    
    def assertImmutable(): Unit = js.native
    def assertImmutable(opts: js.Object): Unit = js.native
    
    def assertImportDeclaration(): Unit = js.native
    def assertImportDeclaration(opts: js.Object): Unit = js.native
    
    def assertImportDefaultSpecifier(): Unit = js.native
    def assertImportDefaultSpecifier(opts: js.Object): Unit = js.native
    
    def assertImportNamespaceSpecifier(): Unit = js.native
    def assertImportNamespaceSpecifier(opts: js.Object): Unit = js.native
    
    def assertImportSpecifier(): Unit = js.native
    def assertImportSpecifier(opts: js.Object): Unit = js.native
    
    def assertInterfaceDeclaration(): Unit = js.native
    def assertInterfaceDeclaration(opts: js.Object): Unit = js.native
    
    def assertInterfaceExtends(): Unit = js.native
    def assertInterfaceExtends(opts: js.Object): Unit = js.native
    
    def assertIntersectionTypeAnnotation(): Unit = js.native
    def assertIntersectionTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertJSX(): Unit = js.native
    def assertJSX(opts: js.Object): Unit = js.native
    
    def assertJSXAttribute(): Unit = js.native
    def assertJSXAttribute(opts: js.Object): Unit = js.native
    
    def assertJSXClosingElement(): Unit = js.native
    def assertJSXClosingElement(opts: js.Object): Unit = js.native
    
    def assertJSXElement(): Unit = js.native
    def assertJSXElement(opts: js.Object): Unit = js.native
    
    def assertJSXEmptyExpression(): Unit = js.native
    def assertJSXEmptyExpression(opts: js.Object): Unit = js.native
    
    def assertJSXExpressionContainer(): Unit = js.native
    def assertJSXExpressionContainer(opts: js.Object): Unit = js.native
    
    def assertJSXIdentifier(): Unit = js.native
    def assertJSXIdentifier(opts: js.Object): Unit = js.native
    
    def assertJSXMemberExpression(): Unit = js.native
    def assertJSXMemberExpression(opts: js.Object): Unit = js.native
    
    def assertJSXNamespacedName(): Unit = js.native
    def assertJSXNamespacedName(opts: js.Object): Unit = js.native
    
    def assertJSXOpeningElement(): Unit = js.native
    def assertJSXOpeningElement(opts: js.Object): Unit = js.native
    
    def assertJSXSpreadAttribute(): Unit = js.native
    def assertJSXSpreadAttribute(opts: js.Object): Unit = js.native
    
    def assertJSXText(): Unit = js.native
    def assertJSXText(opts: js.Object): Unit = js.native
    
    def assertLVal(): Unit = js.native
    def assertLVal(opts: js.Object): Unit = js.native
    
    def assertLabeledStatement(): Unit = js.native
    def assertLabeledStatement(opts: js.Object): Unit = js.native
    
    def assertLiteral(): Unit = js.native
    def assertLiteral(opts: js.Object): Unit = js.native
    
    def assertLogicalExpression(): Unit = js.native
    def assertLogicalExpression(opts: js.Object): Unit = js.native
    
    def assertLoop(): Unit = js.native
    def assertLoop(opts: js.Object): Unit = js.native
    
    def assertMemberExpression(): Unit = js.native
    def assertMemberExpression(opts: js.Object): Unit = js.native
    
    def assertMetaProperty(): Unit = js.native
    def assertMetaProperty(opts: js.Object): Unit = js.native
    
    def assertMethod(): Unit = js.native
    def assertMethod(opts: js.Object): Unit = js.native
    
    def assertMixedTypeAnnotation(): Unit = js.native
    def assertMixedTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertModuleDeclaration(): Unit = js.native
    def assertModuleDeclaration(opts: js.Object): Unit = js.native
    
    def assertModuleSpecifier(): Unit = js.native
    def assertModuleSpecifier(opts: js.Object): Unit = js.native
    
    def assertNewExpression(): Unit = js.native
    def assertNewExpression(opts: js.Object): Unit = js.native
    
    def assertNoop(): Unit = js.native
    def assertNoop(opts: js.Object): Unit = js.native
    
    def assertNullLiteral(): Unit = js.native
    def assertNullLiteral(opts: js.Object): Unit = js.native
    
    def assertNullLiteralTypeAnnotation(): Unit = js.native
    def assertNullLiteralTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertNullableTypeAnnotation(): Unit = js.native
    def assertNullableTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertNumberLiteral(): Unit = js.native
    def assertNumberLiteral(opts: js.Object): Unit = js.native
    
    def assertNumberTypeAnnotation(): Unit = js.native
    def assertNumberTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertNumericLiteral(): Unit = js.native
    def assertNumericLiteral(opts: js.Object): Unit = js.native
    
    def assertNumericLiteralTypeAnnotation(): Unit = js.native
    def assertNumericLiteralTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertObjectExpression(): Unit = js.native
    def assertObjectExpression(opts: js.Object): Unit = js.native
    
    def assertObjectMember(): Unit = js.native
    def assertObjectMember(opts: js.Object): Unit = js.native
    
    def assertObjectMethod(): Unit = js.native
    def assertObjectMethod(opts: js.Object): Unit = js.native
    
    def assertObjectPattern(): Unit = js.native
    def assertObjectPattern(opts: js.Object): Unit = js.native
    
    def assertObjectProperty(): Unit = js.native
    def assertObjectProperty(opts: js.Object): Unit = js.native
    
    def assertObjectTypeAnnotation(): Unit = js.native
    def assertObjectTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertObjectTypeCallProperty(): Unit = js.native
    def assertObjectTypeCallProperty(opts: js.Object): Unit = js.native
    
    def assertObjectTypeIndexer(): Unit = js.native
    def assertObjectTypeIndexer(opts: js.Object): Unit = js.native
    
    def assertObjectTypeProperty(): Unit = js.native
    def assertObjectTypeProperty(opts: js.Object): Unit = js.native
    
    def assertParenthesizedExpression(): Unit = js.native
    def assertParenthesizedExpression(opts: js.Object): Unit = js.native
    
    def assertPattern(): Unit = js.native
    def assertPattern(opts: js.Object): Unit = js.native
    
    def assertProgram(): Unit = js.native
    def assertProgram(opts: js.Object): Unit = js.native
    
    def assertProperty(): Unit = js.native
    def assertProperty(opts: js.Object): Unit = js.native
    
    def assertPureish(): Unit = js.native
    def assertPureish(opts: js.Object): Unit = js.native
    
    def assertQualifiedTypeIdentifier(): Unit = js.native
    def assertQualifiedTypeIdentifier(opts: js.Object): Unit = js.native
    
    def assertRegExpLiteral(): Unit = js.native
    def assertRegExpLiteral(opts: js.Object): Unit = js.native
    
    def assertRegexLiteral(): Unit = js.native
    def assertRegexLiteral(opts: js.Object): Unit = js.native
    
    def assertRestElement(): Unit = js.native
    def assertRestElement(opts: js.Object): Unit = js.native
    
    def assertRestProperty(): Unit = js.native
    def assertRestProperty(opts: js.Object): Unit = js.native
    
    def assertReturnStatement(): Unit = js.native
    def assertReturnStatement(opts: js.Object): Unit = js.native
    
    def assertScopable(): Unit = js.native
    def assertScopable(opts: js.Object): Unit = js.native
    
    def assertSequenceExpression(): Unit = js.native
    def assertSequenceExpression(opts: js.Object): Unit = js.native
    
    def assertSpreadElement(): Unit = js.native
    def assertSpreadElement(opts: js.Object): Unit = js.native
    
    def assertSpreadProperty(): Unit = js.native
    def assertSpreadProperty(opts: js.Object): Unit = js.native
    
    def assertStatement(): Unit = js.native
    def assertStatement(opts: js.Object): Unit = js.native
    
    def assertStringLiteral(): Unit = js.native
    def assertStringLiteral(opts: js.Object): Unit = js.native
    
    def assertStringLiteralTypeAnnotation(): Unit = js.native
    def assertStringLiteralTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertStringTypeAnnotation(): Unit = js.native
    def assertStringTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertSuper(): Unit = js.native
    def assertSuper(opts: js.Object): Unit = js.native
    
    def assertSwitchCase(): Unit = js.native
    def assertSwitchCase(opts: js.Object): Unit = js.native
    
    def assertSwitchStatement(): Unit = js.native
    def assertSwitchStatement(opts: js.Object): Unit = js.native
    
    def assertTaggedTemplateExpression(): Unit = js.native
    def assertTaggedTemplateExpression(opts: js.Object): Unit = js.native
    
    def assertTemplateElement(): Unit = js.native
    def assertTemplateElement(opts: js.Object): Unit = js.native
    
    def assertTemplateLiteral(): Unit = js.native
    def assertTemplateLiteral(opts: js.Object): Unit = js.native
    
    def assertTerminatorless(): Unit = js.native
    def assertTerminatorless(opts: js.Object): Unit = js.native
    
    def assertThisExpression(): Unit = js.native
    def assertThisExpression(opts: js.Object): Unit = js.native
    
    def assertThisTypeAnnotation(): Unit = js.native
    def assertThisTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertThrowStatement(): Unit = js.native
    def assertThrowStatement(opts: js.Object): Unit = js.native
    
    def assertTryStatement(): Unit = js.native
    def assertTryStatement(opts: js.Object): Unit = js.native
    
    def assertTupleTypeAnnotation(): Unit = js.native
    def assertTupleTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertTypeAlias(): Unit = js.native
    def assertTypeAlias(opts: js.Object): Unit = js.native
    
    def assertTypeAnnotation(): Unit = js.native
    def assertTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertTypeCastExpression(): Unit = js.native
    def assertTypeCastExpression(opts: js.Object): Unit = js.native
    
    def assertTypeParameterDeclaration(): Unit = js.native
    def assertTypeParameterDeclaration(opts: js.Object): Unit = js.native
    
    def assertTypeParameterInstantiation(): Unit = js.native
    def assertTypeParameterInstantiation(opts: js.Object): Unit = js.native
    
    def assertTypeofTypeAnnotation(): Unit = js.native
    def assertTypeofTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertUnaryExpression(): Unit = js.native
    def assertUnaryExpression(opts: js.Object): Unit = js.native
    
    def assertUnaryLike(): Unit = js.native
    def assertUnaryLike(opts: js.Object): Unit = js.native
    
    def assertUnionTypeAnnotation(): Unit = js.native
    def assertUnionTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertUpdateExpression(): Unit = js.native
    def assertUpdateExpression(opts: js.Object): Unit = js.native
    
    def assertUserWhitespacable(): Unit = js.native
    def assertUserWhitespacable(opts: js.Object): Unit = js.native
    
    def assertVariableDeclaration(): Unit = js.native
    def assertVariableDeclaration(opts: js.Object): Unit = js.native
    
    def assertVariableDeclarator(): Unit = js.native
    def assertVariableDeclarator(opts: js.Object): Unit = js.native
    
    def assertVoidTypeAnnotation(): Unit = js.native
    def assertVoidTypeAnnotation(opts: js.Object): Unit = js.native
    
    def assertWhile(): Unit = js.native
    def assertWhile(opts: js.Object): Unit = js.native
    
    def assertWhileStatement(): Unit = js.native
    def assertWhileStatement(opts: js.Object): Unit = js.native
    
    def assertWithStatement(): Unit = js.native
    def assertWithStatement(opts: js.Object): Unit = js.native
    
    def assertYieldExpression(): Unit = js.native
    def assertYieldExpression(opts: js.Object): Unit = js.native
    
    def baseTypeStrictlyMatches(right: NodePath[Node]): Boolean = js.native
    
    def buildCodeFrameError[TError /* <: js.Error */](msg: String): TError = js.native
    def buildCodeFrameError[TError /* <: js.Error */](msg: String, Error: Instantiable1[/* msg */ String, TError]): TError = js.native
    
    // ------------------------- context -------------------------
    def call(key: String): Boolean = js.native
    
    /**
      * This checks whether or not we're in one of the following positions:
      *
      *   for (KEY in right);
      *   for (KEY;;);
      *
      * This is because these spots allow VariableDeclarations AND normal expressions so we need
      * to tell the path replacement that it's ok to replace this with an expression.
      */
    def canHaveVariableDeclarationOrExpression(): Boolean = js.native
    
    /**
      * This checks whether we are swapping an arrow function's body between an
      * expression and a block statement (or vice versa).
      *
      * This is because arrow functions may implicitly return an expression, which
      * is the same as containing a block statement.
      */
    def canSwapBetweenExpressionAndStatement(replacement: Node): Boolean = js.native
    
    var container: js.Object | js.Array[js.Object] = js.native
    
    var context: TraversalContext = js.native
    
    var contexts: js.Array[TraversalContext] = js.native
    
    def couldBeBaseType(name: String): Boolean = js.native
    
    var data: js.Object = js.native
    
    // Example: https://github.com/babel/babel/blob/63204ae51e020d84a5b246312f5eeb4d981ab952/packages/babel-traverse/src/path/modification.js#L83
    def debug(buildMessage: js.Function0[String]): Unit = js.native
    
    /** Check whether the path node `key` strict equals `value`. */
    def equals(key: String, value: Any): Boolean = js.native
    
    /**
      * Walk the input `node` and statically evaluate it.
      *
      * Returns an object in the form `{ confident, value }`. `confident` indicates
      * whether or not we had to drop out of evaluating the expression because of
      * hitting an unknown node that we couldn't confidently find the value of.
      *
      * Example:
      *
      *   t.evaluate(parse("5 + 5")) // { confident: true, value: 10 }
      *   t.evaluate(parse("!true")) // { confident: true, value: false }
      *   t.evaluate(parse("foo + foo")) // { confident: false, value: undefined }
      */
    def evaluate(): Confident = js.native
    
    // ------------------------- evaluation -------------------------
    /**
      * Walk the input `node` and statically evaluate if it's truthy.
      *
      * Returning `true` when we're sure that the expression will evaluate to a
      * truthy value, `false` if we're sure that it will evaluate to a falsy
      * value and `undefined` if we aren't sure. Because of this please do not
      * rely on coercion when using this method and check with === if it's false.
      */
    def evaluateTruthy(): Boolean = js.native
    
    def find(callback: js.Function1[/* path */ NodePath[Node], Boolean]): NodePath[Node] = js.native
    
    // ------------------------- ancestry -------------------------
    /**
      * Call the provided `callback` with the `NodePath`s of all the parents.
      * When the `callback` returns a truthy value, we return that node path.
      */
    def findParent(callback: js.Function1[/* path */ NodePath[Node], Boolean]): NodePath[Node] = js.native
    
    def get(key: String): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get(key: String, context: Boolean): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get(key: String, context: TraversalContext): NodePath[Node] | js.Array[NodePath[Node]] = js.native
    def get[K /* <: /* keyof T */ String */](key: K): /* import warning: importer.ImportType#apply Failed type conversion: T[K] extends std.Array<babel-traverse.babel-traverse.Node | null | undefined> ? std.Array<babel-traverse.babel-traverse.NodePath<T[K][number]>> : T[K] extends babel-traverse.babel-traverse.Node | null | undefined ? babel-traverse.babel-traverse.NodePath<T[K]> : never */ js.Any = js.native
    def get[K /* <: /* keyof T */ String */](key: K, context: Boolean): /* import warning: importer.ImportType#apply Failed type conversion: T[K] extends std.Array<babel-traverse.babel-traverse.Node | null | undefined> ? std.Array<babel-traverse.babel-traverse.NodePath<T[K][number]>> : T[K] extends babel-traverse.babel-traverse.Node | null | undefined ? babel-traverse.babel-traverse.NodePath<T[K]> : never */ js.Any = js.native
    def get[K /* <: /* keyof T */ String */](key: K, context: TraversalContext): /* import warning: importer.ImportType#apply Failed type conversion: T[K] extends std.Array<babel-traverse.babel-traverse.Node | null | undefined> ? std.Array<babel-traverse.babel-traverse.NodePath<T[K][number]>> : T[K] extends babel-traverse.babel-traverse.Node | null | undefined ? babel-traverse.babel-traverse.NodePath<T[K]> : never */ js.Any = js.native
    
    def getAllNextSiblings(): js.Array[NodePath[Node]] = js.native
    
    def getAllPrevSiblings(): js.Array[NodePath[Node]] = js.native
    
    /**
      * Build an array of node paths containing the entire ancestry of the current node path.
      *
      * NOTE: The current node path is included in this.
      */
    def getAncestry(): js.Array[NodePath[Node]] = js.native
    
    def getBindingIdentifiers(): js.Array[Node] = js.native
    def getBindingIdentifiers(duplicates: Boolean): js.Array[Node] = js.native
    
    def getCompletionRecords(): js.Array[NodePath[Node]] = js.native
    
    def getData(key: String): Any = js.native
    def getData(key: String, `def`: Any): Any = js.native
    
    /** Get the earliest path in the tree where the provided `paths` intersect. */
    def getDeepestCommonAncestorFrom(paths: js.Array[NodePath[Node]]): NodePath[Node] = js.native
    def getDeepestCommonAncestorFrom(
      paths: js.Array[NodePath[Node]],
      filter: js.Function3[
          /* deepest */ Node, 
          /* i */ Double, 
          /* ancestries */ js.Array[NodePath[Node]], 
          NodePath[Node]
        ]
    ): NodePath[Node] = js.native
    
    /**
      * Get the deepest common ancestor and then from it, get the earliest relationship path
      * to that ancestor.
      *
      * Earliest is defined as being "before" all the other nodes in terms of list container
      * position and visiting key.
      */
    def getEarliestCommonAncestorFrom(paths: js.Array[NodePath[Node]]): js.Array[NodePath[Node]] = js.native
    
    /** Get the parent function of the current path. */
    def getFunctionParent(): NodePath[Function] = js.native
    
    def getNextSibling(): NodePath[Node] = js.native
    
    // ------------------------- family -------------------------
    def getOpposite(): NodePath[Node] = js.native
    
    def getOuterBindingIdentifiers(): js.Array[Node] = js.native
    def getOuterBindingIdentifiers(duplicates: Boolean): js.Array[Node] = js.native
    
    def getPathLocation(): String = js.native
    
    def getPrevSibling(): NodePath[Node] = js.native
    
    def getScope(scope: Scope): Scope = js.native
    
    def getSibling(key: String): NodePath[Node] = js.native
    def getSibling(key: Double): NodePath[Node] = js.native
    
    /** Get the source code associated with this node. */
    def getSource(): String = js.native
    
    /** Walk up the tree until we hit a parent node path in a list. */
    def getStatementParent(): NodePath[Statement] = js.native
    
    // ------------------------- inference -------------------------
    /** Infer the type of the current `NodePath`. */
    def getTypeAnnotation(): FlowTypeAnnotation = js.native
    
    /**
      * Check whether we have the input `key`. If the `key` references an array then we check
      * if the array has any items, otherwise we just check if it's falsy.
      */
    def has(key: String): Boolean = js.native
    
    /** Hoist the current node to the highest scope possible and return a UID referencing it. */
    def hoist(scope: Scope): Unit = js.native
    
    var hub: Hub = js.native
    
    var inList: Boolean = js.native
    
    def inType(candidateTypes: String*): Boolean = js.native
    
    def insertAfter(nodes: js.Array[Node]): Any = js.native
    /**
      * Insert the provided nodes after the current one. When inserting nodes after an
      * expression, ensure that the completion record is correct by pushing the current node.
      */
    def insertAfter(nodes: Node): Any = js.native
    
    def insertBefore(nodes: js.Array[Node]): Any = js.native
    // ------------------------- modification -------------------------
    /** Insert the provided nodes before the current one. */
    def insertBefore(nodes: Node): Any = js.native
    
    /** Alias of `has`. */
    def is(key: String): Boolean = js.native
    
    def isAnyTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.AnyTypeAnnotation> */ Boolean = js.native
    def isAnyTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.AnyTypeAnnotation> */ Boolean = js.native
    
    // ------------------------- isXXX -------------------------
    def isArrayExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ArrayExpression> */ Boolean = js.native
    def isArrayExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ArrayExpression> */ Boolean = js.native
    
    def isArrayPattern(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ArrayPattern> */ Boolean = js.native
    def isArrayPattern(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ArrayPattern> */ Boolean = js.native
    
    def isArrayTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ArrayTypeAnnotation> */ Boolean = js.native
    def isArrayTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ArrayTypeAnnotation> */ Boolean = js.native
    
    def isArrowFunctionExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ArrowFunctionExpression> */ Boolean = js.native
    def isArrowFunctionExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ArrowFunctionExpression> */ Boolean = js.native
    
    def isAssignmentExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.AssignmentExpression> */ Boolean = js.native
    def isAssignmentExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.AssignmentExpression> */ Boolean = js.native
    
    def isAssignmentPattern(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.AssignmentPattern> */ Boolean = js.native
    def isAssignmentPattern(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.AssignmentPattern> */ Boolean = js.native
    
    def isAwaitExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.AwaitExpression> */ Boolean = js.native
    def isAwaitExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.AwaitExpression> */ Boolean = js.native
    
    def isBaseType(baseName: String): Boolean = js.native
    def isBaseType(baseName: String, soft: Boolean): Boolean = js.native
    
    def isBinary(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Binary> */ Boolean = js.native
    def isBinary(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Binary> */ Boolean = js.native
    
    def isBinaryExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BinaryExpression> */ Boolean = js.native
    def isBinaryExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BinaryExpression> */ Boolean = js.native
    
    def isBindExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BindExpression> */ Boolean = js.native
    def isBindExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BindExpression> */ Boolean = js.native
    
    def isBindingIdentifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Identifier> */ Boolean = js.native
    def isBindingIdentifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Identifier> */ Boolean = js.native
    
    def isBlacklisted(): Boolean = js.native
    
    def isBlock(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Block> */ Boolean = js.native
    def isBlock(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Block> */ Boolean = js.native
    
    def isBlockParent(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BlockParent> */ Boolean = js.native
    def isBlockParent(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BlockParent> */ Boolean = js.native
    
    def isBlockScoped(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FunctionDeclaration | babel-types.babel-types.ClassDeclaration | babel-types.babel-types.VariableDeclaration> */ Boolean = js.native
    def isBlockScoped(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FunctionDeclaration | babel-types.babel-types.ClassDeclaration | babel-types.babel-types.VariableDeclaration> */ Boolean = js.native
    
    def isBlockStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BlockStatement> */ Boolean = js.native
    def isBlockStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BlockStatement> */ Boolean = js.native
    
    def isBooleanLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BooleanLiteral> */ Boolean = js.native
    def isBooleanLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BooleanLiteral> */ Boolean = js.native
    
    def isBooleanLiteralTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BooleanLiteralTypeAnnotation> */ Boolean = js.native
    def isBooleanLiteralTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BooleanLiteralTypeAnnotation> */ Boolean = js.native
    
    def isBooleanTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BooleanTypeAnnotation> */ Boolean = js.native
    def isBooleanTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BooleanTypeAnnotation> */ Boolean = js.native
    
    def isBreakStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BreakStatement> */ Boolean = js.native
    def isBreakStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.BreakStatement> */ Boolean = js.native
    
    def isCallExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.CallExpression> */ Boolean = js.native
    def isCallExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.CallExpression> */ Boolean = js.native
    
    def isCatchClause(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.CatchClause> */ Boolean = js.native
    def isCatchClause(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.CatchClause> */ Boolean = js.native
    
    def isClass(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Class> */ Boolean = js.native
    def isClass(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Class> */ Boolean = js.native
    
    def isClassBody(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ClassBody> */ Boolean = js.native
    def isClassBody(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ClassBody> */ Boolean = js.native
    
    def isClassDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ClassDeclaration> */ Boolean = js.native
    def isClassDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ClassDeclaration> */ Boolean = js.native
    
    def isClassExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ClassExpression> */ Boolean = js.native
    def isClassExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ClassExpression> */ Boolean = js.native
    
    def isClassImplements(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ClassImplements> */ Boolean = js.native
    def isClassImplements(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ClassImplements> */ Boolean = js.native
    
    def isClassMethod(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ClassMethod> */ Boolean = js.native
    def isClassMethod(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ClassMethod> */ Boolean = js.native
    
    def isClassProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ClassProperty> */ Boolean = js.native
    def isClassProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ClassProperty> */ Boolean = js.native
    
    /** Check whether the current path references a completion record */
    def isCompletionRecord(): Boolean = js.native
    def isCompletionRecord(allowInsideFunction: Boolean): Boolean = js.native
    
    def isCompletionStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.CompletionStatement> */ Boolean = js.native
    def isCompletionStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.CompletionStatement> */ Boolean = js.native
    
    def isConditional(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Conditional> */ Boolean = js.native
    def isConditional(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Conditional> */ Boolean = js.native
    
    def isConditionalExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ConditionalExpression> */ Boolean = js.native
    def isConditionalExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ConditionalExpression> */ Boolean = js.native
    
    def isContinueStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ContinueStatement> */ Boolean = js.native
    def isContinueStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ContinueStatement> */ Boolean = js.native
    
    def isDebuggerStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DebuggerStatement> */ Boolean = js.native
    def isDebuggerStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DebuggerStatement> */ Boolean = js.native
    
    def isDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Declaration> */ Boolean = js.native
    def isDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Declaration> */ Boolean = js.native
    
    def isDeclareClass(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DeclareClass> */ Boolean = js.native
    def isDeclareClass(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DeclareClass> */ Boolean = js.native
    
    def isDeclareFunction(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DeclareFunction> */ Boolean = js.native
    def isDeclareFunction(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DeclareFunction> */ Boolean = js.native
    
    def isDeclareInterface(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DeclareInterface> */ Boolean = js.native
    def isDeclareInterface(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DeclareInterface> */ Boolean = js.native
    
    def isDeclareModule(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DeclareModule> */ Boolean = js.native
    def isDeclareModule(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DeclareModule> */ Boolean = js.native
    
    def isDeclareTypeAlias(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DeclareTypeAlias> */ Boolean = js.native
    def isDeclareTypeAlias(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DeclareTypeAlias> */ Boolean = js.native
    
    def isDeclareVariable(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DeclareVariable> */ Boolean = js.native
    def isDeclareVariable(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DeclareVariable> */ Boolean = js.native
    
    def isDecorator(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Decorator> */ Boolean = js.native
    def isDecorator(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Decorator> */ Boolean = js.native
    
    def isDirective(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Directive> */ Boolean = js.native
    def isDirective(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Directive> */ Boolean = js.native
    
    def isDirectiveLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DirectiveLiteral> */ Boolean = js.native
    def isDirectiveLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DirectiveLiteral> */ Boolean = js.native
    
    def isDoExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DoExpression> */ Boolean = js.native
    def isDoExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DoExpression> */ Boolean = js.native
    
    def isDoWhileStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DoWhileStatement> */ Boolean = js.native
    def isDoWhileStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.DoWhileStatement> */ Boolean = js.native
    
    def isEmptyStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.EmptyStatement> */ Boolean = js.native
    def isEmptyStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.EmptyStatement> */ Boolean = js.native
    
    def isExistentialTypeParam(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExistentialTypeParam> */ Boolean = js.native
    def isExistentialTypeParam(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExistentialTypeParam> */ Boolean = js.native
    
    def isExportAllDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportAllDeclaration> */ Boolean = js.native
    def isExportAllDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportAllDeclaration> */ Boolean = js.native
    
    def isExportDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportDeclaration> */ Boolean = js.native
    def isExportDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportDeclaration> */ Boolean = js.native
    
    def isExportDefaultDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportDefaultDeclaration> */ Boolean = js.native
    def isExportDefaultDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportDefaultDeclaration> */ Boolean = js.native
    
    def isExportDefaultSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportDefaultSpecifier> */ Boolean = js.native
    def isExportDefaultSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportDefaultSpecifier> */ Boolean = js.native
    
    def isExportNamedDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportNamedDeclaration> */ Boolean = js.native
    def isExportNamedDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportNamedDeclaration> */ Boolean = js.native
    
    def isExportNamespaceSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportNamespaceSpecifier> */ Boolean = js.native
    def isExportNamespaceSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportNamespaceSpecifier> */ Boolean = js.native
    
    def isExportSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportSpecifier> */ Boolean = js.native
    def isExportSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExportSpecifier> */ Boolean = js.native
    
    def isExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Expression> */ Boolean = js.native
    def isExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Expression> */ Boolean = js.native
    
    def isExpressionStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExpressionStatement> */ Boolean = js.native
    def isExpressionStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExpressionStatement> */ Boolean = js.native
    
    def isExpressionWrapper(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExpressionWrapper> */ Boolean = js.native
    def isExpressionWrapper(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ExpressionWrapper> */ Boolean = js.native
    
    def isFile(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.File> */ Boolean = js.native
    def isFile(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.File> */ Boolean = js.native
    
    def isFlow(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Flow> */ Boolean = js.native
    def isFlow(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Flow> */ Boolean = js.native
    
    def isFlowBaseAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FlowBaseAnnotation> */ Boolean = js.native
    def isFlowBaseAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FlowBaseAnnotation> */ Boolean = js.native
    
    def isFlowDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FlowDeclaration> */ Boolean = js.native
    def isFlowDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FlowDeclaration> */ Boolean = js.native
    
    def isFor(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.For> */ Boolean = js.native
    def isFor(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.For> */ Boolean = js.native
    
    def isForInStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ForInStatement> */ Boolean = js.native
    def isForInStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ForInStatement> */ Boolean = js.native
    
    def isForOfStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ForOfStatement> */ Boolean = js.native
    def isForOfStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ForOfStatement> */ Boolean = js.native
    
    def isForStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ForStatement> */ Boolean = js.native
    def isForStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ForStatement> */ Boolean = js.native
    
    def isForXStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ForXStatement> */ Boolean = js.native
    def isForXStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ForXStatement> */ Boolean = js.native
    
    def isFunction(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Function> */ Boolean = js.native
    def isFunction(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Function> */ Boolean = js.native
    
    def isFunctionDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FunctionDeclaration> */ Boolean = js.native
    def isFunctionDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FunctionDeclaration> */ Boolean = js.native
    
    def isFunctionExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FunctionExpression> */ Boolean = js.native
    def isFunctionExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FunctionExpression> */ Boolean = js.native
    
    def isFunctionParent(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FunctionParent> */ Boolean = js.native
    def isFunctionParent(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FunctionParent> */ Boolean = js.native
    
    def isFunctionTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FunctionTypeAnnotation> */ Boolean = js.native
    def isFunctionTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FunctionTypeAnnotation> */ Boolean = js.native
    
    def isFunctionTypeParam(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FunctionTypeParam> */ Boolean = js.native
    def isFunctionTypeParam(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.FunctionTypeParam> */ Boolean = js.native
    
    def isGenerated(): Boolean = js.native
    def isGenerated(opts: js.Object): Boolean = js.native
    
    def isGenericType(genericName: String): Boolean = js.native
    
    def isGenericTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.GenericTypeAnnotation> */ Boolean = js.native
    def isGenericTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.GenericTypeAnnotation> */ Boolean = js.native
    
    def isIdentifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Identifier> */ Boolean = js.native
    def isIdentifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Identifier> */ Boolean = js.native
    
    def isIfStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.IfStatement> */ Boolean = js.native
    def isIfStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.IfStatement> */ Boolean = js.native
    
    def isImmutable(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Immutable> */ Boolean = js.native
    def isImmutable(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Immutable> */ Boolean = js.native
    
    def isImportDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ImportDeclaration> */ Boolean = js.native
    def isImportDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ImportDeclaration> */ Boolean = js.native
    
    def isImportDefaultSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ImportDefaultSpecifier> */ Boolean = js.native
    def isImportDefaultSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ImportDefaultSpecifier> */ Boolean = js.native
    
    def isImportNamespaceSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ImportNamespaceSpecifier> */ Boolean = js.native
    def isImportNamespaceSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ImportNamespaceSpecifier> */ Boolean = js.native
    
    def isImportSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ImportSpecifier> */ Boolean = js.native
    def isImportSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ImportSpecifier> */ Boolean = js.native
    
    def isInterfaceDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.InterfaceDeclaration> */ Boolean = js.native
    def isInterfaceDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.InterfaceDeclaration> */ Boolean = js.native
    
    def isInterfaceExtends(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.InterfaceExtends> */ Boolean = js.native
    def isInterfaceExtends(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.InterfaceExtends> */ Boolean = js.native
    
    def isIntersectionTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.IntersectionTypeAnnotation> */ Boolean = js.native
    def isIntersectionTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.IntersectionTypeAnnotation> */ Boolean = js.native
    
    def isJSX(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSX> */ Boolean = js.native
    def isJSX(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSX> */ Boolean = js.native
    
    def isJSXAttribute(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXAttribute> */ Boolean = js.native
    def isJSXAttribute(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXAttribute> */ Boolean = js.native
    
    def isJSXClosingElement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXClosingElement> */ Boolean = js.native
    def isJSXClosingElement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXClosingElement> */ Boolean = js.native
    
    def isJSXElement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXElement> */ Boolean = js.native
    def isJSXElement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXElement> */ Boolean = js.native
    
    def isJSXEmptyExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXEmptyExpression> */ Boolean = js.native
    def isJSXEmptyExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXEmptyExpression> */ Boolean = js.native
    
    def isJSXExpressionContainer(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXExpressionContainer> */ Boolean = js.native
    def isJSXExpressionContainer(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXExpressionContainer> */ Boolean = js.native
    
    def isJSXIdentifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXIdentifier> */ Boolean = js.native
    def isJSXIdentifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXIdentifier> */ Boolean = js.native
    
    def isJSXMemberExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXMemberExpression> */ Boolean = js.native
    def isJSXMemberExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXMemberExpression> */ Boolean = js.native
    
    def isJSXNamespacedName(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXNamespacedName> */ Boolean = js.native
    def isJSXNamespacedName(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXNamespacedName> */ Boolean = js.native
    
    def isJSXOpeningElement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXOpeningElement> */ Boolean = js.native
    def isJSXOpeningElement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXOpeningElement> */ Boolean = js.native
    
    def isJSXSpreadAttribute(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXSpreadAttribute> */ Boolean = js.native
    def isJSXSpreadAttribute(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXSpreadAttribute> */ Boolean = js.native
    
    def isJSXText(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXText> */ Boolean = js.native
    def isJSXText(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.JSXText> */ Boolean = js.native
    
    def isLVal(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.LVal> */ Boolean = js.native
    def isLVal(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.LVal> */ Boolean = js.native
    
    def isLabeledStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.LabeledStatement> */ Boolean = js.native
    def isLabeledStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.LabeledStatement> */ Boolean = js.native
    
    def isLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Literal> */ Boolean = js.native
    def isLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Literal> */ Boolean = js.native
    
    def isLogicalExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.LogicalExpression> */ Boolean = js.native
    def isLogicalExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.LogicalExpression> */ Boolean = js.native
    
    def isLoop(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Loop> */ Boolean = js.native
    def isLoop(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Loop> */ Boolean = js.native
    
    def isMemberExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.MemberExpression> */ Boolean = js.native
    def isMemberExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.MemberExpression> */ Boolean = js.native
    
    def isMetaProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.MetaProperty> */ Boolean = js.native
    def isMetaProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.MetaProperty> */ Boolean = js.native
    
    def isMethod(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Method> */ Boolean = js.native
    def isMethod(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Method> */ Boolean = js.native
    
    def isMixedTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.MixedTypeAnnotation> */ Boolean = js.native
    def isMixedTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.MixedTypeAnnotation> */ Boolean = js.native
    
    def isModuleDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ModuleDeclaration> */ Boolean = js.native
    def isModuleDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ModuleDeclaration> */ Boolean = js.native
    
    def isModuleSpecifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ModuleSpecifier> */ Boolean = js.native
    def isModuleSpecifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ModuleSpecifier> */ Boolean = js.native
    
    def isNewExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NewExpression> */ Boolean = js.native
    def isNewExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NewExpression> */ Boolean = js.native
    
    /**
      * Check the type against our stored internal type of the node. This is handy when a node has
      * been removed yet we still internally know the type and need it to calculate node replacement.
      */
    def isNodeType(`type`: String): Boolean = js.native
    
    def isNoop(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Noop> */ Boolean = js.native
    def isNoop(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Noop> */ Boolean = js.native
    
    def isNullLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NullLiteral> */ Boolean = js.native
    def isNullLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NullLiteral> */ Boolean = js.native
    
    def isNullLiteralTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NullLiteralTypeAnnotation> */ Boolean = js.native
    def isNullLiteralTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NullLiteralTypeAnnotation> */ Boolean = js.native
    
    def isNullableTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NullableTypeAnnotation> */ Boolean = js.native
    def isNullableTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NullableTypeAnnotation> */ Boolean = js.native
    
    def isNumberLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NumericLiteral> */ Boolean = js.native
    def isNumberLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NumericLiteral> */ Boolean = js.native
    
    def isNumberTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NumberTypeAnnotation> */ Boolean = js.native
    def isNumberTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NumberTypeAnnotation> */ Boolean = js.native
    
    def isNumericLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NumericLiteral> */ Boolean = js.native
    def isNumericLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NumericLiteral> */ Boolean = js.native
    
    def isNumericLiteralTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NumericLiteralTypeAnnotation> */ Boolean = js.native
    def isNumericLiteralTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.NumericLiteralTypeAnnotation> */ Boolean = js.native
    
    def isObjectExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectExpression> */ Boolean = js.native
    def isObjectExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectExpression> */ Boolean = js.native
    
    def isObjectMember(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectMember> */ Boolean = js.native
    def isObjectMember(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectMember> */ Boolean = js.native
    
    def isObjectMethod(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectMethod> */ Boolean = js.native
    def isObjectMethod(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectMethod> */ Boolean = js.native
    
    def isObjectPattern(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectPattern> */ Boolean = js.native
    def isObjectPattern(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectPattern> */ Boolean = js.native
    
    def isObjectProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectProperty> */ Boolean = js.native
    def isObjectProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectProperty> */ Boolean = js.native
    
    def isObjectTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectTypeAnnotation> */ Boolean = js.native
    def isObjectTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectTypeAnnotation> */ Boolean = js.native
    
    def isObjectTypeCallProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectTypeCallProperty> */ Boolean = js.native
    def isObjectTypeCallProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectTypeCallProperty> */ Boolean = js.native
    
    def isObjectTypeIndexer(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectTypeIndexer> */ Boolean = js.native
    def isObjectTypeIndexer(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectTypeIndexer> */ Boolean = js.native
    
    def isObjectTypeProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectTypeProperty> */ Boolean = js.native
    def isObjectTypeProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ObjectTypeProperty> */ Boolean = js.native
    
    def isParenthesizedExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ParenthesizedExpression> */ Boolean = js.native
    def isParenthesizedExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ParenthesizedExpression> */ Boolean = js.native
    
    def isPattern(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Pattern> */ Boolean = js.native
    def isPattern(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Pattern> */ Boolean = js.native
    
    def isProgram(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Program> */ Boolean = js.native
    def isProgram(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Program> */ Boolean = js.native
    
    def isProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Property> */ Boolean = js.native
    def isProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Property> */ Boolean = js.native
    
    def isPure(): Boolean = js.native
    def isPure(opts: js.Object): Boolean = js.native
    
    def isPureish(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Pureish> */ Boolean = js.native
    def isPureish(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Pureish> */ Boolean = js.native
    
    def isQualifiedTypeIdentifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.QualifiedTypeIdentifier> */ Boolean = js.native
    def isQualifiedTypeIdentifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.QualifiedTypeIdentifier> */ Boolean = js.native
    
    def isReferenced(): Boolean = js.native
    def isReferenced(opts: js.Object): Boolean = js.native
    
    def isReferencedIdentifier(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Identifier | babel-types.babel-types.JSXIdentifier> */ Boolean = js.native
    def isReferencedIdentifier(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Identifier | babel-types.babel-types.JSXIdentifier> */ Boolean = js.native
    
    def isReferencedMemberExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.MemberExpression> */ Boolean = js.native
    def isReferencedMemberExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.MemberExpression> */ Boolean = js.native
    
    def isRegExpLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.RegExpLiteral> */ Boolean = js.native
    def isRegExpLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.RegExpLiteral> */ Boolean = js.native
    
    def isRegexLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.RegExpLiteral> */ Boolean = js.native
    def isRegexLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.RegExpLiteral> */ Boolean = js.native
    
    def isRestElement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.RestElement> */ Boolean = js.native
    def isRestElement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.RestElement> */ Boolean = js.native
    
    def isRestProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.RestProperty> */ Boolean = js.native
    def isRestProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.RestProperty> */ Boolean = js.native
    
    def isReturnStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ReturnStatement> */ Boolean = js.native
    def isReturnStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ReturnStatement> */ Boolean = js.native
    
    def isScopable(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Scopable> */ Boolean = js.native
    def isScopable(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Scopable> */ Boolean = js.native
    
    def isScope(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Scopable> */ Boolean = js.native
    def isScope(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Scopable> */ Boolean = js.native
    
    def isSequenceExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.SequenceExpression> */ Boolean = js.native
    def isSequenceExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.SequenceExpression> */ Boolean = js.native
    
    def isSpreadElement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.SpreadElement> */ Boolean = js.native
    def isSpreadElement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.SpreadElement> */ Boolean = js.native
    
    def isSpreadProperty(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.SpreadProperty> */ Boolean = js.native
    def isSpreadProperty(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.SpreadProperty> */ Boolean = js.native
    
    def isStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Statement> */ Boolean = js.native
    def isStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Statement> */ Boolean = js.native
    
    /**
      * Check whether or not the current `key` allows either a single statement or block statement
      * so we can explode it if necessary.
      */
    def isStatementOrBlock(): Boolean = js.native
    
    def isStatic(): Boolean = js.native
    
    def isStringLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.StringLiteral> */ Boolean = js.native
    def isStringLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.StringLiteral> */ Boolean = js.native
    
    def isStringLiteralTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.StringLiteralTypeAnnotation> */ Boolean = js.native
    def isStringLiteralTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.StringLiteralTypeAnnotation> */ Boolean = js.native
    
    def isStringTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.StringTypeAnnotation> */ Boolean = js.native
    def isStringTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.StringTypeAnnotation> */ Boolean = js.native
    
    def isSuper(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Super> */ Boolean = js.native
    def isSuper(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Super> */ Boolean = js.native
    
    def isSwitchCase(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.SwitchCase> */ Boolean = js.native
    def isSwitchCase(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.SwitchCase> */ Boolean = js.native
    
    def isSwitchStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.SwitchStatement> */ Boolean = js.native
    def isSwitchStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.SwitchStatement> */ Boolean = js.native
    
    def isTaggedTemplateExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TaggedTemplateExpression> */ Boolean = js.native
    def isTaggedTemplateExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TaggedTemplateExpression> */ Boolean = js.native
    
    def isTemplateElement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TemplateElement> */ Boolean = js.native
    def isTemplateElement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TemplateElement> */ Boolean = js.native
    
    def isTemplateLiteral(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TemplateLiteral> */ Boolean = js.native
    def isTemplateLiteral(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TemplateLiteral> */ Boolean = js.native
    
    def isTerminatorless(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Terminatorless> */ Boolean = js.native
    def isTerminatorless(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.Terminatorless> */ Boolean = js.native
    
    def isThisExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ThisExpression> */ Boolean = js.native
    def isThisExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ThisExpression> */ Boolean = js.native
    
    def isThisTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ThisTypeAnnotation> */ Boolean = js.native
    def isThisTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ThisTypeAnnotation> */ Boolean = js.native
    
    def isThrowStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ThrowStatement> */ Boolean = js.native
    def isThrowStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.ThrowStatement> */ Boolean = js.native
    
    def isTryStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TryStatement> */ Boolean = js.native
    def isTryStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TryStatement> */ Boolean = js.native
    
    def isTupleTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TupleTypeAnnotation> */ Boolean = js.native
    def isTupleTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TupleTypeAnnotation> */ Boolean = js.native
    
    def isTypeAlias(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TypeAlias> */ Boolean = js.native
    def isTypeAlias(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TypeAlias> */ Boolean = js.native
    
    def isTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TypeAnnotation> */ Boolean = js.native
    def isTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TypeAnnotation> */ Boolean = js.native
    
    def isTypeCastExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TypeCastExpression> */ Boolean = js.native
    def isTypeCastExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TypeCastExpression> */ Boolean = js.native
    
    def isTypeParameterDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TypeParameterDeclaration> */ Boolean = js.native
    def isTypeParameterDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TypeParameterDeclaration> */ Boolean = js.native
    
    def isTypeParameterInstantiation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TypeParameterInstantiation> */ Boolean = js.native
    def isTypeParameterInstantiation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TypeParameterInstantiation> */ Boolean = js.native
    
    def isTypeofTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TypeofTypeAnnotation> */ Boolean = js.native
    def isTypeofTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.TypeofTypeAnnotation> */ Boolean = js.native
    
    def isUnaryExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.UnaryExpression> */ Boolean = js.native
    def isUnaryExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.UnaryExpression> */ Boolean = js.native
    
    def isUnaryLike(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.UnaryLike> */ Boolean = js.native
    def isUnaryLike(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.UnaryLike> */ Boolean = js.native
    
    def isUnionTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.UnionTypeAnnotation> */ Boolean = js.native
    def isUnionTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.UnionTypeAnnotation> */ Boolean = js.native
    
    def isUpdateExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.UpdateExpression> */ Boolean = js.native
    def isUpdateExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.UpdateExpression> */ Boolean = js.native
    
    def isUser(): Boolean = js.native
    def isUser(opts: js.Object): Boolean = js.native
    
    def isUserWhitespacable(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.UserWhitespacable> */ Boolean = js.native
    def isUserWhitespacable(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.UserWhitespacable> */ Boolean = js.native
    
    def isVar(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.VariableDeclaration> */ Boolean = js.native
    def isVar(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.VariableDeclaration> */ Boolean = js.native
    
    def isVariableDeclaration(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.VariableDeclaration> */ Boolean = js.native
    def isVariableDeclaration(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.VariableDeclaration> */ Boolean = js.native
    
    def isVariableDeclarator(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.VariableDeclarator> */ Boolean = js.native
    def isVariableDeclarator(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.VariableDeclarator> */ Boolean = js.native
    
    def isVoidTypeAnnotation(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.VoidTypeAnnotation> */ Boolean = js.native
    def isVoidTypeAnnotation(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.VoidTypeAnnotation> */ Boolean = js.native
    
    def isWhile(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.While> */ Boolean = js.native
    def isWhile(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.While> */ Boolean = js.native
    
    def isWhileStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.WhileStatement> */ Boolean = js.native
    def isWhileStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.WhileStatement> */ Boolean = js.native
    
    def isWithStatement(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.WithStatement> */ Boolean = js.native
    def isWithStatement(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.WithStatement> */ Boolean = js.native
    
    def isYieldExpression(): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.YieldExpression> */ Boolean = js.native
    def isYieldExpression(opts: js.Object): /* is babel-traverse.babel-traverse.NodePath<babel-types.babel-types.YieldExpression> */ Boolean = js.native
    
    /** Opposite of `has`. */
    def isnt(key: String): Boolean = js.native
    
    var key: String | Double = js.native
    
    var listKey: String = js.native
    
    // ------------------------- introspection -------------------------
    /**
      * Match the current node if it matches the provided `pattern`.
      *
      * For example, given the match `React.createClass` it would match the
      * parsed nodes of `React.createClass` and `React["createClass"]`.
      */
    def matchesPattern(pattern: String): Boolean = js.native
    def matchesPattern(pattern: String, allowPartial: Boolean): Boolean = js.native
    
    var node: T = js.native
    
    var opts: js.Object = js.native
    
    var parent: Node = js.native
    
    var parentKey: String = js.native
    
    var parentPath: NodePath[Node] = js.native
    
    def popContext(): Unit = js.native
    
    def pushContext(context: TraversalContext): Unit = js.native
    
    /** Check if the currently assigned path references the `importName` of `moduleSource`. */
    def referencesImport(moduleSource: String, importName: String): Boolean = js.native
    
    // ------------------------- removal -------------------------
    def remove(): Unit = js.native
    
    var removed: Boolean = js.native
    
    /**
      * This method takes an array of statements nodes and then explodes it
      * into expressions. This method retains completion records which is
      * extremely important to retain original semantics.
      */
    def replaceExpressionWithStatements(nodes: js.Array[Node]): Node = js.native
    
    def replaceInline(nodes: js.Array[Node]): Unit = js.native
    def replaceInline(nodes: Node): Unit = js.native
    
    /** Replace the current node with another. */
    def replaceWith(replacement: Node): Unit = js.native
    def replaceWith(replacement: NodePath[Node]): Unit = js.native
    
    // ------------------------- replacement -------------------------
    /**
      * Replace a node with an array of multiple. This method performs the following steps:
      *
      *  - Inherit the comments of first provided node with that of the current node.
      *  - Insert the provided nodes after the current node.
      *  - Remove the current node.
      */
    def replaceWithMultiple(nodes: js.Array[Node]): Unit = js.native
    
    /**
      * Parse a string as an expression and replace the current node with the result.
      *
      * NOTE: This is typically not a good idea to use. Building source strings when
      * transforming ASTs is an antipattern and SHOULD NOT be encouraged. Even if it's
      * easier to use, your transforms will be extremely brittle.
      */
    def replaceWithSourceString(replacement: Any): Unit = js.native
    
    var scope: Scope = js.native
    
    def set(key: String, node: Node): Unit = js.native
    
    def setContext(context: TraversalContext): NodePath[T] = js.native
    
    def setData(key: String, `val`: Any): Any = js.native
    
    def setScope(): Unit = js.native
    
    // ------------------------- comments -------------------------
    /** Share comments amongst siblings. */
    def shareCommentsWithSiblings(): Unit = js.native
    
    var shouldSkip: Boolean = js.native
    
    var shouldStop: Boolean = js.native
    
    def skip(): Unit = js.native
    
    def skipKey(key: String): Unit = js.native
    
    var skipKeys: js.Object = js.native
    
    var state: Any = js.native
    
    def stop(): Unit = js.native
    
    def traverse(visitor: Visitor[Node]): Unit = js.native
    def traverse[T](visitor: Visitor[T], state: T): Unit = js.native
    
    var `type`: /* import warning: importer.ImportType#apply Failed type conversion: T extends undefined | null ? string | null : string */ js.Any = js.native
    
    var typeAnnotation: js.Object = js.native
    
    /** Update all sibling node paths after `fromIndex` by `incrementBy`. */
    def updateSiblingKeys(fromIndex: Double, incrementBy: Double): Unit = js.native
    
    def visit(): Boolean = js.native
    
    /** Check if the current path will maybe execute before another path */
    def willIMaybeExecuteBefore(path: NodePath[Node]): Boolean = js.native
  }
  
  @JSImport("babel-traverse", "Scope")
  @js.native
  open class Scope protected () extends StObject {
    def this(path: NodePath[Node]) = this()
    def this(path: NodePath[Node], parentScope: Scope) = this()
    
    def addGlobal(node: Node): Unit = js.native
    
    def bindingIdentifierEquals(name: String, node: Node): Boolean = js.native
    
    var bindings: StringDictionary[Binding] = js.native
    
    var block: Node = js.native
    
    def buildUndefinedNode(): Node = js.native
    
    def checkBlockScopedCollisions(local: Node, kind: String, name: String, id: js.Object): Unit = js.native
    
    def dump(): Unit = js.native
    
    /** Generate a unique identifier and add it to the current scope. */
    def generateDeclaredUidIdentifier(): Identifier_ = js.native
    def generateDeclaredUidIdentifier(name: String): Identifier_ = js.native
    
    /** Generate a unique `_id1` binding. */
    def generateUid(): String = js.native
    def generateUid(name: String): String = js.native
    
    /** Generate a unique identifier. */
    def generateUidIdentifier(): Identifier_ = js.native
    def generateUidIdentifier(name: String): Identifier_ = js.native
    
    /** Generate a unique identifier based on a node. */
    def generateUidIdentifierBasedOnNode(parent: Node): Identifier_ = js.native
    def generateUidIdentifierBasedOnNode(parent: Node, defaultName: String): Identifier_ = js.native
    
    /** Walks the scope tree and gathers **all** bindings. */
    def getAllBindings(kinds: String*): js.Object = js.native
    
    def getBinding(name: String): js.UndefOr[Binding] = js.native
    
    def getBindingIdentifier(name: String): Identifier_ = js.native
    
    def getBlockParent(): Scope = js.native
    
    def getData(key: String): Any = js.native
    
    def getFunctionParent(): Scope = js.native
    
    def getOwnBinding(name: String): js.UndefOr[Binding] = js.native
    
    def getOwnBindingIdentifier(name: String): Identifier_ = js.native
    
    def getProgramParent(): Scope = js.native
    
    def hasBinding(name: String): Boolean = js.native
    def hasBinding(name: String, noGlobals: Boolean): Boolean = js.native
    
    def hasGlobal(name: String): Boolean = js.native
    
    def hasOwnBinding(name: String): Boolean = js.native
    
    def hasReference(name: String): Boolean = js.native
    
    def hasUid(name: String): Boolean = js.native
    
    var hub: Hub = js.native
    
    def isPure(node: Node): Boolean = js.native
    def isPure(node: Node, constantsOnly: Boolean): Boolean = js.native
    
    /**
      * Determine whether evaluating the specific input `node` is a consequenceless reference. ie.
      * evaluating it wont result in potentially arbitrary code from being ran. The following are
      * whitelisted and determined not to cause side effects:
      *
      *  - `this` expressions
      *  - `super` expressions
      *  - Bound identifiers
      */
    def isStatic(node: Node): Boolean = js.native
    
    /** Possibly generate a memoised identifier if it is not static and has consequences. */
    def maybeGenerateMemoised(node: Node): Identifier_ = js.native
    def maybeGenerateMemoised(node: Node, dontPush: Boolean): Identifier_ = js.native
    
    /** Move a binding of `name` to another `scope`. */
    def moveBindingTo(name: String, scope: Scope): Unit = js.native
    
    var parent: Scope = js.native
    
    var parentBlock: Node = js.native
    
    def parentHasBinding(name: String): Boolean = js.native
    def parentHasBinding(name: String, noGlobals: Boolean): Boolean = js.native
    
    var path: NodePath[Node] = js.native
    
    def push(opts: Any): Unit = js.native
    
    def registerBinding(kind: String, path: NodePath[Node]): Unit = js.native
    def registerBinding(kind: String, path: NodePath[Node], bindingPath: NodePath[Node]): Unit = js.native
    
    def registerConstantViolation(path: NodePath[Node]): Unit = js.native
    
    def registerDeclaration(path: NodePath[Node]): Unit = js.native
    
    def removeBinding(name: String): Unit = js.native
    
    def removeData(key: String): Unit = js.native
    
    def removeOwnBinding(name: String): Unit = js.native
    
    def rename(oldName: String): Unit = js.native
    def rename(oldName: String, newName: String): Unit = js.native
    def rename(oldName: String, newName: String, block: Node): Unit = js.native
    def rename(oldName: String, newName: Unit, block: Node): Unit = js.native
    
    def setData(key: String, `val`: Any): Any = js.native
    
    def toArray(node: Node): Node = js.native
    def toArray(node: Node, i: Double): Node = js.native
    
    def traverse(node: js.Array[Node]): Unit = js.native
    def traverse(node: js.Array[Node], opts: Unit, state: Any): Unit = js.native
    def traverse(node: js.Array[Node], opts: TraverseOptions[Node]): Unit = js.native
    def traverse(node: js.Array[Node], opts: TraverseOptions[Node], state: Any): Unit = js.native
    def traverse(node: Node): Unit = js.native
    def traverse(node: Node, opts: Unit, state: Any): Unit = js.native
    def traverse(node: Node, opts: TraverseOptions[Node]): Unit = js.native
    def traverse(node: Node, opts: TraverseOptions[Node], state: Any): Unit = js.native
    @JSName("traverse")
    def traverse_S[S](node: js.Array[Node], opts: TraverseOptions[S], state: S): Unit = js.native
    /** Traverse node with current scope and path. */
    @JSName("traverse")
    def traverse_S[S](node: Node, opts: TraverseOptions[S], state: S): Unit = js.native
  }
  
  inline def default_S[S](parent: js.Array[Node], opts: TraverseOptions[S], scope: Scope, state: S): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default_S[S](
    parent: js.Array[Node],
    opts: TraverseOptions[S],
    scope: Scope,
    state: S,
    parentPath: NodePath[Node]
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default_S[S](parent: Node, opts: TraverseOptions[S], scope: Scope, state: S): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def default_S[S](parent: Node, opts: TraverseOptions[S], scope: Scope, state: S, parentPath: NodePath[Node]): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(parent.asInstanceOf[js.Any], opts.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], state.asInstanceOf[js.Any], parentPath.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  type Node = typings.babelTypes.mod.Node
  
  trait TraversalContext extends StObject {
    
    var opts: Any
    
    var parentPath: NodePath[Node]
    
    var scope: Scope
    
    var state: Any
  }
  object TraversalContext {
    
    inline def apply(opts: Any, parentPath: NodePath[Node], scope: Scope, state: Any): TraversalContext = {
      val __obj = js.Dynamic.literal(opts = opts.asInstanceOf[js.Any], parentPath = parentPath.asInstanceOf[js.Any], scope = scope.asInstanceOf[js.Any], state = state.asInstanceOf[js.Any])
      __obj.asInstanceOf[TraversalContext]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: TraversalContext] (val x: Self) extends AnyVal {
      
      inline def setOpts(value: Any): Self = StObject.set(x, "opts", value.asInstanceOf[js.Any])
      
      inline def setParentPath(value: NodePath[Node]): Self = StObject.set(x, "parentPath", value.asInstanceOf[js.Any])
      
      inline def setScope(value: Scope): Self = StObject.set(x, "scope", value.asInstanceOf[js.Any])
      
      inline def setState(value: Any): Self = StObject.set(x, "state", value.asInstanceOf[js.Any])
    }
  }
  
  trait TraverseOptions[S]
    extends StObject
       with Visitor[S] {
    
    var noScope: js.UndefOr[Boolean] = js.undefined
    
    var scope: js.UndefOr[Scope] = js.undefined
  }
  object TraverseOptions {
    
    inline def apply[S](): TraverseOptions[S] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[TraverseOptions[S]]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: TraverseOptions[?], S] (val x: Self & TraverseOptions[S]) extends AnyVal {
      
      inline def setNoScope(value: Boolean): Self = StObject.set(x, "noScope", value.asInstanceOf[js.Any])
      
      inline def setNoScopeUndefined: Self = StObject.set(x, "noScope", js.undefined)
      
      inline def setScope(value: Scope): Self = StObject.set(x, "scope", value.asInstanceOf[js.Any])
      
      inline def setScopeUndefined: Self = StObject.set(x, "scope", js.undefined)
    }
  }
  
  type VisitNode[T, P] = (VisitNodeFunction[T, P]) | VisitNodeObject[T]
  
  type VisitNodeFunction[T, P] = js.ThisFunction2[/* this */ T, /* path */ NodePath[P], /* state */ Any, Unit]
  
  trait VisitNodeObject[T] extends StObject {
    
    var enter: js.UndefOr[js.Function2[/* path */ NodePath[T], /* state */ Any, Unit]] = js.undefined
    
    var exit: js.UndefOr[js.Function2[/* path */ NodePath[T], /* state */ Any, Unit]] = js.undefined
  }
  object VisitNodeObject {
    
    inline def apply[T](): VisitNodeObject[T] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[VisitNodeObject[T]]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: VisitNodeObject[?], T] (val x: Self & VisitNodeObject[T]) extends AnyVal {
      
      inline def setEnter(value: (/* path */ NodePath[T], /* state */ Any) => Unit): Self = StObject.set(x, "enter", js.Any.fromFunction2(value))
      
      inline def setEnterUndefined: Self = StObject.set(x, "enter", js.undefined)
      
      inline def setExit(value: (/* path */ NodePath[T], /* state */ Any) => Unit): Self = StObject.set(x, "exit", js.Any.fromFunction2(value))
      
      inline def setExitUndefined: Self = StObject.set(x, "exit", js.undefined)
    }
  }
  
  trait Visitor[S]
    extends StObject
       with VisitNodeObject[Node] {
    
    var AnyTypeAnnotation: js.UndefOr[VisitNode[S, AnyTypeAnnotation_]] = js.undefined
    
    var ArrayExpression: js.UndefOr[VisitNode[S, ArrayExpression_]] = js.undefined
    
    var ArrayPattern: js.UndefOr[VisitNode[S, ArrayPattern_]] = js.undefined
    
    var ArrayTypeAnnotation: js.UndefOr[VisitNode[S, ArrayTypeAnnotation_]] = js.undefined
    
    var ArrowFunctionExpression: js.UndefOr[VisitNode[S, ArrowFunctionExpression_]] = js.undefined
    
    var AssignmentExpression: js.UndefOr[VisitNode[S, AssignmentExpression_]] = js.undefined
    
    var AssignmentPattern: js.UndefOr[VisitNode[S, AssignmentPattern_]] = js.undefined
    
    var AwaitExpression: js.UndefOr[VisitNode[S, AwaitExpression_]] = js.undefined
    
    var Binary: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Binary]] = js.undefined
    
    var BinaryExpression: js.UndefOr[VisitNode[S, BinaryExpression_]] = js.undefined
    
    var BindExpression: js.UndefOr[VisitNode[S, BindExpression_]] = js.undefined
    
    var Block: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Block]] = js.undefined
    
    var BlockParent: js.UndefOr[VisitNode[S, typings.babelTypes.mod.BlockParent]] = js.undefined
    
    var BlockStatement: js.UndefOr[VisitNode[S, BlockStatement_]] = js.undefined
    
    var BooleanLiteral: js.UndefOr[VisitNode[S, BooleanLiteral_]] = js.undefined
    
    var BooleanLiteralTypeAnnotation: js.UndefOr[VisitNode[S, BooleanLiteralTypeAnnotation_]] = js.undefined
    
    var BooleanTypeAnnotation: js.UndefOr[VisitNode[S, BooleanTypeAnnotation_]] = js.undefined
    
    var BreakStatement: js.UndefOr[VisitNode[S, BreakStatement_]] = js.undefined
    
    var CallExpression: js.UndefOr[VisitNode[S, CallExpression_]] = js.undefined
    
    var CatchClause: js.UndefOr[VisitNode[S, CatchClause_]] = js.undefined
    
    var Class: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Class]] = js.undefined
    
    var ClassBody: js.UndefOr[VisitNode[S, ClassBody_]] = js.undefined
    
    var ClassDeclaration: js.UndefOr[VisitNode[S, ClassDeclaration_]] = js.undefined
    
    var ClassExpression: js.UndefOr[VisitNode[S, ClassExpression_]] = js.undefined
    
    var ClassImplements: js.UndefOr[VisitNode[S, ClassImplements_]] = js.undefined
    
    var ClassMethod: js.UndefOr[VisitNode[S, ClassMethod_]] = js.undefined
    
    var ClassProperty: js.UndefOr[VisitNode[S, ClassProperty_]] = js.undefined
    
    var CompletionStatement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.CompletionStatement]] = js.undefined
    
    var Conditional: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Conditional]] = js.undefined
    
    var ConditionalExpression: js.UndefOr[VisitNode[S, ConditionalExpression_]] = js.undefined
    
    var ContinueStatement: js.UndefOr[VisitNode[S, ContinueStatement_]] = js.undefined
    
    var DebuggerStatement: js.UndefOr[VisitNode[S, DebuggerStatement_]] = js.undefined
    
    var Declaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Declaration]] = js.undefined
    
    var DeclareClass: js.UndefOr[VisitNode[S, DeclareClass_]] = js.undefined
    
    var DeclareFunction: js.UndefOr[VisitNode[S, DeclareFunction_]] = js.undefined
    
    var DeclareInterface: js.UndefOr[VisitNode[S, DeclareInterface_]] = js.undefined
    
    var DeclareModule: js.UndefOr[VisitNode[S, DeclareModule_]] = js.undefined
    
    var DeclareTypeAlias: js.UndefOr[VisitNode[S, DeclareTypeAlias_]] = js.undefined
    
    var DeclareVariable: js.UndefOr[VisitNode[S, DeclareVariable_]] = js.undefined
    
    var Decorator: js.UndefOr[VisitNode[S, Decorator_]] = js.undefined
    
    var Directive: js.UndefOr[VisitNode[S, Directive_]] = js.undefined
    
    var DirectiveLiteral: js.UndefOr[VisitNode[S, DirectiveLiteral_]] = js.undefined
    
    var DoExpression: js.UndefOr[VisitNode[S, DoExpression_]] = js.undefined
    
    var DoWhileStatement: js.UndefOr[VisitNode[S, DoWhileStatement_]] = js.undefined
    
    var EmptyStatement: js.UndefOr[VisitNode[S, EmptyStatement_]] = js.undefined
    
    var ExistentialTypeParam: js.UndefOr[VisitNode[S, ExistentialTypeParam_]] = js.undefined
    
    var ExportAllDeclaration: js.UndefOr[VisitNode[S, ExportAllDeclaration_]] = js.undefined
    
    var ExportDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ExportDeclaration]] = js.undefined
    
    var ExportDefaultDeclaration: js.UndefOr[VisitNode[S, ExportDefaultDeclaration_]] = js.undefined
    
    var ExportDefaultSpecifier: js.UndefOr[VisitNode[S, ExportDefaultSpecifier_]] = js.undefined
    
    var ExportNamedDeclaration: js.UndefOr[VisitNode[S, ExportNamedDeclaration_]] = js.undefined
    
    var ExportNamespaceSpecifier: js.UndefOr[VisitNode[S, ExportNamespaceSpecifier_]] = js.undefined
    
    var ExportSpecifier: js.UndefOr[VisitNode[S, ExportSpecifier_]] = js.undefined
    
    var Expression: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Expression]] = js.undefined
    
    var ExpressionStatement: js.UndefOr[VisitNode[S, ExpressionStatement_]] = js.undefined
    
    var ExpressionWrapper: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ExpressionWrapper]] = js.undefined
    
    var File: js.UndefOr[VisitNode[S, File_]] = js.undefined
    
    var Flow: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Flow]] = js.undefined
    
    var FlowBaseAnnotation: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowBaseAnnotation]] = js.undefined
    
    var FlowDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FlowDeclaration]] = js.undefined
    
    var For: js.UndefOr[VisitNode[S, typings.babelTypes.mod.For]] = js.undefined
    
    var ForInStatement: js.UndefOr[VisitNode[S, ForInStatement_]] = js.undefined
    
    var ForOfStatement: js.UndefOr[VisitNode[S, ForOfStatement_]] = js.undefined
    
    var ForStatement: js.UndefOr[VisitNode[S, ForStatement_]] = js.undefined
    
    var ForXStatement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ForXStatement]] = js.undefined
    
    var Function: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Function]] = js.undefined
    
    var FunctionDeclaration: js.UndefOr[VisitNode[S, FunctionDeclaration_]] = js.undefined
    
    var FunctionExpression: js.UndefOr[VisitNode[S, FunctionExpression_]] = js.undefined
    
    var FunctionParent: js.UndefOr[VisitNode[S, typings.babelTypes.mod.FunctionParent]] = js.undefined
    
    var FunctionTypeAnnotation: js.UndefOr[VisitNode[S, FunctionTypeAnnotation_]] = js.undefined
    
    var FunctionTypeParam: js.UndefOr[VisitNode[S, FunctionTypeParam_]] = js.undefined
    
    var GenericTypeAnnotation: js.UndefOr[VisitNode[S, GenericTypeAnnotation_]] = js.undefined
    
    var Identifier: js.UndefOr[VisitNode[S, Identifier_]] = js.undefined
    
    var IfStatement: js.UndefOr[VisitNode[S, IfStatement_]] = js.undefined
    
    var Immutable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Immutable]] = js.undefined
    
    var ImportDeclaration: js.UndefOr[VisitNode[S, ImportDeclaration_]] = js.undefined
    
    var ImportDefaultSpecifier: js.UndefOr[VisitNode[S, ImportDefaultSpecifier_]] = js.undefined
    
    var ImportNamespaceSpecifier: js.UndefOr[VisitNode[S, ImportNamespaceSpecifier_]] = js.undefined
    
    var ImportSpecifier: js.UndefOr[VisitNode[S, ImportSpecifier_]] = js.undefined
    
    var InterfaceDeclaration: js.UndefOr[VisitNode[S, InterfaceDeclaration_]] = js.undefined
    
    var InterfaceExtends: js.UndefOr[VisitNode[S, InterfaceExtends_]] = js.undefined
    
    var IntersectionTypeAnnotation: js.UndefOr[VisitNode[S, IntersectionTypeAnnotation_]] = js.undefined
    
    var JSX: js.UndefOr[VisitNode[S, typings.babelTypes.mod.JSX]] = js.undefined
    
    var JSXAttribute: js.UndefOr[VisitNode[S, JSXAttribute_]] = js.undefined
    
    var JSXClosingElement: js.UndefOr[VisitNode[S, JSXClosingElement_]] = js.undefined
    
    var JSXElement: js.UndefOr[VisitNode[S, JSXElement_]] = js.undefined
    
    var JSXEmptyExpression: js.UndefOr[VisitNode[S, JSXEmptyExpression_]] = js.undefined
    
    var JSXExpressionContainer: js.UndefOr[VisitNode[S, JSXExpressionContainer_]] = js.undefined
    
    var JSXIdentifier: js.UndefOr[VisitNode[S, JSXIdentifier_]] = js.undefined
    
    var JSXMemberExpression: js.UndefOr[VisitNode[S, JSXMemberExpression_]] = js.undefined
    
    var JSXNamespacedName: js.UndefOr[VisitNode[S, JSXNamespacedName_]] = js.undefined
    
    var JSXOpeningElement: js.UndefOr[VisitNode[S, JSXOpeningElement_]] = js.undefined
    
    var JSXSpreadAttribute: js.UndefOr[VisitNode[S, JSXSpreadAttribute_]] = js.undefined
    
    var JSXText: js.UndefOr[VisitNode[S, JSXText_]] = js.undefined
    
    var LVal: js.UndefOr[VisitNode[S, typings.babelTypes.mod.LVal]] = js.undefined
    
    var LabeledStatement: js.UndefOr[VisitNode[S, LabeledStatement_]] = js.undefined
    
    var Literal: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Literal]] = js.undefined
    
    var LogicalExpression: js.UndefOr[VisitNode[S, LogicalExpression_]] = js.undefined
    
    var Loop: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Loop]] = js.undefined
    
    var MemberExpression: js.UndefOr[VisitNode[S, MemberExpression_]] = js.undefined
    
    var MetaProperty: js.UndefOr[VisitNode[S, MetaProperty_]] = js.undefined
    
    var Method: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Method]] = js.undefined
    
    var MixedTypeAnnotation: js.UndefOr[VisitNode[S, MixedTypeAnnotation_]] = js.undefined
    
    var ModuleDeclaration: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ModuleDeclaration]] = js.undefined
    
    var ModuleSpecifier: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ModuleSpecifier]] = js.undefined
    
    var NewExpression: js.UndefOr[VisitNode[S, NewExpression_]] = js.undefined
    
    var Noop: js.UndefOr[VisitNode[S, Noop_]] = js.undefined
    
    var NullLiteral: js.UndefOr[VisitNode[S, NullLiteral_]] = js.undefined
    
    var NullLiteralTypeAnnotation: js.UndefOr[VisitNode[S, NullLiteralTypeAnnotation_]] = js.undefined
    
    var NullableTypeAnnotation: js.UndefOr[VisitNode[S, NullableTypeAnnotation_]] = js.undefined
    
    var NumberTypeAnnotation: js.UndefOr[VisitNode[S, NumberTypeAnnotation_]] = js.undefined
    
    var NumericLiteral: js.UndefOr[VisitNode[S, NumericLiteral_]] = js.undefined
    
    var NumericLiteralTypeAnnotation: js.UndefOr[VisitNode[S, NumericLiteralTypeAnnotation_]] = js.undefined
    
    var ObjectExpression: js.UndefOr[VisitNode[S, ObjectExpression_]] = js.undefined
    
    var ObjectMember: js.UndefOr[VisitNode[S, typings.babelTypes.mod.ObjectMember]] = js.undefined
    
    var ObjectMethod: js.UndefOr[VisitNode[S, ObjectMethod_]] = js.undefined
    
    var ObjectPattern: js.UndefOr[VisitNode[S, ObjectPattern_]] = js.undefined
    
    var ObjectProperty: js.UndefOr[VisitNode[S, ObjectProperty_]] = js.undefined
    
    var ObjectTypeAnnotation: js.UndefOr[VisitNode[S, ObjectTypeAnnotation_]] = js.undefined
    
    var ObjectTypeCallProperty: js.UndefOr[VisitNode[S, ObjectTypeCallProperty_]] = js.undefined
    
    var ObjectTypeIndexer: js.UndefOr[VisitNode[S, ObjectTypeIndexer_]] = js.undefined
    
    var ObjectTypeProperty: js.UndefOr[VisitNode[S, ObjectTypeProperty_]] = js.undefined
    
    var ParenthesizedExpression: js.UndefOr[VisitNode[S, ParenthesizedExpression_]] = js.undefined
    
    var Pattern: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Pattern]] = js.undefined
    
    var Program: js.UndefOr[VisitNode[S, Program_]] = js.undefined
    
    var Property: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Property]] = js.undefined
    
    var Pureish: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Pureish]] = js.undefined
    
    var QualifiedTypeIdentifier: js.UndefOr[VisitNode[S, QualifiedTypeIdentifier_]] = js.undefined
    
    var RegExpLiteral: js.UndefOr[VisitNode[S, RegExpLiteral_]] = js.undefined
    
    var RestElement: js.UndefOr[VisitNode[S, RestElement_]] = js.undefined
    
    var RestProperty: js.UndefOr[VisitNode[S, RestProperty_]] = js.undefined
    
    var ReturnStatement: js.UndefOr[VisitNode[S, ReturnStatement_]] = js.undefined
    
    var Scopable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Scopable]] = js.undefined
    
    var Scope: js.UndefOr[VisitNode[S, Scopable]] = js.undefined
    
    var SequenceExpression: js.UndefOr[VisitNode[S, SequenceExpression_]] = js.undefined
    
    var SpreadElement: js.UndefOr[VisitNode[S, SpreadElement_]] = js.undefined
    
    var SpreadProperty: js.UndefOr[VisitNode[S, SpreadProperty_]] = js.undefined
    
    var Statement: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Statement]] = js.undefined
    
    var StringLiteral: js.UndefOr[VisitNode[S, StringLiteral_]] = js.undefined
    
    var StringLiteralTypeAnnotation: js.UndefOr[VisitNode[S, StringLiteralTypeAnnotation_]] = js.undefined
    
    var StringTypeAnnotation: js.UndefOr[VisitNode[S, StringTypeAnnotation_]] = js.undefined
    
    var Super: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Super]] = js.undefined
    
    var SwitchCase: js.UndefOr[VisitNode[S, SwitchCase_]] = js.undefined
    
    var SwitchStatement: js.UndefOr[VisitNode[S, SwitchStatement_]] = js.undefined
    
    var TaggedTemplateExpression: js.UndefOr[VisitNode[S, TaggedTemplateExpression_]] = js.undefined
    
    var TemplateElement: js.UndefOr[VisitNode[S, TemplateElement_]] = js.undefined
    
    var TemplateLiteral: js.UndefOr[VisitNode[S, TemplateLiteral_]] = js.undefined
    
    var Terminatorless: js.UndefOr[VisitNode[S, typings.babelTypes.mod.Terminatorless]] = js.undefined
    
    var ThisExpression: js.UndefOr[VisitNode[S, ThisExpression_]] = js.undefined
    
    var ThisTypeAnnotation: js.UndefOr[VisitNode[S, ThisTypeAnnotation_]] = js.undefined
    
    var ThrowStatement: js.UndefOr[VisitNode[S, ThrowStatement_]] = js.undefined
    
    var TryStatement: js.UndefOr[VisitNode[S, TryStatement_]] = js.undefined
    
    var TupleTypeAnnotation: js.UndefOr[VisitNode[S, TupleTypeAnnotation_]] = js.undefined
    
    var TypeAlias: js.UndefOr[VisitNode[S, TypeAlias_]] = js.undefined
    
    var TypeAnnotation: js.UndefOr[VisitNode[S, TypeAnnotation_]] = js.undefined
    
    var TypeCastExpression: js.UndefOr[VisitNode[S, TypeCastExpression_]] = js.undefined
    
    var TypeParameterDeclaration: js.UndefOr[VisitNode[S, TypeParameterDeclaration_]] = js.undefined
    
    var TypeParameterInstantiation: js.UndefOr[VisitNode[S, TypeParameterInstantiation_]] = js.undefined
    
    var TypeofTypeAnnotation: js.UndefOr[VisitNode[S, TypeofTypeAnnotation_]] = js.undefined
    
    var UnaryExpression: js.UndefOr[VisitNode[S, UnaryExpression_]] = js.undefined
    
    var UnaryLike: js.UndefOr[VisitNode[S, typings.babelTypes.mod.UnaryLike]] = js.undefined
    
    var UnionTypeAnnotation: js.UndefOr[VisitNode[S, UnionTypeAnnotation_]] = js.undefined
    
    var UpdateExpression: js.UndefOr[VisitNode[S, UpdateExpression_]] = js.undefined
    
    var UserWhitespacable: js.UndefOr[VisitNode[S, typings.babelTypes.mod.UserWhitespacable]] = js.undefined
    
    var VariableDeclaration: js.UndefOr[VisitNode[S, VariableDeclaration_]] = js.undefined
    
    var VariableDeclarator: js.UndefOr[VisitNode[S, VariableDeclarator_]] = js.undefined
    
    var VoidTypeAnnotation: js.UndefOr[VisitNode[S, VoidTypeAnnotation_]] = js.undefined
    
    var While: js.UndefOr[VisitNode[S, typings.babelTypes.mod.While]] = js.undefined
    
    var WhileStatement: js.UndefOr[VisitNode[S, WhileStatement_]] = js.undefined
    
    var WithStatement: js.UndefOr[VisitNode[S, WithStatement_]] = js.undefined
    
    var YieldExpression: js.UndefOr[VisitNode[S, YieldExpression_]] = js.undefined
  }
  object Visitor {
    
    inline def apply[S](): Visitor[S] = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[Visitor[S]]
    }
    
    @scala.inline
    implicit open class MutableBuilder[Self <: Visitor[?], S] (val x: Self & Visitor[S]) extends AnyVal {
      
      inline def setAnyTypeAnnotation(value: VisitNode[S, AnyTypeAnnotation_]): Self = StObject.set(x, "AnyTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setAnyTypeAnnotationUndefined: Self = StObject.set(x, "AnyTypeAnnotation", js.undefined)
      
      inline def setArrayExpression(value: VisitNode[S, ArrayExpression_]): Self = StObject.set(x, "ArrayExpression", value.asInstanceOf[js.Any])
      
      inline def setArrayExpressionUndefined: Self = StObject.set(x, "ArrayExpression", js.undefined)
      
      inline def setArrayPattern(value: VisitNode[S, ArrayPattern_]): Self = StObject.set(x, "ArrayPattern", value.asInstanceOf[js.Any])
      
      inline def setArrayPatternUndefined: Self = StObject.set(x, "ArrayPattern", js.undefined)
      
      inline def setArrayTypeAnnotation(value: VisitNode[S, ArrayTypeAnnotation_]): Self = StObject.set(x, "ArrayTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setArrayTypeAnnotationUndefined: Self = StObject.set(x, "ArrayTypeAnnotation", js.undefined)
      
      inline def setArrowFunctionExpression(value: VisitNode[S, ArrowFunctionExpression_]): Self = StObject.set(x, "ArrowFunctionExpression", value.asInstanceOf[js.Any])
      
      inline def setArrowFunctionExpressionUndefined: Self = StObject.set(x, "ArrowFunctionExpression", js.undefined)
      
      inline def setAssignmentExpression(value: VisitNode[S, AssignmentExpression_]): Self = StObject.set(x, "AssignmentExpression", value.asInstanceOf[js.Any])
      
      inline def setAssignmentExpressionUndefined: Self = StObject.set(x, "AssignmentExpression", js.undefined)
      
      inline def setAssignmentPattern(value: VisitNode[S, AssignmentPattern_]): Self = StObject.set(x, "AssignmentPattern", value.asInstanceOf[js.Any])
      
      inline def setAssignmentPatternUndefined: Self = StObject.set(x, "AssignmentPattern", js.undefined)
      
      inline def setAwaitExpression(value: VisitNode[S, AwaitExpression_]): Self = StObject.set(x, "AwaitExpression", value.asInstanceOf[js.Any])
      
      inline def setAwaitExpressionUndefined: Self = StObject.set(x, "AwaitExpression", js.undefined)
      
      inline def setBinary(value: VisitNode[S, Binary]): Self = StObject.set(x, "Binary", value.asInstanceOf[js.Any])
      
      inline def setBinaryExpression(value: VisitNode[S, BinaryExpression_]): Self = StObject.set(x, "BinaryExpression", value.asInstanceOf[js.Any])
      
      inline def setBinaryExpressionUndefined: Self = StObject.set(x, "BinaryExpression", js.undefined)
      
      inline def setBinaryUndefined: Self = StObject.set(x, "Binary", js.undefined)
      
      inline def setBindExpression(value: VisitNode[S, BindExpression_]): Self = StObject.set(x, "BindExpression", value.asInstanceOf[js.Any])
      
      inline def setBindExpressionUndefined: Self = StObject.set(x, "BindExpression", js.undefined)
      
      inline def setBlock(value: VisitNode[S, Block]): Self = StObject.set(x, "Block", value.asInstanceOf[js.Any])
      
      inline def setBlockParent(value: VisitNode[S, BlockParent]): Self = StObject.set(x, "BlockParent", value.asInstanceOf[js.Any])
      
      inline def setBlockParentUndefined: Self = StObject.set(x, "BlockParent", js.undefined)
      
      inline def setBlockStatement(value: VisitNode[S, BlockStatement_]): Self = StObject.set(x, "BlockStatement", value.asInstanceOf[js.Any])
      
      inline def setBlockStatementUndefined: Self = StObject.set(x, "BlockStatement", js.undefined)
      
      inline def setBlockUndefined: Self = StObject.set(x, "Block", js.undefined)
      
      inline def setBooleanLiteral(value: VisitNode[S, BooleanLiteral_]): Self = StObject.set(x, "BooleanLiteral", value.asInstanceOf[js.Any])
      
      inline def setBooleanLiteralTypeAnnotation(value: VisitNode[S, BooleanLiteralTypeAnnotation_]): Self = StObject.set(x, "BooleanLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setBooleanLiteralTypeAnnotationUndefined: Self = StObject.set(x, "BooleanLiteralTypeAnnotation", js.undefined)
      
      inline def setBooleanLiteralUndefined: Self = StObject.set(x, "BooleanLiteral", js.undefined)
      
      inline def setBooleanTypeAnnotation(value: VisitNode[S, BooleanTypeAnnotation_]): Self = StObject.set(x, "BooleanTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setBooleanTypeAnnotationUndefined: Self = StObject.set(x, "BooleanTypeAnnotation", js.undefined)
      
      inline def setBreakStatement(value: VisitNode[S, BreakStatement_]): Self = StObject.set(x, "BreakStatement", value.asInstanceOf[js.Any])
      
      inline def setBreakStatementUndefined: Self = StObject.set(x, "BreakStatement", js.undefined)
      
      inline def setCallExpression(value: VisitNode[S, CallExpression_]): Self = StObject.set(x, "CallExpression", value.asInstanceOf[js.Any])
      
      inline def setCallExpressionUndefined: Self = StObject.set(x, "CallExpression", js.undefined)
      
      inline def setCatchClause(value: VisitNode[S, CatchClause_]): Self = StObject.set(x, "CatchClause", value.asInstanceOf[js.Any])
      
      inline def setCatchClauseUndefined: Self = StObject.set(x, "CatchClause", js.undefined)
      
      inline def setClass(value: VisitNode[S, Class]): Self = StObject.set(x, "Class", value.asInstanceOf[js.Any])
      
      inline def setClassBody(value: VisitNode[S, ClassBody_]): Self = StObject.set(x, "ClassBody", value.asInstanceOf[js.Any])
      
      inline def setClassBodyUndefined: Self = StObject.set(x, "ClassBody", js.undefined)
      
      inline def setClassDeclaration(value: VisitNode[S, ClassDeclaration_]): Self = StObject.set(x, "ClassDeclaration", value.asInstanceOf[js.Any])
      
      inline def setClassDeclarationUndefined: Self = StObject.set(x, "ClassDeclaration", js.undefined)
      
      inline def setClassExpression(value: VisitNode[S, ClassExpression_]): Self = StObject.set(x, "ClassExpression", value.asInstanceOf[js.Any])
      
      inline def setClassExpressionUndefined: Self = StObject.set(x, "ClassExpression", js.undefined)
      
      inline def setClassImplements(value: VisitNode[S, ClassImplements_]): Self = StObject.set(x, "ClassImplements", value.asInstanceOf[js.Any])
      
      inline def setClassImplementsUndefined: Self = StObject.set(x, "ClassImplements", js.undefined)
      
      inline def setClassMethod(value: VisitNode[S, ClassMethod_]): Self = StObject.set(x, "ClassMethod", value.asInstanceOf[js.Any])
      
      inline def setClassMethodUndefined: Self = StObject.set(x, "ClassMethod", js.undefined)
      
      inline def setClassProperty(value: VisitNode[S, ClassProperty_]): Self = StObject.set(x, "ClassProperty", value.asInstanceOf[js.Any])
      
      inline def setClassPropertyUndefined: Self = StObject.set(x, "ClassProperty", js.undefined)
      
      inline def setClassUndefined: Self = StObject.set(x, "Class", js.undefined)
      
      inline def setCompletionStatement(value: VisitNode[S, CompletionStatement]): Self = StObject.set(x, "CompletionStatement", value.asInstanceOf[js.Any])
      
      inline def setCompletionStatementUndefined: Self = StObject.set(x, "CompletionStatement", js.undefined)
      
      inline def setConditional(value: VisitNode[S, Conditional]): Self = StObject.set(x, "Conditional", value.asInstanceOf[js.Any])
      
      inline def setConditionalExpression(value: VisitNode[S, ConditionalExpression_]): Self = StObject.set(x, "ConditionalExpression", value.asInstanceOf[js.Any])
      
      inline def setConditionalExpressionUndefined: Self = StObject.set(x, "ConditionalExpression", js.undefined)
      
      inline def setConditionalUndefined: Self = StObject.set(x, "Conditional", js.undefined)
      
      inline def setContinueStatement(value: VisitNode[S, ContinueStatement_]): Self = StObject.set(x, "ContinueStatement", value.asInstanceOf[js.Any])
      
      inline def setContinueStatementUndefined: Self = StObject.set(x, "ContinueStatement", js.undefined)
      
      inline def setDebuggerStatement(value: VisitNode[S, DebuggerStatement_]): Self = StObject.set(x, "DebuggerStatement", value.asInstanceOf[js.Any])
      
      inline def setDebuggerStatementUndefined: Self = StObject.set(x, "DebuggerStatement", js.undefined)
      
      inline def setDeclaration(value: VisitNode[S, Declaration]): Self = StObject.set(x, "Declaration", value.asInstanceOf[js.Any])
      
      inline def setDeclarationUndefined: Self = StObject.set(x, "Declaration", js.undefined)
      
      inline def setDeclareClass(value: VisitNode[S, DeclareClass_]): Self = StObject.set(x, "DeclareClass", value.asInstanceOf[js.Any])
      
      inline def setDeclareClassUndefined: Self = StObject.set(x, "DeclareClass", js.undefined)
      
      inline def setDeclareFunction(value: VisitNode[S, DeclareFunction_]): Self = StObject.set(x, "DeclareFunction", value.asInstanceOf[js.Any])
      
      inline def setDeclareFunctionUndefined: Self = StObject.set(x, "DeclareFunction", js.undefined)
      
      inline def setDeclareInterface(value: VisitNode[S, DeclareInterface_]): Self = StObject.set(x, "DeclareInterface", value.asInstanceOf[js.Any])
      
      inline def setDeclareInterfaceUndefined: Self = StObject.set(x, "DeclareInterface", js.undefined)
      
      inline def setDeclareModule(value: VisitNode[S, DeclareModule_]): Self = StObject.set(x, "DeclareModule", value.asInstanceOf[js.Any])
      
      inline def setDeclareModuleUndefined: Self = StObject.set(x, "DeclareModule", js.undefined)
      
      inline def setDeclareTypeAlias(value: VisitNode[S, DeclareTypeAlias_]): Self = StObject.set(x, "DeclareTypeAlias", value.asInstanceOf[js.Any])
      
      inline def setDeclareTypeAliasUndefined: Self = StObject.set(x, "DeclareTypeAlias", js.undefined)
      
      inline def setDeclareVariable(value: VisitNode[S, DeclareVariable_]): Self = StObject.set(x, "DeclareVariable", value.asInstanceOf[js.Any])
      
      inline def setDeclareVariableUndefined: Self = StObject.set(x, "DeclareVariable", js.undefined)
      
      inline def setDecorator(value: VisitNode[S, Decorator_]): Self = StObject.set(x, "Decorator", value.asInstanceOf[js.Any])
      
      inline def setDecoratorUndefined: Self = StObject.set(x, "Decorator", js.undefined)
      
      inline def setDirective(value: VisitNode[S, Directive_]): Self = StObject.set(x, "Directive", value.asInstanceOf[js.Any])
      
      inline def setDirectiveLiteral(value: VisitNode[S, DirectiveLiteral_]): Self = StObject.set(x, "DirectiveLiteral", value.asInstanceOf[js.Any])
      
      inline def setDirectiveLiteralUndefined: Self = StObject.set(x, "DirectiveLiteral", js.undefined)
      
      inline def setDirectiveUndefined: Self = StObject.set(x, "Directive", js.undefined)
      
      inline def setDoExpression(value: VisitNode[S, DoExpression_]): Self = StObject.set(x, "DoExpression", value.asInstanceOf[js.Any])
      
      inline def setDoExpressionUndefined: Self = StObject.set(x, "DoExpression", js.undefined)
      
      inline def setDoWhileStatement(value: VisitNode[S, DoWhileStatement_]): Self = StObject.set(x, "DoWhileStatement", value.asInstanceOf[js.Any])
      
      inline def setDoWhileStatementUndefined: Self = StObject.set(x, "DoWhileStatement", js.undefined)
      
      inline def setEmptyStatement(value: VisitNode[S, EmptyStatement_]): Self = StObject.set(x, "EmptyStatement", value.asInstanceOf[js.Any])
      
      inline def setEmptyStatementUndefined: Self = StObject.set(x, "EmptyStatement", js.undefined)
      
      inline def setExistentialTypeParam(value: VisitNode[S, ExistentialTypeParam_]): Self = StObject.set(x, "ExistentialTypeParam", value.asInstanceOf[js.Any])
      
      inline def setExistentialTypeParamUndefined: Self = StObject.set(x, "ExistentialTypeParam", js.undefined)
      
      inline def setExportAllDeclaration(value: VisitNode[S, ExportAllDeclaration_]): Self = StObject.set(x, "ExportAllDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportAllDeclarationUndefined: Self = StObject.set(x, "ExportAllDeclaration", js.undefined)
      
      inline def setExportDeclaration(value: VisitNode[S, ExportDeclaration]): Self = StObject.set(x, "ExportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportDeclarationUndefined: Self = StObject.set(x, "ExportDeclaration", js.undefined)
      
      inline def setExportDefaultDeclaration(value: VisitNode[S, ExportDefaultDeclaration_]): Self = StObject.set(x, "ExportDefaultDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportDefaultDeclarationUndefined: Self = StObject.set(x, "ExportDefaultDeclaration", js.undefined)
      
      inline def setExportDefaultSpecifier(value: VisitNode[S, ExportDefaultSpecifier_]): Self = StObject.set(x, "ExportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportDefaultSpecifierUndefined: Self = StObject.set(x, "ExportDefaultSpecifier", js.undefined)
      
      inline def setExportNamedDeclaration(value: VisitNode[S, ExportNamedDeclaration_]): Self = StObject.set(x, "ExportNamedDeclaration", value.asInstanceOf[js.Any])
      
      inline def setExportNamedDeclarationUndefined: Self = StObject.set(x, "ExportNamedDeclaration", js.undefined)
      
      inline def setExportNamespaceSpecifier(value: VisitNode[S, ExportNamespaceSpecifier_]): Self = StObject.set(x, "ExportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportNamespaceSpecifierUndefined: Self = StObject.set(x, "ExportNamespaceSpecifier", js.undefined)
      
      inline def setExportSpecifier(value: VisitNode[S, ExportSpecifier_]): Self = StObject.set(x, "ExportSpecifier", value.asInstanceOf[js.Any])
      
      inline def setExportSpecifierUndefined: Self = StObject.set(x, "ExportSpecifier", js.undefined)
      
      inline def setExpression(value: VisitNode[S, Expression]): Self = StObject.set(x, "Expression", value.asInstanceOf[js.Any])
      
      inline def setExpressionStatement(value: VisitNode[S, ExpressionStatement_]): Self = StObject.set(x, "ExpressionStatement", value.asInstanceOf[js.Any])
      
      inline def setExpressionStatementUndefined: Self = StObject.set(x, "ExpressionStatement", js.undefined)
      
      inline def setExpressionUndefined: Self = StObject.set(x, "Expression", js.undefined)
      
      inline def setExpressionWrapper(value: VisitNode[S, ExpressionWrapper]): Self = StObject.set(x, "ExpressionWrapper", value.asInstanceOf[js.Any])
      
      inline def setExpressionWrapperUndefined: Self = StObject.set(x, "ExpressionWrapper", js.undefined)
      
      inline def setFile(value: VisitNode[S, File_]): Self = StObject.set(x, "File", value.asInstanceOf[js.Any])
      
      inline def setFileUndefined: Self = StObject.set(x, "File", js.undefined)
      
      inline def setFlow(value: VisitNode[S, Flow]): Self = StObject.set(x, "Flow", value.asInstanceOf[js.Any])
      
      inline def setFlowBaseAnnotation(value: VisitNode[S, FlowBaseAnnotation]): Self = StObject.set(x, "FlowBaseAnnotation", value.asInstanceOf[js.Any])
      
      inline def setFlowBaseAnnotationUndefined: Self = StObject.set(x, "FlowBaseAnnotation", js.undefined)
      
      inline def setFlowDeclaration(value: VisitNode[S, FlowDeclaration]): Self = StObject.set(x, "FlowDeclaration", value.asInstanceOf[js.Any])
      
      inline def setFlowDeclarationUndefined: Self = StObject.set(x, "FlowDeclaration", js.undefined)
      
      inline def setFlowUndefined: Self = StObject.set(x, "Flow", js.undefined)
      
      inline def setFor(value: VisitNode[S, For]): Self = StObject.set(x, "For", value.asInstanceOf[js.Any])
      
      inline def setForInStatement(value: VisitNode[S, ForInStatement_]): Self = StObject.set(x, "ForInStatement", value.asInstanceOf[js.Any])
      
      inline def setForInStatementUndefined: Self = StObject.set(x, "ForInStatement", js.undefined)
      
      inline def setForOfStatement(value: VisitNode[S, ForOfStatement_]): Self = StObject.set(x, "ForOfStatement", value.asInstanceOf[js.Any])
      
      inline def setForOfStatementUndefined: Self = StObject.set(x, "ForOfStatement", js.undefined)
      
      inline def setForStatement(value: VisitNode[S, ForStatement_]): Self = StObject.set(x, "ForStatement", value.asInstanceOf[js.Any])
      
      inline def setForStatementUndefined: Self = StObject.set(x, "ForStatement", js.undefined)
      
      inline def setForUndefined: Self = StObject.set(x, "For", js.undefined)
      
      inline def setForXStatement(value: VisitNode[S, ForXStatement]): Self = StObject.set(x, "ForXStatement", value.asInstanceOf[js.Any])
      
      inline def setForXStatementUndefined: Self = StObject.set(x, "ForXStatement", js.undefined)
      
      inline def setFunction(value: VisitNode[S, Function]): Self = StObject.set(x, "Function", value.asInstanceOf[js.Any])
      
      inline def setFunctionDeclaration(value: VisitNode[S, FunctionDeclaration_]): Self = StObject.set(x, "FunctionDeclaration", value.asInstanceOf[js.Any])
      
      inline def setFunctionDeclarationUndefined: Self = StObject.set(x, "FunctionDeclaration", js.undefined)
      
      inline def setFunctionExpression(value: VisitNode[S, FunctionExpression_]): Self = StObject.set(x, "FunctionExpression", value.asInstanceOf[js.Any])
      
      inline def setFunctionExpressionUndefined: Self = StObject.set(x, "FunctionExpression", js.undefined)
      
      inline def setFunctionParent(value: VisitNode[S, FunctionParent]): Self = StObject.set(x, "FunctionParent", value.asInstanceOf[js.Any])
      
      inline def setFunctionParentUndefined: Self = StObject.set(x, "FunctionParent", js.undefined)
      
      inline def setFunctionTypeAnnotation(value: VisitNode[S, FunctionTypeAnnotation_]): Self = StObject.set(x, "FunctionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setFunctionTypeAnnotationUndefined: Self = StObject.set(x, "FunctionTypeAnnotation", js.undefined)
      
      inline def setFunctionTypeParam(value: VisitNode[S, FunctionTypeParam_]): Self = StObject.set(x, "FunctionTypeParam", value.asInstanceOf[js.Any])
      
      inline def setFunctionTypeParamUndefined: Self = StObject.set(x, "FunctionTypeParam", js.undefined)
      
      inline def setFunctionUndefined: Self = StObject.set(x, "Function", js.undefined)
      
      inline def setGenericTypeAnnotation(value: VisitNode[S, GenericTypeAnnotation_]): Self = StObject.set(x, "GenericTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setGenericTypeAnnotationUndefined: Self = StObject.set(x, "GenericTypeAnnotation", js.undefined)
      
      inline def setIdentifier(value: VisitNode[S, Identifier_]): Self = StObject.set(x, "Identifier", value.asInstanceOf[js.Any])
      
      inline def setIdentifierUndefined: Self = StObject.set(x, "Identifier", js.undefined)
      
      inline def setIfStatement(value: VisitNode[S, IfStatement_]): Self = StObject.set(x, "IfStatement", value.asInstanceOf[js.Any])
      
      inline def setIfStatementUndefined: Self = StObject.set(x, "IfStatement", js.undefined)
      
      inline def setImmutable(value: VisitNode[S, Immutable]): Self = StObject.set(x, "Immutable", value.asInstanceOf[js.Any])
      
      inline def setImmutableUndefined: Self = StObject.set(x, "Immutable", js.undefined)
      
      inline def setImportDeclaration(value: VisitNode[S, ImportDeclaration_]): Self = StObject.set(x, "ImportDeclaration", value.asInstanceOf[js.Any])
      
      inline def setImportDeclarationUndefined: Self = StObject.set(x, "ImportDeclaration", js.undefined)
      
      inline def setImportDefaultSpecifier(value: VisitNode[S, ImportDefaultSpecifier_]): Self = StObject.set(x, "ImportDefaultSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportDefaultSpecifierUndefined: Self = StObject.set(x, "ImportDefaultSpecifier", js.undefined)
      
      inline def setImportNamespaceSpecifier(value: VisitNode[S, ImportNamespaceSpecifier_]): Self = StObject.set(x, "ImportNamespaceSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportNamespaceSpecifierUndefined: Self = StObject.set(x, "ImportNamespaceSpecifier", js.undefined)
      
      inline def setImportSpecifier(value: VisitNode[S, ImportSpecifier_]): Self = StObject.set(x, "ImportSpecifier", value.asInstanceOf[js.Any])
      
      inline def setImportSpecifierUndefined: Self = StObject.set(x, "ImportSpecifier", js.undefined)
      
      inline def setInterfaceDeclaration(value: VisitNode[S, InterfaceDeclaration_]): Self = StObject.set(x, "InterfaceDeclaration", value.asInstanceOf[js.Any])
      
      inline def setInterfaceDeclarationUndefined: Self = StObject.set(x, "InterfaceDeclaration", js.undefined)
      
      inline def setInterfaceExtends(value: VisitNode[S, InterfaceExtends_]): Self = StObject.set(x, "InterfaceExtends", value.asInstanceOf[js.Any])
      
      inline def setInterfaceExtendsUndefined: Self = StObject.set(x, "InterfaceExtends", js.undefined)
      
      inline def setIntersectionTypeAnnotation(value: VisitNode[S, IntersectionTypeAnnotation_]): Self = StObject.set(x, "IntersectionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setIntersectionTypeAnnotationUndefined: Self = StObject.set(x, "IntersectionTypeAnnotation", js.undefined)
      
      inline def setJSX(value: VisitNode[S, JSX]): Self = StObject.set(x, "JSX", value.asInstanceOf[js.Any])
      
      inline def setJSXAttribute(value: VisitNode[S, JSXAttribute_]): Self = StObject.set(x, "JSXAttribute", value.asInstanceOf[js.Any])
      
      inline def setJSXAttributeUndefined: Self = StObject.set(x, "JSXAttribute", js.undefined)
      
      inline def setJSXClosingElement(value: VisitNode[S, JSXClosingElement_]): Self = StObject.set(x, "JSXClosingElement", value.asInstanceOf[js.Any])
      
      inline def setJSXClosingElementUndefined: Self = StObject.set(x, "JSXClosingElement", js.undefined)
      
      inline def setJSXElement(value: VisitNode[S, JSXElement_]): Self = StObject.set(x, "JSXElement", value.asInstanceOf[js.Any])
      
      inline def setJSXElementUndefined: Self = StObject.set(x, "JSXElement", js.undefined)
      
      inline def setJSXEmptyExpression(value: VisitNode[S, JSXEmptyExpression_]): Self = StObject.set(x, "JSXEmptyExpression", value.asInstanceOf[js.Any])
      
      inline def setJSXEmptyExpressionUndefined: Self = StObject.set(x, "JSXEmptyExpression", js.undefined)
      
      inline def setJSXExpressionContainer(value: VisitNode[S, JSXExpressionContainer_]): Self = StObject.set(x, "JSXExpressionContainer", value.asInstanceOf[js.Any])
      
      inline def setJSXExpressionContainerUndefined: Self = StObject.set(x, "JSXExpressionContainer", js.undefined)
      
      inline def setJSXIdentifier(value: VisitNode[S, JSXIdentifier_]): Self = StObject.set(x, "JSXIdentifier", value.asInstanceOf[js.Any])
      
      inline def setJSXIdentifierUndefined: Self = StObject.set(x, "JSXIdentifier", js.undefined)
      
      inline def setJSXMemberExpression(value: VisitNode[S, JSXMemberExpression_]): Self = StObject.set(x, "JSXMemberExpression", value.asInstanceOf[js.Any])
      
      inline def setJSXMemberExpressionUndefined: Self = StObject.set(x, "JSXMemberExpression", js.undefined)
      
      inline def setJSXNamespacedName(value: VisitNode[S, JSXNamespacedName_]): Self = StObject.set(x, "JSXNamespacedName", value.asInstanceOf[js.Any])
      
      inline def setJSXNamespacedNameUndefined: Self = StObject.set(x, "JSXNamespacedName", js.undefined)
      
      inline def setJSXOpeningElement(value: VisitNode[S, JSXOpeningElement_]): Self = StObject.set(x, "JSXOpeningElement", value.asInstanceOf[js.Any])
      
      inline def setJSXOpeningElementUndefined: Self = StObject.set(x, "JSXOpeningElement", js.undefined)
      
      inline def setJSXSpreadAttribute(value: VisitNode[S, JSXSpreadAttribute_]): Self = StObject.set(x, "JSXSpreadAttribute", value.asInstanceOf[js.Any])
      
      inline def setJSXSpreadAttributeUndefined: Self = StObject.set(x, "JSXSpreadAttribute", js.undefined)
      
      inline def setJSXText(value: VisitNode[S, JSXText_]): Self = StObject.set(x, "JSXText", value.asInstanceOf[js.Any])
      
      inline def setJSXTextUndefined: Self = StObject.set(x, "JSXText", js.undefined)
      
      inline def setJSXUndefined: Self = StObject.set(x, "JSX", js.undefined)
      
      inline def setLVal(value: VisitNode[S, LVal]): Self = StObject.set(x, "LVal", value.asInstanceOf[js.Any])
      
      inline def setLValUndefined: Self = StObject.set(x, "LVal", js.undefined)
      
      inline def setLabeledStatement(value: VisitNode[S, LabeledStatement_]): Self = StObject.set(x, "LabeledStatement", value.asInstanceOf[js.Any])
      
      inline def setLabeledStatementUndefined: Self = StObject.set(x, "LabeledStatement", js.undefined)
      
      inline def setLiteral(value: VisitNode[S, Literal]): Self = StObject.set(x, "Literal", value.asInstanceOf[js.Any])
      
      inline def setLiteralUndefined: Self = StObject.set(x, "Literal", js.undefined)
      
      inline def setLogicalExpression(value: VisitNode[S, LogicalExpression_]): Self = StObject.set(x, "LogicalExpression", value.asInstanceOf[js.Any])
      
      inline def setLogicalExpressionUndefined: Self = StObject.set(x, "LogicalExpression", js.undefined)
      
      inline def setLoop(value: VisitNode[S, Loop]): Self = StObject.set(x, "Loop", value.asInstanceOf[js.Any])
      
      inline def setLoopUndefined: Self = StObject.set(x, "Loop", js.undefined)
      
      inline def setMemberExpression(value: VisitNode[S, MemberExpression_]): Self = StObject.set(x, "MemberExpression", value.asInstanceOf[js.Any])
      
      inline def setMemberExpressionUndefined: Self = StObject.set(x, "MemberExpression", js.undefined)
      
      inline def setMetaProperty(value: VisitNode[S, MetaProperty_]): Self = StObject.set(x, "MetaProperty", value.asInstanceOf[js.Any])
      
      inline def setMetaPropertyUndefined: Self = StObject.set(x, "MetaProperty", js.undefined)
      
      inline def setMethod(value: VisitNode[S, Method]): Self = StObject.set(x, "Method", value.asInstanceOf[js.Any])
      
      inline def setMethodUndefined: Self = StObject.set(x, "Method", js.undefined)
      
      inline def setMixedTypeAnnotation(value: VisitNode[S, MixedTypeAnnotation_]): Self = StObject.set(x, "MixedTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setMixedTypeAnnotationUndefined: Self = StObject.set(x, "MixedTypeAnnotation", js.undefined)
      
      inline def setModuleDeclaration(value: VisitNode[S, ModuleDeclaration]): Self = StObject.set(x, "ModuleDeclaration", value.asInstanceOf[js.Any])
      
      inline def setModuleDeclarationUndefined: Self = StObject.set(x, "ModuleDeclaration", js.undefined)
      
      inline def setModuleSpecifier(value: VisitNode[S, ModuleSpecifier]): Self = StObject.set(x, "ModuleSpecifier", value.asInstanceOf[js.Any])
      
      inline def setModuleSpecifierUndefined: Self = StObject.set(x, "ModuleSpecifier", js.undefined)
      
      inline def setNewExpression(value: VisitNode[S, NewExpression_]): Self = StObject.set(x, "NewExpression", value.asInstanceOf[js.Any])
      
      inline def setNewExpressionUndefined: Self = StObject.set(x, "NewExpression", js.undefined)
      
      inline def setNoop(value: VisitNode[S, Noop_]): Self = StObject.set(x, "Noop", value.asInstanceOf[js.Any])
      
      inline def setNoopUndefined: Self = StObject.set(x, "Noop", js.undefined)
      
      inline def setNullLiteral(value: VisitNode[S, NullLiteral_]): Self = StObject.set(x, "NullLiteral", value.asInstanceOf[js.Any])
      
      inline def setNullLiteralTypeAnnotation(value: VisitNode[S, NullLiteralTypeAnnotation_]): Self = StObject.set(x, "NullLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNullLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NullLiteralTypeAnnotation", js.undefined)
      
      inline def setNullLiteralUndefined: Self = StObject.set(x, "NullLiteral", js.undefined)
      
      inline def setNullableTypeAnnotation(value: VisitNode[S, NullableTypeAnnotation_]): Self = StObject.set(x, "NullableTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNullableTypeAnnotationUndefined: Self = StObject.set(x, "NullableTypeAnnotation", js.undefined)
      
      inline def setNumberTypeAnnotation(value: VisitNode[S, NumberTypeAnnotation_]): Self = StObject.set(x, "NumberTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNumberTypeAnnotationUndefined: Self = StObject.set(x, "NumberTypeAnnotation", js.undefined)
      
      inline def setNumericLiteral(value: VisitNode[S, NumericLiteral_]): Self = StObject.set(x, "NumericLiteral", value.asInstanceOf[js.Any])
      
      inline def setNumericLiteralTypeAnnotation(value: VisitNode[S, NumericLiteralTypeAnnotation_]): Self = StObject.set(x, "NumericLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setNumericLiteralTypeAnnotationUndefined: Self = StObject.set(x, "NumericLiteralTypeAnnotation", js.undefined)
      
      inline def setNumericLiteralUndefined: Self = StObject.set(x, "NumericLiteral", js.undefined)
      
      inline def setObjectExpression(value: VisitNode[S, ObjectExpression_]): Self = StObject.set(x, "ObjectExpression", value.asInstanceOf[js.Any])
      
      inline def setObjectExpressionUndefined: Self = StObject.set(x, "ObjectExpression", js.undefined)
      
      inline def setObjectMember(value: VisitNode[S, ObjectMember]): Self = StObject.set(x, "ObjectMember", value.asInstanceOf[js.Any])
      
      inline def setObjectMemberUndefined: Self = StObject.set(x, "ObjectMember", js.undefined)
      
      inline def setObjectMethod(value: VisitNode[S, ObjectMethod_]): Self = StObject.set(x, "ObjectMethod", value.asInstanceOf[js.Any])
      
      inline def setObjectMethodUndefined: Self = StObject.set(x, "ObjectMethod", js.undefined)
      
      inline def setObjectPattern(value: VisitNode[S, ObjectPattern_]): Self = StObject.set(x, "ObjectPattern", value.asInstanceOf[js.Any])
      
      inline def setObjectPatternUndefined: Self = StObject.set(x, "ObjectPattern", js.undefined)
      
      inline def setObjectProperty(value: VisitNode[S, ObjectProperty_]): Self = StObject.set(x, "ObjectProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectPropertyUndefined: Self = StObject.set(x, "ObjectProperty", js.undefined)
      
      inline def setObjectTypeAnnotation(value: VisitNode[S, ObjectTypeAnnotation_]): Self = StObject.set(x, "ObjectTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeAnnotationUndefined: Self = StObject.set(x, "ObjectTypeAnnotation", js.undefined)
      
      inline def setObjectTypeCallProperty(value: VisitNode[S, ObjectTypeCallProperty_]): Self = StObject.set(x, "ObjectTypeCallProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeCallPropertyUndefined: Self = StObject.set(x, "ObjectTypeCallProperty", js.undefined)
      
      inline def setObjectTypeIndexer(value: VisitNode[S, ObjectTypeIndexer_]): Self = StObject.set(x, "ObjectTypeIndexer", value.asInstanceOf[js.Any])
      
      inline def setObjectTypeIndexerUndefined: Self = StObject.set(x, "ObjectTypeIndexer", js.undefined)
      
      inline def setObjectTypeProperty(value: VisitNode[S, ObjectTypeProperty_]): Self = StObject.set(x, "ObjectTypeProperty", value.asInstanceOf[js.Any])
      
      inline def setObjectTypePropertyUndefined: Self = StObject.set(x, "ObjectTypeProperty", js.undefined)
      
      inline def setParenthesizedExpression(value: VisitNode[S, ParenthesizedExpression_]): Self = StObject.set(x, "ParenthesizedExpression", value.asInstanceOf[js.Any])
      
      inline def setParenthesizedExpressionUndefined: Self = StObject.set(x, "ParenthesizedExpression", js.undefined)
      
      inline def setPattern(value: VisitNode[S, Pattern]): Self = StObject.set(x, "Pattern", value.asInstanceOf[js.Any])
      
      inline def setPatternUndefined: Self = StObject.set(x, "Pattern", js.undefined)
      
      inline def setProgram(value: VisitNode[S, Program_]): Self = StObject.set(x, "Program", value.asInstanceOf[js.Any])
      
      inline def setProgramUndefined: Self = StObject.set(x, "Program", js.undefined)
      
      inline def setProperty(value: VisitNode[S, Property]): Self = StObject.set(x, "Property", value.asInstanceOf[js.Any])
      
      inline def setPropertyUndefined: Self = StObject.set(x, "Property", js.undefined)
      
      inline def setPureish(value: VisitNode[S, Pureish]): Self = StObject.set(x, "Pureish", value.asInstanceOf[js.Any])
      
      inline def setPureishUndefined: Self = StObject.set(x, "Pureish", js.undefined)
      
      inline def setQualifiedTypeIdentifier(value: VisitNode[S, QualifiedTypeIdentifier_]): Self = StObject.set(x, "QualifiedTypeIdentifier", value.asInstanceOf[js.Any])
      
      inline def setQualifiedTypeIdentifierUndefined: Self = StObject.set(x, "QualifiedTypeIdentifier", js.undefined)
      
      inline def setRegExpLiteral(value: VisitNode[S, RegExpLiteral_]): Self = StObject.set(x, "RegExpLiteral", value.asInstanceOf[js.Any])
      
      inline def setRegExpLiteralUndefined: Self = StObject.set(x, "RegExpLiteral", js.undefined)
      
      inline def setRestElement(value: VisitNode[S, RestElement_]): Self = StObject.set(x, "RestElement", value.asInstanceOf[js.Any])
      
      inline def setRestElementUndefined: Self = StObject.set(x, "RestElement", js.undefined)
      
      inline def setRestProperty(value: VisitNode[S, RestProperty_]): Self = StObject.set(x, "RestProperty", value.asInstanceOf[js.Any])
      
      inline def setRestPropertyUndefined: Self = StObject.set(x, "RestProperty", js.undefined)
      
      inline def setReturnStatement(value: VisitNode[S, ReturnStatement_]): Self = StObject.set(x, "ReturnStatement", value.asInstanceOf[js.Any])
      
      inline def setReturnStatementUndefined: Self = StObject.set(x, "ReturnStatement", js.undefined)
      
      inline def setScopable(value: VisitNode[S, Scopable]): Self = StObject.set(x, "Scopable", value.asInstanceOf[js.Any])
      
      inline def setScopableUndefined: Self = StObject.set(x, "Scopable", js.undefined)
      
      inline def setScope(value: VisitNode[S, Scopable]): Self = StObject.set(x, "Scope", value.asInstanceOf[js.Any])
      
      inline def setScopeUndefined: Self = StObject.set(x, "Scope", js.undefined)
      
      inline def setSequenceExpression(value: VisitNode[S, SequenceExpression_]): Self = StObject.set(x, "SequenceExpression", value.asInstanceOf[js.Any])
      
      inline def setSequenceExpressionUndefined: Self = StObject.set(x, "SequenceExpression", js.undefined)
      
      inline def setSpreadElement(value: VisitNode[S, SpreadElement_]): Self = StObject.set(x, "SpreadElement", value.asInstanceOf[js.Any])
      
      inline def setSpreadElementUndefined: Self = StObject.set(x, "SpreadElement", js.undefined)
      
      inline def setSpreadProperty(value: VisitNode[S, SpreadProperty_]): Self = StObject.set(x, "SpreadProperty", value.asInstanceOf[js.Any])
      
      inline def setSpreadPropertyUndefined: Self = StObject.set(x, "SpreadProperty", js.undefined)
      
      inline def setStatement(value: VisitNode[S, Statement]): Self = StObject.set(x, "Statement", value.asInstanceOf[js.Any])
      
      inline def setStatementUndefined: Self = StObject.set(x, "Statement", js.undefined)
      
      inline def setStringLiteral(value: VisitNode[S, StringLiteral_]): Self = StObject.set(x, "StringLiteral", value.asInstanceOf[js.Any])
      
      inline def setStringLiteralTypeAnnotation(value: VisitNode[S, StringLiteralTypeAnnotation_]): Self = StObject.set(x, "StringLiteralTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setStringLiteralTypeAnnotationUndefined: Self = StObject.set(x, "StringLiteralTypeAnnotation", js.undefined)
      
      inline def setStringLiteralUndefined: Self = StObject.set(x, "StringLiteral", js.undefined)
      
      inline def setStringTypeAnnotation(value: VisitNode[S, StringTypeAnnotation_]): Self = StObject.set(x, "StringTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setStringTypeAnnotationUndefined: Self = StObject.set(x, "StringTypeAnnotation", js.undefined)
      
      inline def setSuper(value: VisitNode[S, Super]): Self = StObject.set(x, "Super", value.asInstanceOf[js.Any])
      
      inline def setSuperUndefined: Self = StObject.set(x, "Super", js.undefined)
      
      inline def setSwitchCase(value: VisitNode[S, SwitchCase_]): Self = StObject.set(x, "SwitchCase", value.asInstanceOf[js.Any])
      
      inline def setSwitchCaseUndefined: Self = StObject.set(x, "SwitchCase", js.undefined)
      
      inline def setSwitchStatement(value: VisitNode[S, SwitchStatement_]): Self = StObject.set(x, "SwitchStatement", value.asInstanceOf[js.Any])
      
      inline def setSwitchStatementUndefined: Self = StObject.set(x, "SwitchStatement", js.undefined)
      
      inline def setTaggedTemplateExpression(value: VisitNode[S, TaggedTemplateExpression_]): Self = StObject.set(x, "TaggedTemplateExpression", value.asInstanceOf[js.Any])
      
      inline def setTaggedTemplateExpressionUndefined: Self = StObject.set(x, "TaggedTemplateExpression", js.undefined)
      
      inline def setTemplateElement(value: VisitNode[S, TemplateElement_]): Self = StObject.set(x, "TemplateElement", value.asInstanceOf[js.Any])
      
      inline def setTemplateElementUndefined: Self = StObject.set(x, "TemplateElement", js.undefined)
      
      inline def setTemplateLiteral(value: VisitNode[S, TemplateLiteral_]): Self = StObject.set(x, "TemplateLiteral", value.asInstanceOf[js.Any])
      
      inline def setTemplateLiteralUndefined: Self = StObject.set(x, "TemplateLiteral", js.undefined)
      
      inline def setTerminatorless(value: VisitNode[S, Terminatorless]): Self = StObject.set(x, "Terminatorless", value.asInstanceOf[js.Any])
      
      inline def setTerminatorlessUndefined: Self = StObject.set(x, "Terminatorless", js.undefined)
      
      inline def setThisExpression(value: VisitNode[S, ThisExpression_]): Self = StObject.set(x, "ThisExpression", value.asInstanceOf[js.Any])
      
      inline def setThisExpressionUndefined: Self = StObject.set(x, "ThisExpression", js.undefined)
      
      inline def setThisTypeAnnotation(value: VisitNode[S, ThisTypeAnnotation_]): Self = StObject.set(x, "ThisTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setThisTypeAnnotationUndefined: Self = StObject.set(x, "ThisTypeAnnotation", js.undefined)
      
      inline def setThrowStatement(value: VisitNode[S, ThrowStatement_]): Self = StObject.set(x, "ThrowStatement", value.asInstanceOf[js.Any])
      
      inline def setThrowStatementUndefined: Self = StObject.set(x, "ThrowStatement", js.undefined)
      
      inline def setTryStatement(value: VisitNode[S, TryStatement_]): Self = StObject.set(x, "TryStatement", value.asInstanceOf[js.Any])
      
      inline def setTryStatementUndefined: Self = StObject.set(x, "TryStatement", js.undefined)
      
      inline def setTupleTypeAnnotation(value: VisitNode[S, TupleTypeAnnotation_]): Self = StObject.set(x, "TupleTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTupleTypeAnnotationUndefined: Self = StObject.set(x, "TupleTypeAnnotation", js.undefined)
      
      inline def setTypeAlias(value: VisitNode[S, TypeAlias_]): Self = StObject.set(x, "TypeAlias", value.asInstanceOf[js.Any])
      
      inline def setTypeAliasUndefined: Self = StObject.set(x, "TypeAlias", js.undefined)
      
      inline def setTypeAnnotation(value: VisitNode[S, TypeAnnotation_]): Self = StObject.set(x, "TypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTypeAnnotationUndefined: Self = StObject.set(x, "TypeAnnotation", js.undefined)
      
      inline def setTypeCastExpression(value: VisitNode[S, TypeCastExpression_]): Self = StObject.set(x, "TypeCastExpression", value.asInstanceOf[js.Any])
      
      inline def setTypeCastExpressionUndefined: Self = StObject.set(x, "TypeCastExpression", js.undefined)
      
      inline def setTypeParameterDeclaration(value: VisitNode[S, TypeParameterDeclaration_]): Self = StObject.set(x, "TypeParameterDeclaration", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterDeclarationUndefined: Self = StObject.set(x, "TypeParameterDeclaration", js.undefined)
      
      inline def setTypeParameterInstantiation(value: VisitNode[S, TypeParameterInstantiation_]): Self = StObject.set(x, "TypeParameterInstantiation", value.asInstanceOf[js.Any])
      
      inline def setTypeParameterInstantiationUndefined: Self = StObject.set(x, "TypeParameterInstantiation", js.undefined)
      
      inline def setTypeofTypeAnnotation(value: VisitNode[S, TypeofTypeAnnotation_]): Self = StObject.set(x, "TypeofTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setTypeofTypeAnnotationUndefined: Self = StObject.set(x, "TypeofTypeAnnotation", js.undefined)
      
      inline def setUnaryExpression(value: VisitNode[S, UnaryExpression_]): Self = StObject.set(x, "UnaryExpression", value.asInstanceOf[js.Any])
      
      inline def setUnaryExpressionUndefined: Self = StObject.set(x, "UnaryExpression", js.undefined)
      
      inline def setUnaryLike(value: VisitNode[S, UnaryLike]): Self = StObject.set(x, "UnaryLike", value.asInstanceOf[js.Any])
      
      inline def setUnaryLikeUndefined: Self = StObject.set(x, "UnaryLike", js.undefined)
      
      inline def setUnionTypeAnnotation(value: VisitNode[S, UnionTypeAnnotation_]): Self = StObject.set(x, "UnionTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setUnionTypeAnnotationUndefined: Self = StObject.set(x, "UnionTypeAnnotation", js.undefined)
      
      inline def setUpdateExpression(value: VisitNode[S, UpdateExpression_]): Self = StObject.set(x, "UpdateExpression", value.asInstanceOf[js.Any])
      
      inline def setUpdateExpressionUndefined: Self = StObject.set(x, "UpdateExpression", js.undefined)
      
      inline def setUserWhitespacable(value: VisitNode[S, UserWhitespacable]): Self = StObject.set(x, "UserWhitespacable", value.asInstanceOf[js.Any])
      
      inline def setUserWhitespacableUndefined: Self = StObject.set(x, "UserWhitespacable", js.undefined)
      
      inline def setVariableDeclaration(value: VisitNode[S, VariableDeclaration_]): Self = StObject.set(x, "VariableDeclaration", value.asInstanceOf[js.Any])
      
      inline def setVariableDeclarationUndefined: Self = StObject.set(x, "VariableDeclaration", js.undefined)
      
      inline def setVariableDeclarator(value: VisitNode[S, VariableDeclarator_]): Self = StObject.set(x, "VariableDeclarator", value.asInstanceOf[js.Any])
      
      inline def setVariableDeclaratorUndefined: Self = StObject.set(x, "VariableDeclarator", js.undefined)
      
      inline def setVoidTypeAnnotation(value: VisitNode[S, VoidTypeAnnotation_]): Self = StObject.set(x, "VoidTypeAnnotation", value.asInstanceOf[js.Any])
      
      inline def setVoidTypeAnnotationUndefined: Self = StObject.set(x, "VoidTypeAnnotation", js.undefined)
      
      inline def setWhile(value: VisitNode[S, While]): Self = StObject.set(x, "While", value.asInstanceOf[js.Any])
      
      inline def setWhileStatement(value: VisitNode[S, WhileStatement_]): Self = StObject.set(x, "WhileStatement", value.asInstanceOf[js.Any])
      
      inline def setWhileStatementUndefined: Self = StObject.set(x, "WhileStatement", js.undefined)
      
      inline def setWhileUndefined: Self = StObject.set(x, "While", js.undefined)
      
      inline def setWithStatement(value: VisitNode[S, WithStatement_]): Self = StObject.set(x, "WithStatement", value.asInstanceOf[js.Any])
      
      inline def setWithStatementUndefined: Self = StObject.set(x, "WithStatement", js.undefined)
      
      inline def setYieldExpression(value: VisitNode[S, YieldExpression_]): Self = StObject.set(x, "YieldExpression", value.asInstanceOf[js.Any])
      
      inline def setYieldExpressionUndefined: Self = StObject.set(x, "YieldExpression", js.undefined)
    }
  }
}
