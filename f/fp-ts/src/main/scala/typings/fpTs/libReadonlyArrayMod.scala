package typings.fpTs

import typings.fpTs.anon.Fn20
import typings.fpTs.anon.FnCallXsYs
import typings.fpTs.fpTsStrings.ReadonlyArray
import typings.fpTs.libAltMod.Alt1
import typings.fpTs.libAlternativeMod.Alternative1
import typings.fpTs.libApplicativeMod.Applicative1
import typings.fpTs.libApplyMod.Apply1
import typings.fpTs.libChainMod.Chain1
import typings.fpTs.libChainRecMod.ChainRec1
import typings.fpTs.libCompactableMod.Compactable1
import typings.fpTs.libEitherMod.Either_
import typings.fpTs.libEqMod.Eq
import typings.fpTs.libExtendMod.Extend1
import typings.fpTs.libFilterableMod.Filterable1
import typings.fpTs.libFilterableWithIndexMod.FilterableWithIndex1
import typings.fpTs.libFilterableWithIndexMod.PredicateWithIndex
import typings.fpTs.libFilterableWithIndexMod.RefinementWithIndex
import typings.fpTs.libFoldableMod.Foldable1
import typings.fpTs.libFoldableWithIndexMod.FoldableWithIndex1
import typings.fpTs.libFromEitherMod.FromEither1
import typings.fpTs.libFunctionMod.Lazy
import typings.fpTs.libFunctorMod.Functor1
import typings.fpTs.libFunctorWithIndexMod.FunctorWithIndex1
import typings.fpTs.libMagmaMod.Magma
import typings.fpTs.libMonadMod.Monad1
import typings.fpTs.libMonoidMod.Monoid
import typings.fpTs.libOptionMod.Option_
import typings.fpTs.libOrdMod.Ord_
import typings.fpTs.libPointedMod.Pointed1
import typings.fpTs.libPredicateMod.Predicate
import typings.fpTs.libReadonlyNonEmptyArrayMod.ReadonlyNonEmptyArray_
import typings.fpTs.libRefinementMod.Refinement
import typings.fpTs.libSemigroupMod.Semigroup
import typings.fpTs.libSeparatedMod.Separated_
import typings.fpTs.libShowMod.Show
import typings.fpTs.libTraversableMod.PipeableTraverse1
import typings.fpTs.libTraversableMod.Sequence1
import typings.fpTs.libTraversableMod.Traversable1
import typings.fpTs.libTraversableWithIndexMod.PipeableTraverseWithIndex1
import typings.fpTs.libTraversableWithIndexMod.TraversableWithIndex1
import typings.fpTs.libUnfoldableMod.Unfoldable1
import typings.fpTs.libWitherableMod.FilterE1
import typings.fpTs.libWitherableMod.PipeableWilt1
import typings.fpTs.libWitherableMod.PipeableWither1
import typings.fpTs.libWitherableMod.Witherable1
import typings.fpTs.libZeroMod.Zero1
import typings.std.Exclude
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object libReadonlyArrayMod {
  
  @JSImport("fp-ts/lib/ReadonlyArray", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Alt")
  @js.native
  val Alt_ : Alt1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Alternative")
  @js.native
  val Alternative: Alternative1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Applicative")
  @js.native
  val Applicative: Applicative1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Apply")
  @js.native
  val Apply: Apply1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "ChainRecBreadthFirst")
  @js.native
  val ChainRecBreadthFirst_ : ChainRec1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "ChainRecDepthFirst")
  @js.native
  val ChainRecDepthFirst_ : ChainRec1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Chain")
  @js.native
  val Chain_ : Chain1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Compactable")
  @js.native
  val Compactable: Compactable1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Do")
  @js.native
  val Do: js.Array[js.Object] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Extend")
  @js.native
  val Extend_ : Extend1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Filterable")
  @js.native
  val Filterable: Filterable1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "FilterableWithIndex")
  @js.native
  val FilterableWithIndex: FilterableWithIndex1[typings.fpTs.libReadonlyArrayMod.URI, Double] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Foldable")
  @js.native
  val Foldable: Foldable1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "FoldableWithIndex")
  @js.native
  val FoldableWithIndex: FoldableWithIndex1[typings.fpTs.libReadonlyArrayMod.URI, Double] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "FromEither")
  @js.native
  val FromEither_ : FromEither1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Functor")
  @js.native
  val Functor: Functor1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "FunctorWithIndex")
  @js.native
  val FunctorWithIndex: FunctorWithIndex1[typings.fpTs.libReadonlyArrayMod.URI, Double] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Monad")
  @js.native
  val Monad: Monad1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Pointed")
  @js.native
  val Pointed: Pointed1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Traversable")
  @js.native
  val Traversable: Traversable1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "TraversableWithIndex")
  @js.native
  val TraversableWithIndex: TraversableWithIndex1[typings.fpTs.libReadonlyArrayMod.URI, Double] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "URI")
  @js.native
  val URI: /* "ReadonlyArray" */ String = js.native
  type URI = /* "ReadonlyArray" */ String
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Unfoldable")
  @js.native
  val Unfoldable: Unfoldable1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Witherable")
  @js.native
  val Witherable: Witherable1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "Zero")
  @js.native
  val Zero_ : Zero1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  inline def alt[A](that: Lazy[js.Array[A]]): js.Function1[/* fa */ js.Array[A], js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("alt")(that.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* fa */ js.Array[A], js.Array[A]]]
  
  inline def altW[B](that: Lazy[js.Array[B]]): js.Function1[/* fa */ js.Array[Any], js.Array[B | Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("altW")(that.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* fa */ js.Array[Any], js.Array[B | Any]]]
  
  inline def ap[A](fa: js.Array[A]): js.Function1[/* fab */ js.Array[js.Function1[/* a */ A, Any]], js.Array[Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("ap")(fa.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* fab */ js.Array[js.Function1[/* a */ A, Any]], js.Array[Any]]]
  
  inline def apFirst[B](second: js.Array[B]): js.Function1[/* first */ js.Array[Any], js.Array[Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("apFirst")(second.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* first */ js.Array[Any], js.Array[Any]]]
  
  inline def apS[N /* <: String */, A, B](name: Exclude[N, /* keyof A */ String], fb: js.Array[B]): js.Function1[
    /* fa */ js.Array[A], 
    js.Array[
      /* import warning: importer.ImportType#apply Failed type conversion: {readonly [ K in N | keyof A ]: K extends keyof A? A[K] : B} */ js.Any
    ]
  ] = (^.asInstanceOf[js.Dynamic].applyDynamic("apS")(name.asInstanceOf[js.Any], fb.asInstanceOf[js.Any])).asInstanceOf[js.Function1[
    /* fa */ js.Array[A], 
    js.Array[
      /* import warning: importer.ImportType#apply Failed type conversion: {readonly [ K in N | keyof A ]: K extends keyof A? A[K] : B} */ js.Any
    ]
  ]]
  
  inline def apSecond[B](second: js.Array[B]): js.Function1[/* first */ js.Array[Any], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("apSecond")(second.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* first */ js.Array[Any], js.Array[B]]]
  
  inline def append[A](end: A): js.Function1[/* init */ js.Array[A], ReadonlyNonEmptyArray_[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("append")(end.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* init */ js.Array[A], ReadonlyNonEmptyArray_[A]]]
  
  inline def appendW[B](end: B): js.Function1[/* init */ js.Array[Any], ReadonlyNonEmptyArray_[B | Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("appendW")(end.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* init */ js.Array[Any], ReadonlyNonEmptyArray_[B | Any]]]
  
  inline def bind[N /* <: String */, A, B](name: Exclude[N, /* keyof A */ String], f: js.Function1[/* a */ A, js.Array[B]]): js.Function1[
    /* ma */ js.Array[A], 
    js.Array[
      /* import warning: importer.ImportType#apply Failed type conversion: {readonly [ K in N | keyof A ]: K extends keyof A? A[K] : B} */ js.Any
    ]
  ] = (^.asInstanceOf[js.Dynamic].applyDynamic("bind")(name.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Function1[
    /* ma */ js.Array[A], 
    js.Array[
      /* import warning: importer.ImportType#apply Failed type conversion: {readonly [ K in N | keyof A ]: K extends keyof A? A[K] : B} */ js.Any
    ]
  ]]
  
  inline def bindTo[N /* <: String */](name: N): js.Function1[
    /* fa */ js.Array[Any], 
    js.Array[
      /* import warning: importer.ImportType#apply Failed type conversion: {readonly [ K in N ]: any} */ js.Any
    ]
  ] = ^.asInstanceOf[js.Dynamic].applyDynamic("bindTo")(name.asInstanceOf[js.Any]).asInstanceOf[js.Function1[
    /* fa */ js.Array[Any], 
    js.Array[
      /* import warning: importer.ImportType#apply Failed type conversion: {readonly [ K in N ]: any} */ js.Any
    ]
  ]]
  
  inline def chain[A, B](f: js.Function1[/* a */ A, js.Array[B]]): js.Function1[/* ma */ js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("chain")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* ma */ js.Array[A], js.Array[B]]]
  
  inline def chainFirst[A, B](f: js.Function1[/* a */ A, js.Array[B]]): js.Function1[/* first */ js.Array[A], js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("chainFirst")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* first */ js.Array[A], js.Array[A]]]
  
  inline def chainRecBreadthFirst[A, B](f: js.Function1[/* a */ A, js.Array[Either_[A, B]]]): js.Function1[/* a */ A, js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("chainRecBreadthFirst")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* a */ A, js.Array[B]]]
  
  inline def chainRecDepthFirst[A, B](f: js.Function1[/* a */ A, js.Array[Either_[A, B]]]): js.Function1[/* a */ A, js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("chainRecDepthFirst")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* a */ A, js.Array[B]]]
  
  inline def chainWithIndex[A, B](f: js.Function2[/* i */ Double, /* a */ A, js.Array[B]]): js.Function1[/* as */ js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("chainWithIndex")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], js.Array[B]]]
  
  inline def chop[A, B](f: js.Function1[/* as */ ReadonlyNonEmptyArray_[A], js.Tuple2[B, js.Array[A]]]): js.Function1[/* as */ js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("chop")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], js.Array[B]]]
  
  inline def chunksOf(n: Double): js.Function1[/* as */ js.Array[Any], js.Array[ReadonlyNonEmptyArray_[Any]]] = ^.asInstanceOf[js.Dynamic].applyDynamic("chunksOf")(n.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[Any], js.Array[ReadonlyNonEmptyArray_[Any]]]]
  
  inline def compact[A](fa: js.Array[Option_[A]]): js.Array[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("compact")(fa.asInstanceOf[js.Any]).asInstanceOf[js.Array[A]]
  
  inline def comprehension[A, R](input: js.Array[js.Array[A]], f: js.Function1[/* a */ A, R]): js.Array[R] = (^.asInstanceOf[js.Dynamic].applyDynamic("comprehension")(input.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Array[R]]
  inline def comprehension[A, R](input: js.Array[js.Array[A]], f: js.Function1[/* a */ A, R], g: js.Function1[/* a */ A, Boolean]): js.Array[R] = (^.asInstanceOf[js.Dynamic].applyDynamic("comprehension")(input.asInstanceOf[js.Any], f.asInstanceOf[js.Any], g.asInstanceOf[js.Any])).asInstanceOf[js.Array[R]]
  inline def comprehension[A, B, R](input: js.Tuple2[js.Array[A], js.Array[B]], f: js.Function2[/* a */ A, /* b */ B, R]): js.Array[R] = (^.asInstanceOf[js.Dynamic].applyDynamic("comprehension")(input.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Array[R]]
  inline def comprehension[A, B, R](
    input: js.Tuple2[js.Array[A], js.Array[B]],
    f: js.Function2[/* a */ A, /* b */ B, R],
    g: js.Function2[/* a */ A, /* b */ B, Boolean]
  ): js.Array[R] = (^.asInstanceOf[js.Dynamic].applyDynamic("comprehension")(input.asInstanceOf[js.Any], f.asInstanceOf[js.Any], g.asInstanceOf[js.Any])).asInstanceOf[js.Array[R]]
  inline def comprehension[A, B, C, R](
    input: js.Tuple3[js.Array[A], js.Array[B], js.Array[C]],
    f: js.Function3[/* a */ A, /* b */ B, /* c */ C, R]
  ): js.Array[R] = (^.asInstanceOf[js.Dynamic].applyDynamic("comprehension")(input.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Array[R]]
  inline def comprehension[A, B, C, R](
    input: js.Tuple3[js.Array[A], js.Array[B], js.Array[C]],
    f: js.Function3[/* a */ A, /* b */ B, /* c */ C, R],
    g: js.Function3[/* a */ A, /* b */ B, /* c */ C, Boolean]
  ): js.Array[R] = (^.asInstanceOf[js.Dynamic].applyDynamic("comprehension")(input.asInstanceOf[js.Any], f.asInstanceOf[js.Any], g.asInstanceOf[js.Any])).asInstanceOf[js.Array[R]]
  inline def comprehension[A, B, C, D, R](
    input: js.Tuple4[js.Array[A], js.Array[B], js.Array[C], js.Array[D]],
    f: js.Function4[/* a */ A, /* b */ B, /* c */ C, /* d */ D, R]
  ): js.Array[R] = (^.asInstanceOf[js.Dynamic].applyDynamic("comprehension")(input.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Array[R]]
  inline def comprehension[A, B, C, D, R](
    input: js.Tuple4[js.Array[A], js.Array[B], js.Array[C], js.Array[D]],
    f: js.Function4[/* a */ A, /* b */ B, /* c */ C, /* d */ D, R],
    g: js.Function4[/* a */ A, /* b */ B, /* c */ C, /* d */ D, Boolean]
  ): js.Array[R] = (^.asInstanceOf[js.Dynamic].applyDynamic("comprehension")(input.asInstanceOf[js.Any], f.asInstanceOf[js.Any], g.asInstanceOf[js.Any])).asInstanceOf[js.Array[R]]
  
  inline def concat[A](second: js.Array[A]): js.Function1[/* first */ js.Array[A], js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("concat")(second.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* first */ js.Array[A], js.Array[A]]]
  
  inline def concatW[B](second: js.Array[B]): js.Function1[/* first */ js.Array[Any], js.Array[B | Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("concatW")(second.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* first */ js.Array[Any], js.Array[B | Any]]]
  
  inline def cons[A](head: A): js.Function1[/* tail */ js.Array[A], ReadonlyNonEmptyArray_[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("cons")(head.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* tail */ js.Array[A], ReadonlyNonEmptyArray_[A]]]
  inline def cons[A](head: A, tail: js.Array[A]): ReadonlyNonEmptyArray_[A] = (^.asInstanceOf[js.Dynamic].applyDynamic("cons")(head.asInstanceOf[js.Any], tail.asInstanceOf[js.Any])).asInstanceOf[ReadonlyNonEmptyArray_[A]]
  
  inline def deleteAt(i: Double): js.Function1[/* as */ js.Array[Any], Option_[js.Array[Any]]] = ^.asInstanceOf[js.Dynamic].applyDynamic("deleteAt")(i.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[Any], Option_[js.Array[Any]]]]
  
  inline def difference[A](E: Eq[A]): FnCallXsYs[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("difference")(E.asInstanceOf[js.Any]).asInstanceOf[FnCallXsYs[A]]
  
  inline def dropLeft(n: Double): js.Function1[/* as */ js.Array[Any], js.Array[Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("dropLeft")(n.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[Any], js.Array[Any]]]
  
  inline def dropLeftWhile[A](predicate: Predicate[A]): js.Function1[/* bs */ js.Array[A], js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("dropLeftWhile")(predicate.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* bs */ js.Array[A], js.Array[A]]]
  
  inline def dropLeftWhile_AB[A, B /* <: A */](refinement: Refinement[A, B]): js.Function1[/* as */ js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("dropLeftWhile")(refinement.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], js.Array[B]]]
  
  inline def dropRight(n: Double): js.Function1[/* as */ js.Array[Any], js.Array[Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("dropRight")(n.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[Any], js.Array[Any]]]
  
  inline def duplicate[A](wa: js.Array[A]): js.Array[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("duplicate")(wa.asInstanceOf[js.Any]).asInstanceOf[js.Array[js.Array[A]]]
  
  inline def elem[A](E: Eq[A]): Fn20[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("elem")(E.asInstanceOf[js.Any]).asInstanceOf[Fn20[A]]
  
  @JSImport("fp-ts/lib/ReadonlyArray", "empty")
  @js.native
  val empty: js.Array[scala.Nothing] = js.native
  
  inline def every[A](predicate: Predicate[A]): Predicate[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("every")(predicate.asInstanceOf[js.Any]).asInstanceOf[Predicate[js.Array[A]]]
  
  inline def every_AB_Refinement[A, B /* <: A */](refinement: Refinement[A, B]): Refinement[js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("every")(refinement.asInstanceOf[js.Any]).asInstanceOf[Refinement[js.Array[A], js.Array[B]]]
  
  inline def exists[A](predicate: Predicate[A]): js.Function1[
    /* as */ js.Array[A], 
    /* is fp-ts.fp-ts/lib/ReadonlyNonEmptyArray.ReadonlyNonEmptyArray<A> */ Boolean
  ] = ^.asInstanceOf[js.Dynamic].applyDynamic("exists")(predicate.asInstanceOf[js.Any]).asInstanceOf[js.Function1[
    /* as */ js.Array[A], 
    /* is fp-ts.fp-ts/lib/ReadonlyNonEmptyArray.ReadonlyNonEmptyArray<A> */ Boolean
  ]]
  
  inline def extend[A, B](f: js.Function1[/* fa */ js.Array[A], B]): js.Function1[/* wa */ js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("extend")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* wa */ js.Array[A], js.Array[B]]]
  
  inline def filter[A](predicate: Predicate[A]): js.Function1[/* bs */ js.Array[A], js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("filter")(predicate.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* bs */ js.Array[A], js.Array[A]]]
  
  @JSImport("fp-ts/lib/ReadonlyArray", "filterE")
  @js.native
  val filterE: FilterE1[ReadonlyArray] = js.native
  
  inline def filterMap[A, B](f: js.Function1[/* a */ A, Option_[B]]): js.Function1[/* fa */ js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("filterMap")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* fa */ js.Array[A], js.Array[B]]]
  
  inline def filterMapWithIndex[A, B](f: js.Function2[/* i */ Double, /* a */ A, Option_[B]]): js.Function1[/* fa */ js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("filterMapWithIndex")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* fa */ js.Array[A], js.Array[B]]]
  
  inline def filterWithIndex[A](predicateWithIndex: PredicateWithIndex[Double, A]): js.Function1[/* bs */ js.Array[A], js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("filterWithIndex")(predicateWithIndex.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* bs */ js.Array[A], js.Array[A]]]
  
  inline def filterWithIndex_AB[A, B /* <: A */](refinementWithIndex: RefinementWithIndex[Double, A, B]): js.Function1[/* as */ js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("filterWithIndex")(refinementWithIndex.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], js.Array[B]]]
  
  inline def filter_AB[A, B /* <: A */](refinement: Refinement[A, B]): js.Function1[/* as */ js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("filter")(refinement.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], js.Array[B]]]
  
  inline def findFirst[A](predicate: Predicate[A]): js.Function1[/* bs */ js.Array[A], Option_[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("findFirst")(predicate.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* bs */ js.Array[A], Option_[A]]]
  
  inline def findFirstMap[A, B](f: js.Function1[/* a */ A, Option_[B]]): js.Function1[/* as */ js.Array[A], Option_[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("findFirstMap")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], Option_[B]]]
  
  inline def findFirst_AB[A, B /* <: A */](refinement: Refinement[A, B]): js.Function1[/* as */ js.Array[A], Option_[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("findFirst")(refinement.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], Option_[B]]]
  
  inline def findIndex[A](predicate: Predicate[A]): js.Function1[/* as */ js.Array[A], Option_[Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("findIndex")(predicate.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], Option_[Double]]]
  
  inline def findLast[A](predicate: Predicate[A]): js.Function1[/* bs */ js.Array[A], Option_[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("findLast")(predicate.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* bs */ js.Array[A], Option_[A]]]
  
  inline def findLastIndex[A](predicate: Predicate[A]): js.Function1[/* as */ js.Array[A], Option_[Double]] = ^.asInstanceOf[js.Dynamic].applyDynamic("findLastIndex")(predicate.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], Option_[Double]]]
  
  inline def findLastMap[A, B](f: js.Function1[/* a */ A, Option_[B]]): js.Function1[/* as */ js.Array[A], Option_[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("findLastMap")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], Option_[B]]]
  
  inline def findLast_AB[A, B /* <: A */](refinement: Refinement[A, B]): js.Function1[/* as */ js.Array[A], Option_[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("findLast")(refinement.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], Option_[B]]]
  
  inline def flap[A](a: A): js.Function1[/* fab */ js.Array[js.Function1[/* a */ A, Any]], js.Array[Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("flap")(a.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* fab */ js.Array[js.Function1[/* a */ A, Any]], js.Array[Any]]]
  
  inline def flatten[A](mma: js.Array[js.Array[A]]): js.Array[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("flatten")(mma.asInstanceOf[js.Any]).asInstanceOf[js.Array[A]]
  
  inline def foldLeft[A, B](onEmpty: Lazy[B], onNonEmpty: js.Function2[/* head */ A, /* tail */ js.Array[A], B]): js.Function1[/* as */ js.Array[A], B] = (^.asInstanceOf[js.Dynamic].applyDynamic("foldLeft")(onEmpty.asInstanceOf[js.Any], onNonEmpty.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], B]]
  
  inline def foldMap[M](M: Monoid[M]): js.Function1[/* f */ js.Function1[/* a */ Any, M], js.Function1[/* fa */ js.Array[Any], M]] = ^.asInstanceOf[js.Dynamic].applyDynamic("foldMap")(M.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* f */ js.Function1[/* a */ Any, M], js.Function1[/* fa */ js.Array[Any], M]]]
  
  inline def foldMapWithIndex[M](M: Monoid[M]): js.Function1[
    /* f */ js.Function2[/* i */ Double, /* a */ Any, M], 
    js.Function1[/* fa */ js.Array[Any], M]
  ] = ^.asInstanceOf[js.Dynamic].applyDynamic("foldMapWithIndex")(M.asInstanceOf[js.Any]).asInstanceOf[js.Function1[
    /* f */ js.Function2[/* i */ Double, /* a */ Any, M], 
    js.Function1[/* fa */ js.Array[Any], M]
  ]]
  
  inline def foldRight[A, B](onEmpty: Lazy[B], onNonEmpty: js.Function2[/* init */ js.Array[A], /* last */ A, B]): js.Function1[/* as */ js.Array[A], B] = (^.asInstanceOf[js.Dynamic].applyDynamic("foldRight")(onEmpty.asInstanceOf[js.Any], onNonEmpty.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], B]]
  
  inline def fromArray[A](as: js.Array[A]): js.Array[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("fromArray")(as.asInstanceOf[js.Any]).asInstanceOf[js.Array[A]]
  
  inline def fromEither[A](fa: Either_[Any, A]): js.Array[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("fromEither")(fa.asInstanceOf[js.Any]).asInstanceOf[js.Array[A]]
  
  inline def fromEitherK[E, A /* <: js.Array[Any] */, B](f: js.Function1[/* a */ A, Either_[E, B]]): js.Function1[/* a */ A, js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("fromEitherK")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* a */ A, js.Array[B]]]
  
  inline def fromOption[A](fa: Option_[A]): js.Array[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("fromOption")(fa.asInstanceOf[js.Any]).asInstanceOf[js.Array[A]]
  
  inline def fromOptionK[A /* <: js.Array[Any] */, B](f: js.Function1[/* a */ A, Option_[B]]): js.Function1[/* a */ A, js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("fromOptionK")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* a */ A, js.Array[B]]]
  
  inline def fromPredicate[A](predicate: Predicate[A]): js.Function1[/* b */ A, js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("fromPredicate")(predicate.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* b */ A, js.Array[A]]]
  
  inline def fromPredicate_AB[A, B /* <: A */](refinement: Refinement[A, B]): js.Function1[/* a */ A, js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("fromPredicate")(refinement.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* a */ A, js.Array[B]]]
  
  inline def getDifferenceMagma[A](E: Eq[A]): Magma[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getDifferenceMagma")(E.asInstanceOf[js.Any]).asInstanceOf[Magma[js.Array[A]]]
  
  inline def getEq[A](E: Eq[A]): Eq[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getEq")(E.asInstanceOf[js.Any]).asInstanceOf[Eq[js.Array[A]]]
  
  inline def getIntersectionSemigroup[A](E: Eq[A]): Semigroup[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getIntersectionSemigroup")(E.asInstanceOf[js.Any]).asInstanceOf[Semigroup[js.Array[A]]]
  
  inline def getMonoid[A](): Monoid[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getMonoid")().asInstanceOf[Monoid[js.Array[A]]]
  
  inline def getOrd[A](O: Ord_[A]): Ord_[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getOrd")(O.asInstanceOf[js.Any]).asInstanceOf[Ord_[js.Array[A]]]
  
  inline def getSemigroup[A](): Semigroup[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getSemigroup")().asInstanceOf[Semigroup[js.Array[A]]]
  
  inline def getShow[A](S: Show[A]): Show[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getShow")(S.asInstanceOf[js.Any]).asInstanceOf[Show[js.Array[A]]]
  
  inline def getUnionMonoid[A](E: Eq[A]): Monoid[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getUnionMonoid")(E.asInstanceOf[js.Any]).asInstanceOf[Monoid[js.Array[A]]]
  
  inline def getUnionSemigroup[A](E: Eq[A]): Semigroup[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("getUnionSemigroup")(E.asInstanceOf[js.Any]).asInstanceOf[Semigroup[js.Array[A]]]
  
  inline def guard(b: Boolean): js.Array[Unit] = ^.asInstanceOf[js.Dynamic].applyDynamic("guard")(b.asInstanceOf[js.Any]).asInstanceOf[js.Array[Unit]]
  
  inline def head[A](as: js.Array[A]): Option_[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("head")(as.asInstanceOf[js.Any]).asInstanceOf[Option_[A]]
  
  inline def init[A](as: js.Array[A]): Option_[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("init")(as.asInstanceOf[js.Any]).asInstanceOf[Option_[js.Array[A]]]
  
  inline def insertAt[A](i: Double, a: A): js.Function1[/* as */ js.Array[A], Option_[ReadonlyNonEmptyArray_[A]]] = (^.asInstanceOf[js.Dynamic].applyDynamic("insertAt")(i.asInstanceOf[js.Any], a.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], Option_[ReadonlyNonEmptyArray_[A]]]]
  
  inline def intercalate[A](M: Monoid[A]): js.Function1[/* middle */ A, js.Function1[/* as */ js.Array[A], A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("intercalate")(M.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* middle */ A, js.Function1[/* as */ js.Array[A], A]]]
  
  inline def intersection[A](E: Eq[A]): FnCallXsYs[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("intersection")(E.asInstanceOf[js.Any]).asInstanceOf[FnCallXsYs[A]]
  
  inline def intersperse[A](middle: A): js.Function1[/* as */ js.Array[A], js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("intersperse")(middle.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], js.Array[A]]]
  
  inline def isEmpty[A](as: js.Array[A]): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isEmpty")(as.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isNonEmpty[A](as: js.Array[A]): /* is fp-ts.fp-ts/lib/ReadonlyNonEmptyArray.ReadonlyNonEmptyArray<A> */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isNonEmpty")(as.asInstanceOf[js.Any]).asInstanceOf[/* is fp-ts.fp-ts/lib/ReadonlyNonEmptyArray.ReadonlyNonEmptyArray<A> */ Boolean]
  
  inline def isOutOfBound[A](i: Double, as: js.Array[A]): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("isOutOfBound")(i.asInstanceOf[js.Any], as.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  
  inline def last[A](as: js.Array[A]): Option_[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("last")(as.asInstanceOf[js.Any]).asInstanceOf[Option_[A]]
  
  inline def lefts[E, A](as: js.Array[Either_[E, A]]): js.Array[E] = ^.asInstanceOf[js.Dynamic].applyDynamic("lefts")(as.asInstanceOf[js.Any]).asInstanceOf[js.Array[E]]
  
  inline def let[N /* <: String */, A, B](name: Exclude[N, /* keyof A */ String], f: js.Function1[/* a */ A, B]): js.Function1[
    /* fa */ js.Array[A], 
    js.Array[
      /* import warning: importer.ImportType#apply Failed type conversion: {readonly [ K in N | keyof A ]: K extends keyof A? A[K] : B} */ js.Any
    ]
  ] = (^.asInstanceOf[js.Dynamic].applyDynamic("let")(name.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Function1[
    /* fa */ js.Array[A], 
    js.Array[
      /* import warning: importer.ImportType#apply Failed type conversion: {readonly [ K in N | keyof A ]: K extends keyof A? A[K] : B} */ js.Any
    ]
  ]]
  
  inline def lookup(i: Double): js.Function1[/* as */ js.Array[Any], Option_[Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("lookup")(i.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[Any], Option_[Any]]]
  inline def lookup[A](i: Double, as: js.Array[A]): Option_[A] = (^.asInstanceOf[js.Dynamic].applyDynamic("lookup")(i.asInstanceOf[js.Any], as.asInstanceOf[js.Any])).asInstanceOf[Option_[A]]
  
  inline def makeBy[A](n: Double, f: js.Function1[/* i */ Double, A]): js.Array[A] = (^.asInstanceOf[js.Dynamic].applyDynamic("makeBy")(n.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Array[A]]
  
  inline def map[A, B](f: js.Function1[/* a */ A, B]): js.Function1[/* fa */ js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("map")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* fa */ js.Array[A], js.Array[B]]]
  
  inline def mapWithIndex[A, B](f: js.Function2[/* i */ Double, /* a */ A, B]): js.Function1[/* fa */ js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("mapWithIndex")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* fa */ js.Array[A], js.Array[B]]]
  
  inline def `match`[B, A](onEmpty: Lazy[B], onNonEmpty: js.Function1[/* as */ ReadonlyNonEmptyArray_[A], B]): js.Function1[/* as */ js.Array[A], B] = (^.asInstanceOf[js.Dynamic].applyDynamic("match")(onEmpty.asInstanceOf[js.Any], onNonEmpty.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], B]]
  
  inline def matchLeft[B, A](onEmpty: Lazy[B], onNonEmpty: js.Function2[/* head */ A, /* tail */ js.Array[A], B]): js.Function1[/* as */ js.Array[A], B] = (^.asInstanceOf[js.Dynamic].applyDynamic("matchLeft")(onEmpty.asInstanceOf[js.Any], onNonEmpty.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], B]]
  
  inline def matchLeftW[B, A, C](onEmpty: Lazy[B], onNonEmpty: js.Function2[/* head */ A, /* tail */ js.Array[A], C]): js.Function1[/* as */ js.Array[A], B | C] = (^.asInstanceOf[js.Dynamic].applyDynamic("matchLeftW")(onEmpty.asInstanceOf[js.Any], onNonEmpty.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], B | C]]
  
  inline def matchRight[B, A](onEmpty: Lazy[B], onNonEmpty: js.Function2[/* init */ js.Array[A], /* last */ A, B]): js.Function1[/* as */ js.Array[A], B] = (^.asInstanceOf[js.Dynamic].applyDynamic("matchRight")(onEmpty.asInstanceOf[js.Any], onNonEmpty.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], B]]
  
  inline def matchRightW[B, A, C](onEmpty: Lazy[B], onNonEmpty: js.Function2[/* init */ js.Array[A], /* last */ A, C]): js.Function1[/* as */ js.Array[A], B | C] = (^.asInstanceOf[js.Dynamic].applyDynamic("matchRightW")(onEmpty.asInstanceOf[js.Any], onNonEmpty.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], B | C]]
  
  inline def matchW[B, A, C](onEmpty: Lazy[B], onNonEmpty: js.Function1[/* as */ ReadonlyNonEmptyArray_[A], C]): js.Function1[/* as */ js.Array[A], B | C] = (^.asInstanceOf[js.Dynamic].applyDynamic("matchW")(onEmpty.asInstanceOf[js.Any], onNonEmpty.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], B | C]]
  
  inline def modifyAt[A](i: Double, f: js.Function1[/* a */ A, A]): js.Function1[/* as */ js.Array[A], Option_[js.Array[A]]] = (^.asInstanceOf[js.Dynamic].applyDynamic("modifyAt")(i.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], Option_[js.Array[A]]]]
  
  inline def of[A](a: A): js.Array[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("of")(a.asInstanceOf[js.Any]).asInstanceOf[js.Array[A]]
  
  inline def partition[A](predicate: Predicate[A]): js.Function1[/* bs */ js.Array[A], Separated_[js.Array[A], js.Array[A]]] = ^.asInstanceOf[js.Dynamic].applyDynamic("partition")(predicate.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* bs */ js.Array[A], Separated_[js.Array[A], js.Array[A]]]]
  
  inline def partitionMap[A, B, C](f: js.Function1[/* a */ A, Either_[B, C]]): js.Function1[/* fa */ js.Array[A], Separated_[js.Array[B], js.Array[C]]] = ^.asInstanceOf[js.Dynamic].applyDynamic("partitionMap")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* fa */ js.Array[A], Separated_[js.Array[B], js.Array[C]]]]
  
  inline def partitionMapWithIndex[A, B, C](f: js.Function2[/* i */ Double, /* a */ A, Either_[B, C]]): js.Function1[/* fa */ js.Array[A], Separated_[js.Array[B], js.Array[C]]] = ^.asInstanceOf[js.Dynamic].applyDynamic("partitionMapWithIndex")(f.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* fa */ js.Array[A], Separated_[js.Array[B], js.Array[C]]]]
  
  inline def partitionWithIndex[A](predicateWithIndex: PredicateWithIndex[Double, A]): js.Function1[/* bs */ js.Array[A], Separated_[js.Array[A], js.Array[A]]] = ^.asInstanceOf[js.Dynamic].applyDynamic("partitionWithIndex")(predicateWithIndex.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* bs */ js.Array[A], Separated_[js.Array[A], js.Array[A]]]]
  
  inline def partitionWithIndex_AB[A, B /* <: A */](refinementWithIndex: RefinementWithIndex[Double, A, B]): js.Function1[/* as */ js.Array[A], Separated_[js.Array[A], js.Array[B]]] = ^.asInstanceOf[js.Dynamic].applyDynamic("partitionWithIndex")(refinementWithIndex.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], Separated_[js.Array[A], js.Array[B]]]]
  
  inline def partition_AB[A, B /* <: A */](refinement: Refinement[A, B]): js.Function1[/* as */ js.Array[A], Separated_[js.Array[A], js.Array[B]]] = ^.asInstanceOf[js.Dynamic].applyDynamic("partition")(refinement.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], Separated_[js.Array[A], js.Array[B]]]]
  
  inline def prepend[A](head: A): js.Function1[/* tail */ js.Array[A], ReadonlyNonEmptyArray_[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("prepend")(head.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* tail */ js.Array[A], ReadonlyNonEmptyArray_[A]]]
  
  inline def prependAll[A](middle: A): js.Function1[/* as */ js.Array[A], js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("prependAll")(middle.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], js.Array[A]]]
  
  inline def prependToAll[A](middle: A): js.Function1[/* as */ js.Array[A], js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("prependToAll")(middle.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], js.Array[A]]]
  
  inline def prependW[B](head: B): js.Function1[/* tail */ js.Array[Any], ReadonlyNonEmptyArray_[B | Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("prependW")(head.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* tail */ js.Array[Any], ReadonlyNonEmptyArray_[B | Any]]]
  
  inline def range(start: Double, end: Double): ReadonlyNonEmptyArray_[Double] = (^.asInstanceOf[js.Dynamic].applyDynamic("range")(start.asInstanceOf[js.Any], end.asInstanceOf[js.Any])).asInstanceOf[ReadonlyNonEmptyArray_[Double]]
  
  @JSImport("fp-ts/lib/ReadonlyArray", "readonlyArray")
  @js.native
  val readonlyArray: (FunctorWithIndex1[typings.fpTs.libReadonlyArrayMod.URI, Double]) & Monad1[typings.fpTs.libReadonlyArrayMod.URI] & Unfoldable1[typings.fpTs.libReadonlyArrayMod.URI] & Alternative1[typings.fpTs.libReadonlyArrayMod.URI] & Extend1[typings.fpTs.libReadonlyArrayMod.URI] & (FilterableWithIndex1[typings.fpTs.libReadonlyArrayMod.URI, Double]) & (FoldableWithIndex1[typings.fpTs.libReadonlyArrayMod.URI, Double]) & (TraversableWithIndex1[typings.fpTs.libReadonlyArrayMod.URI, Double]) & Witherable1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  inline def reduce[A, B](b: B, f: js.Function2[/* b */ B, /* a */ A, B]): js.Function1[/* fa */ js.Array[A], B] = (^.asInstanceOf[js.Dynamic].applyDynamic("reduce")(b.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* fa */ js.Array[A], B]]
  
  inline def reduceRight[A, B](b: B, f: js.Function2[/* a */ A, /* b */ B, B]): js.Function1[/* fa */ js.Array[A], B] = (^.asInstanceOf[js.Dynamic].applyDynamic("reduceRight")(b.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* fa */ js.Array[A], B]]
  
  inline def reduceRightWithIndex[A, B](b: B, f: js.Function3[/* i */ Double, /* a */ A, /* b */ B, B]): js.Function1[/* fa */ js.Array[A], B] = (^.asInstanceOf[js.Dynamic].applyDynamic("reduceRightWithIndex")(b.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* fa */ js.Array[A], B]]
  
  inline def reduceWithIndex[A, B](b: B, f: js.Function3[/* i */ Double, /* b */ B, /* a */ A, B]): js.Function1[/* fa */ js.Array[A], B] = (^.asInstanceOf[js.Dynamic].applyDynamic("reduceWithIndex")(b.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* fa */ js.Array[A], B]]
  
  inline def replicate[A](n: Double, a: A): js.Array[A] = (^.asInstanceOf[js.Dynamic].applyDynamic("replicate")(n.asInstanceOf[js.Any], a.asInstanceOf[js.Any])).asInstanceOf[js.Array[A]]
  
  inline def reverse[A](as: js.Array[A]): js.Array[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("reverse")(as.asInstanceOf[js.Any]).asInstanceOf[js.Array[A]]
  
  inline def rights[E, A](as: js.Array[Either_[E, A]]): js.Array[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("rights")(as.asInstanceOf[js.Any]).asInstanceOf[js.Array[A]]
  
  inline def rotate(n: Double): js.Function1[/* as */ js.Array[Any], js.Array[Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("rotate")(n.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[Any], js.Array[Any]]]
  
  inline def scanLeft[A, B](b: B, f: js.Function2[/* b */ B, /* a */ A, B]): js.Function1[/* as */ js.Array[A], ReadonlyNonEmptyArray_[B]] = (^.asInstanceOf[js.Dynamic].applyDynamic("scanLeft")(b.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], ReadonlyNonEmptyArray_[B]]]
  
  inline def scanRight[A, B](b: B, f: js.Function2[/* a */ A, /* b */ B, B]): js.Function1[/* as */ js.Array[A], ReadonlyNonEmptyArray_[B]] = (^.asInstanceOf[js.Dynamic].applyDynamic("scanRight")(b.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], ReadonlyNonEmptyArray_[B]]]
  
  inline def separate[A, B](fa: js.Array[Either_[A, B]]): Separated_[js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("separate")(fa.asInstanceOf[js.Any]).asInstanceOf[Separated_[js.Array[A], js.Array[B]]]
  
  @JSImport("fp-ts/lib/ReadonlyArray", "sequence")
  @js.native
  val sequence: Sequence1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  inline def size[A](as: js.Array[A]): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("size")(as.asInstanceOf[js.Any]).asInstanceOf[Double]
  
  inline def snoc[A](init: js.Array[A], end: A): ReadonlyNonEmptyArray_[A] = (^.asInstanceOf[js.Dynamic].applyDynamic("snoc")(init.asInstanceOf[js.Any], end.asInstanceOf[js.Any])).asInstanceOf[ReadonlyNonEmptyArray_[A]]
  
  inline def some[A](predicate: Predicate[A]): js.Function1[
    /* as */ js.Array[A], 
    /* is fp-ts.fp-ts/lib/ReadonlyNonEmptyArray.ReadonlyNonEmptyArray<A> */ Boolean
  ] = ^.asInstanceOf[js.Dynamic].applyDynamic("some")(predicate.asInstanceOf[js.Any]).asInstanceOf[js.Function1[
    /* as */ js.Array[A], 
    /* is fp-ts.fp-ts/lib/ReadonlyNonEmptyArray.ReadonlyNonEmptyArray<A> */ Boolean
  ]]
  
  inline def sort[B](O: Ord_[B]): js.Function1[/* as */ js.Array[B], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("sort")(O.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[B], js.Array[B]]]
  
  inline def sortBy[B](ords: js.Array[Ord_[B]]): js.Function1[/* as */ js.Array[B], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("sortBy")(ords.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[B], js.Array[B]]]
  
  inline def spanLeft[A](predicate: Predicate[A]): js.Function1[/* bs */ js.Array[A], Spanned[A, A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("spanLeft")(predicate.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* bs */ js.Array[A], Spanned[A, A]]]
  
  inline def spanLeft_AB[A, B /* <: A */](refinement: Refinement[A, B]): js.Function1[/* as */ js.Array[A], Spanned[B, A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("spanLeft")(refinement.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], Spanned[B, A]]]
  
  inline def splitAt(n: Double): js.Function1[/* as */ js.Array[Any], js.Tuple2[js.Array[Any], js.Array[Any]]] = ^.asInstanceOf[js.Dynamic].applyDynamic("splitAt")(n.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[Any], js.Tuple2[js.Array[Any], js.Array[Any]]]]
  
  inline def tail[A](as: js.Array[A]): Option_[js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("tail")(as.asInstanceOf[js.Any]).asInstanceOf[Option_[js.Array[A]]]
  
  inline def takeLeft(n: Double): js.Function1[/* as */ js.Array[Any], js.Array[Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("takeLeft")(n.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[Any], js.Array[Any]]]
  
  inline def takeLeftWhile[A](predicate: Predicate[A]): js.Function1[/* bs */ js.Array[A], js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("takeLeftWhile")(predicate.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* bs */ js.Array[A], js.Array[A]]]
  
  inline def takeLeftWhile_AB[A, B /* <: A */](refinement: Refinement[A, B]): js.Function1[/* as */ js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("takeLeftWhile")(refinement.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], js.Array[B]]]
  
  inline def takeRight(n: Double): js.Function1[/* as */ js.Array[Any], js.Array[Any]] = ^.asInstanceOf[js.Dynamic].applyDynamic("takeRight")(n.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[Any], js.Array[Any]]]
  
  inline def toArray[A](as: js.Array[A]): js.Array[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("toArray")(as.asInstanceOf[js.Any]).asInstanceOf[js.Array[A]]
  
  @JSImport("fp-ts/lib/ReadonlyArray", "traverse")
  @js.native
  val traverse: PipeableTraverse1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "traverseWithIndex")
  @js.native
  val traverseWithIndex: PipeableTraverseWithIndex1[typings.fpTs.libReadonlyArrayMod.URI, Double] = js.native
  
  inline def unfold[A, B](b: B, f: js.Function1[/* b */ B, Option_[js.Tuple2[A, B]]]): js.Array[A] = (^.asInstanceOf[js.Dynamic].applyDynamic("unfold")(b.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Array[A]]
  
  inline def union[A](E: Eq[A]): FnCallXsYs[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("union")(E.asInstanceOf[js.Any]).asInstanceOf[FnCallXsYs[A]]
  
  inline def uniq[A](E: Eq[A]): js.Function1[/* as */ js.Array[A], js.Array[A]] = ^.asInstanceOf[js.Dynamic].applyDynamic("uniq")(E.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[A], js.Array[A]]]
  
  inline def unsafeDeleteAt[A](i: Double, as: js.Array[A]): js.Array[A] = (^.asInstanceOf[js.Dynamic].applyDynamic("unsafeDeleteAt")(i.asInstanceOf[js.Any], as.asInstanceOf[js.Any])).asInstanceOf[js.Array[A]]
  
  inline def unsafeInsertAt[A](i: Double, a: A, as: js.Array[A]): ReadonlyNonEmptyArray_[A] = (^.asInstanceOf[js.Dynamic].applyDynamic("unsafeInsertAt")(i.asInstanceOf[js.Any], a.asInstanceOf[js.Any], as.asInstanceOf[js.Any])).asInstanceOf[ReadonlyNonEmptyArray_[A]]
  
  inline def unsafeUpdateAt[A](i: Double, a: A, as: js.Array[A]): js.Array[A] = (^.asInstanceOf[js.Dynamic].applyDynamic("unsafeUpdateAt")(i.asInstanceOf[js.Any], a.asInstanceOf[js.Any], as.asInstanceOf[js.Any])).asInstanceOf[js.Array[A]]
  
  inline def unzip[A, B](as: js.Array[js.Tuple2[A, B]]): js.Tuple2[js.Array[A], js.Array[B]] = ^.asInstanceOf[js.Dynamic].applyDynamic("unzip")(as.asInstanceOf[js.Any]).asInstanceOf[js.Tuple2[js.Array[A], js.Array[B]]]
  
  inline def updateAt[A](i: Double, a: A): js.Function1[/* as */ js.Array[A], Option_[js.Array[A]]] = (^.asInstanceOf[js.Dynamic].applyDynamic("updateAt")(i.asInstanceOf[js.Any], a.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* as */ js.Array[A], Option_[js.Array[A]]]]
  
  @JSImport("fp-ts/lib/ReadonlyArray", "wilt")
  @js.native
  val wilt: PipeableWilt1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  @JSImport("fp-ts/lib/ReadonlyArray", "wither")
  @js.native
  val wither: PipeableWither1[typings.fpTs.libReadonlyArrayMod.URI] = js.native
  
  inline def zero[A](): js.Array[A] = ^.asInstanceOf[js.Dynamic].applyDynamic("zero")().asInstanceOf[js.Array[A]]
  
  inline def zip[B](bs: js.Array[B]): js.Function1[/* as */ js.Array[Any], js.Array[js.Tuple2[Any, B]]] = ^.asInstanceOf[js.Dynamic].applyDynamic("zip")(bs.asInstanceOf[js.Any]).asInstanceOf[js.Function1[/* as */ js.Array[Any], js.Array[js.Tuple2[Any, B]]]]
  inline def zip[A, B](as: js.Array[A], bs: js.Array[B]): js.Array[js.Tuple2[A, B]] = (^.asInstanceOf[js.Dynamic].applyDynamic("zip")(as.asInstanceOf[js.Any], bs.asInstanceOf[js.Any])).asInstanceOf[js.Array[js.Tuple2[A, B]]]
  
  inline def zipWith[A, B, C](fa: js.Array[A], fb: js.Array[B], f: js.Function2[/* a */ A, /* b */ B, C]): js.Array[C] = (^.asInstanceOf[js.Dynamic].applyDynamic("zipWith")(fa.asInstanceOf[js.Any], fb.asInstanceOf[js.Any], f.asInstanceOf[js.Any])).asInstanceOf[js.Array[C]]
  
  /* augmented module */
  object HKTAugmentingMod {
    
    @js.native
    trait URItoKind[A] extends StObject
  }
  
  trait Spanned[I, R] extends StObject {
    
    val init: js.Array[I]
    
    val rest: js.Array[R]
  }
  object Spanned {
    
    inline def apply[I, R](init: js.Array[I], rest: js.Array[R]): Spanned[I, R] = {
      val __obj = js.Dynamic.literal(init = init.asInstanceOf[js.Any], rest = rest.asInstanceOf[js.Any])
      __obj.asInstanceOf[Spanned[I, R]]
    }
    
    extension [Self <: Spanned[?, ?], I, R](x: Self & (Spanned[I, R])) {
      
      inline def setInit(value: js.Array[I]): Self = StObject.set(x, "init", value.asInstanceOf[js.Any])
      
      inline def setInitVarargs(value: I*): Self = StObject.set(x, "init", js.Array(value*))
      
      inline def setRest(value: js.Array[R]): Self = StObject.set(x, "rest", value.asInstanceOf[js.Any])
      
      inline def setRestVarargs(value: R*): Self = StObject.set(x, "rest", js.Array(value*))
    }
  }
}
