package typings.mixpanel

import org.scalablytyped.runtime.StringDictionary
import typings.mixpanel.Mixpanel.Config
import typings.mixpanel.Mixpanel.People
import typings.mixpanel.Mixpanel.Query
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation._

@JSName("Mixpanel")
@js.native
trait Mixpanel_ extends js.Object {
  var people: People = js.native
  /**
    * Create an alias, which Mixpanel will use to link two distinct_ids going forward (not retroactively).
    * Multiple aliases can map to the same original ID, but not vice-versa. Aliases can also be chained - the
    * following is a valid scenario:
    *
    *     mixpanel.alias('new_id', 'existing_id');
    *     ...
    *     mixpanel.alias('newer_id', 'new_id');
    *
    * If the original ID is not passed in, we will use the current distinct_id - probably the auto-generated GUID.
    *
    * ### Notes:
    *
    * The best practice is to call `alias()` when a unique ID is first created for a user
    * (e.g., when a user first registers for an account and provides an email address).
    * `alias()` should never be called more than once for a given user, except to
    * chain a newer ID to a previously new ID, as described above.
    *
    * @param alias A unique identifier that you want to use for this user in the future.
    * @param currentId The current identifier being used for this user.
    */
  def alias(alias: String): Unit = js.native
  def alias(alias: String, currentId: String): Unit = js.native
  /**
    * Disable events on the Mixpanel object. If passed no arguments,
    * this function disables tracking of any event. If passed an
    * array of event names, those events will be disabled, but other
    * events will continue to be tracked.
    *
    * Note: this function does not stop other mixpanel functions from
    * firing, such as `register()` or `people.set()`.
    *
    * @param events An array of event names to disable
    */
  def disable(): Unit = js.native
  def disable(events: js.Array[String]): Unit = js.native
  /**
    * Returns the current config object for the library.
    */
  def get_config(): Config = js.native
  /**
    * Returns the current distinct id of the user. This is either the id automatically
    * generated by the library or the id that has been passed by a call to `identify()`.
    *
    * ### Notes:
    *
    * `get_distinct_id()` can only be called after the Mixpanel library has finished loading.
    * `init()` has a loaded function available to handle this automatically. For example:
    *
    *     // set distinct_id after the mixpanel library has loaded
    *     mixpanel.init('YOUR PROJECT TOKEN', {
    *         loaded: function(mixpanel) {
    *             distinct_id = mixpanel.get_distinct_id();
    *         }
    *     });
    */
  def get_distinct_id(): String = js.native
  /**
    * Returns the value of the super property named property_name. If no such
    * property is set, `get_property()` will return the undefined value.
    *
    * ### Notes:
    *
    * `get_property()` can only be called after the Mixpanel library has finished loading.
    * `init()` has a loaded function available to handle this automatically. For example:
    *
    *     // grab value for 'user_id' after the mixpanel library has loaded
    *     mixpanel.init('YOUR PROJECT TOKEN', {
    *         loaded: function(mixpanel) {
    *             user_id = mixpanel.get_property('user_id');
    *         }
    *     });
    *
    * @param propertyName The name of the super property you want to retrieve
    */
  def get_property(propertyName: String): js.Any = js.native
  /**
    * Identify a user with a unique ID. All subsequent
    * actions caused by this user will be tied to this unique ID. This
    * property is used to track unique visitors. If the method is
    * never called, then unique visitors will be identified by a UUID
    * generated the first time they visit the site.
    *
    * ### Notes:
    *
    * You can call this function to overwrite a previously set
    * unique ID for the current user. Mixpanel cannot translate
    * between IDs at this time, so when you change a user's ID
    * they will appear to be a new user.
    *
    * `identify()` should not be called to link anonymous activity to
    * subsequent activity when a unique ID is first assigned.
    * Use `alias()` when a unique ID is first assigned (registration), and
    * use `identify()` to identify the user with that unique ID on an ongoing
    * basis (e.g., each time a user logs in after registering).
    * Do not call `identify()` at the same time as `alias()`.
    *
    * @param unique_id A string that uniquely identifies a user. If not provided, the distinct_id currently in the persistent store (cookie or localStorage) will be used.
    */
  def identify(): Unit = js.native
  def identify(uniqueId: String): Unit = js.native
  /**
    * This function initializes a new instance of the Mixpanel tracking object.
    * All new instances are added to the main mixpanel object as sub properties (such as
    * mixpanel.library_name) and also returned by this function. To define a
    * second instance on the page, you would call:
    *
    *     mixpanel.init('new token', { your: 'config' }, 'library_name');
    *
    * and use it like so:
    *
    *     mixpanel.library_name.track(...);
    *
    * @param token Your Mixpanel API token
    * @param config A dictionary of config options to override
    * @param libraryName The name for the new mixpanel instance that you want created
    */
  def init(token: String): Mixpanel = js.native
  def init(token: String, config: Config): Mixpanel = js.native
  def init(token: String, config: Config, libraryName: String): Mixpanel = js.native
  /**
    * `push()` keeps the standard async-array-push
    * behavior around after the lib is loaded.
    * This is only useful for external integrations that
    * do not wish to rely on our convenience methods
    * (created in the snippet).
    *
    * ### Usage:
    *     mixpanel.push(['register', { a: 'b' }]);
    *
    * @param item A [function_name, args...] array to be executed
    */
  def push(item: js.Array[_]): Unit = js.native
  /**
    * Register a set of super properties, which are included with all
    * events. This will overwrite previous super property values.
    *
    * ### Usage:
    *
    *     // register 'Gender' as a super property
    *     mixpanel.register({'Gender': 'Female'});
    *
    *     // register several super properties when a user signs up
    *     mixpanel.register({
    *         'Email': 'jdoe@example.com',
    *         'Account Type': 'Free'
    *     });
    *
    * @param properties An associative array of properties to store about the user
    * @param days How many days since the user's last visit to store the super properties
    */
  def register(properties: StringDictionary[js.Any]): Unit = js.native
  def register(properties: StringDictionary[js.Any], days: Double): Unit = js.native
  /**
    * Register a set of super properties only once. This will not
    * overwrite previous super property values, unlike `register()`.
    *
    * ### Usage:
    *
    *     // register a super property for the first time only
    *     mixpanel.register_once({
    *         'First Login Date': new Date().toISOString()
    *     });
    *
    * ### Notes:
    *
    * If default_value is specified, current super properties
    * with that value will be overwritten.
    *
    * @param properties An associative array of properties to store about the user
    * @param defaultValue Value to override if already set in super properties (ex: 'False') Default: 'None'
    * @param days How many days since the users last visit to store the super properties
    */
  def register_once(properties: StringDictionary[js.Any]): Unit = js.native
  def register_once(properties: StringDictionary[js.Any], defaultValue: String): Unit = js.native
  def register_once(properties: StringDictionary[js.Any], defaultValue: String, days: Double): Unit = js.native
  /**
    * Clears super properties and generates a new random `distinct_id` for this instance.
    * Useful for clearing data when a user logs out.
    */
  def reset(): Unit = js.native
  /**
    * Update the configuration of a mixpanel library instance.
    *
    * @param config A dictionary of new configuration values to update
    */
  def set_config(config: Config): Unit = js.native
  /**
    * Time an event by including the time between this call and a
    * later `track` call for the same event in the properties sent
    * with the event.
    *
    * ### Usage:
    *
    *     // time an event named 'Registered'
    *     mixpanel.time_event('Registered');
    *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});
    *
    * When called for a particular event name, the next track call for that event
    * name will include the elapsed time between the `time_event` and `track`
    * calls. This value is stored as seconds in the `$duration` property.
    *
    * @param eventName The name of the event.
    */
  def time_event(eventName: String): Unit = js.native
  /**
    * Track an event. This is the most important and
    * frequently used Mixpanel function.
    *
    * ### Usage:
    *
    *     // track an event named 'Registered'
    *     mixpanel.track('Registered', {'Gender': 'Male', 'Age': 21});
    *
    * To track link clicks or form submissions, see `track_links()` or `track_forms()`.
    *
    * @param eventName The name of the event. This can be anything the user does - 'Button Click', 'Sign Up', 'Item Purchased', etc.
    * @param properties A set of properties to include with the event you're sending. These describe the user who did the event or details about the event itself.
    * @param callback If provided, the callback function will be called after tracking the event.
    */
  def track(eventName: String): Unit = js.native
  def track(eventName: String, properties: StringDictionary[js.Any]): Unit = js.native
  def track(eventName: String, properties: StringDictionary[js.Any], callback: js.Function0[Unit]): Unit = js.native
  /**
    * Track form submissions. Selector must be a valid query.
    *
    * ### Usage:
    *
    *     // track submission for form id 'register'
    *     mixpanel.track_forms('#register', 'Created Account');
    *
    * ### Notes:
    *
    * This function will wait up to 300 ms for the mixpanel
    * servers to respond, if they have not responded by that time
    * it will head to the link without ensuring that your event
    * has been tracked.  To configure this timeout please see the
    * `set_config()` documentation below.
    *
    * If you pass a function in as the properties argument, the
    * function will receive the `DOMElement` that triggered the
    * event as an argument.  You are expected to return an object
    * from the function; any properties defined on this object
    * will be sent to mixpanel as event properties.
    *
    * @param querySelector A valid DOM query, element or jQuery-esque list
    * @param eventName The name of the event to track
    * @param properties This can be a set of properties, or a function that returns a set of properties after being passed a DOMElement
    */
  def track_forms(querySelector: Query, eventName: String): Unit = js.native
  def track_forms(querySelector: Query, eventName: String, properties: StringDictionary[js.Any]): Unit = js.native
  /**
    * Track clicks on a set of document elements. Selector must be a
    * valid query. Elements must exist on the page at the time `track_links` is called.
    *
    * ### Usage:
    *
    *     // track click for link id #nav
    *     mixpanel.track_links('#nav', 'Clicked Nav Link');
    *
    * ### Notes:
    *
    * This function will wait up to 300 ms for the Mixpanel
    * servers to respond. If they have not responded by that time
    * it will head to the link without ensuring that your event
    * has been tracked.  To configure this timeout please see the
    * `set_config()` documentation below.
    *
    * If you pass a function in as the properties argument, the
    * function will receive the DOMElement that triggered the
    * event as an argument.  You are expected to return an object
    * from the function; any properties defined on this object
    * will be sent to mixpanel as event properties.
    *
    * @param querySelector A valid DOM query, element or jQuery-esque list
    * @param eventName The name of the event to track
    * @param properties A properties object or function that returns a dictionary of properties when passed a DOMElement
    */
  def track_links(querySelector: Query, eventName: String): Unit = js.native
  def track_links(querySelector: Query, eventName: String, properties: StringDictionary[js.Any]): Unit = js.native
  /**
    * Delete a super property stored with the current user.
    *
    * @param propertyName The name of the super property to remove
    */
  def unregister(propertyName: String): Unit = js.native
}

