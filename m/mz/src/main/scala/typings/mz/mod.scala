package typings.mz

import typings.mz.anon.BufferBytesRead
import typings.mz.anon.BufferDataView
import typings.mz.anon.BufferFloat32Array
import typings.mz.anon.BufferFloat64Array
import typings.mz.anon.BufferInt16Array
import typings.mz.anon.BufferInt32Array
import typings.mz.anon.BufferInt8Array
import typings.mz.anon.BufferUint32Array
import typings.mz.anon.BytesRead
import typings.mz.anon.Encoding
import typings.mz.anon.EncodingPersistent
import typings.mz.anon.EncodingWithFileTypes
import typings.mz.anon.Interval
import typings.mz.anon.Persistent
import typings.mz.anon.Recursive
import typings.mz.anon.WithFileTypes
import typings.mz.anon.`2`
import typings.mz.anon.`4`
import typings.mz.anon.encodingBufferEncodingund
import typings.mz.anon.encodingbuffernullundefin
import typings.mz.anon.encodingstringnullundefin
import typings.mz.childProcessMod.ExecFileOptionsWithBufferEncoding
import typings.mz.childProcessMod.ExecFileOptionsWithOtherEncoding
import typings.mz.mzNumbers.`0`
import typings.mz.mzNumbers.`1`
import typings.mz.mzStrings.A
import typings.mz.mzStrings.AAAA
import typings.mz.mzStrings.ANY
import typings.mz.mzStrings.CNAME
import typings.mz.mzStrings.MX
import typings.mz.mzStrings.NAPTR
import typings.mz.mzStrings.NS
import typings.mz.mzStrings.PTR
import typings.mz.mzStrings.SOA
import typings.mz.mzStrings.SRV
import typings.mz.mzStrings.TXT
import typings.mz.mzStrings.base64
import typings.mz.mzStrings.buffer
import typings.mz.mzStrings.compressed
import typings.mz.mzStrings.der
import typings.mz.mzStrings.dsa
import typings.mz.mzStrings.ec
import typings.mz.mzStrings.ed25519
import typings.mz.mzStrings.ed448
import typings.mz.mzStrings.hex
import typings.mz.mzStrings.hybrid
import typings.mz.mzStrings.latin1
import typings.mz.mzStrings.pem
import typings.mz.mzStrings.rsa
import typings.mz.mzStrings.uncompressed
import typings.mz.mzStrings.x25519
import typings.mz.mzStrings.x448
import typings.node.Buffer
import typings.node.BufferEncoding
import typings.node.NodeJS.ArrayBufferView
import typings.node.NodeJS.ErrnoException
import typings.node.NodeJS.ReadableStream
import typings.node.NodeJS.WritableStream
import typings.node.anon.AutoClose
import typings.node.anon.BaseEncodingOptionsflagOp
import typings.node.anon.BaseEncodingOptionsflagst
import typings.node.anon.BaseEncodingOptionsmodeMo
import typings.node.anon.BaseEncodingOptionswithFi
import typings.node.anon.BaseEncodingOptionswithFiEncoding
import typings.node.anon.BufferBytesWritten
import typings.node.anon.BytesWritten
import typings.node.anon.EmitClose
import typings.node.anon.EncodingBufferEncoding
import typings.node.anon.EncodingFlag
import typings.node.anon.Flag
import typings.node.anon.Hostname
import typings.node.anon.MakeDirectoryOptionsrecur
import typings.node.anon.MakeDirectoryOptionsrecurMode
import typings.node.anon.PrivateKey
import typings.node.anon.`3`
import typings.node.childProcessMod.ChildProcess
import typings.node.childProcessMod.ChildProcessByStdio
import typings.node.childProcessMod.ChildProcessWithoutNullStreams
import typings.node.childProcessMod.ExecException
import typings.node.childProcessMod.ExecFileOptions
import typings.node.childProcessMod.ExecFileOptionsWithStringEncoding
import typings.node.childProcessMod.ExecFileSyncOptions
import typings.node.childProcessMod.ExecFileSyncOptionsWithBufferEncoding
import typings.node.childProcessMod.ExecFileSyncOptionsWithStringEncoding
import typings.node.childProcessMod.ExecSyncOptions
import typings.node.childProcessMod.ExecSyncOptionsWithBufferEncoding
import typings.node.childProcessMod.ExecSyncOptionsWithStringEncoding
import typings.node.childProcessMod.ForkOptions
import typings.node.childProcessMod.SpawnOptions
import typings.node.childProcessMod.SpawnOptionsWithStdioTuple
import typings.node.childProcessMod.SpawnOptionsWithoutStdio
import typings.node.childProcessMod.SpawnSyncOptions
import typings.node.childProcessMod.SpawnSyncOptionsWithBufferEncoding
import typings.node.childProcessMod.SpawnSyncOptionsWithStringEncoding
import typings.node.childProcessMod.SpawnSyncReturns
import typings.node.childProcessMod.StdioNull
import typings.node.childProcessMod.StdioPipe
import typings.node.cryptoMod.BinaryLike
import typings.node.cryptoMod.CipherCCM
import typings.node.cryptoMod.CipherCCMOptions
import typings.node.cryptoMod.CipherCCMTypes
import typings.node.cryptoMod.CipherGCM
import typings.node.cryptoMod.CipherGCMOptions
import typings.node.cryptoMod.CipherGCMTypes
import typings.node.cryptoMod.CipherKey
import typings.node.cryptoMod.DSAKeyPairKeyObjectOptions
import typings.node.cryptoMod.DSAKeyPairOptions
import typings.node.cryptoMod.DecipherCCM
import typings.node.cryptoMod.DecipherGCM
import typings.node.cryptoMod.ECKeyPairKeyObjectOptions
import typings.node.cryptoMod.ECKeyPairOptions
import typings.node.cryptoMod.ED25519KeyPairKeyObjectOptions
import typings.node.cryptoMod.ED25519KeyPairOptions
import typings.node.cryptoMod.ED448KeyPairKeyObjectOptions
import typings.node.cryptoMod.ED448KeyPairOptions
import typings.node.cryptoMod.HashOptions
import typings.node.cryptoMod.HexBase64Latin1Encoding
import typings.node.cryptoMod.KeyLike
import typings.node.cryptoMod.KeyPairKeyObjectResult
import typings.node.cryptoMod.KeyPairSyncResult
import typings.node.cryptoMod.PrivateKeyInput
import typings.node.cryptoMod.PublicKeyInput
import typings.node.cryptoMod.RSAKeyPairKeyObjectOptions
import typings.node.cryptoMod.RSAKeyPairOptions
import typings.node.cryptoMod.RsaPrivateKey
import typings.node.cryptoMod.RsaPublicKey
import typings.node.cryptoMod.ScryptOptions
import typings.node.cryptoMod.SignKeyObjectInput
import typings.node.cryptoMod.SignPrivateKeyInput
import typings.node.cryptoMod.VerifyKeyObjectInput
import typings.node.cryptoMod.VerifyPublicKeyInput
import typings.node.cryptoMod.X25519KeyPairKeyObjectOptions
import typings.node.cryptoMod.X25519KeyPairOptions
import typings.node.cryptoMod.X448KeyPairKeyObjectOptions
import typings.node.cryptoMod.X448KeyPairOptions
import typings.node.dnsMod.AnyRecord
import typings.node.dnsMod.LookupAddress
import typings.node.dnsMod.LookupAllOptions
import typings.node.dnsMod.LookupOneOptions
import typings.node.dnsMod.LookupOptions
import typings.node.dnsMod.MxRecord
import typings.node.dnsMod.NaptrRecord
import typings.node.dnsMod.RecordWithTtl
import typings.node.dnsMod.ResolveOptions
import typings.node.dnsMod.ResolveWithTtlOptions
import typings.node.dnsMod.SoaRecord
import typings.node.dnsMod.SrvRecord
import typings.node.fsMod.BaseEncodingOptions
import typings.node.fsMod.BigIntOptions
import typings.node.fsMod.BufferEncodingOption
import typings.node.fsMod.FSWatcher
import typings.node.fsMod.MakeDirectoryOptions
import typings.node.fsMod.Mode
import typings.node.fsMod.NoParamCallback
import typings.node.fsMod.OpenDirOptions
import typings.node.fsMod.OpenMode
import typings.node.fsMod.PathLike
import typings.node.fsMod.ReadSyncOptions
import typings.node.fsMod.RmDirOptions
import typings.node.fsMod.RmOptions
import typings.node.fsMod.StatOptions
import typings.node.fsMod.WriteFileOptions
import typings.node.fsMod.symlink.Type
import typings.node.promisesMod.FileHandle
import typings.node.readlineMod.AsyncCompleter
import typings.node.readlineMod.Completer
import typings.node.readlineMod.Direction
import typings.node.readlineMod.ReadLineOptions
import typings.node.streamMod.Readable
import typings.node.streamMod.ReadableOptions
import typings.node.streamMod.TransformOptions
import typings.node.streamMod.Writable
import typings.node.streamMod.WritableOptions
import typings.node.zlibMod.BrotliCompress_
import typings.node.zlibMod.BrotliDecompress_
import typings.node.zlibMod.BrotliOptions
import typings.node.zlibMod.CompressCallback
import typings.node.zlibMod.DeflateRaw_
import typings.node.zlibMod.Deflate_
import typings.node.zlibMod.Gunzip_
import typings.node.zlibMod.Gzip_
import typings.node.zlibMod.InflateRaw_
import typings.node.zlibMod.Inflate_
import typings.node.zlibMod.InputType
import typings.node.zlibMod.Unzip_
import typings.node.zlibMod.ZlibOptions
import typings.std.DataView
import typings.std.Date
import typings.std.Error
import typings.std.Float32Array
import typings.std.Float64Array
import typings.std.Int16Array
import typings.std.Int32Array
import typings.std.Int8Array
import typings.std.Uint16Array
import typings.std.Uint32Array
import typings.std.Uint8Array
import typings.std.Uint8ClampedArray
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.`|`
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object mod {
  
  object childProcess {
    
    @JSImport("mz", "child_process.exec")
    @js.native
    def exec(command: String): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "child_process.exec")
    @js.native
    def exec(
      command: String,
      callback: js.Function3[/* error */ ExecException | Null, /* stdout */ String, /* stderr */ String, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.exec")
    @js.native
    def exec(
      command: String,
      options: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          ExecException | Null, 
          Buffer | (/* stdout */ String), 
          Buffer | (/* stderr */ String), 
          Unit
        ]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.exec")
    @js.native
    def exec(
      command: String,
      options: Null,
      callback: js.Function3[
          ExecException | Null, 
          Buffer | (/* stdout */ String), 
          Buffer | (/* stderr */ String), 
          Unit
        ]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.exec")
    @js.native
    def exec(command: String, options: encodingBufferEncodingund): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "child_process.exec")
    @js.native
    def exec(
      command: String,
      options: encodingBufferEncodingund,
      callback: js.Function3[/* error */ ExecException | Null, /* stdout */ String, /* stderr */ String, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.exec")
    @js.native
    def exec(command: String, options: encodingbuffernullundefin): js.Promise[js.Tuple2[Buffer, Buffer]] = js.native
    @JSImport("mz", "child_process.exec")
    @js.native
    def exec(
      command: String,
      options: encodingbuffernullundefin,
      callback: js.Function3[/* error */ ExecException | Null, /* stdout */ Buffer, /* stderr */ Buffer, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.exec")
    @js.native
    def exec(command: String, options: encodingstringnullundefin): js.Promise[js.Tuple2[String | Buffer, String | Buffer]] = js.native
    @JSImport("mz", "child_process.exec")
    @js.native
    def exec(
      command: String,
      options: encodingstringnullundefin,
      callback: js.Function3[
          /* error */ ExecException | Null, 
          /* stdout */ String | Buffer, 
          /* stderr */ String | Buffer, 
          Unit
        ]
    ): ChildProcess = js.native
    
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.UndefOr[scala.Nothing],
      callback: js.Function3[Error | Null, Buffer | (/* stdout */ String), Buffer | (/* stderr */ String), Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.UndefOr[scala.Nothing],
      options: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* error */ Error | Null, 
          /* stdout */ String | Buffer, 
          /* stderr */ String | Buffer, 
          Unit
        ]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.UndefOr[scala.Nothing],
      options: Null,
      callback: js.Function3[
          /* error */ Error | Null, 
          /* stdout */ String | Buffer, 
          /* stderr */ String | Buffer, 
          Unit
        ]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: js.UndefOr[scala.Nothing], options: ExecFileOptionsWithBufferEncoding): js.Promise[js.Tuple2[Buffer, Buffer]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.UndefOr[scala.Nothing],
      options: ExecFileOptionsWithBufferEncoding,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ Buffer, /* stderr */ Buffer, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: js.UndefOr[scala.Nothing], options: ExecFileOptionsWithOtherEncoding): js.Promise[js.Tuple2[String | Buffer, String | Buffer]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.UndefOr[scala.Nothing],
      options: ExecFileOptionsWithOtherEncoding,
      callback: js.Function3[
          /* error */ Error | Null, 
          /* stdout */ String | Buffer, 
          /* stderr */ String | Buffer, 
          Unit
        ]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: js.UndefOr[scala.Nothing], options: ExecFileOptions): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: js.UndefOr[scala.Nothing], options: ExecFileOptionsWithStringEncoding): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.UndefOr[scala.Nothing],
      options: ExecFileOptionsWithStringEncoding,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ String, /* stderr */ String, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.UndefOr[scala.Nothing],
      options: ExecFileOptions,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ String, /* stderr */ String, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: js.Array[String]): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.Array[String],
      callback: js.Function3[/* error */ Error | Null, /* stdout */ String, /* stderr */ String, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.Array[String],
      options: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* error */ Error | Null, 
          /* stdout */ String | Buffer, 
          /* stderr */ String | Buffer, 
          Unit
        ]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.Array[String],
      options: Null,
      callback: js.Function3[
          /* error */ Error | Null, 
          /* stdout */ String | Buffer, 
          /* stderr */ String | Buffer, 
          Unit
        ]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: js.Array[String], options: ExecFileOptionsWithBufferEncoding): js.Promise[js.Tuple2[Buffer, Buffer]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.Array[String],
      options: ExecFileOptionsWithBufferEncoding,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ Buffer, /* stderr */ Buffer, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: js.Array[String], options: ExecFileOptionsWithOtherEncoding): js.Promise[js.Tuple2[String | Buffer, String | Buffer]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.Array[String],
      options: ExecFileOptionsWithOtherEncoding,
      callback: js.Function3[
          /* error */ Error | Null, 
          /* stdout */ String | Buffer, 
          /* stderr */ String | Buffer, 
          Unit
        ]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: js.Array[String], options: ExecFileOptions): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: js.Array[String], options: ExecFileOptionsWithStringEncoding): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.Array[String],
      options: ExecFileOptionsWithStringEncoding,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ String, /* stderr */ String, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: js.Array[String],
      options: ExecFileOptions,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ String, /* stderr */ String, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: Null,
      callback: js.Function3[Error | Null, Buffer | (/* stdout */ String), Buffer | (/* stderr */ String), Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: Null,
      options: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* error */ Error | Null, 
          /* stdout */ String | Buffer, 
          /* stderr */ String | Buffer, 
          Unit
        ]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: Null,
      options: Null,
      callback: js.Function3[
          /* error */ Error | Null, 
          /* stdout */ String | Buffer, 
          /* stderr */ String | Buffer, 
          Unit
        ]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: Null, options: ExecFileOptionsWithBufferEncoding): js.Promise[js.Tuple2[Buffer, Buffer]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: Null,
      options: ExecFileOptionsWithBufferEncoding,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ Buffer, /* stderr */ Buffer, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: Null, options: ExecFileOptionsWithOtherEncoding): js.Promise[js.Tuple2[String | Buffer, String | Buffer]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: Null,
      options: ExecFileOptionsWithOtherEncoding,
      callback: js.Function3[
          /* error */ Error | Null, 
          /* stdout */ String | Buffer, 
          /* stderr */ String | Buffer, 
          Unit
        ]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: Null, options: ExecFileOptions): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, args: Null, options: ExecFileOptionsWithStringEncoding): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: Null,
      options: ExecFileOptionsWithStringEncoding,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ String, /* stderr */ String, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      args: Null,
      options: ExecFileOptions,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ String, /* stderr */ String, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ String, /* stderr */ String, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, options: ExecFileOptionsWithBufferEncoding): js.Promise[js.Tuple2[Buffer, Buffer]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      options: ExecFileOptionsWithBufferEncoding,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ Buffer, /* stderr */ Buffer, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, options: ExecFileOptionsWithOtherEncoding): js.Promise[js.Tuple2[String | Buffer, String | Buffer]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      options: ExecFileOptionsWithOtherEncoding,
      callback: js.Function3[
          /* error */ Error | Null, 
          /* stdout */ String | Buffer, 
          /* stderr */ String | Buffer, 
          Unit
        ]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, options: ExecFileOptions): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(file: String, options: ExecFileOptionsWithStringEncoding): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      // `options` can't be mixed into `args`
    // tslint:disable-next-line: unified-signatures
    options: ExecFileOptionsWithStringEncoding,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ String, /* stderr */ String, Unit]
    ): ChildProcess = js.native
    @JSImport("mz", "child_process.execFile")
    @js.native
    def execFile(
      file: String,
      // `options` can't be mixed into `args`
    // tslint:disable-next-line: unified-signatures
    options: ExecFileOptions,
      callback: js.Function3[/* error */ Error | Null, /* stdout */ String, /* stderr */ String, Unit]
    ): ChildProcess = js.native
    
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync(command: String): String = js.native
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync(command: String, args: js.UndefOr[scala.Nothing], options: ExecFileSyncOptions): Buffer = js.native
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync(command: String, args: js.UndefOr[scala.Nothing], options: ExecFileSyncOptionsWithBufferEncoding): Buffer = js.native
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync(command: String, args: js.UndefOr[scala.Nothing], options: ExecFileSyncOptionsWithStringEncoding): String = js.native
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync(command: String, args: js.Array[String]): String = js.native
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync(command: String, args: js.Array[String], options: ExecFileSyncOptions): Buffer = js.native
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync(command: String, args: js.Array[String], options: ExecFileSyncOptionsWithBufferEncoding): Buffer = js.native
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync(command: String, args: js.Array[String], options: ExecFileSyncOptionsWithStringEncoding): String = js.native
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync(command: String, options: ExecFileSyncOptions): Buffer = js.native
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync(command: String, options: ExecFileSyncOptionsWithBufferEncoding): Buffer = js.native
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync(command: String, options: ExecFileSyncOptionsWithStringEncoding): String = js.native
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync_Buffer(command: String): Buffer = js.native
    @JSImport("mz", "child_process.execFileSync")
    @js.native
    def execFileSync_Buffer(command: String, args: js.Array[String]): Buffer = js.native
    
    @JSImport("mz", "child_process.execSync")
    @js.native
    def execSync(command: String): String = js.native
    @JSImport("mz", "child_process.execSync")
    @js.native
    def execSync(command: String, options: ExecSyncOptions): Buffer = js.native
    @JSImport("mz", "child_process.execSync")
    @js.native
    def execSync(command: String, options: ExecSyncOptionsWithBufferEncoding): Buffer = js.native
    @JSImport("mz", "child_process.execSync")
    @js.native
    def execSync(command: String, options: ExecSyncOptionsWithStringEncoding): String = js.native
    @JSImport("mz", "child_process.execSync")
    @js.native
    def execSync_Buffer(command: String): Buffer = js.native
    
    @JSImport("mz", "child_process.fork")
    @js.native
    def fork(modulePath: String): ChildProcess = js.native
    @JSImport("mz", "child_process.fork")
    @js.native
    def fork(modulePath: String, args: js.UndefOr[scala.Nothing], options: ForkOptions): ChildProcess = js.native
    @JSImport("mz", "child_process.fork")
    @js.native
    def fork(modulePath: String, args: js.Array[String]): ChildProcess = js.native
    @JSImport("mz", "child_process.fork")
    @js.native
    def fork(modulePath: String, args: js.Array[String], options: ForkOptions): ChildProcess = js.native
    @JSImport("mz", "child_process.fork")
    @js.native
    def fork(modulePath: String, options: ForkOptions): ChildProcess = js.native
    
    // overloads of spawn without 'args'
    @JSImport("mz", "child_process.spawn")
    @js.native
    def spawn(command: String): ChildProcessWithoutNullStreams = js.native
    @JSImport("mz", "child_process.spawn")
    @js.native
    def spawn(command: String, args: js.UndefOr[scala.Nothing], options: SpawnOptionsWithoutStdio): ChildProcessWithoutNullStreams = js.native
    @JSImport("mz", "child_process.spawn")
    @js.native
    def spawn(command: String, args: js.Array[String]): ChildProcessWithoutNullStreams = js.native
    @JSImport("mz", "child_process.spawn")
    @js.native
    def spawn(command: String, args: js.Array[String], options: SpawnOptions): ChildProcess = js.native
    @JSImport("mz", "child_process.spawn")
    @js.native
    def spawn(
      command: String,
      args: js.Array[String],
      options: SpawnOptionsWithStdioTuple[StdioNull | StdioPipe, StdioNull | StdioPipe, StdioNull | StdioPipe]
    ): ChildProcessByStdio[Writable, Readable, Readable] = js.native
    @JSImport("mz", "child_process.spawn")
    @js.native
    def spawn(command: String, args: js.Array[String], options: SpawnOptionsWithoutStdio): ChildProcessWithoutNullStreams = js.native
    @JSImport("mz", "child_process.spawn")
    @js.native
    def spawn(command: String, options: SpawnOptions): ChildProcess = js.native
    @JSImport("mz", "child_process.spawn")
    @js.native
    def spawn(
      command: String,
      options: SpawnOptionsWithStdioTuple[StdioNull | StdioPipe, StdioNull | StdioPipe, StdioNull | StdioPipe]
    ): ChildProcessByStdio[Writable, Readable, Readable] = js.native
    @JSImport("mz", "child_process.spawn")
    @js.native
    def spawn(command: String, options: SpawnOptionsWithoutStdio): ChildProcessWithoutNullStreams = js.native
    
    @JSImport("mz", "child_process.spawnSync")
    @js.native
    def spawnSync(command: String): SpawnSyncReturns[Buffer] = js.native
    @JSImport("mz", "child_process.spawnSync")
    @js.native
    def spawnSync(command: String, args: js.UndefOr[scala.Nothing], options: SpawnSyncOptions): SpawnSyncReturns[Buffer] = js.native
    @JSImport("mz", "child_process.spawnSync")
    @js.native
    def spawnSync(command: String, args: js.UndefOr[scala.Nothing], options: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns[Buffer] = js.native
    @JSImport("mz", "child_process.spawnSync")
    @js.native
    def spawnSync(command: String, args: js.UndefOr[scala.Nothing], options: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns[String] = js.native
    @JSImport("mz", "child_process.spawnSync")
    @js.native
    def spawnSync(command: String, args: js.Array[String]): SpawnSyncReturns[String] = js.native
    @JSImport("mz", "child_process.spawnSync")
    @js.native
    def spawnSync(command: String, args: js.Array[String], options: SpawnSyncOptions): SpawnSyncReturns[Buffer] = js.native
    @JSImport("mz", "child_process.spawnSync")
    @js.native
    def spawnSync(command: String, args: js.Array[String], options: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns[Buffer] = js.native
    @JSImport("mz", "child_process.spawnSync")
    @js.native
    def spawnSync(command: String, args: js.Array[String], options: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns[String] = js.native
    @JSImport("mz", "child_process.spawnSync")
    @js.native
    def spawnSync(command: String, options: SpawnSyncOptions): SpawnSyncReturns[Buffer] = js.native
    @JSImport("mz", "child_process.spawnSync")
    @js.native
    def spawnSync(command: String, options: SpawnSyncOptionsWithBufferEncoding): SpawnSyncReturns[Buffer] = js.native
    @JSImport("mz", "child_process.spawnSync")
    @js.native
    def spawnSync(command: String, options: SpawnSyncOptionsWithStringEncoding): SpawnSyncReturns[String] = js.native
  }
  
  object crypto {
    
    @JSImport("mz", "crypto.Certificate")
    @js.native
    def Certificate(): typings.node.cryptoMod.Certificate = js.native
    
    /* This class was inferred from a value with a constructor, it was renamed because a distinct type already exists with the same name. */
    @JSImport("mz", "crypto.CertificateCls")
    @js.native
    class CertificateCls ()
      extends typings.mz.cryptoMod.CertificateCls
    
    @JSImport("mz", "crypto.Cipher")
    @js.native
    class Cipher protected ()
      extends typings.mz.cryptoMod.Cipher
    
    /** @deprecated since v10.0.0 */
    @JSImport("mz", "crypto.DEFAULT_ENCODING")
    @js.native
    val DEFAULT_ENCODING: BufferEncoding = js.native
    
    @JSImport("mz", "crypto.Decipher")
    @js.native
    class Decipher protected ()
      extends typings.mz.cryptoMod.Decipher
    
    @JSImport("mz", "crypto.DiffieHellman")
    @js.native
    class DiffieHellman_ protected ()
      extends typings.mz.cryptoMod.DiffieHellman_
    
    @JSImport("mz", "crypto.ECDH")
    @js.native
    class ECDH protected ()
      extends typings.mz.cryptoMod.ECDH
    object ECDH {
      
      /* static member */
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(key: BinaryLike, curve: String): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: js.UndefOr[scala.Nothing],
        outputEncoding: base64,
        format: compressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: js.UndefOr[scala.Nothing],
        outputEncoding: base64,
        format: hybrid
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: js.UndefOr[scala.Nothing],
        outputEncoding: base64,
        format: uncompressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: js.UndefOr[scala.Nothing],
        outputEncoding: hex,
        format: compressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: js.UndefOr[scala.Nothing],
        outputEncoding: hex,
        format: hybrid
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: js.UndefOr[scala.Nothing],
        outputEncoding: hex,
        format: uncompressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: js.UndefOr[scala.Nothing],
        outputEncoding: latin1,
        format: compressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: js.UndefOr[scala.Nothing],
        outputEncoding: latin1,
        format: hybrid
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: js.UndefOr[scala.Nothing],
        outputEncoding: latin1,
        format: uncompressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(key: BinaryLike, curve: String, inputEncoding: HexBase64Latin1Encoding): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: HexBase64Latin1Encoding,
        outputEncoding: base64,
        format: compressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: HexBase64Latin1Encoding,
        outputEncoding: base64,
        format: hybrid
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: HexBase64Latin1Encoding,
        outputEncoding: base64,
        format: uncompressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: HexBase64Latin1Encoding,
        outputEncoding: hex,
        format: compressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: HexBase64Latin1Encoding,
        outputEncoding: hex,
        format: hybrid
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: HexBase64Latin1Encoding,
        outputEncoding: hex,
        format: uncompressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: HexBase64Latin1Encoding,
        outputEncoding: latin1,
        format: compressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: HexBase64Latin1Encoding,
        outputEncoding: latin1,
        format: hybrid
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey(
        key: BinaryLike,
        curve: String,
        inputEncoding: HexBase64Latin1Encoding,
        outputEncoding: latin1,
        format: uncompressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey_base64(key: BinaryLike, curve: String, inputEncoding: js.UndefOr[scala.Nothing], outputEncoding: base64): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey_base64(key: BinaryLike, curve: String, inputEncoding: HexBase64Latin1Encoding, outputEncoding: base64): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey_compressed(
        key: BinaryLike,
        curve: String,
        inputEncoding: js.UndefOr[scala.Nothing],
        outputEncoding: js.UndefOr[scala.Nothing],
        format: compressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey_compressed(
        key: BinaryLike,
        curve: String,
        inputEncoding: HexBase64Latin1Encoding,
        outputEncoding: js.UndefOr[scala.Nothing],
        format: compressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey_hex(key: BinaryLike, curve: String, inputEncoding: js.UndefOr[scala.Nothing], outputEncoding: hex): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey_hex(key: BinaryLike, curve: String, inputEncoding: HexBase64Latin1Encoding, outputEncoding: hex): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey_hybrid(
        key: BinaryLike,
        curve: String,
        inputEncoding: js.UndefOr[scala.Nothing],
        outputEncoding: js.UndefOr[scala.Nothing],
        format: hybrid
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey_hybrid(
        key: BinaryLike,
        curve: String,
        inputEncoding: HexBase64Latin1Encoding,
        outputEncoding: js.UndefOr[scala.Nothing],
        format: hybrid
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey_latin1(key: BinaryLike, curve: String, inputEncoding: js.UndefOr[scala.Nothing], outputEncoding: latin1): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey_latin1(key: BinaryLike, curve: String, inputEncoding: HexBase64Latin1Encoding, outputEncoding: latin1): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey_uncompressed(
        key: BinaryLike,
        curve: String,
        inputEncoding: js.UndefOr[scala.Nothing],
        outputEncoding: js.UndefOr[scala.Nothing],
        format: uncompressed
      ): Buffer | String = js.native
      @JSImport("mz", "crypto.ECDH.convertKey")
      @js.native
      def convertKey_uncompressed(
        key: BinaryLike,
        curve: String,
        inputEncoding: HexBase64Latin1Encoding,
        outputEncoding: js.UndefOr[scala.Nothing],
        format: uncompressed
      ): Buffer | String = js.native
    }
    
    @JSImport("mz", "crypto.Hash")
    @js.native
    class Hash protected ()
      extends typings.mz.cryptoMod.Hash
    
    @JSImport("mz", "crypto.Hmac")
    @js.native
    class Hmac protected ()
      extends typings.mz.cryptoMod.Hmac
    
    @JSImport("mz", "crypto.KeyObject")
    @js.native
    class KeyObject protected ()
      extends typings.mz.cryptoMod.KeyObject
    
    @JSImport("mz", "crypto.Signer")
    @js.native
    class Signer protected ()
      extends typings.mz.cryptoMod.Signer
    
    @JSImport("mz", "crypto.Verify")
    @js.native
    class Verify_ protected ()
      extends typings.mz.cryptoMod.Verify_
    
    object constants {
      
      @JSImport("mz", "crypto.constants.ALPN_ENABLED")
      @js.native
      val ALPN_ENABLED: Double = js.native
      
      @JSImport("mz", "crypto.constants.DH_CHECK_P_NOT_PRIME")
      @js.native
      val DH_CHECK_P_NOT_PRIME: Double = js.native
      
      @JSImport("mz", "crypto.constants.DH_CHECK_P_NOT_SAFE_PRIME")
      @js.native
      val DH_CHECK_P_NOT_SAFE_PRIME: Double = js.native
      
      @JSImport("mz", "crypto.constants.DH_NOT_SUITABLE_GENERATOR")
      @js.native
      val DH_NOT_SUITABLE_GENERATOR: Double = js.native
      
      @JSImport("mz", "crypto.constants.DH_UNABLE_TO_CHECK_GENERATOR")
      @js.native
      val DH_UNABLE_TO_CHECK_GENERATOR: Double = js.native
      
      @JSImport("mz", "crypto.constants.ENGINE_METHOD_ALL")
      @js.native
      val ENGINE_METHOD_ALL: Double = js.native
      
      @JSImport("mz", "crypto.constants.ENGINE_METHOD_CIPHERS")
      @js.native
      val ENGINE_METHOD_CIPHERS: Double = js.native
      
      @JSImport("mz", "crypto.constants.ENGINE_METHOD_DH")
      @js.native
      val ENGINE_METHOD_DH: Double = js.native
      
      @JSImport("mz", "crypto.constants.ENGINE_METHOD_DIGESTS")
      @js.native
      val ENGINE_METHOD_DIGESTS: Double = js.native
      
      @JSImport("mz", "crypto.constants.ENGINE_METHOD_DSA")
      @js.native
      val ENGINE_METHOD_DSA: Double = js.native
      
      @JSImport("mz", "crypto.constants.ENGINE_METHOD_EC")
      @js.native
      val ENGINE_METHOD_EC: Double = js.native
      
      @JSImport("mz", "crypto.constants.ENGINE_METHOD_NONE")
      @js.native
      val ENGINE_METHOD_NONE: Double = js.native
      
      @JSImport("mz", "crypto.constants.ENGINE_METHOD_PKEY_ASN1_METHS")
      @js.native
      val ENGINE_METHOD_PKEY_ASN1_METHS: Double = js.native
      
      @JSImport("mz", "crypto.constants.ENGINE_METHOD_PKEY_METHS")
      @js.native
      val ENGINE_METHOD_PKEY_METHS: Double = js.native
      
      @JSImport("mz", "crypto.constants.ENGINE_METHOD_RAND")
      @js.native
      val ENGINE_METHOD_RAND: Double = js.native
      
      @JSImport("mz", "crypto.constants.ENGINE_METHOD_RSA")
      @js.native
      val ENGINE_METHOD_RSA: Double = js.native
      
      // https://nodejs.org/dist/latest-v10.x/docs/api/crypto.html#crypto_crypto_constants
      @JSImport("mz", "crypto.constants.OPENSSL_VERSION_NUMBER")
      @js.native
      val OPENSSL_VERSION_NUMBER: Double = js.native
      
      @JSImport("mz", "crypto.constants.POINT_CONVERSION_COMPRESSED")
      @js.native
      val POINT_CONVERSION_COMPRESSED: Double = js.native
      
      @JSImport("mz", "crypto.constants.POINT_CONVERSION_HYBRID")
      @js.native
      val POINT_CONVERSION_HYBRID: Double = js.native
      
      @JSImport("mz", "crypto.constants.POINT_CONVERSION_UNCOMPRESSED")
      @js.native
      val POINT_CONVERSION_UNCOMPRESSED: Double = js.native
      
      @JSImport("mz", "crypto.constants.RSA_NO_PADDING")
      @js.native
      val RSA_NO_PADDING: Double = js.native
      
      @JSImport("mz", "crypto.constants.RSA_PKCS1_OAEP_PADDING")
      @js.native
      val RSA_PKCS1_OAEP_PADDING: Double = js.native
      
      @JSImport("mz", "crypto.constants.RSA_PKCS1_PADDING")
      @js.native
      val RSA_PKCS1_PADDING: Double = js.native
      
      @JSImport("mz", "crypto.constants.RSA_PKCS1_PSS_PADDING")
      @js.native
      val RSA_PKCS1_PSS_PADDING: Double = js.native
      
      /** Causes the salt length for RSA_PKCS1_PSS_PADDING to be determined automatically when verifying a signature. */
      @JSImport("mz", "crypto.constants.RSA_PSS_SALTLEN_AUTO")
      @js.native
      val RSA_PSS_SALTLEN_AUTO: Double = js.native
      
      /** Sets the salt length for RSA_PKCS1_PSS_PADDING to the digest size when signing or verifying. */
      @JSImport("mz", "crypto.constants.RSA_PSS_SALTLEN_DIGEST")
      @js.native
      val RSA_PSS_SALTLEN_DIGEST: Double = js.native
      
      /** Sets the salt length for RSA_PKCS1_PSS_PADDING to the maximum permissible value when signing data. */
      @JSImport("mz", "crypto.constants.RSA_PSS_SALTLEN_MAX_SIGN")
      @js.native
      val RSA_PSS_SALTLEN_MAX_SIGN: Double = js.native
      
      @JSImport("mz", "crypto.constants.RSA_SSLV23_PADDING")
      @js.native
      val RSA_SSLV23_PADDING: Double = js.native
      
      @JSImport("mz", "crypto.constants.RSA_X931_PADDING")
      @js.native
      val RSA_X931_PADDING: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_NO_SSLv2")
      @js.native
      val SSLOPNOSSLv2: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_NO_SSLv3")
      @js.native
      val SSLOPNOSSLv3: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_NO_TLSv1")
      @js.native
      val SSLOPNOTLSv1: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_NO_TLSv1_1")
      @js.native
      val SSLOPNOTLSv11: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_NO_TLSv1_2")
      @js.native
      val SSLOPNOTLSv12: Double = js.native
      
      /** Applies multiple bug workarounds within OpenSSL. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html for detail. */
      @JSImport("mz", "crypto.constants.SSL_OP_ALL")
      @js.native
      val SSL_OP_ALL: Double = js.native
      
      /** Allows legacy insecure renegotiation between OpenSSL and unpatched clients or servers. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html. */
      @JSImport("mz", "crypto.constants.SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION")
      @js.native
      val SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: Double = js.native
      
      /** Attempts to use the server's preferences instead of the client's when selecting a cipher. See https://www.openssl.org/docs/man1.0.2/ssl/SSL_CTX_set_options.html. */
      @JSImport("mz", "crypto.constants.SSL_OP_CIPHER_SERVER_PREFERENCE")
      @js.native
      val SSL_OP_CIPHER_SERVER_PREFERENCE: Double = js.native
      
      /** Instructs OpenSSL to use Cisco's "speshul" version of DTLS_BAD_VER. */
      @JSImport("mz", "crypto.constants.SSL_OP_CISCO_ANYCONNECT")
      @js.native
      val SSL_OP_CISCO_ANYCONNECT: Double = js.native
      
      /** Instructs OpenSSL to turn on cookie exchange. */
      @JSImport("mz", "crypto.constants.SSL_OP_COOKIE_EXCHANGE")
      @js.native
      val SSL_OP_COOKIE_EXCHANGE: Double = js.native
      
      /** Instructs OpenSSL to add server-hello extension from an early version of the cryptopro draft. */
      @JSImport("mz", "crypto.constants.SSL_OP_CRYPTOPRO_TLSEXT_BUG")
      @js.native
      val SSL_OP_CRYPTOPRO_TLSEXT_BUG: Double = js.native
      
      /** Instructs OpenSSL to disable a SSL 3.0/TLS 1.0 vulnerability workaround added in OpenSSL 0.9.6d. */
      @JSImport("mz", "crypto.constants.SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS")
      @js.native
      val SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: Double = js.native
      
      /** Instructs OpenSSL to always use the tmp_rsa key when performing RSA operations. */
      @JSImport("mz", "crypto.constants.SSL_OP_EPHEMERAL_RSA")
      @js.native
      val SSL_OP_EPHEMERAL_RSA: Double = js.native
      
      /** Allows initial connection to servers that do not support RI. */
      @JSImport("mz", "crypto.constants.SSL_OP_LEGACY_SERVER_CONNECT")
      @js.native
      val SSL_OP_LEGACY_SERVER_CONNECT: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER")
      @js.native
      val SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_MICROSOFT_SESS_ID_BUG")
      @js.native
      val SSL_OP_MICROSOFT_SESS_ID_BUG: Double = js.native
      
      /** Instructs OpenSSL to disable the workaround for a man-in-the-middle protocol-version vulnerability in the SSL 2.0 server implementation. */
      @JSImport("mz", "crypto.constants.SSL_OP_MSIE_SSLV2_RSA_PADDING")
      @js.native
      val SSL_OP_MSIE_SSLV2_RSA_PADDING: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_NETSCAPE_CA_DN_BUG")
      @js.native
      val SSL_OP_NETSCAPE_CA_DN_BUG: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_NETSCAPE_CHALLENGE_BUG")
      @js.native
      val SSL_OP_NETSCAPE_CHALLENGE_BUG: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG")
      @js.native
      val SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG")
      @js.native
      val SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: Double = js.native
      
      /** Instructs OpenSSL to disable support for SSL/TLS compression. */
      @JSImport("mz", "crypto.constants.SSL_OP_NO_COMPRESSION")
      @js.native
      val SSL_OP_NO_COMPRESSION: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_NO_QUERY_MTU")
      @js.native
      val SSL_OP_NO_QUERY_MTU: Double = js.native
      
      /** Instructs OpenSSL to always start a new session when performing renegotiation. */
      @JSImport("mz", "crypto.constants.SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION")
      @js.native
      val SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_NO_TICKET")
      @js.native
      val SSL_OP_NO_TICKET: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_PKCS1_CHECK_1")
      @js.native
      val SSL_OP_PKCS1_CHECK_1: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_PKCS1_CHECK_2")
      @js.native
      val SSL_OP_PKCS1_CHECK_2: Double = js.native
      
      /** Instructs OpenSSL to always create a new key when using temporary/ephemeral DH parameters. */
      @JSImport("mz", "crypto.constants.SSL_OP_SINGLE_DH_USE")
      @js.native
      val SSL_OP_SINGLE_DH_USE: Double = js.native
      
      /** Instructs OpenSSL to always create a new key when using temporary/ephemeral ECDH parameters. */
      @JSImport("mz", "crypto.constants.SSL_OP_SINGLE_ECDH_USE")
      @js.native
      val SSL_OP_SINGLE_ECDH_USE: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_SSLEAY_080_CLIENT_DH_BUG")
      @js.native
      val SSL_OP_SSLEAY_080_CLIENT_DH_BUG: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG")
      @js.native
      val SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_TLS_BLOCK_PADDING_BUG")
      @js.native
      val SSL_OP_TLS_BLOCK_PADDING_BUG: Double = js.native
      
      @JSImport("mz", "crypto.constants.SSL_OP_TLS_D5_BUG")
      @js.native
      val SSL_OP_TLS_D5_BUG: Double = js.native
      
      /** Instructs OpenSSL to disable version rollback attack detection. */
      @JSImport("mz", "crypto.constants.SSL_OP_TLS_ROLLBACK_BUG")
      @js.native
      val SSL_OP_TLS_ROLLBACK_BUG: Double = js.native
      
      /** Specifies the active default cipher list used by the current Node.js process  (colon-separated values). */
      @JSImport("mz", "crypto.constants.defaultCipherList")
      @js.native
      val defaultCipherList: String = js.native
      
      /** Specifies the built-in default cipher list used by Node.js (colon-separated values). */
      @JSImport("mz", "crypto.constants.defaultCoreCipherList")
      @js.native
      val defaultCoreCipherList: String = js.native
    }
    
    /** @deprecated since v10.0.0 use `createCipheriv()` */
    @JSImport("mz", "crypto.createCipher")
    @js.native
    def createCipher(algorithm: String, password: BinaryLike): typings.node.cryptoMod.Cipher = js.native
    @JSImport("mz", "crypto.createCipher")
    @js.native
    def createCipher(algorithm: String, password: BinaryLike, options: TransformOptions): typings.node.cryptoMod.Cipher = js.native
    /** @deprecated since v10.0.0 use `createCipheriv()` */
    @JSImport("mz", "crypto.createCipher")
    @js.native
    def createCipher(algorithm: CipherCCMTypes, password: BinaryLike, options: CipherCCMOptions): CipherCCM = js.native
    /** @deprecated since v10.0.0 use `createCipheriv()` */
    @JSImport("mz", "crypto.createCipher")
    @js.native
    def createCipher(algorithm: CipherGCMTypes, password: BinaryLike): CipherGCM = js.native
    @JSImport("mz", "crypto.createCipher")
    @js.native
    def createCipher(algorithm: CipherGCMTypes, password: BinaryLike, options: CipherGCMOptions): CipherGCM = js.native
    
    @JSImport("mz", "crypto.createCipheriv")
    @js.native
    def createCipheriv(algorithm: String, key: CipherKey): typings.node.cryptoMod.Cipher = js.native
    @JSImport("mz", "crypto.createCipheriv")
    @js.native
    def createCipheriv(algorithm: String, key: CipherKey, iv: Null, options: TransformOptions): typings.node.cryptoMod.Cipher = js.native
    @JSImport("mz", "crypto.createCipheriv")
    @js.native
    def createCipheriv(algorithm: String, key: CipherKey, iv: BinaryLike): typings.node.cryptoMod.Cipher = js.native
    @JSImport("mz", "crypto.createCipheriv")
    @js.native
    def createCipheriv(algorithm: String, key: CipherKey, iv: BinaryLike, options: TransformOptions): typings.node.cryptoMod.Cipher = js.native
    @JSImport("mz", "crypto.createCipheriv")
    @js.native
    def createCipheriv(algorithm: CipherCCMTypes, key: CipherKey, iv: Null, options: CipherCCMOptions): CipherCCM = js.native
    @JSImport("mz", "crypto.createCipheriv")
    @js.native
    def createCipheriv(algorithm: CipherCCMTypes, key: CipherKey, iv: BinaryLike, options: CipherCCMOptions): CipherCCM = js.native
    @JSImport("mz", "crypto.createCipheriv")
    @js.native
    def createCipheriv(algorithm: CipherGCMTypes, key: CipherKey): CipherGCM = js.native
    @JSImport("mz", "crypto.createCipheriv")
    @js.native
    def createCipheriv(algorithm: CipherGCMTypes, key: CipherKey, iv: Null, options: CipherGCMOptions): CipherGCM = js.native
    @JSImport("mz", "crypto.createCipheriv")
    @js.native
    def createCipheriv(algorithm: CipherGCMTypes, key: CipherKey, iv: BinaryLike): CipherGCM = js.native
    @JSImport("mz", "crypto.createCipheriv")
    @js.native
    def createCipheriv(algorithm: CipherGCMTypes, key: CipherKey, iv: BinaryLike, options: CipherGCMOptions): CipherGCM = js.native
    
    /** @deprecated since v10.0.0 use `createDecipheriv()` */
    @JSImport("mz", "crypto.createDecipher")
    @js.native
    def createDecipher(algorithm: String, password: BinaryLike): typings.node.cryptoMod.Decipher = js.native
    @JSImport("mz", "crypto.createDecipher")
    @js.native
    def createDecipher(algorithm: String, password: BinaryLike, options: TransformOptions): typings.node.cryptoMod.Decipher = js.native
    /** @deprecated since v10.0.0 use `createDecipheriv()` */
    @JSImport("mz", "crypto.createDecipher")
    @js.native
    def createDecipher(algorithm: CipherCCMTypes, password: BinaryLike, options: CipherCCMOptions): DecipherCCM = js.native
    /** @deprecated since v10.0.0 use `createDecipheriv()` */
    @JSImport("mz", "crypto.createDecipher")
    @js.native
    def createDecipher(algorithm: CipherGCMTypes, password: BinaryLike): DecipherGCM = js.native
    @JSImport("mz", "crypto.createDecipher")
    @js.native
    def createDecipher(algorithm: CipherGCMTypes, password: BinaryLike, options: CipherGCMOptions): DecipherGCM = js.native
    
    @JSImport("mz", "crypto.createDecipheriv")
    @js.native
    def createDecipheriv(algorithm: String, key: CipherKey): typings.node.cryptoMod.Decipher = js.native
    @JSImport("mz", "crypto.createDecipheriv")
    @js.native
    def createDecipheriv(algorithm: String, key: CipherKey, iv: Null, options: TransformOptions): typings.node.cryptoMod.Decipher = js.native
    @JSImport("mz", "crypto.createDecipheriv")
    @js.native
    def createDecipheriv(algorithm: String, key: CipherKey, iv: BinaryLike): typings.node.cryptoMod.Decipher = js.native
    @JSImport("mz", "crypto.createDecipheriv")
    @js.native
    def createDecipheriv(algorithm: String, key: CipherKey, iv: BinaryLike, options: TransformOptions): typings.node.cryptoMod.Decipher = js.native
    @JSImport("mz", "crypto.createDecipheriv")
    @js.native
    def createDecipheriv(algorithm: CipherCCMTypes, key: CipherKey, iv: Null, options: CipherCCMOptions): DecipherCCM = js.native
    @JSImport("mz", "crypto.createDecipheriv")
    @js.native
    def createDecipheriv(algorithm: CipherCCMTypes, key: CipherKey, iv: BinaryLike, options: CipherCCMOptions): DecipherCCM = js.native
    @JSImport("mz", "crypto.createDecipheriv")
    @js.native
    def createDecipheriv(algorithm: CipherGCMTypes, key: CipherKey): DecipherGCM = js.native
    @JSImport("mz", "crypto.createDecipheriv")
    @js.native
    def createDecipheriv(algorithm: CipherGCMTypes, key: CipherKey, iv: Null, options: CipherGCMOptions): DecipherGCM = js.native
    @JSImport("mz", "crypto.createDecipheriv")
    @js.native
    def createDecipheriv(algorithm: CipherGCMTypes, key: CipherKey, iv: BinaryLike): DecipherGCM = js.native
    @JSImport("mz", "crypto.createDecipheriv")
    @js.native
    def createDecipheriv(algorithm: CipherGCMTypes, key: CipherKey, iv: BinaryLike, options: CipherGCMOptions): DecipherGCM = js.native
    
    @JSImport("mz", "crypto.createDiffieHellman")
    @js.native
    def createDiffieHellman(prime_length: Double): typings.node.cryptoMod.DiffieHellman_ = js.native
    @JSImport("mz", "crypto.createDiffieHellman")
    @js.native
    def createDiffieHellman(prime_length: Double, generator: Double): typings.node.cryptoMod.DiffieHellman_ = js.native
    @JSImport("mz", "crypto.createDiffieHellman")
    @js.native
    def createDiffieHellman(prime_length: Double, generator: ArrayBufferView): typings.node.cryptoMod.DiffieHellman_ = js.native
    @JSImport("mz", "crypto.createDiffieHellman")
    @js.native
    def createDiffieHellman(prime: String, prime_encoding: HexBase64Latin1Encoding): typings.node.cryptoMod.DiffieHellman_ = js.native
    @JSImport("mz", "crypto.createDiffieHellman")
    @js.native
    def createDiffieHellman(
      prime: String,
      prime_encoding: HexBase64Latin1Encoding,
      generator: String,
      generator_encoding: HexBase64Latin1Encoding
    ): typings.node.cryptoMod.DiffieHellman_ = js.native
    @JSImport("mz", "crypto.createDiffieHellman")
    @js.native
    def createDiffieHellman(prime: String, prime_encoding: HexBase64Latin1Encoding, generator: Double): typings.node.cryptoMod.DiffieHellman_ = js.native
    @JSImport("mz", "crypto.createDiffieHellman")
    @js.native
    def createDiffieHellman(prime: String, prime_encoding: HexBase64Latin1Encoding, generator: ArrayBufferView): typings.node.cryptoMod.DiffieHellman_ = js.native
    @JSImport("mz", "crypto.createDiffieHellman")
    @js.native
    def createDiffieHellman(prime: ArrayBufferView): typings.node.cryptoMod.DiffieHellman_ = js.native
    
    @JSImport("mz", "crypto.createECDH")
    @js.native
    def createECDH(curve_name: String): typings.node.cryptoMod.ECDH = js.native
    
    @JSImport("mz", "crypto.createHash")
    @js.native
    def createHash(algorithm: String): typings.node.cryptoMod.Hash = js.native
    @JSImport("mz", "crypto.createHash")
    @js.native
    def createHash(algorithm: String, options: HashOptions): typings.node.cryptoMod.Hash = js.native
    
    @JSImport("mz", "crypto.createHmac")
    @js.native
    def createHmac(algorithm: String, key: BinaryLike): typings.node.cryptoMod.Hmac = js.native
    @JSImport("mz", "crypto.createHmac")
    @js.native
    def createHmac(algorithm: String, key: BinaryLike, options: TransformOptions): typings.node.cryptoMod.Hmac = js.native
    @JSImport("mz", "crypto.createHmac")
    @js.native
    def createHmac(algorithm: String, key: typings.node.cryptoMod.KeyObject): typings.node.cryptoMod.Hmac = js.native
    @JSImport("mz", "crypto.createHmac")
    @js.native
    def createHmac(algorithm: String, key: typings.node.cryptoMod.KeyObject, options: TransformOptions): typings.node.cryptoMod.Hmac = js.native
    
    @JSImport("mz", "crypto.createPrivateKey")
    @js.native
    def createPrivateKey(key: String): typings.node.cryptoMod.KeyObject = js.native
    @JSImport("mz", "crypto.createPrivateKey")
    @js.native
    def createPrivateKey(key: Buffer): typings.node.cryptoMod.KeyObject = js.native
    @JSImport("mz", "crypto.createPrivateKey")
    @js.native
    def createPrivateKey(key: PrivateKeyInput): typings.node.cryptoMod.KeyObject = js.native
    
    @JSImport("mz", "crypto.createPublicKey")
    @js.native
    def createPublicKey(key: String): typings.node.cryptoMod.KeyObject = js.native
    @JSImport("mz", "crypto.createPublicKey")
    @js.native
    def createPublicKey(key: Buffer): typings.node.cryptoMod.KeyObject = js.native
    @JSImport("mz", "crypto.createPublicKey")
    @js.native
    def createPublicKey(key: typings.node.cryptoMod.KeyObject): typings.node.cryptoMod.KeyObject = js.native
    @JSImport("mz", "crypto.createPublicKey")
    @js.native
    def createPublicKey(key: PublicKeyInput): typings.node.cryptoMod.KeyObject = js.native
    
    @JSImport("mz", "crypto.createSecretKey")
    @js.native
    def createSecretKey(key: ArrayBufferView): typings.node.cryptoMod.KeyObject = js.native
    
    @JSImport("mz", "crypto.createSign")
    @js.native
    def createSign(algorithm: String): typings.node.cryptoMod.Signer = js.native
    @JSImport("mz", "crypto.createSign")
    @js.native
    def createSign(algorithm: String, options: WritableOptions): typings.node.cryptoMod.Signer = js.native
    
    @JSImport("mz", "crypto.createVerify")
    @js.native
    def createVerify(algorithm: String): typings.node.cryptoMod.Verify_ = js.native
    @JSImport("mz", "crypto.createVerify")
    @js.native
    def createVerify(algorithm: String, options: WritableOptions): typings.node.cryptoMod.Verify_ = js.native
    
    /**
      * Computes the Diffie-Hellman secret based on a privateKey and a publicKey.
      * Both keys must have the same asymmetricKeyType, which must be one of
      * 'dh' (for Diffie-Hellman), 'ec' (for ECDH), 'x448', or 'x25519' (for ECDH-ES).
      */
    @JSImport("mz", "crypto.diffieHellman")
    @js.native
    def diffieHellman(options: PrivateKey): Buffer = js.native
    
    /** @deprecated since v10.0.0 */
    @JSImport("mz", "crypto.fips")
    @js.native
    val fips: Boolean = js.native
    
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: dsa,
      options: DSAKeyPairKeyObjectOptions,
      callback: js.Function3[
          /* err */ Error | Null, 
          /* publicKey */ typings.node.cryptoMod.KeyObject, 
          /* privateKey */ typings.node.cryptoMod.KeyObject, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: dsa,
      options: DSAKeyPairOptions[der | pem, der | pem],
      callback: js.Function3[
          Error | Null, 
          (/* publicKey */ Buffer) | (/* publicKey */ String), 
          (/* privateKey */ Buffer) | (/* privateKey */ String), 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: ec,
      options: ECKeyPairKeyObjectOptions,
      callback: js.Function3[
          /* err */ Error | Null, 
          /* publicKey */ typings.node.cryptoMod.KeyObject, 
          /* privateKey */ typings.node.cryptoMod.KeyObject, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: ec,
      options: ECKeyPairOptions[der | pem, der | pem],
      callback: js.Function3[
          Error | Null, 
          (/* publicKey */ Buffer) | (/* publicKey */ String), 
          (/* privateKey */ Buffer) | (/* privateKey */ String), 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: ed25519,
      options: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ Error | Null, 
          /* publicKey */ typings.node.cryptoMod.KeyObject, 
          /* privateKey */ typings.node.cryptoMod.KeyObject, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: ed25519,
      options: ED25519KeyPairKeyObjectOptions,
      callback: js.Function3[
          /* err */ Error | Null, 
          /* publicKey */ typings.node.cryptoMod.KeyObject, 
          /* privateKey */ typings.node.cryptoMod.KeyObject, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: ed25519,
      options: ED25519KeyPairOptions[der | pem, der | pem],
      callback: js.Function3[
          Error | Null, 
          (/* publicKey */ Buffer) | (/* publicKey */ String), 
          (/* privateKey */ Buffer) | (/* privateKey */ String), 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: ed448,
      options: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ Error | Null, 
          /* publicKey */ typings.node.cryptoMod.KeyObject, 
          /* privateKey */ typings.node.cryptoMod.KeyObject, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: ed448,
      options: ED448KeyPairKeyObjectOptions,
      callback: js.Function3[
          /* err */ Error | Null, 
          /* publicKey */ typings.node.cryptoMod.KeyObject, 
          /* privateKey */ typings.node.cryptoMod.KeyObject, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: ed448,
      options: ED448KeyPairOptions[der | pem, der | pem],
      callback: js.Function3[
          Error | Null, 
          (/* publicKey */ Buffer) | (/* publicKey */ String), 
          (/* privateKey */ Buffer) | (/* privateKey */ String), 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: rsa,
      options: RSAKeyPairKeyObjectOptions,
      callback: js.Function3[
          /* err */ Error | Null, 
          /* publicKey */ typings.node.cryptoMod.KeyObject, 
          /* privateKey */ typings.node.cryptoMod.KeyObject, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: rsa,
      options: RSAKeyPairOptions[der | pem, der | pem],
      callback: js.Function3[
          Error | Null, 
          (/* publicKey */ Buffer) | (/* publicKey */ String), 
          (/* privateKey */ Buffer) | (/* privateKey */ String), 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: x25519,
      options: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ Error | Null, 
          /* publicKey */ typings.node.cryptoMod.KeyObject, 
          /* privateKey */ typings.node.cryptoMod.KeyObject, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: x25519,
      options: X25519KeyPairKeyObjectOptions,
      callback: js.Function3[
          /* err */ Error | Null, 
          /* publicKey */ typings.node.cryptoMod.KeyObject, 
          /* privateKey */ typings.node.cryptoMod.KeyObject, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: x25519,
      options: X25519KeyPairOptions[der | pem, der | pem],
      callback: js.Function3[
          Error | Null, 
          (/* publicKey */ Buffer) | (/* publicKey */ String), 
          (/* privateKey */ Buffer) | (/* privateKey */ String), 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: x448,
      options: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ Error | Null, 
          /* publicKey */ typings.node.cryptoMod.KeyObject, 
          /* privateKey */ typings.node.cryptoMod.KeyObject, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: x448,
      options: X448KeyPairKeyObjectOptions,
      callback: js.Function3[
          /* err */ Error | Null, 
          /* publicKey */ typings.node.cryptoMod.KeyObject, 
          /* privateKey */ typings.node.cryptoMod.KeyObject, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "crypto.generateKeyPair")
    @js.native
    def generateKeyPair(
      `type`: x448,
      options: X448KeyPairOptions[der | pem, der | pem],
      callback: js.Function3[
          Error | Null, 
          (/* publicKey */ Buffer) | (/* publicKey */ String), 
          (/* privateKey */ Buffer) | (/* privateKey */ String), 
          Unit
        ]
    ): Unit = js.native
    
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync(`type`: dsa, options: DSAKeyPairOptions[der | pem, der | pem]): KeyPairSyncResult[String, String] = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync(`type`: ec, options: ECKeyPairOptions[der | pem, der | pem]): KeyPairSyncResult[String, String] = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync(`type`: ed25519, options: ED25519KeyPairOptions[der | pem, der | pem]): KeyPairSyncResult[String, String] = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync(`type`: ed448, options: ED448KeyPairOptions[der | pem, der | pem]): KeyPairSyncResult[String, String] = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync(`type`: rsa, options: RSAKeyPairOptions[der | pem, der | pem]): KeyPairSyncResult[String, String] = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync(`type`: x25519, options: X25519KeyPairOptions[der | pem, der | pem]): KeyPairSyncResult[String, String] = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync(`type`: x448, options: X448KeyPairOptions[der | pem, der | pem]): KeyPairSyncResult[String, String] = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync_dsa(`type`: dsa, options: DSAKeyPairKeyObjectOptions): KeyPairKeyObjectResult = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync_ec(`type`: ec, options: ECKeyPairKeyObjectOptions): KeyPairKeyObjectResult = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync_ed25519(`type`: ed25519): KeyPairKeyObjectResult = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync_ed25519(`type`: ed25519, options: ED25519KeyPairKeyObjectOptions): KeyPairKeyObjectResult = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync_ed448(`type`: ed448): KeyPairKeyObjectResult = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync_ed448(`type`: ed448, options: ED448KeyPairKeyObjectOptions): KeyPairKeyObjectResult = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync_rsa(`type`: rsa, options: RSAKeyPairKeyObjectOptions): KeyPairKeyObjectResult = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync_x25519(`type`: x25519): KeyPairKeyObjectResult = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync_x25519(`type`: x25519, options: X25519KeyPairKeyObjectOptions): KeyPairKeyObjectResult = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync_x448(`type`: x448): KeyPairKeyObjectResult = js.native
    @JSImport("mz", "crypto.generateKeyPairSync")
    @js.native
    def generateKeyPairSync_x448(`type`: x448, options: X448KeyPairKeyObjectOptions): KeyPairKeyObjectResult = js.native
    
    @JSImport("mz", "crypto.getCiphers")
    @js.native
    def getCiphers(): js.Array[String] = js.native
    
    @JSImport("mz", "crypto.getCurves")
    @js.native
    def getCurves(): js.Array[String] = js.native
    
    @JSImport("mz", "crypto.getDiffieHellman")
    @js.native
    def getDiffieHellman(group_name: String): typings.node.cryptoMod.DiffieHellman_ = js.native
    
    @JSImport("mz", "crypto.getFips")
    @js.native
    def getFips(): `1` | `0` = js.native
    
    @JSImport("mz", "crypto.getHashes")
    @js.native
    def getHashes(): js.Array[String] = js.native
    
    @JSImport("mz", "crypto.pbkdf2")
    @js.native
    def pbkdf2(password: BinaryLike, salt: BinaryLike, iterations: Double, keylen: Double, digest: String): js.Promise[Buffer] = js.native
    @JSImport("mz", "crypto.pbkdf2")
    @js.native
    def pbkdf2(
      password: BinaryLike,
      salt: BinaryLike,
      iterations: Double,
      keylen: Double,
      digest: String,
      callback: js.Function2[/* err */ Error | Null, /* derivedKey */ Buffer, _]
    ): Unit = js.native
    
    @JSImport("mz", "crypto.pbkdf2Sync")
    @js.native
    def pbkdf2Sync(password: BinaryLike, salt: BinaryLike, iterations: Double, keylen: Double, digest: String): Buffer = js.native
    
    @JSImport("mz", "crypto.privateDecrypt")
    @js.native
    def privateDecrypt(private_key: KeyLike, buffer: ArrayBufferView): Buffer = js.native
    @JSImport("mz", "crypto.privateDecrypt")
    @js.native
    def privateDecrypt(private_key: RsaPrivateKey, buffer: ArrayBufferView): Buffer = js.native
    
    @JSImport("mz", "crypto.privateEncrypt")
    @js.native
    def privateEncrypt(private_key: KeyLike, buffer: ArrayBufferView): Buffer = js.native
    @JSImport("mz", "crypto.privateEncrypt")
    @js.native
    def privateEncrypt(private_key: RsaPrivateKey, buffer: ArrayBufferView): Buffer = js.native
    
    @JSImport("mz", "crypto.pseudoRandomBytes")
    @js.native
    def pseudoRandomBytes(size: Double): js.Promise[Buffer] = js.native
    @JSImport("mz", "crypto.pseudoRandomBytes")
    @js.native
    def pseudoRandomBytes(size: Double, callback: js.Function2[/* err */ Error | Null, /* buf */ Buffer, Unit]): Unit = js.native
    
    @JSImport("mz", "crypto.publicDecrypt")
    @js.native
    def publicDecrypt(key: KeyLike, buffer: ArrayBufferView): Buffer = js.native
    @JSImport("mz", "crypto.publicDecrypt")
    @js.native
    def publicDecrypt(key: RsaPrivateKey, buffer: ArrayBufferView): Buffer = js.native
    @JSImport("mz", "crypto.publicDecrypt")
    @js.native
    def publicDecrypt(key: RsaPublicKey, buffer: ArrayBufferView): Buffer = js.native
    
    @JSImport("mz", "crypto.publicEncrypt")
    @js.native
    def publicEncrypt(key: KeyLike, buffer: ArrayBufferView): Buffer = js.native
    @JSImport("mz", "crypto.publicEncrypt")
    @js.native
    def publicEncrypt(key: RsaPrivateKey, buffer: ArrayBufferView): Buffer = js.native
    @JSImport("mz", "crypto.publicEncrypt")
    @js.native
    def publicEncrypt(key: RsaPublicKey, buffer: ArrayBufferView): Buffer = js.native
    
    @JSImport("mz", "crypto.randomBytes")
    @js.native
    def randomBytes(size: Double): js.Promise[Buffer] = js.native
    @JSImport("mz", "crypto.randomBytes")
    @js.native
    def randomBytes(size: Double, callback: js.Function2[/* err */ Error | Null, /* buf */ Buffer, Unit]): Unit = js.native
    
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(buffer: DataView, callback: js.Function2[/* err */ Error | Null, /* buf */ DataView, Unit]): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: DataView,
      offset: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: DataView,
      offset: Double,
      size: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(buffer: Float32Array, callback: js.Function2[/* err */ Error | Null, /* buf */ Float32Array, Unit]): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Float32Array,
      offset: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Float32Array,
      offset: Double,
      size: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(buffer: Float64Array, callback: js.Function2[/* err */ Error | Null, /* buf */ Float64Array, Unit]): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Float64Array,
      offset: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Float64Array,
      offset: Double,
      size: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(buffer: Int16Array, callback: js.Function2[/* err */ Error | Null, /* buf */ Int16Array, Unit]): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Int16Array,
      offset: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Int16Array,
      offset: Double,
      size: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(buffer: Int32Array, callback: js.Function2[/* err */ Error | Null, /* buf */ Int32Array, Unit]): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Int32Array,
      offset: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Int32Array,
      offset: Double,
      size: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(buffer: Int8Array, callback: js.Function2[/* err */ Error | Null, /* buf */ Int8Array, Unit]): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Int8Array,
      offset: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Int8Array,
      offset: Double,
      size: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(buffer: Uint16Array, callback: js.Function2[/* err */ Error | Null, /* buf */ Uint16Array, Unit]): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Uint16Array,
      offset: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Uint16Array,
      offset: Double,
      size: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(buffer: Uint32Array, callback: js.Function2[/* err */ Error | Null, /* buf */ Uint32Array, Unit]): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Uint32Array,
      offset: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Uint32Array,
      offset: Double,
      size: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(buffer: Uint8Array, callback: js.Function2[/* err */ Error | Null, /* buf */ Uint8Array, Unit]): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Uint8Array,
      offset: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Uint8Array,
      offset: Double,
      size: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Uint8ClampedArray,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Uint8ClampedArray, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Uint8ClampedArray,
      offset: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Uint8ClampedArray, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.randomFill")
    @js.native
    def randomFill(
      buffer: Uint8ClampedArray,
      offset: Double,
      size: Double,
      callback: js.Function2[/* err */ Error | Null, /* buf */ Uint8ClampedArray, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: DataView): DataView = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: DataView, offset: js.UndefOr[scala.Nothing], size: Double): DataView = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: DataView, offset: Double): DataView = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: DataView, offset: Double, size: Double): DataView = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Float32Array): Float32Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Float32Array, offset: js.UndefOr[scala.Nothing], size: Double): Float32Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Float32Array, offset: Double): Float32Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Float32Array, offset: Double, size: Double): Float32Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Float64Array): Float64Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Float64Array, offset: js.UndefOr[scala.Nothing], size: Double): Float64Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Float64Array, offset: Double): Float64Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Float64Array, offset: Double, size: Double): Float64Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Int16Array): Int16Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Int16Array, offset: js.UndefOr[scala.Nothing], size: Double): Int16Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Int16Array, offset: Double): Int16Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Int16Array, offset: Double, size: Double): Int16Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Int32Array): Int32Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Int32Array, offset: js.UndefOr[scala.Nothing], size: Double): Int32Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Int32Array, offset: Double): Int32Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Int32Array, offset: Double, size: Double): Int32Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Int8Array): Int8Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Int8Array, offset: js.UndefOr[scala.Nothing], size: Double): Int8Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Int8Array, offset: Double): Int8Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Int8Array, offset: Double, size: Double): Int8Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint16Array): Uint16Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint16Array, offset: js.UndefOr[scala.Nothing], size: Double): Uint16Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint16Array, offset: Double): Uint16Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint16Array, offset: Double, size: Double): Uint16Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint32Array): Uint32Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint32Array, offset: js.UndefOr[scala.Nothing], size: Double): Uint32Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint32Array, offset: Double): Uint32Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint32Array, offset: Double, size: Double): Uint32Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint8Array): Uint8Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint8Array, offset: js.UndefOr[scala.Nothing], size: Double): Uint8Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint8Array, offset: Double): Uint8Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint8Array, offset: Double, size: Double): Uint8Array = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint8ClampedArray): Uint8ClampedArray = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint8ClampedArray, offset: js.UndefOr[scala.Nothing], size: Double): Uint8ClampedArray = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint8ClampedArray, offset: Double): Uint8ClampedArray = js.native
    @JSImport("mz", "crypto.randomFillSync")
    @js.native
    def randomFillSync(buffer: Uint8ClampedArray, offset: Double, size: Double): Uint8ClampedArray = js.native
    
    @JSImport("mz", "crypto.randomInt")
    @js.native
    def randomInt(max: Double): Double = js.native
    @JSImport("mz", "crypto.randomInt")
    @js.native
    def randomInt(max: Double, callback: js.Function2[/* err */ Error | Null, /* value */ Double, Unit]): Unit = js.native
    @JSImport("mz", "crypto.randomInt")
    @js.native
    def randomInt(min: Double, max: Double): Double = js.native
    @JSImport("mz", "crypto.randomInt")
    @js.native
    def randomInt(min: Double, max: Double, callback: js.Function2[/* err */ Error | Null, /* value */ Double, Unit]): Unit = js.native
    
    @JSImport("mz", "crypto.scrypt")
    @js.native
    def scrypt(
      password: BinaryLike,
      salt: BinaryLike,
      keylen: Double,
      callback: js.Function2[/* err */ Error | Null, /* derivedKey */ Buffer, Unit]
    ): Unit = js.native
    @JSImport("mz", "crypto.scrypt")
    @js.native
    def scrypt(
      password: BinaryLike,
      salt: BinaryLike,
      keylen: Double,
      options: ScryptOptions,
      callback: js.Function2[/* err */ Error | Null, /* derivedKey */ Buffer, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "crypto.scryptSync")
    @js.native
    def scryptSync(password: BinaryLike, salt: BinaryLike, keylen: Double): Buffer = js.native
    @JSImport("mz", "crypto.scryptSync")
    @js.native
    def scryptSync(password: BinaryLike, salt: BinaryLike, keylen: Double, options: ScryptOptions): Buffer = js.native
    
    @JSImport("mz", "crypto.sign")
    @js.native
    def sign(algorithm: js.UndefOr[scala.Nothing], data: ArrayBufferView, key: KeyLike): Buffer = js.native
    @JSImport("mz", "crypto.sign")
    @js.native
    def sign(algorithm: js.UndefOr[scala.Nothing], data: ArrayBufferView, key: SignKeyObjectInput): Buffer = js.native
    @JSImport("mz", "crypto.sign")
    @js.native
    def sign(algorithm: js.UndefOr[scala.Nothing], data: ArrayBufferView, key: SignPrivateKeyInput): Buffer = js.native
    /**
      * Calculates and returns the signature for `data` using the given private key and
      * algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is
      * dependent upon the key type (especially Ed25519 and Ed448).
      *
      * If `key` is not a [`KeyObject`][], this function behaves as if `key` had been
      * passed to [`crypto.createPrivateKey()`][].
      */
    @JSImport("mz", "crypto.sign")
    @js.native
    def sign(algorithm: String, data: ArrayBufferView, key: KeyLike): Buffer = js.native
    @JSImport("mz", "crypto.sign")
    @js.native
    def sign(algorithm: String, data: ArrayBufferView, key: SignKeyObjectInput): Buffer = js.native
    @JSImport("mz", "crypto.sign")
    @js.native
    def sign(algorithm: String, data: ArrayBufferView, key: SignPrivateKeyInput): Buffer = js.native
    @JSImport("mz", "crypto.sign")
    @js.native
    def sign(algorithm: Null, data: ArrayBufferView, key: KeyLike): Buffer = js.native
    @JSImport("mz", "crypto.sign")
    @js.native
    def sign(algorithm: Null, data: ArrayBufferView, key: SignKeyObjectInput): Buffer = js.native
    @JSImport("mz", "crypto.sign")
    @js.native
    def sign(algorithm: Null, data: ArrayBufferView, key: SignPrivateKeyInput): Buffer = js.native
    
    @JSImport("mz", "crypto.timingSafeEqual")
    @js.native
    def timingSafeEqual(a: ArrayBufferView, b: ArrayBufferView): Boolean = js.native
    
    @JSImport("mz", "crypto.verify")
    @js.native
    def verify(
      algorithm: js.UndefOr[scala.Nothing],
      data: ArrayBufferView,
      key: KeyLike,
      signature: ArrayBufferView
    ): Boolean = js.native
    @JSImport("mz", "crypto.verify")
    @js.native
    def verify(
      algorithm: js.UndefOr[scala.Nothing],
      data: ArrayBufferView,
      key: VerifyKeyObjectInput,
      signature: ArrayBufferView
    ): Boolean = js.native
    @JSImport("mz", "crypto.verify")
    @js.native
    def verify(
      algorithm: js.UndefOr[scala.Nothing],
      data: ArrayBufferView,
      key: VerifyPublicKeyInput,
      signature: ArrayBufferView
    ): Boolean = js.native
    /**
      * Calculates and returns the signature for `data` using the given private key and
      * algorithm. If `algorithm` is `null` or `undefined`, then the algorithm is
      * dependent upon the key type (especially Ed25519 and Ed448).
      *
      * If `key` is not a [`KeyObject`][], this function behaves as if `key` had been
      * passed to [`crypto.createPublicKey()`][].
      */
    @JSImport("mz", "crypto.verify")
    @js.native
    def verify(algorithm: String, data: ArrayBufferView, key: KeyLike, signature: ArrayBufferView): Boolean = js.native
    @JSImport("mz", "crypto.verify")
    @js.native
    def verify(algorithm: String, data: ArrayBufferView, key: VerifyKeyObjectInput, signature: ArrayBufferView): Boolean = js.native
    @JSImport("mz", "crypto.verify")
    @js.native
    def verify(algorithm: String, data: ArrayBufferView, key: VerifyPublicKeyInput, signature: ArrayBufferView): Boolean = js.native
    @JSImport("mz", "crypto.verify")
    @js.native
    def verify(algorithm: Null, data: ArrayBufferView, key: KeyLike, signature: ArrayBufferView): Boolean = js.native
    @JSImport("mz", "crypto.verify")
    @js.native
    def verify(algorithm: Null, data: ArrayBufferView, key: VerifyKeyObjectInput, signature: ArrayBufferView): Boolean = js.native
    @JSImport("mz", "crypto.verify")
    @js.native
    def verify(algorithm: Null, data: ArrayBufferView, key: VerifyPublicKeyInput, signature: ArrayBufferView): Boolean = js.native
  }
  
  object dns {
    
    // Supported getaddrinfo flags.
    @JSImport("mz", "dns.ADDRCONFIG")
    @js.native
    val ADDRCONFIG: Double = js.native
    
    @JSImport("mz", "dns.ADDRGETNETWORKPARAMS")
    @js.native
    val ADDRGETNETWORKPARAMS: String = js.native
    
    /**
      * If `dns.V4MAPPED` is specified, return resolved IPv6 addresses as
      * well as IPv4 mapped IPv6 addresses.
      */
    @JSImport("mz", "dns.ALL")
    @js.native
    val ALL: Double = js.native
    
    @JSImport("mz", "dns.BADFAMILY")
    @js.native
    val BADFAMILY: String = js.native
    
    @JSImport("mz", "dns.BADFLAGS")
    @js.native
    val BADFLAGS: String = js.native
    
    @JSImport("mz", "dns.BADHINTS")
    @js.native
    val BADHINTS: String = js.native
    
    @JSImport("mz", "dns.BADNAME")
    @js.native
    val BADNAME: String = js.native
    
    @JSImport("mz", "dns.BADQUERY")
    @js.native
    val BADQUERY: String = js.native
    
    @JSImport("mz", "dns.BADRESP")
    @js.native
    val BADRESP: String = js.native
    
    @JSImport("mz", "dns.BADSTR")
    @js.native
    val BADSTR: String = js.native
    
    @JSImport("mz", "dns.CANCELLED")
    @js.native
    val CANCELLED: String = js.native
    
    @JSImport("mz", "dns.CONNREFUSED")
    @js.native
    val CONNREFUSED: String = js.native
    
    @JSImport("mz", "dns.DESTRUCTION")
    @js.native
    val DESTRUCTION: String = js.native
    
    @JSImport("mz", "dns.EOF")
    @js.native
    val EOF: String = js.native
    
    @JSImport("mz", "dns.FILE")
    @js.native
    val FILE: String = js.native
    
    @JSImport("mz", "dns.FORMERR")
    @js.native
    val FORMERR: String = js.native
    
    @JSImport("mz", "dns.LOADIPHLPAPI")
    @js.native
    val LOADIPHLPAPI: String = js.native
    
    // Error codes
    @JSImport("mz", "dns.NODATA")
    @js.native
    val NODATA: String = js.native
    
    @JSImport("mz", "dns.NOMEM")
    @js.native
    val NOMEM: String = js.native
    
    @JSImport("mz", "dns.NONAME")
    @js.native
    val NONAME: String = js.native
    
    @JSImport("mz", "dns.NOTFOUND")
    @js.native
    val NOTFOUND: String = js.native
    
    @JSImport("mz", "dns.NOTIMP")
    @js.native
    val NOTIMP: String = js.native
    
    @JSImport("mz", "dns.NOTINITIALIZED")
    @js.native
    val NOTINITIALIZED: String = js.native
    
    @JSImport("mz", "dns.REFUSED")
    @js.native
    val REFUSED: String = js.native
    
    @JSImport("mz", "dns.Resolver")
    @js.native
    class Resolver ()
      extends typings.mz.dnsMod.Resolver
    
    @JSImport("mz", "dns.SERVFAIL")
    @js.native
    val SERVFAIL: String = js.native
    
    @JSImport("mz", "dns.TIMEOUT")
    @js.native
    val TIMEOUT: String = js.native
    
    @JSImport("mz", "dns.V4MAPPED")
    @js.native
    val V4MAPPED: Double = js.native
    
    @JSImport("mz", "dns.getServers")
    @js.native
    def getServers(): js.Array[String] = js.native
    
    @JSImport("mz", "dns.lookup")
    @js.native
    def lookup(hostname: String): js.Promise[js.Tuple2[String, Double]] = js.native
    @JSImport("mz", "dns.lookup")
    @js.native
    def lookup(
      hostname: String,
      callback: js.Function3[/* err */ ErrnoException | Null, /* address */ String, /* family */ Double, Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.lookup")
    @js.native
    def lookup(
      hostname: String,
      family: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* address */ String, /* family */ Double, Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.lookup")
    @js.native
    def lookup(hostname: String, options: Double): js.Promise[js.Tuple2[String, Double]] = js.native
    @JSImport("mz", "dns.lookup")
    @js.native
    def lookup(hostname: String, options: LookupAllOptions): js.Promise[js.Array[LookupAddress]] = js.native
    @JSImport("mz", "dns.lookup")
    @js.native
    def lookup(
      hostname: String,
      options: LookupAllOptions,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[LookupAddress], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.lookup")
    @js.native
    def lookup(hostname: String, options: LookupOneOptions): js.Promise[js.Tuple2[String, Double]] = js.native
    @JSImport("mz", "dns.lookup")
    @js.native
    def lookup(
      hostname: String,
      // `options` can't be mixed into `family`
    // tslint:disable-next-line: unified-signatures
    options: LookupOneOptions,
      callback: js.Function3[/* err */ ErrnoException | Null, /* address */ String, /* family */ Double, Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.lookup")
    @js.native
    def lookup(hostname: String, options: LookupOptions): js.Promise[(js.Tuple2[String, Double]) | js.Array[LookupAddress]] = js.native
    @JSImport("mz", "dns.lookup")
    @js.native
    def lookup(
      hostname: String,
      options: LookupOptions,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* address */ String | js.Array[LookupAddress], 
          /* family */ Double, 
          Unit
        ]
    ): Unit = js.native
    
    @JSImport("mz", "dns.lookupService")
    @js.native
    def lookupService(address: String, port: Double): js.Promise[js.Tuple2[String, String]] = js.native
    @JSImport("mz", "dns.lookupService")
    @js.native
    def lookupService(
      address: String,
      port: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* hostname */ String, /* service */ String, Unit]
    ): Unit = js.native
    
    object promises {
      
      @JSImport("mz", "dns.promises.Resolver")
      @js.native
      class Resolver ()
        extends typings.mz.dnsMod.promises.Resolver
      
      @JSImport("mz", "dns.promises.getServers")
      @js.native
      def getServers(): js.Array[String] = js.native
      
      @JSImport("mz", "dns.promises.lookup")
      @js.native
      def lookup(hostname: String): js.Promise[LookupAddress] = js.native
      @JSImport("mz", "dns.promises.lookup")
      @js.native
      def lookup(hostname: String, family: Double): js.Promise[LookupAddress] = js.native
      @JSImport("mz", "dns.promises.lookup")
      @js.native
      def lookup(hostname: String, options: LookupAllOptions): js.Promise[js.Array[LookupAddress]] = js.native
      @JSImport("mz", "dns.promises.lookup")
      @js.native
      def lookup(hostname: String, options: LookupOneOptions): js.Promise[LookupAddress] = js.native
      @JSImport("mz", "dns.promises.lookup")
      @js.native
      def lookup(hostname: String, options: LookupOptions): js.Promise[LookupAddress | js.Array[LookupAddress]] = js.native
      
      @JSImport("mz", "dns.promises.lookupService")
      @js.native
      def lookupService(address: String, port: Double): js.Promise[Hostname] = js.native
      
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve(hostname: String): js.Promise[js.Array[String]] = js.native
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve(hostname: String, rrtype: String): js.Promise[
            (js.Array[AnyRecord | js.Array[String] | MxRecord | NaptrRecord | SrvRecord | String]) | SoaRecord
          ] = js.native
      
      @JSImport("mz", "dns.promises.resolve4")
      @js.native
      def resolve4(hostname: String): js.Promise[js.Array[String]] = js.native
      @JSImport("mz", "dns.promises.resolve4")
      @js.native
      def resolve4(hostname: String, options: ResolveOptions): js.Promise[js.Array[RecordWithTtl | String]] = js.native
      @JSImport("mz", "dns.promises.resolve4")
      @js.native
      def resolve4(hostname: String, options: ResolveWithTtlOptions): js.Promise[js.Array[RecordWithTtl]] = js.native
      
      @JSImport("mz", "dns.promises.resolve6")
      @js.native
      def resolve6(hostname: String): js.Promise[js.Array[String]] = js.native
      @JSImport("mz", "dns.promises.resolve6")
      @js.native
      def resolve6(hostname: String, options: ResolveOptions): js.Promise[js.Array[RecordWithTtl | String]] = js.native
      @JSImport("mz", "dns.promises.resolve6")
      @js.native
      def resolve6(hostname: String, options: ResolveWithTtlOptions): js.Promise[js.Array[RecordWithTtl]] = js.native
      
      @JSImport("mz", "dns.promises.resolveAny")
      @js.native
      def resolveAny(hostname: String): js.Promise[js.Array[AnyRecord]] = js.native
      
      @JSImport("mz", "dns.promises.resolveCname")
      @js.native
      def resolveCname(hostname: String): js.Promise[js.Array[String]] = js.native
      
      @JSImport("mz", "dns.promises.resolveMx")
      @js.native
      def resolveMx(hostname: String): js.Promise[js.Array[MxRecord]] = js.native
      
      @JSImport("mz", "dns.promises.resolveNaptr")
      @js.native
      def resolveNaptr(hostname: String): js.Promise[js.Array[NaptrRecord]] = js.native
      
      @JSImport("mz", "dns.promises.resolveNs")
      @js.native
      def resolveNs(hostname: String): js.Promise[js.Array[String]] = js.native
      
      @JSImport("mz", "dns.promises.resolvePtr")
      @js.native
      def resolvePtr(hostname: String): js.Promise[js.Array[String]] = js.native
      
      @JSImport("mz", "dns.promises.resolveSoa")
      @js.native
      def resolveSoa(hostname: String): js.Promise[SoaRecord] = js.native
      
      @JSImport("mz", "dns.promises.resolveSrv")
      @js.native
      def resolveSrv(hostname: String): js.Promise[js.Array[SrvRecord]] = js.native
      
      @JSImport("mz", "dns.promises.resolveTxt")
      @js.native
      def resolveTxt(hostname: String): js.Promise[js.Array[js.Array[String]]] = js.native
      
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve_A(hostname: String, rrtype: A): js.Promise[js.Array[String]] = js.native
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve_AAAA(hostname: String, rrtype: AAAA): js.Promise[js.Array[String]] = js.native
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve_ANY(hostname: String, rrtype: ANY): js.Promise[js.Array[AnyRecord]] = js.native
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve_CNAME(hostname: String, rrtype: CNAME): js.Promise[js.Array[String]] = js.native
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve_MX(hostname: String, rrtype: MX): js.Promise[js.Array[MxRecord]] = js.native
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve_NAPTR(hostname: String, rrtype: NAPTR): js.Promise[js.Array[NaptrRecord]] = js.native
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve_NS(hostname: String, rrtype: NS): js.Promise[js.Array[String]] = js.native
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve_PTR(hostname: String, rrtype: PTR): js.Promise[js.Array[String]] = js.native
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve_SOA(hostname: String, rrtype: SOA): js.Promise[SoaRecord] = js.native
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve_SRV(hostname: String, rrtype: SRV): js.Promise[js.Array[SrvRecord]] = js.native
      @JSImport("mz", "dns.promises.resolve")
      @js.native
      def resolve_TXT(hostname: String, rrtype: TXT): js.Promise[js.Array[js.Array[String]]] = js.native
      
      @JSImport("mz", "dns.promises.reverse")
      @js.native
      def reverse(ip: String): js.Promise[js.Array[String]] = js.native
      
      @JSImport("mz", "dns.promises.setServers")
      @js.native
      def setServers(servers: js.Array[String]): Unit = js.native
    }
    
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve(hostname: String): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve(
      hostname: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[String], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve(hostname: String, rrtype: String): js.Promise[
        (js.Array[AnyRecord | js.Array[String] | MxRecord | NaptrRecord | SrvRecord | String]) | SoaRecord
      ] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve(
      hostname: String,
      rrtype: String,
      callback: js.Function2[
          /* err */ ErrnoException | Null, 
          /* addresses */ (js.Array[AnyRecord | js.Array[String] | MxRecord | NaptrRecord | SrvRecord | String]) | SoaRecord, 
          Unit
        ]
    ): Unit = js.native
    
    @JSImport("mz", "dns.resolve4")
    @js.native
    def resolve4(hostname: String): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "dns.resolve4")
    @js.native
    def resolve4(
      hostname: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[String], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve4")
    @js.native
    def resolve4(hostname: String, options: ResolveOptions): js.Promise[js.Array[RecordWithTtl | String]] = js.native
    @JSImport("mz", "dns.resolve4")
    @js.native
    def resolve4(
      hostname: String,
      options: ResolveOptions,
      callback: js.Function2[
          /* err */ ErrnoException | Null, 
          /* addresses */ js.Array[RecordWithTtl | String], 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve4")
    @js.native
    def resolve4(hostname: String, options: ResolveWithTtlOptions): js.Promise[js.Array[RecordWithTtl]] = js.native
    @JSImport("mz", "dns.resolve4")
    @js.native
    def resolve4(
      hostname: String,
      options: ResolveWithTtlOptions,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[RecordWithTtl], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.resolve6")
    @js.native
    def resolve6(hostname: String): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "dns.resolve6")
    @js.native
    def resolve6(
      hostname: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[String], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve6")
    @js.native
    def resolve6(hostname: String, options: ResolveOptions): js.Promise[js.Array[RecordWithTtl | String]] = js.native
    @JSImport("mz", "dns.resolve6")
    @js.native
    def resolve6(
      hostname: String,
      options: ResolveOptions,
      callback: js.Function2[
          /* err */ ErrnoException | Null, 
          /* addresses */ js.Array[RecordWithTtl | String], 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve6")
    @js.native
    def resolve6(hostname: String, options: ResolveWithTtlOptions): js.Promise[js.Array[RecordWithTtl]] = js.native
    @JSImport("mz", "dns.resolve6")
    @js.native
    def resolve6(
      hostname: String,
      options: ResolveWithTtlOptions,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[RecordWithTtl], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.resolveAny")
    @js.native
    def resolveAny(hostname: String): js.Promise[js.Array[AnyRecord]] = js.native
    @JSImport("mz", "dns.resolveAny")
    @js.native
    def resolveAny(
      hostname: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[AnyRecord], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.resolveCname")
    @js.native
    def resolveCname(hostname: String): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "dns.resolveCname")
    @js.native
    def resolveCname(
      hostname: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[String], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.resolveMx")
    @js.native
    def resolveMx(hostname: String): js.Promise[js.Array[MxRecord]] = js.native
    @JSImport("mz", "dns.resolveMx")
    @js.native
    def resolveMx(
      hostname: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[MxRecord], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.resolveNaptr")
    @js.native
    def resolveNaptr(hostname: String): js.Promise[js.Array[NaptrRecord]] = js.native
    @JSImport("mz", "dns.resolveNaptr")
    @js.native
    def resolveNaptr(
      hostname: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[NaptrRecord], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.resolveNs")
    @js.native
    def resolveNs(hostname: String): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "dns.resolveNs")
    @js.native
    def resolveNs(
      hostname: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[String], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.resolvePtr")
    @js.native
    def resolvePtr(hostname: String): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "dns.resolvePtr")
    @js.native
    def resolvePtr(
      hostname: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[String], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.resolveSoa")
    @js.native
    def resolveSoa(hostname: String): js.Promise[SoaRecord] = js.native
    @JSImport("mz", "dns.resolveSoa")
    @js.native
    def resolveSoa(
      hostname: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* address */ SoaRecord, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.resolveSrv")
    @js.native
    def resolveSrv(hostname: String): js.Promise[js.Array[SrvRecord]] = js.native
    @JSImport("mz", "dns.resolveSrv")
    @js.native
    def resolveSrv(
      hostname: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[SrvRecord], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.resolveTxt")
    @js.native
    def resolveTxt(hostname: String): js.Promise[js.Array[js.Array[String]]] = js.native
    @JSImport("mz", "dns.resolveTxt")
    @js.native
    def resolveTxt(
      hostname: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[js.Array[String]], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_A(hostname: String, rrtype: A): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_A(
      hostname: String,
      rrtype: A,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[String], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_AAAA(hostname: String, rrtype: AAAA): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_AAAA(
      hostname: String,
      rrtype: AAAA,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[String], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_ANY(hostname: String, rrtype: ANY): js.Promise[js.Array[AnyRecord]] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_ANY(
      hostname: String,
      rrtype: ANY,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[AnyRecord], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_CNAME(hostname: String, rrtype: CNAME): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_CNAME(
      hostname: String,
      rrtype: CNAME,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[String], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_MX(hostname: String, rrtype: MX): js.Promise[js.Array[MxRecord]] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_MX(
      hostname: String,
      rrtype: MX,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[MxRecord], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_NAPTR(hostname: String, rrtype: NAPTR): js.Promise[js.Array[NaptrRecord]] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_NAPTR(
      hostname: String,
      rrtype: NAPTR,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[NaptrRecord], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_NS(hostname: String, rrtype: NS): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_NS(
      hostname: String,
      rrtype: NS,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[String], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_PTR(hostname: String, rrtype: PTR): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_PTR(
      hostname: String,
      rrtype: PTR,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[String], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_SOA(hostname: String, rrtype: SOA): js.Promise[SoaRecord] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_SOA(
      hostname: String,
      rrtype: SOA,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ SoaRecord, Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_SRV(hostname: String, rrtype: SRV): js.Promise[js.Array[SrvRecord]] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_SRV(
      hostname: String,
      rrtype: SRV,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[SrvRecord], Unit]
    ): Unit = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_TXT(hostname: String, rrtype: TXT): js.Promise[js.Array[js.Array[String]]] = js.native
    @JSImport("mz", "dns.resolve")
    @js.native
    def resolve_TXT(
      hostname: String,
      rrtype: TXT,
      callback: js.Function2[/* err */ ErrnoException | Null, /* addresses */ js.Array[js.Array[String]], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.reverse")
    @js.native
    def reverse(ip: String): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "dns.reverse")
    @js.native
    def reverse(
      ip: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* domains */ js.Array[String], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "dns.setServers")
    @js.native
    def setServers(servers: js.Array[String]): Unit = js.native
  }
  
  object fs {
    
    @JSImport("mz", "fs.BigIntStats")
    @js.native
    class BigIntStats ()
      extends typings.mz.fsMod.BigIntStats
    
    @JSImport("mz", "fs.Dir")
    @js.native
    class Dir ()
      extends typings.mz.fsMod.Dir
    
    @JSImport("mz", "fs.Dirent")
    @js.native
    class Dirent ()
      extends typings.mz.fsMod.Dirent
    
    @JSImport("mz", "fs.ReadStream")
    @js.native
    class ReadStream ()
      extends typings.mz.fsMod.ReadStream {
      def this(opts: ReadableOptions) = this()
    }
    
    @JSImport("mz", "fs.Stats")
    @js.native
    class Stats ()
      extends typings.mz.fsMod.Stats
    
    @JSImport("mz", "fs.WriteStream")
    @js.native
    class WriteStream ()
      extends typings.mz.fsMod.WriteStream {
      def this(opts: WritableOptions) = this()
    }
    
    @JSImport("mz", "fs.access")
    @js.native
    def access(path: PathLike): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.access")
    @js.native
    def access(path: PathLike, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.access")
    @js.native
    def access(path: PathLike, mode: js.UndefOr[scala.Nothing], callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.access")
    @js.native
    def access(path: PathLike, mode: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.access")
    @js.native
    def access(path: PathLike, mode: Double, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.accessSync")
    @js.native
    def accessSync(path: PathLike): Unit = js.native
    @JSImport("mz", "fs.accessSync")
    @js.native
    def accessSync(path: PathLike, mode: Double): Unit = js.native
    
    @JSImport("mz", "fs.appendFile")
    @js.native
    def appendFile(file: Double, data: js.Any): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.appendFile")
    @js.native
    def appendFile(file: Double, data: js.Any, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.appendFile")
    @js.native
    def appendFile(file: Double, data: js.Any, options: WriteFileOptions): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.appendFile")
    @js.native
    def appendFile(file: Double, data: js.Any, options: WriteFileOptions, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.appendFile")
    @js.native
    def appendFile(file: PathLike, data: js.Any): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.appendFile")
    @js.native
    def appendFile(file: PathLike, data: js.Any, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.appendFile")
    @js.native
    def appendFile(file: PathLike, data: js.Any, options: WriteFileOptions): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.appendFile")
    @js.native
    def appendFile(file: PathLike, data: js.Any, options: WriteFileOptions, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.appendFileSync")
    @js.native
    def appendFileSync(file: Double, data: String): Unit = js.native
    @JSImport("mz", "fs.appendFileSync")
    @js.native
    def appendFileSync(file: Double, data: String, options: WriteFileOptions): Unit = js.native
    @JSImport("mz", "fs.appendFileSync")
    @js.native
    def appendFileSync(file: Double, data: Uint8Array): Unit = js.native
    @JSImport("mz", "fs.appendFileSync")
    @js.native
    def appendFileSync(file: Double, data: Uint8Array, options: WriteFileOptions): Unit = js.native
    @JSImport("mz", "fs.appendFileSync")
    @js.native
    def appendFileSync(file: PathLike, data: String): Unit = js.native
    @JSImport("mz", "fs.appendFileSync")
    @js.native
    def appendFileSync(file: PathLike, data: String, options: WriteFileOptions): Unit = js.native
    @JSImport("mz", "fs.appendFileSync")
    @js.native
    def appendFileSync(file: PathLike, data: Uint8Array): Unit = js.native
    @JSImport("mz", "fs.appendFileSync")
    @js.native
    def appendFileSync(file: PathLike, data: Uint8Array, options: WriteFileOptions): Unit = js.native
    
    @JSImport("mz", "fs.chmod")
    @js.native
    def chmod(path: PathLike, mode: String): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.chmod")
    @js.native
    def chmod(path: PathLike, mode: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.chmod")
    @js.native
    def chmod(path: PathLike, mode: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.chmod")
    @js.native
    def chmod(path: PathLike, mode: Double, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.chmodSync")
    @js.native
    def chmodSync(path: PathLike, mode: Mode): Unit = js.native
    
    @JSImport("mz", "fs.chown")
    @js.native
    def chown(path: PathLike, uid: Double, gid: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.chown")
    @js.native
    def chown(path: PathLike, uid: Double, gid: Double, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.chownSync")
    @js.native
    def chownSync(path: PathLike, uid: Double, gid: Double): Unit = js.native
    
    @JSImport("mz", "fs.close")
    @js.native
    def close(fd: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.close")
    @js.native
    def close(fd: Double, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.closeSync")
    @js.native
    def closeSync(fd: Double): Unit = js.native
    
    object constants {
      
      // File Copy Constants
      /** Constant for fs.copyFile. Flag indicating the destination file should not be overwritten if it already exists. */
      @JSImport("mz", "fs.constants.COPYFILE_EXCL")
      @js.native
      val COPYFILE_EXCL: Double = js.native
      
      /**
        * Constant for fs.copyFile. copy operation will attempt to create a copy-on-write reflink.
        * If the underlying platform does not support copy-on-write, then a fallback copy mechanism is used.
        */
      @JSImport("mz", "fs.constants.COPYFILE_FICLONE")
      @js.native
      val COPYFILE_FICLONE: Double = js.native
      
      /**
        * Constant for fs.copyFile. Copy operation will attempt to create a copy-on-write reflink.
        * If the underlying platform does not support copy-on-write, then the operation will fail with an error.
        */
      @JSImport("mz", "fs.constants.COPYFILE_FICLONE_FORCE")
      @js.native
      val COPYFILE_FICLONE_FORCE: Double = js.native
      
      // File Access Constants
      /** Constant for fs.access(). File is visible to the calling process. */
      @JSImport("mz", "fs.constants.F_OK")
      @js.native
      val F_OK: Double = js.native
      
      /** Constant for fs.open(). Flag indicating that data will be appended to the end of the file. */
      @JSImport("mz", "fs.constants.O_APPEND")
      @js.native
      val O_APPEND: Double = js.native
      
      /** Constant for fs.open(). Flag indicating to create the file if it does not already exist. */
      @JSImport("mz", "fs.constants.O_CREAT")
      @js.native
      val O_CREAT: Double = js.native
      
      /** Constant for fs.open(). When set, an attempt will be made to minimize caching effects of file I/O. */
      @JSImport("mz", "fs.constants.O_DIRECT")
      @js.native
      val O_DIRECT: Double = js.native
      
      /** Constant for fs.open(). Flag indicating that the open should fail if the path is not a directory. */
      @JSImport("mz", "fs.constants.O_DIRECTORY")
      @js.native
      val O_DIRECTORY: Double = js.native
      
      /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O with write operations waiting for data integrity. */
      @JSImport("mz", "fs.constants.O_DSYNC")
      @js.native
      val O_DSYNC: Double = js.native
      
      /** Constant for fs.open(). Flag indicating that opening a file should fail if the O_CREAT flag is set and the file already exists. */
      @JSImport("mz", "fs.constants.O_EXCL")
      @js.native
      val O_EXCL: Double = js.native
      
      /**
        * constant for fs.open().
        * Flag indicating reading accesses to the file system will no longer result in
        * an update to the atime information associated with the file.
        * This flag is available on Linux operating systems only.
        */
      @JSImport("mz", "fs.constants.O_NOATIME")
      @js.native
      val O_NOATIME: Double = js.native
      
      /**
        * Constant for fs.open(). Flag indicating that if path identifies a terminal device,
        * opening the path shall not cause that terminal to become the controlling terminal for the process
        * (if the process does not already have one).
        */
      @JSImport("mz", "fs.constants.O_NOCTTY")
      @js.native
      val O_NOCTTY: Double = js.native
      
      /** Constant for fs.open(). Flag indicating that the open should fail if the path is a symbolic link. */
      @JSImport("mz", "fs.constants.O_NOFOLLOW")
      @js.native
      val O_NOFOLLOW: Double = js.native
      
      /** Constant for fs.open(). Flag indicating to open the file in nonblocking mode when possible. */
      @JSImport("mz", "fs.constants.O_NONBLOCK")
      @js.native
      val O_NONBLOCK: Double = js.native
      
      // File Open Constants
      /** Constant for fs.open(). Flag indicating to open a file for read-only access. */
      @JSImport("mz", "fs.constants.O_RDONLY")
      @js.native
      val O_RDONLY: Double = js.native
      
      /** Constant for fs.open(). Flag indicating to open a file for read-write access. */
      @JSImport("mz", "fs.constants.O_RDWR")
      @js.native
      val O_RDWR: Double = js.native
      
      /** Constant for fs.open(). Flag indicating to open the symbolic link itself rather than the resource it is pointing to. */
      @JSImport("mz", "fs.constants.O_SYMLINK")
      @js.native
      val O_SYMLINK: Double = js.native
      
      /** Constant for fs.open(). Flag indicating that the file is opened for synchronous I/O. */
      @JSImport("mz", "fs.constants.O_SYNC")
      @js.native
      val O_SYNC: Double = js.native
      
      /** Constant for fs.open(). Flag indicating that if the file exists and is a regular file, and the file is opened successfully for write access, its length shall be truncated to zero. */
      @JSImport("mz", "fs.constants.O_TRUNC")
      @js.native
      val O_TRUNC: Double = js.native
      
      /** Constant for fs.open(). Flag indicating to open a file for write-only access. */
      @JSImport("mz", "fs.constants.O_WRONLY")
      @js.native
      val O_WRONLY: Double = js.native
      
      /** Constant for fs.access(). File can be read by the calling process. */
      @JSImport("mz", "fs.constants.R_OK")
      @js.native
      val R_OK: Double = js.native
      
      /** Constant for fs.Stats mode property for determining a file's type. File type constant for a block-oriented device file. */
      @JSImport("mz", "fs.constants.S_IFBLK")
      @js.native
      val S_IFBLK: Double = js.native
      
      /** Constant for fs.Stats mode property for determining a file's type. File type constant for a character-oriented device file. */
      @JSImport("mz", "fs.constants.S_IFCHR")
      @js.native
      val S_IFCHR: Double = js.native
      
      /** Constant for fs.Stats mode property for determining a file's type. File type constant for a directory. */
      @JSImport("mz", "fs.constants.S_IFDIR")
      @js.native
      val S_IFDIR: Double = js.native
      
      /** Constant for fs.Stats mode property for determining a file's type. File type constant for a FIFO/pipe. */
      @JSImport("mz", "fs.constants.S_IFIFO")
      @js.native
      val S_IFIFO: Double = js.native
      
      /** Constant for fs.Stats mode property for determining a file's type. File type constant for a symbolic link. */
      @JSImport("mz", "fs.constants.S_IFLNK")
      @js.native
      val S_IFLNK: Double = js.native
      
      // File Type Constants
      /** Constant for fs.Stats mode property for determining a file's type. Bit mask used to extract the file type code. */
      @JSImport("mz", "fs.constants.S_IFMT")
      @js.native
      val S_IFMT: Double = js.native
      
      /** Constant for fs.Stats mode property for determining a file's type. File type constant for a regular file. */
      @JSImport("mz", "fs.constants.S_IFREG")
      @js.native
      val S_IFREG: Double = js.native
      
      /** Constant for fs.Stats mode property for determining a file's type. File type constant for a socket. */
      @JSImport("mz", "fs.constants.S_IFSOCK")
      @js.native
      val S_IFSOCK: Double = js.native
      
      /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by group. */
      @JSImport("mz", "fs.constants.S_IRGRP")
      @js.native
      val S_IRGRP: Double = js.native
      
      /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by others. */
      @JSImport("mz", "fs.constants.S_IROTH")
      @js.native
      val S_IROTH: Double = js.native
      
      /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable by owner. */
      @JSImport("mz", "fs.constants.S_IRUSR")
      @js.native
      val S_IRUSR: Double = js.native
      
      /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by group. */
      @JSImport("mz", "fs.constants.S_IRWXG")
      @js.native
      val S_IRWXG: Double = js.native
      
      /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by others. */
      @JSImport("mz", "fs.constants.S_IRWXO")
      @js.native
      val S_IRWXO: Double = js.native
      
      // File Mode Constants
      /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating readable, writable and executable by owner. */
      @JSImport("mz", "fs.constants.S_IRWXU")
      @js.native
      val S_IRWXU: Double = js.native
      
      /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by group. */
      @JSImport("mz", "fs.constants.S_IWGRP")
      @js.native
      val S_IWGRP: Double = js.native
      
      /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by others. */
      @JSImport("mz", "fs.constants.S_IWOTH")
      @js.native
      val S_IWOTH: Double = js.native
      
      /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating writable by owner. */
      @JSImport("mz", "fs.constants.S_IWUSR")
      @js.native
      val S_IWUSR: Double = js.native
      
      /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by group. */
      @JSImport("mz", "fs.constants.S_IXGRP")
      @js.native
      val S_IXGRP: Double = js.native
      
      /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by others. */
      @JSImport("mz", "fs.constants.S_IXOTH")
      @js.native
      val S_IXOTH: Double = js.native
      
      /** Constant for fs.Stats mode property for determining access permissions for a file. File mode indicating executable by owner. */
      @JSImport("mz", "fs.constants.S_IXUSR")
      @js.native
      val S_IXUSR: Double = js.native
      
      /**
        * When set, a memory file mapping is used to access the file. This flag
        * is available on Windows operating systems only. On other operating systems,
        * this flag is ignored.
        */
      @JSImport("mz", "fs.constants.UV_FS_O_FILEMAP")
      @js.native
      val UV_FS_O_FILEMAP: Double = js.native
      
      /** Constant for fs.access(). File can be written by the calling process. */
      @JSImport("mz", "fs.constants.W_OK")
      @js.native
      val W_OK: Double = js.native
      
      /** Constant for fs.access(). File can be executed by the calling process. */
      @JSImport("mz", "fs.constants.X_OK")
      @js.native
      val X_OK: Double = js.native
    }
    
    @JSImport("mz", "fs.copyFile")
    @js.native
    def copyFile(src: PathLike, dest: PathLike): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.copyFile")
    @js.native
    def copyFile(src: PathLike, dest: PathLike, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.copyFile")
    @js.native
    def copyFile(src: PathLike, dest: PathLike, flags: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.copyFile")
    @js.native
    def copyFile(src: PathLike, dest: PathLike, flags: Double, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.copyFileSync")
    @js.native
    def copyFileSync(src: PathLike, dest: PathLike): Unit = js.native
    @JSImport("mz", "fs.copyFileSync")
    @js.native
    def copyFileSync(src: PathLike, dest: PathLike, flags: Double): Unit = js.native
    
    @JSImport("mz", "fs.createReadStream")
    @js.native
    def createReadStream(path: PathLike): typings.node.fsMod.ReadStream = js.native
    @JSImport("mz", "fs.createReadStream")
    @js.native
    def createReadStream(path: PathLike, options: String): typings.node.fsMod.ReadStream = js.native
    @JSImport("mz", "fs.createReadStream")
    @js.native
    def createReadStream(path: PathLike, options: AutoClose): typings.node.fsMod.ReadStream = js.native
    
    @JSImport("mz", "fs.createWriteStream")
    @js.native
    def createWriteStream(path: PathLike): typings.node.fsMod.WriteStream = js.native
    @JSImport("mz", "fs.createWriteStream")
    @js.native
    def createWriteStream(path: PathLike, options: String): typings.node.fsMod.WriteStream = js.native
    @JSImport("mz", "fs.createWriteStream")
    @js.native
    def createWriteStream(path: PathLike, options: EmitClose): typings.node.fsMod.WriteStream = js.native
    
    @JSImport("mz", "fs.exists")
    @js.native
    def exists(path: PathLike): js.Promise[Boolean] = js.native
    @JSImport("mz", "fs.exists")
    @js.native
    def exists(
      path: PathLike,
      callback: js.Function2[/* err */ ErrnoException | Null, /* exists */ Boolean, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.existsSync")
    @js.native
    def existsSync(path: PathLike): Boolean = js.native
    
    @JSImport("mz", "fs.fchmod")
    @js.native
    def fchmod(fd: Double, mode: String): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.fchmod")
    @js.native
    def fchmod(fd: Double, mode: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.fchmod")
    @js.native
    def fchmod(fd: Double, mode: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.fchmod")
    @js.native
    def fchmod(fd: Double, mode: Double, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.fchmodSync")
    @js.native
    def fchmodSync(fd: Double, mode: Mode): Unit = js.native
    
    @JSImport("mz", "fs.fchown")
    @js.native
    def fchown(fd: Double, uid: Double, gid: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.fchown")
    @js.native
    def fchown(fd: Double, uid: Double, gid: Double, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.fchownSync")
    @js.native
    def fchownSync(fd: Double, uid: Double, gid: Double): Unit = js.native
    
    @JSImport("mz", "fs.fdatasync")
    @js.native
    def fdatasync(fd: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.fdatasync")
    @js.native
    def fdatasync(fd: Double, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.fdatasyncSync")
    @js.native
    def fdatasyncSync(fd: Double): Unit = js.native
    
    @JSImport("mz", "fs.fstat")
    @js.native
    def fstat(fd: Double): js.Promise[typings.node.fsMod.Stats] = js.native
    @JSImport("mz", "fs.fstat")
    @js.native
    def fstat(
      fd: Double,
      callback: js.Function2[/* err */ ErrnoException | Null, /* stats */ typings.node.fsMod.Stats, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.fstatSync")
    @js.native
    def fstatSync(fd: Double): typings.node.fsMod.Stats = js.native
    
    @JSImport("mz", "fs.fsync")
    @js.native
    def fsync(fd: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.fsync")
    @js.native
    def fsync(fd: Double, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.fsyncSync")
    @js.native
    def fsyncSync(fd: Double): Unit = js.native
    
    @JSImport("mz", "fs.ftruncate")
    @js.native
    def ftruncate(fd: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.ftruncate")
    @js.native
    def ftruncate(fd: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.ftruncate")
    @js.native
    def ftruncate(fd: Double, len: js.UndefOr[scala.Nothing], callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.ftruncate")
    @js.native
    def ftruncate(fd: Double, len: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.ftruncate")
    @js.native
    def ftruncate(fd: Double, len: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.ftruncate")
    @js.native
    def ftruncate(fd: Double, len: Null, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.ftruncateSync")
    @js.native
    def ftruncateSync(fd: Double): Unit = js.native
    @JSImport("mz", "fs.ftruncateSync")
    @js.native
    def ftruncateSync(fd: Double, len: Double): Unit = js.native
    
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: String, mtime: String): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: String, mtime: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: String, mtime: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: String, mtime: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: String, mtime: Date): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: String, mtime: Date, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: Double, mtime: String): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: Double, mtime: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: Double, mtime: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: Double, mtime: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: Double, mtime: Date): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: Double, mtime: Date, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: Date, mtime: String): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: Date, mtime: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: Date, mtime: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: Date, mtime: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: Date, mtime: Date): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.futimes")
    @js.native
    def futimes(fd: Double, atime: Date, mtime: Date, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.futimesSync")
    @js.native
    def futimesSync(fd: Double, atime: String, mtime: String): Unit = js.native
    @JSImport("mz", "fs.futimesSync")
    @js.native
    def futimesSync(fd: Double, atime: String, mtime: Double): Unit = js.native
    @JSImport("mz", "fs.futimesSync")
    @js.native
    def futimesSync(fd: Double, atime: String, mtime: Date): Unit = js.native
    @JSImport("mz", "fs.futimesSync")
    @js.native
    def futimesSync(fd: Double, atime: Double, mtime: String): Unit = js.native
    @JSImport("mz", "fs.futimesSync")
    @js.native
    def futimesSync(fd: Double, atime: Double, mtime: Double): Unit = js.native
    @JSImport("mz", "fs.futimesSync")
    @js.native
    def futimesSync(fd: Double, atime: Double, mtime: Date): Unit = js.native
    @JSImport("mz", "fs.futimesSync")
    @js.native
    def futimesSync(fd: Double, atime: Date, mtime: String): Unit = js.native
    @JSImport("mz", "fs.futimesSync")
    @js.native
    def futimesSync(fd: Double, atime: Date, mtime: Double): Unit = js.native
    @JSImport("mz", "fs.futimesSync")
    @js.native
    def futimesSync(fd: Double, atime: Date, mtime: Date): Unit = js.native
    
    @JSImport("mz", "fs.lchmod")
    @js.native
    def lchmod(path: PathLike, mode: String): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.lchmod")
    @js.native
    def lchmod(path: PathLike, mode: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.lchmod")
    @js.native
    def lchmod(path: PathLike, mode: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.lchmod")
    @js.native
    def lchmod(path: PathLike, mode: Double, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.lchmodSync")
    @js.native
    def lchmodSync(path: PathLike, mode: Mode): Unit = js.native
    
    @JSImport("mz", "fs.lchown")
    @js.native
    def lchown(path: PathLike, uid: Double, gid: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.lchown")
    @js.native
    def lchown(path: PathLike, uid: Double, gid: Double, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.lchownSync")
    @js.native
    def lchownSync(path: PathLike, uid: Double, gid: Double): Unit = js.native
    
    @JSImport("mz", "fs.link")
    @js.native
    def link(existingPath: PathLike, newPath: PathLike): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.link")
    @js.native
    def link(existingPath: PathLike, newPath: PathLike, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.linkSync")
    @js.native
    def linkSync(existingPath: PathLike, newPath: PathLike): Unit = js.native
    
    @JSImport("mz", "fs.lstat")
    @js.native
    def lstat(path: PathLike): js.Promise[typings.node.fsMod.Stats] = js.native
    @JSImport("mz", "fs.lstat")
    @js.native
    def lstat(
      path: PathLike,
      callback: js.Function2[/* err */ ErrnoException | Null, /* stats */ typings.node.fsMod.Stats, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.lstatSync")
    @js.native
    def lstatSync(path: PathLike): typings.node.fsMod.Stats = js.native
    
    @JSImport("mz", "fs.lutimes")
    @js.native
    def lutimes(path: PathLike, atime: String, mtime: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.lutimes")
    @js.native
    def lutimes(path: PathLike, atime: String, mtime: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.lutimes")
    @js.native
    def lutimes(path: PathLike, atime: String, mtime: Date, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.lutimes")
    @js.native
    def lutimes(path: PathLike, atime: Double, mtime: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.lutimes")
    @js.native
    def lutimes(path: PathLike, atime: Double, mtime: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.lutimes")
    @js.native
    def lutimes(path: PathLike, atime: Double, mtime: Date, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.lutimes")
    @js.native
    def lutimes(path: PathLike, atime: Date, mtime: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.lutimes")
    @js.native
    def lutimes(path: PathLike, atime: Date, mtime: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.lutimes")
    @js.native
    def lutimes(path: PathLike, atime: Date, mtime: Date, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.lutimesSync")
    @js.native
    def lutimesSync(path: PathLike, atime: String, mtime: String): Unit = js.native
    @JSImport("mz", "fs.lutimesSync")
    @js.native
    def lutimesSync(path: PathLike, atime: String, mtime: Double): Unit = js.native
    @JSImport("mz", "fs.lutimesSync")
    @js.native
    def lutimesSync(path: PathLike, atime: String, mtime: Date): Unit = js.native
    @JSImport("mz", "fs.lutimesSync")
    @js.native
    def lutimesSync(path: PathLike, atime: Double, mtime: String): Unit = js.native
    @JSImport("mz", "fs.lutimesSync")
    @js.native
    def lutimesSync(path: PathLike, atime: Double, mtime: Double): Unit = js.native
    @JSImport("mz", "fs.lutimesSync")
    @js.native
    def lutimesSync(path: PathLike, atime: Double, mtime: Date): Unit = js.native
    @JSImport("mz", "fs.lutimesSync")
    @js.native
    def lutimesSync(path: PathLike, atime: Date, mtime: String): Unit = js.native
    @JSImport("mz", "fs.lutimesSync")
    @js.native
    def lutimesSync(path: PathLike, atime: Date, mtime: Double): Unit = js.native
    @JSImport("mz", "fs.lutimesSync")
    @js.native
    def lutimesSync(path: PathLike, atime: Date, mtime: Date): Unit = js.native
    
    @JSImport("mz", "fs.mkdir")
    @js.native
    def mkdir(path: PathLike): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.mkdir")
    @js.native
    def mkdir(path: PathLike, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.mkdir")
    @js.native
    def mkdir(path: PathLike, options: js.UndefOr[scala.Nothing], callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.mkdir")
    @js.native
    def mkdir(path: PathLike, options: String): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.mkdir")
    @js.native
    def mkdir(path: PathLike, options: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.mkdir")
    @js.native
    def mkdir(path: PathLike, options: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.mkdir")
    @js.native
    def mkdir(path: PathLike, options: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.mkdir")
    @js.native
    def mkdir(path: PathLike, options: Null, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.mkdir")
    @js.native
    def mkdir(path: PathLike, options: MakeDirectoryOptions): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.mkdir")
    @js.native
    def mkdir(path: PathLike, options: MakeDirectoryOptions, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.mkdirSync")
    @js.native
    def mkdirSync(path: PathLike): js.UndefOr[String] = js.native
    @JSImport("mz", "fs.mkdirSync")
    @js.native
    def mkdirSync(path: PathLike, options: MakeDirectoryOptionsrecur): String = js.native
    @JSImport("mz", "fs.mkdirSync")
    @js.native
    def mkdirSync(path: PathLike, options: MakeDirectoryOptionsrecurMode): Unit = js.native
    @JSImport("mz", "fs.mkdirSync")
    @js.native
    def mkdirSync(path: PathLike, options: MakeDirectoryOptions): js.UndefOr[String] = js.native
    @JSImport("mz", "fs.mkdirSync")
    @js.native
    def mkdirSync(path: PathLike, options: Mode): js.UndefOr[String] = js.native
    @JSImport("mz", "fs.mkdirSync")
    @js.native
    def mkdirSync_Unit(path: PathLike): Unit = js.native
    @JSImport("mz", "fs.mkdirSync")
    @js.native
    def mkdirSync_Unit(path: PathLike, options: Mode): Unit = js.native
    
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(prefix: String): js.Promise[String] = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(prefix: String, callback: js.Function2[/* err */ ErrnoException | Null, /* folder */ String, Unit]): Unit = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(
      prefix: String,
      options: js.UndefOr[scala.Nothing],
      callback: js.Function2[ErrnoException | Null, Buffer | (/* folder */ String), Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(prefix: String, options: String): js.Promise[String | Buffer] = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(
      prefix: String,
      options: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* folder */ String | Buffer, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(
      prefix: String,
      options: Null,
      callback: js.Function2[ErrnoException | Null, Buffer | (/* folder */ String), Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(prefix: String, options: Encoding): js.Promise[String] = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(
      prefix: String,
      options: Encoding,
      callback: js.Function2[/* err */ ErrnoException | Null, /* folder */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(prefix: String, options: typings.mz.anon.`0`): js.Promise[Buffer] = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(
      prefix: String,
      options: typings.mz.anon.`0`,
      callback: js.Function2[/* err */ ErrnoException | Null, /* folder */ Buffer, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(prefix: String, options: typings.mz.anon.`1`): js.Promise[String | Buffer] = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(
      prefix: String,
      options: typings.mz.anon.`1`,
      callback: js.Function2[/* err */ ErrnoException | Null, /* folder */ String | Buffer, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(prefix: String, options: BufferEncoding): js.Promise[String] = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp(
      prefix: String,
      options: BufferEncoding,
      callback: js.Function2[/* err */ ErrnoException | Null, /* folder */ String, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.mkdtempSync")
    @js.native
    def mkdtempSync(prefix: String): String = js.native
    @JSImport("mz", "fs.mkdtempSync")
    @js.native
    def mkdtempSync(prefix: String, options: String): String | Buffer = js.native
    @JSImport("mz", "fs.mkdtempSync")
    @js.native
    def mkdtempSync(prefix: String, options: BufferEncoding): String = js.native
    @JSImport("mz", "fs.mkdtempSync")
    @js.native
    def mkdtempSync(prefix: String, options: BaseEncodingOptions): String = js.native
    @JSImport("mz", "fs.mkdtempSync")
    @js.native
    def mkdtempSync(prefix: String, options: BufferEncodingOption): Buffer = js.native
    @JSImport("mz", "fs.mkdtempSync")
    @js.native
    def mkdtempSync_Union(prefix: String): String | Buffer = js.native
    @JSImport("mz", "fs.mkdtempSync")
    @js.native
    def mkdtempSync_Union(prefix: String, options: BaseEncodingOptions): String | Buffer = js.native
    
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp_buffer(prefix: String, options: buffer): js.Promise[Buffer] = js.native
    @JSImport("mz", "fs.mkdtemp")
    @js.native
    def mkdtemp_buffer(
      prefix: String,
      options: buffer,
      callback: js.Function2[/* err */ ErrnoException | Null, /* folder */ Buffer, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.open")
    @js.native
    def open(path: PathLike, flags: String): js.Promise[Double] = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(
      path: PathLike,
      flags: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* fd */ Double, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(
      path: PathLike,
      flags: String,
      mode: js.UndefOr[scala.Nothing],
      callback: js.Function2[/* err */ ErrnoException | Null, /* fd */ Double, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(path: PathLike, flags: String, mode: String): js.Promise[Double] = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(
      path: PathLike,
      flags: String,
      mode: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* fd */ Double, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(path: PathLike, flags: String, mode: Double): js.Promise[Double] = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(
      path: PathLike,
      flags: String,
      mode: Double,
      callback: js.Function2[/* err */ ErrnoException | Null, /* fd */ Double, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(
      path: PathLike,
      flags: String,
      mode: Null,
      callback: js.Function2[/* err */ ErrnoException | Null, /* fd */ Double, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(path: PathLike, flags: Double): js.Promise[Double] = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(
      path: PathLike,
      flags: Double,
      callback: js.Function2[/* err */ ErrnoException | Null, /* fd */ Double, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(
      path: PathLike,
      flags: Double,
      mode: js.UndefOr[scala.Nothing],
      callback: js.Function2[/* err */ ErrnoException | Null, /* fd */ Double, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(path: PathLike, flags: Double, mode: String): js.Promise[Double] = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(
      path: PathLike,
      flags: Double,
      mode: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* fd */ Double, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(path: PathLike, flags: Double, mode: Double): js.Promise[Double] = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(
      path: PathLike,
      flags: Double,
      mode: Double,
      callback: js.Function2[/* err */ ErrnoException | Null, /* fd */ Double, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.open")
    @js.native
    def open(
      path: PathLike,
      flags: Double,
      mode: Null,
      callback: js.Function2[/* err */ ErrnoException | Null, /* fd */ Double, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.openSync")
    @js.native
    def openSync(path: PathLike, flags: OpenMode): Double = js.native
    @JSImport("mz", "fs.openSync")
    @js.native
    def openSync(path: PathLike, flags: OpenMode, mode: Mode): Double = js.native
    
    @JSImport("mz", "fs.opendir")
    @js.native
    def opendir(
      path: String,
      cb: js.Function2[/* err */ ErrnoException | Null, /* dir */ typings.node.fsMod.Dir, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.opendir")
    @js.native
    def opendir(
      path: String,
      options: OpenDirOptions,
      cb: js.Function2[/* err */ ErrnoException | Null, /* dir */ typings.node.fsMod.Dir, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.opendirSync")
    @js.native
    def opendirSync(path: String): typings.node.fsMod.Dir = js.native
    @JSImport("mz", "fs.opendirSync")
    @js.native
    def opendirSync(path: String, options: OpenDirOptions): typings.node.fsMod.Dir = js.native
    
    object promises {
      
      /**
        * Asynchronously tests a user's permissions for the file specified by path.
        * @param path A path to a file or directory. If a URL is provided, it must use the `file:` protocol.
        * URL support is _experimental_.
        */
      @JSImport("mz", "fs.promises.access")
      @js.native
      def access(path: PathLike): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.access")
      @js.native
      def access(path: PathLike, mode: Double): js.Promise[Unit] = js.native
      
      /**
        * Asynchronously append data to a file, creating the file if it does not exist.
        * @param file A path to a file. If a URL is provided, it must use the `file:` protocol.
        * URL support is _experimental_.
        * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
        * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.
        * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
        * If `encoding` is not supplied, the default of `'utf8'` is used.
        * If `mode` is not supplied, the default of `0o666` is used.
        * If `mode` is a string, it is parsed as an octal integer.
        * If `flag` is not supplied, the default of `'a'` is used.
        */
      @JSImport("mz", "fs.promises.appendFile")
      @js.native
      def appendFile(path: PathLike, data: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.appendFile")
      @js.native
      def appendFile(path: PathLike, data: String, options: BufferEncoding): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.appendFile")
      @js.native
      def appendFile(path: PathLike, data: String, options: BaseEncodingOptionsmodeMo): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.appendFile")
      @js.native
      def appendFile(path: PathLike, data: Uint8Array): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.appendFile")
      @js.native
      def appendFile(path: PathLike, data: Uint8Array, options: BufferEncoding): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.appendFile")
      @js.native
      def appendFile(path: PathLike, data: Uint8Array, options: BaseEncodingOptionsmodeMo): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.appendFile")
      @js.native
      def appendFile(path: FileHandle, data: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.appendFile")
      @js.native
      def appendFile(path: FileHandle, data: String, options: BufferEncoding): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.appendFile")
      @js.native
      def appendFile(path: FileHandle, data: String, options: BaseEncodingOptionsmodeMo): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.appendFile")
      @js.native
      def appendFile(path: FileHandle, data: Uint8Array): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.appendFile")
      @js.native
      def appendFile(path: FileHandle, data: Uint8Array, options: BufferEncoding): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.appendFile")
      @js.native
      def appendFile(path: FileHandle, data: Uint8Array, options: BaseEncodingOptionsmodeMo): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous chmod(2) - Change permissions of a file.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
        */
      @JSImport("mz", "fs.promises.chmod")
      @js.native
      def chmod(path: PathLike, mode: Mode): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous chown(2) - Change ownership of a file.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        */
      @JSImport("mz", "fs.promises.chown")
      @js.native
      def chown(path: PathLike, uid: Double, gid: Double): js.Promise[Unit] = js.native
      
      /**
        * Asynchronously copies `src` to `dest`. By default, `dest` is overwritten if it already exists.
        * Node.js makes no guarantees about the atomicity of the copy operation.
        * If an error occurs after the destination file has been opened for writing, Node.js will attempt
        * to remove the destination.
        * @param src A path to the source file.
        * @param dest A path to the destination file.
        * @param flags An optional integer that specifies the behavior of the copy operation. The only
        * supported flag is `fs.constants.COPYFILE_EXCL`, which causes the copy operation to fail if
        * `dest` already exists.
        */
      @JSImport("mz", "fs.promises.copyFile")
      @js.native
      def copyFile(src: PathLike, dest: PathLike): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.copyFile")
      @js.native
      def copyFile(src: PathLike, dest: PathLike, flags: Double): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous fchmod(2) - Change permissions of a file.
        * @param handle A `FileHandle`.
        * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
        */
      @JSImport("mz", "fs.promises.fchmod")
      @js.native
      def fchmod(handle: FileHandle, mode: Mode): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous fchown(2) - Change ownership of a file.
        * @param handle A `FileHandle`.
        */
      @JSImport("mz", "fs.promises.fchown")
      @js.native
      def fchown(handle: FileHandle, uid: Double, gid: Double): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous fdatasync(2) - synchronize a file's in-core state with storage device.
        * @param handle A `FileHandle`.
        */
      @JSImport("mz", "fs.promises.fdatasync")
      @js.native
      def fdatasync(handle: FileHandle): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous fstat(2) - Get file status.
        * @param handle A `FileHandle`.
        */
      @JSImport("mz", "fs.promises.fstat")
      @js.native
      def fstat(handle: FileHandle): js.Promise[typings.node.fsMod.Stats] = js.native
      
      /**
        * Asynchronous fsync(2) - synchronize a file's in-core state with the underlying storage device.
        * @param handle A `FileHandle`.
        */
      @JSImport("mz", "fs.promises.fsync")
      @js.native
      def fsync(handle: FileHandle): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous ftruncate(2) - Truncate a file to a specified length.
        * @param handle A `FileHandle`.
        * @param len If not specified, defaults to `0`.
        */
      @JSImport("mz", "fs.promises.ftruncate")
      @js.native
      def ftruncate(handle: FileHandle): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.ftruncate")
      @js.native
      def ftruncate(handle: FileHandle, len: Double): js.Promise[Unit] = js.native
      
      /**
        * Asynchronously change file timestamps of the file referenced by the supplied `FileHandle`.
        * @param handle A `FileHandle`.
        * @param atime The last access time. If a string is provided, it will be coerced to number.
        * @param mtime The last modified time. If a string is provided, it will be coerced to number.
        */
      @JSImport("mz", "fs.promises.futimes")
      @js.native
      def futimes(handle: FileHandle, atime: String, mtime: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.futimes")
      @js.native
      def futimes(handle: FileHandle, atime: String, mtime: Double): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.futimes")
      @js.native
      def futimes(handle: FileHandle, atime: String, mtime: Date): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.futimes")
      @js.native
      def futimes(handle: FileHandle, atime: Double, mtime: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.futimes")
      @js.native
      def futimes(handle: FileHandle, atime: Double, mtime: Double): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.futimes")
      @js.native
      def futimes(handle: FileHandle, atime: Double, mtime: Date): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.futimes")
      @js.native
      def futimes(handle: FileHandle, atime: Date, mtime: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.futimes")
      @js.native
      def futimes(handle: FileHandle, atime: Date, mtime: Double): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.futimes")
      @js.native
      def futimes(handle: FileHandle, atime: Date, mtime: Date): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous lchmod(2) - Change permissions of a file. Does not dereference symbolic links.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param mode A file mode. If a string is passed, it is parsed as an octal integer.
        */
      @JSImport("mz", "fs.promises.lchmod")
      @js.native
      def lchmod(path: PathLike, mode: Mode): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous lchown(2) - Change ownership of a file. Does not dereference symbolic links.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        */
      @JSImport("mz", "fs.promises.lchown")
      @js.native
      def lchown(path: PathLike, uid: Double, gid: Double): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous link(2) - Create a new link (also known as a hard link) to an existing file.
        * @param existingPath A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
        */
      @JSImport("mz", "fs.promises.link")
      @js.native
      def link(existingPath: PathLike, newPath: PathLike): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous lstat(2) - Get file status. Does not dereference symbolic links.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        */
      @JSImport("mz", "fs.promises.lstat")
      @js.native
      def lstat(path: PathLike): js.Promise[typings.node.fsMod.Stats] = js.native
      
      /**
        * Changes the access and modification times of a file in the same way as `fsPromises.utimes()`,
        * with the difference that if the path refers to a symbolic link, then the link is not
        * dereferenced: instead, the timestamps of the symbolic link itself are changed.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param atime The last access time. If a string is provided, it will be coerced to number.
        * @param mtime The last modified time. If a string is provided, it will be coerced to number.
        */
      @JSImport("mz", "fs.promises.lutimes")
      @js.native
      def lutimes(path: PathLike, atime: String, mtime: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.lutimes")
      @js.native
      def lutimes(path: PathLike, atime: String, mtime: Double): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.lutimes")
      @js.native
      def lutimes(path: PathLike, atime: String, mtime: Date): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.lutimes")
      @js.native
      def lutimes(path: PathLike, atime: Double, mtime: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.lutimes")
      @js.native
      def lutimes(path: PathLike, atime: Double, mtime: Double): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.lutimes")
      @js.native
      def lutimes(path: PathLike, atime: Double, mtime: Date): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.lutimes")
      @js.native
      def lutimes(path: PathLike, atime: Date, mtime: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.lutimes")
      @js.native
      def lutimes(path: PathLike, atime: Date, mtime: Double): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.lutimes")
      @js.native
      def lutimes(path: PathLike, atime: Date, mtime: Date): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous mkdir(2) - create a directory.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
        * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
        */
      @JSImport("mz", "fs.promises.mkdir")
      @js.native
      def mkdir(path: PathLike): js.Promise[Unit] = js.native
      /**
        * Asynchronous mkdir(2) - create a directory.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param options Either the file mode, or an object optionally specifying the file mode and whether parent folders
        * should be created. If a string is passed, it is parsed as an octal integer. If not specified, defaults to `0o777`.
        */
      @JSImport("mz", "fs.promises.mkdir")
      @js.native
      def mkdir(path: PathLike, options: MakeDirectoryOptionsrecur): js.Promise[String] = js.native
      @JSImport("mz", "fs.promises.mkdir")
      @js.native
      def mkdir(path: PathLike, options: MakeDirectoryOptionsrecurMode): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.mkdir")
      @js.native
      def mkdir(path: PathLike, options: MakeDirectoryOptions): js.Promise[js.UndefOr[String]] = js.native
      @JSImport("mz", "fs.promises.mkdir")
      @js.native
      def mkdir(path: PathLike, options: Mode): js.Promise[Unit] = js.native
      
      /**
        * Asynchronously creates a unique temporary directory.
        * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
        * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
        */
      @JSImport("mz", "fs.promises.mkdtemp")
      @js.native
      def mkdtemp(prefix: String): js.Promise[String] = js.native
      @JSImport("mz", "fs.promises.mkdtemp")
      @js.native
      def mkdtemp(prefix: String, options: BufferEncoding): js.Promise[String] = js.native
      @JSImport("mz", "fs.promises.mkdtemp")
      @js.native
      def mkdtemp(prefix: String, options: BaseEncodingOptions): js.Promise[String] = js.native
      /**
        * Asynchronously creates a unique temporary directory.
        * Generates six random characters to be appended behind a required `prefix` to create a unique temporary directory.
        * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
        */
      @JSImport("mz", "fs.promises.mkdtemp")
      @js.native
      def mkdtemp(prefix: String, options: BufferEncodingOption): js.Promise[Buffer] = js.native
      
      /**
        * Asynchronous open(2) - open and possibly create a file.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param mode A file mode. If a string is passed, it is parsed as an octal integer. If not
        * supplied, defaults to `0o666`.
        */
      @JSImport("mz", "fs.promises.open")
      @js.native
      def open(path: PathLike, flags: String): js.Promise[FileHandle] = js.native
      @JSImport("mz", "fs.promises.open")
      @js.native
      def open(path: PathLike, flags: String, mode: Mode): js.Promise[FileHandle] = js.native
      @JSImport("mz", "fs.promises.open")
      @js.native
      def open(path: PathLike, flags: Double): js.Promise[FileHandle] = js.native
      @JSImport("mz", "fs.promises.open")
      @js.native
      def open(path: PathLike, flags: Double, mode: Mode): js.Promise[FileHandle] = js.native
      
      @JSImport("mz", "fs.promises.opendir")
      @js.native
      def opendir(path: String): js.Promise[typings.node.fsMod.Dir] = js.native
      @JSImport("mz", "fs.promises.opendir")
      @js.native
      def opendir(path: String, options: OpenDirOptions): js.Promise[typings.node.fsMod.Dir] = js.native
      
      /**
        * Asynchronously reads data from the file referenced by the supplied `FileHandle`.
        * @param handle A `FileHandle`.
        * @param buffer The buffer that the data will be written to.
        * @param offset The offset in the buffer at which to start writing.
        * @param length The number of bytes to read.
        * @param position The offset from the beginning of the file from which data should be read. If
        * `null`, data will be read from the current position.
        */
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](
        handle: FileHandle,
        buffer: TBuffer,
        offset: js.UndefOr[scala.Nothing],
        length: js.UndefOr[scala.Nothing],
        position: Double
      ): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: js.UndefOr[scala.Nothing], length: Double): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](
        handle: FileHandle,
        buffer: TBuffer,
        offset: js.UndefOr[scala.Nothing],
        length: Double,
        position: Double
      ): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](
        handle: FileHandle,
        buffer: TBuffer,
        offset: js.UndefOr[scala.Nothing],
        length: Null,
        position: Double
      ): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Double): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](
        handle: FileHandle,
        buffer: TBuffer,
        offset: Double,
        length: js.UndefOr[scala.Nothing],
        position: Double
      ): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Double, length: Double): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Double, length: Double, position: Double): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Double, length: Null, position: Double): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](
        handle: FileHandle,
        buffer: TBuffer,
        offset: Null,
        length: js.UndefOr[scala.Nothing],
        position: Double
      ): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Null, length: Double): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Null, length: Double, position: Double): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.read")
      @js.native
      def read[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Null, length: Null, position: Double): js.Promise[typings.node.anon.Buffer[TBuffer]] = js.native
      
      /**
        * Asynchronously reads the entire contents of a file.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
        * @param options An object that may contain an optional flag.
        * If a flag is not provided, it defaults to `'r'`.
        */
      @JSImport("mz", "fs.promises.readFile")
      @js.native
      def readFile(path: PathLike): js.Promise[Buffer] = js.native
      @JSImport("mz", "fs.promises.readFile")
      @js.native
      def readFile(path: PathLike, options: BufferEncoding): js.Promise[String] = js.native
      @JSImport("mz", "fs.promises.readFile")
      @js.native
      def readFile(path: PathLike, options: BaseEncodingOptionsflagOp): js.Promise[String | Buffer] = js.native
      /**
        * Asynchronously reads the entire contents of a file.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
        * @param options An object that may contain an optional flag.
        * If a flag is not provided, it defaults to `'r'`.
        */
      @JSImport("mz", "fs.promises.readFile")
      @js.native
      def readFile(path: PathLike, options: EncodingFlag): js.Promise[String] = js.native
      @JSImport("mz", "fs.promises.readFile")
      @js.native
      def readFile(path: PathLike, options: Flag): js.Promise[Buffer] = js.native
      @JSImport("mz", "fs.promises.readFile")
      @js.native
      def readFile(path: FileHandle): js.Promise[Buffer] = js.native
      @JSImport("mz", "fs.promises.readFile")
      @js.native
      def readFile(path: FileHandle, options: BufferEncoding): js.Promise[String] = js.native
      @JSImport("mz", "fs.promises.readFile")
      @js.native
      def readFile(path: FileHandle, options: BaseEncodingOptionsflagOp): js.Promise[String | Buffer] = js.native
      @JSImport("mz", "fs.promises.readFile")
      @js.native
      def readFile(path: FileHandle, options: EncodingFlag): js.Promise[String] = js.native
      @JSImport("mz", "fs.promises.readFile")
      @js.native
      def readFile(path: FileHandle, options: Flag): js.Promise[Buffer] = js.native
      
      /**
        * Asynchronous readdir(3) - read a directory.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
        */
      @JSImport("mz", "fs.promises.readdir")
      @js.native
      def readdir(path: PathLike): js.Promise[js.Array[String]] = js.native
      @JSImport("mz", "fs.promises.readdir")
      @js.native
      def readdir(path: PathLike, options: BufferEncoding): js.Promise[js.Array[String]] = js.native
      @JSImport("mz", "fs.promises.readdir")
      @js.native
      def readdir(path: PathLike, options: BaseEncodingOptionswithFi): js.Promise[js.Array[String]] = js.native
      /**
        * Asynchronous readdir(3) - read a directory.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param options If called with `withFileTypes: true` the result data will be an array of Dirent.
        */
      @JSImport("mz", "fs.promises.readdir")
      @js.native
      def readdir(path: PathLike, options: BaseEncodingOptionswithFiEncoding): js.Promise[js.Array[typings.node.fsMod.Dirent]] = js.native
      /**
        * Asynchronous readdir(3) - read a directory.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
        */
      @JSImport("mz", "fs.promises.readdir")
      @js.native
      def readdir(path: PathLike, options: typings.node.anon.Encoding): js.Promise[js.Array[Buffer]] = js.native
      @JSImport("mz", "fs.promises.readdir")
      @js.native
      def readdir_buffer(path: PathLike, options: buffer): js.Promise[js.Array[Buffer]] = js.native
      
      /**
        * Asynchronous readlink(2) - read value of a symbolic link.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
        */
      @JSImport("mz", "fs.promises.readlink")
      @js.native
      def readlink(path: PathLike): js.Promise[String] = js.native
      @JSImport("mz", "fs.promises.readlink")
      @js.native
      def readlink(path: PathLike, options: String): js.Promise[String | Buffer] = js.native
      @JSImport("mz", "fs.promises.readlink")
      @js.native
      def readlink(path: PathLike, options: BufferEncoding): js.Promise[String] = js.native
      @JSImport("mz", "fs.promises.readlink")
      @js.native
      def readlink(path: PathLike, options: BaseEncodingOptions): js.Promise[String] = js.native
      /**
        * Asynchronous readlink(2) - read value of a symbolic link.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
        */
      @JSImport("mz", "fs.promises.readlink")
      @js.native
      def readlink(path: PathLike, options: BufferEncodingOption): js.Promise[Buffer] = js.native
      
      /**
        * Asynchronous realpath(3) - return the canonicalized absolute pathname.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
        */
      @JSImport("mz", "fs.promises.realpath")
      @js.native
      def realpath(path: PathLike): js.Promise[String] = js.native
      @JSImport("mz", "fs.promises.realpath")
      @js.native
      def realpath(path: PathLike, options: BufferEncoding): js.Promise[String] = js.native
      @JSImport("mz", "fs.promises.realpath")
      @js.native
      def realpath(path: PathLike, options: BaseEncodingOptions): js.Promise[String] = js.native
      /**
        * Asynchronous realpath(3) - return the canonicalized absolute pathname.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param options The encoding (or an object specifying the encoding), used as the encoding of the result. If not provided, `'utf8'` is used.
        */
      @JSImport("mz", "fs.promises.realpath")
      @js.native
      def realpath(path: PathLike, options: BufferEncodingOption): js.Promise[Buffer] = js.native
      
      /**
        * Asynchronous rename(2) - Change the name or location of a file or directory.
        * @param oldPath A path to a file. If a URL is provided, it must use the `file:` protocol.
        * URL support is _experimental_.
        * @param newPath A path to a file. If a URL is provided, it must use the `file:` protocol.
        * URL support is _experimental_.
        */
      @JSImport("mz", "fs.promises.rename")
      @js.native
      def rename(oldPath: PathLike, newPath: PathLike): js.Promise[Unit] = js.native
      
      /**
        * Asynchronously removes files and directories (modeled on the standard POSIX `rm` utility).
        */
      @JSImport("mz", "fs.promises.rm")
      @js.native
      def rm(path: PathLike): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.rm")
      @js.native
      def rm(path: PathLike, options: RmOptions): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous rmdir(2) - delete a directory.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        */
      @JSImport("mz", "fs.promises.rmdir")
      @js.native
      def rmdir(path: PathLike): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.rmdir")
      @js.native
      def rmdir(path: PathLike, options: RmDirOptions): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous stat(2) - Get file status.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        */
      @JSImport("mz", "fs.promises.stat")
      @js.native
      def stat(path: PathLike): js.Promise[typings.node.fsMod.Stats] = js.native
      
      /**
        * Asynchronous symlink(2) - Create a new symbolic link to an existing file.
        * @param target A path to an existing file. If a URL is provided, it must use the `file:` protocol.
        * @param path A path to the new symlink. If a URL is provided, it must use the `file:` protocol.
        * @param type May be set to `'dir'`, `'file'`, or `'junction'` (default is `'file'`) and is only available on Windows (ignored on other platforms).
        * When using `'junction'`, the `target` argument will automatically be normalized to an absolute path.
        */
      @JSImport("mz", "fs.promises.symlink")
      @js.native
      def symlink(target: PathLike, path: PathLike): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.symlink")
      @js.native
      def symlink(target: PathLike, path: PathLike, `type`: String): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous truncate(2) - Truncate a file to a specified length.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param len If not specified, defaults to `0`.
        */
      @JSImport("mz", "fs.promises.truncate")
      @js.native
      def truncate(path: PathLike): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.truncate")
      @js.native
      def truncate(path: PathLike, len: Double): js.Promise[Unit] = js.native
      
      /**
        * Asynchronous unlink(2) - delete a name and possibly the file it refers to.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        */
      @JSImport("mz", "fs.promises.unlink")
      @js.native
      def unlink(path: PathLike): js.Promise[Unit] = js.native
      
      /**
        * Asynchronously change file timestamps of the file referenced by the supplied path.
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * @param atime The last access time. If a string is provided, it will be coerced to number.
        * @param mtime The last modified time. If a string is provided, it will be coerced to number.
        */
      @JSImport("mz", "fs.promises.utimes")
      @js.native
      def utimes(path: PathLike, atime: String, mtime: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.utimes")
      @js.native
      def utimes(path: PathLike, atime: String, mtime: Double): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.utimes")
      @js.native
      def utimes(path: PathLike, atime: String, mtime: Date): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.utimes")
      @js.native
      def utimes(path: PathLike, atime: Double, mtime: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.utimes")
      @js.native
      def utimes(path: PathLike, atime: Double, mtime: Double): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.utimes")
      @js.native
      def utimes(path: PathLike, atime: Double, mtime: Date): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.utimes")
      @js.native
      def utimes(path: PathLike, atime: Date, mtime: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.utimes")
      @js.native
      def utimes(path: PathLike, atime: Date, mtime: Double): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.utimes")
      @js.native
      def utimes(path: PathLike, atime: Date, mtime: Date): js.Promise[Unit] = js.native
      
      /**
        * Asynchronously writes `string` to the file referenced by the supplied `FileHandle`.
        * It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`
        * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.
        * @param handle A `FileHandle`.
        * @param string A string to write.
        * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
        * @param encoding The expected string encoding.
        */
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write(handle: FileHandle, string: String): js.Promise[BufferBytesWritten] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write(handle: FileHandle, string: String, position: js.UndefOr[scala.Nothing], encoding: BufferEncoding): js.Promise[BufferBytesWritten] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write(handle: FileHandle, string: String, position: Double): js.Promise[BufferBytesWritten] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write(handle: FileHandle, string: String, position: Double, encoding: BufferEncoding): js.Promise[BufferBytesWritten] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write(handle: FileHandle, string: String, position: Null, encoding: BufferEncoding): js.Promise[BufferBytesWritten] = js.native
      /**
        * Asynchronously writes `buffer` to the file referenced by the supplied `FileHandle`.
        * It is unsafe to call `fsPromises.write()` multiple times on the same file without waiting for the `Promise`
        * to be resolved (or rejected). For this scenario, `fs.createWriteStream` is strongly recommended.
        * @param handle A `FileHandle`.
        * @param buffer The buffer that the data will be written to.
        * @param offset The part of the buffer to be written. If not supplied, defaults to `0`.
        * @param length The number of bytes to write. If not supplied, defaults to `buffer.length - offset`.
        * @param position The offset from the beginning of the file where this data should be written. If not supplied, defaults to the current position.
        */
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](
        handle: FileHandle,
        buffer: TBuffer,
        offset: js.UndefOr[scala.Nothing],
        length: js.UndefOr[scala.Nothing],
        position: Double
      ): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: js.UndefOr[scala.Nothing], length: Double): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](
        handle: FileHandle,
        buffer: TBuffer,
        offset: js.UndefOr[scala.Nothing],
        length: Double,
        position: Double
      ): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](
        handle: FileHandle,
        buffer: TBuffer,
        offset: js.UndefOr[scala.Nothing],
        length: Null,
        position: Double
      ): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Double): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](
        handle: FileHandle,
        buffer: TBuffer,
        offset: Double,
        length: js.UndefOr[scala.Nothing],
        position: Double
      ): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Double, length: Double): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Double, length: Double, position: Double): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Double, length: Null, position: Double): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](
        handle: FileHandle,
        buffer: TBuffer,
        offset: Null,
        length: js.UndefOr[scala.Nothing],
        position: Double
      ): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Null, length: Double): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Null, length: Double, position: Double): js.Promise[BytesWritten[TBuffer]] = js.native
      @JSImport("mz", "fs.promises.write")
      @js.native
      def write[TBuffer /* <: Uint8Array */](handle: FileHandle, buffer: TBuffer, offset: Null, length: Null, position: Double): js.Promise[BytesWritten[TBuffer]] = js.native
      
      /**
        * Asynchronously writes data to a file, replacing the file if it already exists.
        * It is unsafe to call `fsPromises.writeFile()` multiple times on the same file without waiting for the `Promise` to be resolved (or rejected).
        * @param path A path to a file. If a URL is provided, it must use the `file:` protocol.
        * URL support is _experimental_.
        * If a `FileHandle` is provided, the underlying file will _not_ be closed automatically.
        * @param data The data to write. If something other than a `Buffer` or `Uint8Array` is provided, the value is coerced to a string.
        * @param options Either the encoding for the file, or an object optionally specifying the encoding, file mode, and flag.
        * If `encoding` is not supplied, the default of `'utf8'` is used.
        * If `mode` is not supplied, the default of `0o666` is used.
        * If `mode` is a string, it is parsed as an octal integer.
        * If `flag` is not supplied, the default of `'w'` is used.
        */
      @JSImport("mz", "fs.promises.writeFile")
      @js.native
      def writeFile(path: PathLike, data: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.writeFile")
      @js.native
      def writeFile(path: PathLike, data: String, options: BufferEncoding): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.writeFile")
      @js.native
      def writeFile(path: PathLike, data: String, options: BaseEncodingOptionsmodeMo): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.writeFile")
      @js.native
      def writeFile(path: PathLike, data: Uint8Array): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.writeFile")
      @js.native
      def writeFile(path: PathLike, data: Uint8Array, options: BufferEncoding): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.writeFile")
      @js.native
      def writeFile(path: PathLike, data: Uint8Array, options: BaseEncodingOptionsmodeMo): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.writeFile")
      @js.native
      def writeFile(path: FileHandle, data: String): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.writeFile")
      @js.native
      def writeFile(path: FileHandle, data: String, options: BufferEncoding): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.writeFile")
      @js.native
      def writeFile(path: FileHandle, data: String, options: BaseEncodingOptionsmodeMo): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.writeFile")
      @js.native
      def writeFile(path: FileHandle, data: Uint8Array): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.writeFile")
      @js.native
      def writeFile(path: FileHandle, data: Uint8Array, options: BufferEncoding): js.Promise[Unit] = js.native
      @JSImport("mz", "fs.promises.writeFile")
      @js.native
      def writeFile(path: FileHandle, data: Uint8Array, options: BaseEncodingOptionsmodeMo): js.Promise[Unit] = js.native
    }
    
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: DataView, offset: Double, length: Double): js.Promise[BufferDataView] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: DataView, offset: Double, length: Double, position: Double): js.Promise[BufferDataView] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* bytesRead */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* bytesRead */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Float32Array, offset: Double, length: Double): js.Promise[BufferFloat32Array] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Float32Array, offset: Double, length: Double, position: Double): js.Promise[BufferFloat32Array] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesRead */ Double, 
          /* buffer */ Float32Array, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesRead */ Double, 
          /* buffer */ Float32Array, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Float64Array, offset: Double, length: Double): js.Promise[BufferFloat64Array] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Float64Array, offset: Double, length: Double, position: Double): js.Promise[BufferFloat64Array] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesRead */ Double, 
          /* buffer */ Float64Array, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesRead */ Double, 
          /* buffer */ Float64Array, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Int16Array, offset: Double, length: Double): js.Promise[BufferInt16Array] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Int16Array, offset: Double, length: Double, position: Double): js.Promise[BufferInt16Array] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* bytesRead */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* bytesRead */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Int32Array, offset: Double, length: Double): js.Promise[BufferInt32Array] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Int32Array, offset: Double, length: Double, position: Double): js.Promise[BufferInt32Array] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* bytesRead */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* bytesRead */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Int8Array, offset: Double, length: Double): js.Promise[BufferInt8Array] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Int8Array, offset: Double, length: Double, position: Double): js.Promise[BufferInt8Array] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* bytesRead */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* bytesRead */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Uint16Array, offset: Double, length: Double): js.Promise[BufferBytesRead] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Uint16Array, offset: Double, length: Double, position: Double): js.Promise[BufferBytesRead] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesRead */ Double, 
          /* buffer */ Uint16Array, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesRead */ Double, 
          /* buffer */ Uint16Array, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Uint32Array, offset: Double, length: Double): js.Promise[BufferUint32Array] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Uint32Array, offset: Double, length: Double, position: Double): js.Promise[BufferUint32Array] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesRead */ Double, 
          /* buffer */ Uint32Array, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesRead */ Double, 
          /* buffer */ Uint32Array, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Uint8Array, offset: Double, length: Double): js.Promise[typings.mz.anon.Buffer] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Uint8Array, offset: Double, length: Double, position: Double): js.Promise[typings.mz.anon.Buffer] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* bytesRead */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* bytesRead */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Uint8ClampedArray, offset: Double, length: Double): js.Promise[BytesRead] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(fd: Double, buffer: Uint8ClampedArray, offset: Double, length: Double, position: Double): js.Promise[BytesRead] = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesRead */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.read")
    @js.native
    def read(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesRead */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(path: Double): js.Promise[Buffer] = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(path: Double, callback: js.Function2[/* err */ ErrnoException | Null, /* data */ Buffer, Unit]): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(
      path: Double,
      options: js.UndefOr[scala.Nothing],
      callback: js.Function2[ErrnoException | Null, (/* data */ Buffer) | String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(path: Double, options: String): js.Promise[String] = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(
      path: Double,
      options: String,
      callback: js.Function2[ErrnoException | Null, Buffer | (/* data */ String), Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(
      path: Double,
      options: Null,
      callback: js.Function2[ErrnoException | Null, (/* data */ Buffer) | String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(path: Double, options: typings.mz.anon.EncodingFlag): js.Promise[String] = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(
      path: Double,
      options: typings.mz.anon.EncodingFlag,
      callback: js.Function2[/* err */ ErrnoException | Null, /* data */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(path: Double, options: typings.mz.anon.Flag): js.Promise[Buffer] = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(
      path: Double,
      options: typings.mz.anon.Flag,
      callback: js.Function2[/* err */ ErrnoException | Null, /* data */ Buffer, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(path: Double, options: `4`): js.Promise[String | Buffer] = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(
      path: Double,
      options: `4`,
      callback: js.Function2[/* err */ ErrnoException | Null, /* data */ String | Buffer, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(path: PathLike): js.Promise[Buffer] = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(path: PathLike, callback: js.Function2[/* err */ ErrnoException | Null, /* data */ Buffer, Unit]): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(
      path: PathLike,
      options: js.UndefOr[scala.Nothing],
      callback: js.Function2[ErrnoException | Null, (/* data */ Buffer) | String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(path: PathLike, options: String): js.Promise[String] = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(
      path: PathLike,
      options: String,
      callback: js.Function2[ErrnoException | Null, Buffer | (/* data */ String), Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(
      path: PathLike,
      options: Null,
      callback: js.Function2[ErrnoException | Null, (/* data */ Buffer) | String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(path: PathLike, options: typings.mz.anon.EncodingFlag): js.Promise[String] = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(
      path: PathLike,
      options: typings.mz.anon.EncodingFlag,
      callback: js.Function2[/* err */ ErrnoException | Null, /* data */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(path: PathLike, options: typings.mz.anon.Flag): js.Promise[Buffer] = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(
      path: PathLike,
      options: typings.mz.anon.Flag,
      callback: js.Function2[/* err */ ErrnoException | Null, /* data */ Buffer, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(path: PathLike, options: `4`): js.Promise[String | Buffer] = js.native
    @JSImport("mz", "fs.readFile")
    @js.native
    def readFile(
      path: PathLike,
      options: `4`,
      callback: js.Function2[/* err */ ErrnoException | Null, /* data */ String | Buffer, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync(path: Double): String | Buffer = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync(path: Double, options: BufferEncoding): String = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync(path: Double, options: BaseEncodingOptionsflagst): String | Buffer = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync(path: Double, options: EncodingBufferEncoding): String = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync(path: Double, options: `3`): Buffer = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync(path: PathLike): String | Buffer = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync(path: PathLike, options: BufferEncoding): String = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync(path: PathLike, options: BaseEncodingOptionsflagst): String | Buffer = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync(path: PathLike, options: EncodingBufferEncoding): String = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync(path: PathLike, options: `3`): Buffer = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync_Buffer(path: Double): Buffer = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync_Buffer(path: PathLike): Buffer = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync_Union(path: Double, options: BufferEncoding): String | Buffer = js.native
    @JSImport("mz", "fs.readFileSync")
    @js.native
    def readFileSync_Union(path: PathLike, options: BufferEncoding): String | Buffer = js.native
    
    @JSImport("mz", "fs.readSync")
    @js.native
    def readSync(fd: Double, buffer: ArrayBufferView): Double = js.native
    @JSImport("mz", "fs.readSync")
    @js.native
    def readSync(fd: Double, buffer: ArrayBufferView, offset: Double, length: Double): Double = js.native
    @JSImport("mz", "fs.readSync")
    @js.native
    def readSync(fd: Double, buffer: ArrayBufferView, offset: Double, length: Double, position: Double): Double = js.native
    @JSImport("mz", "fs.readSync")
    @js.native
    def readSync(fd: Double, buffer: ArrayBufferView, opts: ReadSyncOptions): Double = js.native
    
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(path: PathLike): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(
      path: PathLike,
      callback: js.Function2[/* err */ ErrnoException | Null, /* files */ js.Array[String], Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(
      path: PathLike,
      options: js.UndefOr[scala.Nothing],
      callback: js.Function2[ErrnoException | Null, /* files */ js.Array[Buffer | String], Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(path: PathLike, options: String): js.Promise[js.Array[Buffer | String]] = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(
      path: PathLike,
      options: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* files */ js.Array[Buffer | String], Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(
      path: PathLike,
      options: Null,
      callback: js.Function2[ErrnoException | Null, /* files */ js.Array[Buffer | String], Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(path: PathLike, options: EncodingWithFileTypes): js.Promise[js.Array[Buffer]] = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(
      path: PathLike,
      options: EncodingWithFileTypes,
      callback: js.Function2[/* err */ ErrnoException | Null, /* files */ js.Array[Buffer], Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(path: PathLike, options: WithFileTypes): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(
      path: PathLike,
      options: WithFileTypes,
      callback: js.Function2[/* err */ ErrnoException | Null, /* files */ js.Array[String], Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(path: PathLike, options: `2`): js.Promise[js.Array[Buffer | String]] = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(
      path: PathLike,
      options: `2`,
      callback: js.Function2[/* err */ ErrnoException | Null, /* files */ js.Array[Buffer | String], Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(path: PathLike, options: typings.mz.anon.`3`): js.Promise[js.Array[typings.node.fsMod.Dirent]] = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(
      path: PathLike,
      options: typings.mz.anon.`3`,
      callback: js.Function2[
          /* err */ ErrnoException | Null, 
          /* files */ js.Array[typings.node.fsMod.Dirent], 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(path: PathLike, options: BufferEncoding): js.Promise[js.Array[String]] = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir(
      path: PathLike,
      options: BufferEncoding,
      callback: js.Function2[/* err */ ErrnoException | Null, /* files */ js.Array[String], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.readdirSync")
    @js.native
    def readdirSync(path: PathLike): js.Array[String] = js.native
    @JSImport("mz", "fs.readdirSync")
    @js.native
    def readdirSync(path: PathLike, options: BufferEncoding): js.Array[String] = js.native
    @JSImport("mz", "fs.readdirSync")
    @js.native
    def readdirSync(path: PathLike, options: BaseEncodingOptionswithFi): js.Array[Buffer | String] = js.native
    @JSImport("mz", "fs.readdirSync")
    @js.native
    def readdirSync(path: PathLike, options: BaseEncodingOptionswithFiEncoding): js.Array[typings.node.fsMod.Dirent] = js.native
    @JSImport("mz", "fs.readdirSync")
    @js.native
    def readdirSync(path: PathLike, options: typings.node.anon.Encoding): js.Array[Buffer] = js.native
    @JSImport("mz", "fs.readdirSync")
    @js.native
    def readdirSync(path: PathLike, options: typings.node.anon.WithFileTypes): js.Array[String] = js.native
    @JSImport("mz", "fs.readdirSync")
    @js.native
    def readdirSync_buffer(path: PathLike, options: buffer): js.Array[Buffer] = js.native
    
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir_buffer(path: PathLike, options: buffer): js.Promise[js.Array[Buffer]] = js.native
    @JSImport("mz", "fs.readdir")
    @js.native
    def readdir_buffer(
      path: PathLike,
      options: buffer,
      callback: js.Function2[/* err */ ErrnoException | Null, /* files */ js.Array[Buffer], Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(path: PathLike): js.Promise[String] = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(
      path: PathLike,
      callback: js.Function2[/* err */ ErrnoException | Null, /* linkString */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(
      path: PathLike,
      options: js.UndefOr[scala.Nothing],
      callback: js.Function2[ErrnoException | Null, Buffer | (/* linkString */ String), Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(path: PathLike, options: String): js.Promise[String | Buffer] = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(
      path: PathLike,
      options: String,
      callback: js.Function2[/* err */ ErrnoException | Null, /* linkString */ String | Buffer, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(
      path: PathLike,
      options: Null,
      callback: js.Function2[ErrnoException | Null, Buffer | (/* linkString */ String), Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(path: PathLike, options: Encoding): js.Promise[String] = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(
      path: PathLike,
      options: Encoding,
      callback: js.Function2[/* err */ ErrnoException | Null, /* linkString */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(path: PathLike, options: typings.mz.anon.`0`): js.Promise[Buffer] = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(
      path: PathLike,
      options: typings.mz.anon.`0`,
      callback: js.Function2[/* err */ ErrnoException | Null, /* linkString */ Buffer, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(path: PathLike, options: typings.mz.anon.`1`): js.Promise[String | Buffer] = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(
      path: PathLike,
      options: typings.mz.anon.`1`,
      callback: js.Function2[/* err */ ErrnoException | Null, /* linkString */ String | Buffer, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(path: PathLike, options: BufferEncoding): js.Promise[String] = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink(
      path: PathLike,
      options: BufferEncoding,
      callback: js.Function2[/* err */ ErrnoException | Null, /* linkString */ String, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.readlinkSync")
    @js.native
    def readlinkSync(path: PathLike): String = js.native
    @JSImport("mz", "fs.readlinkSync")
    @js.native
    def readlinkSync(path: PathLike, options: String): String | Buffer = js.native
    @JSImport("mz", "fs.readlinkSync")
    @js.native
    def readlinkSync(path: PathLike, options: BufferEncoding): String = js.native
    @JSImport("mz", "fs.readlinkSync")
    @js.native
    def readlinkSync(path: PathLike, options: BaseEncodingOptions): String = js.native
    @JSImport("mz", "fs.readlinkSync")
    @js.native
    def readlinkSync(path: PathLike, options: BufferEncodingOption): Buffer = js.native
    @JSImport("mz", "fs.readlinkSync")
    @js.native
    def readlinkSync_Union(path: PathLike): String | Buffer = js.native
    @JSImport("mz", "fs.readlinkSync")
    @js.native
    def readlinkSync_Union(path: PathLike, options: BaseEncodingOptions): String | Buffer = js.native
    
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink_buffer(path: PathLike, options: buffer): js.Promise[Buffer] = js.native
    @JSImport("mz", "fs.readlink")
    @js.native
    def readlink_buffer(
      path: PathLike,
      options: buffer,
      callback: js.Function2[/* err */ ErrnoException | Null, /* linkString */ Buffer, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.readv")
    @js.native
    def readv(
      fd: Double,
      buffers: js.Array[ArrayBufferView],
      cb: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesRead */ Double, 
          /* buffers */ js.Array[ArrayBufferView], 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.readv")
    @js.native
    def readv(
      fd: Double,
      buffers: js.Array[ArrayBufferView],
      position: Double,
      cb: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesRead */ Double, 
          /* buffers */ js.Array[ArrayBufferView], 
          Unit
        ]
    ): Unit = js.native
    
    @JSImport("mz", "fs.readvSync")
    @js.native
    def readvSync(fd: Double, buffers: js.Array[ArrayBufferView]): Double = js.native
    @JSImport("mz", "fs.readvSync")
    @js.native
    def readvSync(fd: Double, buffers: js.Array[ArrayBufferView], position: Double): Double = js.native
    
    object realpath {
      
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(path: PathLike): js.Promise[String] = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(
        path: PathLike,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ String, Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(
        path: PathLike,
        options: js.UndefOr[scala.Nothing],
        callback: js.Function2[ErrnoException | Null, Buffer | (/* resolvedPath */ String), Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(path: PathLike, options: String): js.Promise[String | Buffer] = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(
        path: PathLike,
        options: String,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ String | Buffer, Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(
        path: PathLike,
        options: Null,
        callback: js.Function2[ErrnoException | Null, Buffer | (/* resolvedPath */ String), Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(path: PathLike, options: Encoding): js.Promise[String] = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(
        path: PathLike,
        options: Encoding,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ String, Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(path: PathLike, options: typings.mz.anon.`0`): js.Promise[Buffer] = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(
        path: PathLike,
        options: typings.mz.anon.`0`,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ Buffer, Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(path: PathLike, options: typings.mz.anon.`1`): js.Promise[String | Buffer] = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(
        path: PathLike,
        options: typings.mz.anon.`1`,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ String | Buffer, Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(path: PathLike, options: buffer): js.Promise[Buffer] = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(
        path: PathLike,
        options: buffer,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ Buffer, Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(path: PathLike, options: BufferEncoding): js.Promise[String] = js.native
      @JSImport("mz", "fs.realpath")
      @js.native
      def apply(
        path: PathLike,
        options: BufferEncoding,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ String, Unit]
      ): Unit = js.native
      
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(path: PathLike): js.Promise[String] = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(
        path: PathLike,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ String, Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(
        path: PathLike,
        options: js.UndefOr[scala.Nothing],
        callback: js.Function2[ErrnoException | Null, Buffer | (/* resolvedPath */ String), Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(path: PathLike, options: String): js.Promise[String | Buffer] = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(
        path: PathLike,
        options: String,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ String | Buffer, Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(
        path: PathLike,
        options: Null,
        callback: js.Function2[ErrnoException | Null, Buffer | (/* resolvedPath */ String), Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(path: PathLike, options: Encoding): js.Promise[String] = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(
        path: PathLike,
        options: Encoding,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ String, Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(path: PathLike, options: typings.mz.anon.`0`): js.Promise[Buffer] = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(
        path: PathLike,
        options: typings.mz.anon.`0`,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ Buffer, Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(path: PathLike, options: typings.mz.anon.`1`): js.Promise[String | Buffer] = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(
        path: PathLike,
        options: typings.mz.anon.`1`,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ String | Buffer, Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(path: PathLike, options: BufferEncoding): js.Promise[String] = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native(
        path: PathLike,
        options: BufferEncoding,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ String, Unit]
      ): Unit = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native_buffer(path: PathLike, options: buffer): js.Promise[Buffer] = js.native
      @JSImport("mz", "fs.realpath.native")
      @js.native
      def native_buffer(
        path: PathLike,
        options: buffer,
        callback: js.Function2[/* err */ ErrnoException | Null, /* resolvedPath */ Buffer, Unit]
      ): Unit = js.native
    }
    
    object realpathSync {
      
      @JSImport("mz", "fs.realpathSync")
      @js.native
      def apply(path: PathLike): String = js.native
      @JSImport("mz", "fs.realpathSync")
      @js.native
      def apply(path: PathLike, options: String): String | Buffer = js.native
      @JSImport("mz", "fs.realpathSync")
      @js.native
      def apply(path: PathLike, options: BufferEncoding): String = js.native
      @JSImport("mz", "fs.realpathSync")
      @js.native
      def apply(path: PathLike, options: BaseEncodingOptions): String = js.native
      @JSImport("mz", "fs.realpathSync")
      @js.native
      def apply(path: PathLike, options: BufferEncodingOption): Buffer = js.native
      
      @JSImport("mz", "fs.realpathSync.native")
      @js.native
      def native(path: PathLike): String = js.native
      @JSImport("mz", "fs.realpathSync.native")
      @js.native
      def native(path: PathLike, options: String): String | Buffer = js.native
      @JSImport("mz", "fs.realpathSync.native")
      @js.native
      def native(path: PathLike, options: BufferEncoding): String = js.native
      @JSImport("mz", "fs.realpathSync.native")
      @js.native
      def native(path: PathLike, options: BaseEncodingOptions): String = js.native
      @JSImport("mz", "fs.realpathSync.native")
      @js.native
      def native(path: PathLike, options: BufferEncodingOption): Buffer = js.native
      @JSImport("mz", "fs.realpathSync.native")
      @js.native
      def native_Union(path: PathLike): String | Buffer = js.native
      @JSImport("mz", "fs.realpathSync.native")
      @js.native
      def native_Union(path: PathLike, options: BaseEncodingOptions): String | Buffer = js.native
    }
    
    @JSImport("mz", "fs.rename")
    @js.native
    def rename(oldPath: PathLike, newPath: PathLike): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.rename")
    @js.native
    def rename(oldPath: PathLike, newPath: PathLike, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.renameSync")
    @js.native
    def renameSync(oldPath: PathLike, newPath: PathLike): Unit = js.native
    
    @JSImport("mz", "fs.rm")
    @js.native
    def rm(path: PathLike, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.rm")
    @js.native
    def rm(path: PathLike, options: RmOptions, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.rmSync")
    @js.native
    def rmSync(path: PathLike): Unit = js.native
    @JSImport("mz", "fs.rmSync")
    @js.native
    def rmSync(path: PathLike, options: RmOptions): Unit = js.native
    
    @JSImport("mz", "fs.rmdir")
    @js.native
    def rmdir(path: PathLike): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.rmdir")
    @js.native
    def rmdir(path: PathLike, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.rmdir")
    @js.native
    def rmdir(path: PathLike, options: RmDirOptions): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.rmdir")
    @js.native
    def rmdir(path: PathLike, options: RmDirOptions, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.rmdirSync")
    @js.native
    def rmdirSync(path: PathLike): Unit = js.native
    @JSImport("mz", "fs.rmdirSync")
    @js.native
    def rmdirSync(path: PathLike, options: RmDirOptions): Unit = js.native
    
    @JSImport("mz", "fs.stat")
    @js.native
    def stat(path: PathLike): js.Promise[typings.node.fsMod.Stats] = js.native
    @JSImport("mz", "fs.stat")
    @js.native
    def stat(
      path: PathLike,
      callback: js.Function2[/* err */ ErrnoException | Null, /* stats */ typings.node.fsMod.Stats, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.statSync")
    @js.native
    def statSync(path: PathLike): typings.node.fsMod.Stats = js.native
    @JSImport("mz", "fs.statSync")
    @js.native
    def statSync(path: PathLike, options: BigIntOptions): typings.node.fsMod.BigIntStats = js.native
    @JSImport("mz", "fs.statSync")
    @js.native
    def statSync(path: PathLike, options: StatOptions): typings.node.fsMod.Stats | typings.node.fsMod.BigIntStats = js.native
    
    @JSImport("mz", "fs.symlink")
    @js.native
    def symlink(target: PathLike, path: PathLike): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.symlink")
    @js.native
    def symlink(target: PathLike, path: PathLike, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.symlink")
    @js.native
    def symlink(target: PathLike, path: PathLike, `type`: js.UndefOr[scala.Nothing], callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.symlink")
    @js.native
    def symlink(target: PathLike, path: PathLike, `type`: String): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.symlink")
    @js.native
    def symlink(target: PathLike, path: PathLike, `type`: Null, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.symlink")
    @js.native
    def symlink(target: PathLike, path: PathLike, `type`: Type, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.symlinkSync")
    @js.native
    def symlinkSync(target: PathLike, path: PathLike): Unit = js.native
    @JSImport("mz", "fs.symlinkSync")
    @js.native
    def symlinkSync(target: PathLike, path: PathLike, `type`: Type): Unit = js.native
    
    @JSImport("mz", "fs.truncate")
    @js.native
    def truncate(path: PathLike): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.truncate")
    @js.native
    def truncate(path: PathLike, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.truncate")
    @js.native
    def truncate(path: PathLike, len: js.UndefOr[scala.Nothing], callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.truncate")
    @js.native
    def truncate(path: PathLike, len: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.truncate")
    @js.native
    def truncate(path: PathLike, len: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.truncate")
    @js.native
    def truncate(path: PathLike, len: Null, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.truncateSync")
    @js.native
    def truncateSync(path: PathLike): Unit = js.native
    @JSImport("mz", "fs.truncateSync")
    @js.native
    def truncateSync(path: PathLike, len: Double): Unit = js.native
    
    @JSImport("mz", "fs.unlink")
    @js.native
    def unlink(path: PathLike): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.unlink")
    @js.native
    def unlink(path: PathLike, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.unlinkSync")
    @js.native
    def unlinkSync(path: PathLike): Unit = js.native
    
    @JSImport("mz", "fs.unwatchFile")
    @js.native
    def unwatchFile(filename: PathLike): Unit = js.native
    @JSImport("mz", "fs.unwatchFile")
    @js.native
    def unwatchFile(
      filename: PathLike,
      listener: js.Function2[/* curr */ typings.node.fsMod.Stats, /* prev */ typings.node.fsMod.Stats, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: String, mtime: String): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: String, mtime: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: String, mtime: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: String, mtime: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: String, mtime: Date): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: String, mtime: Date, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: Double, mtime: String): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: Double, mtime: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: Double, mtime: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: Double, mtime: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: Double, mtime: Date): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: Double, mtime: Date, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: Date, mtime: String): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: Date, mtime: String, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: Date, mtime: Double): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: Date, mtime: Double, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: Date, mtime: Date): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.utimes")
    @js.native
    def utimes(path: PathLike, atime: Date, mtime: Date, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.utimesSync")
    @js.native
    def utimesSync(path: PathLike, atime: String, mtime: String): Unit = js.native
    @JSImport("mz", "fs.utimesSync")
    @js.native
    def utimesSync(path: PathLike, atime: String, mtime: Double): Unit = js.native
    @JSImport("mz", "fs.utimesSync")
    @js.native
    def utimesSync(path: PathLike, atime: String, mtime: Date): Unit = js.native
    @JSImport("mz", "fs.utimesSync")
    @js.native
    def utimesSync(path: PathLike, atime: Double, mtime: String): Unit = js.native
    @JSImport("mz", "fs.utimesSync")
    @js.native
    def utimesSync(path: PathLike, atime: Double, mtime: Double): Unit = js.native
    @JSImport("mz", "fs.utimesSync")
    @js.native
    def utimesSync(path: PathLike, atime: Double, mtime: Date): Unit = js.native
    @JSImport("mz", "fs.utimesSync")
    @js.native
    def utimesSync(path: PathLike, atime: Date, mtime: String): Unit = js.native
    @JSImport("mz", "fs.utimesSync")
    @js.native
    def utimesSync(path: PathLike, atime: Date, mtime: Double): Unit = js.native
    @JSImport("mz", "fs.utimesSync")
    @js.native
    def utimesSync(path: PathLike, atime: Date, mtime: Date): Unit = js.native
    
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(filename: PathLike): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(filename: PathLike, listener: js.Function2[/* event */ String, /* filename */ String, _]): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(
      filename: PathLike,
      options: js.UndefOr[scala.Nothing],
      listener: js.Function2[/* event */ String, /* filename */ String, Unit]
    ): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(filename: PathLike, options: String): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(
      filename: PathLike,
      options: String,
      listener: js.Function2[/* event */ String, /* filename */ String | Buffer, Unit]
    ): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(
      filename: PathLike,
      options: Null,
      listener: js.Function2[/* event */ String, Buffer | (/* filename */ String), Unit]
    ): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(filename: PathLike, options: EncodingPersistent): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(
      filename: PathLike,
      options: EncodingPersistent,
      listener: js.Function2[/* event */ String, /* filename */ String | Buffer, Unit]
    ): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(filename: PathLike, options: Persistent): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(
      filename: PathLike,
      options: Persistent,
      listener: js.Function2[/* event */ String, /* filename */ String, Unit]
    ): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(filename: PathLike, options: Recursive): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(
      filename: PathLike,
      options: Recursive,
      listener: js.Function2[/* event */ String, /* filename */ Buffer, Unit]
    ): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(filename: PathLike, options: BufferEncoding): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch(
      filename: PathLike,
      options: BufferEncoding,
      listener: js.Function2[/* event */ String, /* filename */ String, Unit]
    ): FSWatcher = js.native
    
    @JSImport("mz", "fs.watchFile")
    @js.native
    def watchFile(
      filename: PathLike,
      listener: js.Function2[/* curr */ typings.node.fsMod.Stats, /* prev */ typings.node.fsMod.Stats, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.watchFile")
    @js.native
    def watchFile(
      filename: PathLike,
      options: js.UndefOr[scala.Nothing],
      listener: js.Function2[/* curr */ typings.node.fsMod.Stats, /* prev */ typings.node.fsMod.Stats, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.watchFile")
    @js.native
    def watchFile(
      filename: PathLike,
      options: Interval,
      listener: js.Function2[/* curr */ typings.node.fsMod.Stats, /* prev */ typings.node.fsMod.Stats, Unit]
    ): Unit = js.native
    
    @JSImport("mz", "fs.watch")
    @js.native
    def watch_buffer(filename: PathLike, options: buffer): FSWatcher = js.native
    @JSImport("mz", "fs.watch")
    @js.native
    def watch_buffer(
      filename: PathLike,
      options: buffer,
      listener: js.Function2[/* event */ String, /* filename */ Buffer, Unit]
    ): FSWatcher = js.native
    
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Double,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: DataView,
      offset: Null,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ DataView, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Double,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float32Array,
      offset: Null,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Double,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Float64Array,
      offset: Null,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Float64Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Double,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int16Array,
      offset: Null,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Double,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int32Array,
      offset: Null,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Double,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Int8Array,
      offset: Null,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Int8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Double,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint16Array,
      offset: Null,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint16Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Double,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint32Array,
      offset: Null,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint32Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Double,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      length: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      length: Double,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      length: Double,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      length: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      length: Null,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8Array,
      offset: Null,
      length: Null,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* buffer */ Uint8Array, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: Double,
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: Double,
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: Null,
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Double,
      length: Null,
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      length: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      length: Double,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      length: Double,
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      length: Double,
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      length: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      length: Null,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      length: Null,
      position: Double,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      buffer: Uint8ClampedArray,
      offset: Null,
      length: Null,
      position: Null,
      callback: js.Function3[
          /* err */ ErrnoException | Null, 
          /* written */ Double, 
          /* buffer */ Uint8ClampedArray, 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      position: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      position: js.UndefOr[scala.Nothing],
      encoding: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      position: js.UndefOr[scala.Nothing],
      encoding: String,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      position: js.UndefOr[scala.Nothing],
      encoding: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      position: Double,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      position: Double,
      encoding: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      position: Double,
      encoding: String,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      position: Double,
      encoding: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      position: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      position: Null,
      encoding: js.UndefOr[scala.Nothing],
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      position: Null,
      encoding: String,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(
      fd: Double,
      data: js.Any,
      position: Null,
      encoding: Null,
      callback: js.Function3[/* err */ ErrnoException | Null, /* written */ Double, /* str */ String, Unit]
    ): Unit = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(fd: Double, string: js.Any): js.Promise[js.Tuple2[Double, String]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(fd: Double, string: js.Any, position: js.UndefOr[scala.Nothing], encoding: String): js.Promise[js.Tuple2[Double, String]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(fd: Double, string: js.Any, position: Double): js.Promise[js.Tuple2[Double, String]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(fd: Double, string: js.Any, position: Double, encoding: String): js.Promise[js.Tuple2[Double, String]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write(fd: Double, string: js.Any, position: Null, encoding: String): js.Promise[js.Tuple2[Double, String]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](fd: Double): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](fd: Double, buffer: TBuffer): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](
      fd: Double,
      buffer: TBuffer,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double
    ): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](fd: Double, buffer: TBuffer, offset: js.UndefOr[scala.Nothing], length: Double): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](fd: Double, buffer: TBuffer, offset: js.UndefOr[scala.Nothing], length: Double, position: Double): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](fd: Double, buffer: TBuffer, offset: Double): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](fd: Double, buffer: TBuffer, offset: Double, length: js.UndefOr[scala.Nothing], position: Double): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](fd: Double, buffer: TBuffer, offset: Double, length: Double): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](fd: Double, buffer: TBuffer, offset: Double, length: Double, position: Double): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](
      fd: Double,
      buffer: js.UndefOr[scala.Nothing],
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double
    ): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](fd: Double, buffer: js.UndefOr[scala.Nothing], offset: js.UndefOr[scala.Nothing], length: Double): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](
      fd: Double,
      buffer: js.UndefOr[scala.Nothing],
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Double
    ): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](fd: Double, buffer: js.UndefOr[scala.Nothing], offset: Double): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](
      fd: Double,
      buffer: js.UndefOr[scala.Nothing],
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Double
    ): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](fd: Double, buffer: js.UndefOr[scala.Nothing], offset: Double, length: Double): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    @JSImport("mz", "fs.write")
    @js.native
    def write[TBuffer /* <: ArrayBufferView */](fd: Double, buffer: js.UndefOr[scala.Nothing], offset: Double, length: Double, position: Double): js.Promise[js.Tuple2[Double, TBuffer]] = js.native
    
    @JSImport("mz", "fs.writeFile")
    @js.native
    def writeFile(path: Double, data: js.Any): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.writeFile")
    @js.native
    def writeFile(path: Double, data: js.Any, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.writeFile")
    @js.native
    def writeFile(path: Double, data: js.Any, options: WriteFileOptions): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.writeFile")
    @js.native
    def writeFile(path: Double, data: js.Any, options: WriteFileOptions, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.writeFile")
    @js.native
    def writeFile(path: PathLike, data: js.Any): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.writeFile")
    @js.native
    def writeFile(path: PathLike, data: js.Any, callback: NoParamCallback): Unit = js.native
    @JSImport("mz", "fs.writeFile")
    @js.native
    def writeFile(path: PathLike, data: js.Any, options: WriteFileOptions): js.Promise[Unit] = js.native
    @JSImport("mz", "fs.writeFile")
    @js.native
    def writeFile(path: PathLike, data: js.Any, options: WriteFileOptions, callback: NoParamCallback): Unit = js.native
    
    @JSImport("mz", "fs.writeFileSync")
    @js.native
    def writeFileSync(path: Double, data: String): Unit = js.native
    @JSImport("mz", "fs.writeFileSync")
    @js.native
    def writeFileSync(path: Double, data: String, options: WriteFileOptions): Unit = js.native
    @JSImport("mz", "fs.writeFileSync")
    @js.native
    def writeFileSync(path: Double, data: ArrayBufferView): Unit = js.native
    @JSImport("mz", "fs.writeFileSync")
    @js.native
    def writeFileSync(path: Double, data: ArrayBufferView, options: WriteFileOptions): Unit = js.native
    @JSImport("mz", "fs.writeFileSync")
    @js.native
    def writeFileSync(path: PathLike, data: String): Unit = js.native
    @JSImport("mz", "fs.writeFileSync")
    @js.native
    def writeFileSync(path: PathLike, data: String, options: WriteFileOptions): Unit = js.native
    @JSImport("mz", "fs.writeFileSync")
    @js.native
    def writeFileSync(path: PathLike, data: ArrayBufferView): Unit = js.native
    @JSImport("mz", "fs.writeFileSync")
    @js.native
    def writeFileSync(path: PathLike, data: ArrayBufferView, options: WriteFileOptions): Unit = js.native
    
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, buffer: ArrayBufferView): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(
      fd: Double,
      buffer: ArrayBufferView,
      offset: js.UndefOr[scala.Nothing],
      length: js.UndefOr[scala.Nothing],
      position: Double
    ): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, buffer: ArrayBufferView, offset: js.UndefOr[scala.Nothing], length: Double): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(
      fd: Double,
      buffer: ArrayBufferView,
      offset: js.UndefOr[scala.Nothing],
      length: Double,
      position: Double
    ): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(
      fd: Double,
      buffer: ArrayBufferView,
      offset: js.UndefOr[scala.Nothing],
      length: Null,
      position: Double
    ): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, buffer: ArrayBufferView, offset: Double): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(
      fd: Double,
      buffer: ArrayBufferView,
      offset: Double,
      length: js.UndefOr[scala.Nothing],
      position: Double
    ): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, buffer: ArrayBufferView, offset: Double, length: Double): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, buffer: ArrayBufferView, offset: Double, length: Double, position: Double): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, buffer: ArrayBufferView, offset: Double, length: Null, position: Double): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(
      fd: Double,
      buffer: ArrayBufferView,
      offset: Null,
      length: js.UndefOr[scala.Nothing],
      position: Double
    ): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, buffer: ArrayBufferView, offset: Null, length: Double): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, buffer: ArrayBufferView, offset: Null, length: Double, position: Double): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, buffer: ArrayBufferView, offset: Null, length: Null, position: Double): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, string: String): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, string: String, position: js.UndefOr[scala.Nothing], encoding: BufferEncoding): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, string: String, position: Double): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, string: String, position: Double, encoding: BufferEncoding): Double = js.native
    @JSImport("mz", "fs.writeSync")
    @js.native
    def writeSync(fd: Double, string: String, position: Null, encoding: BufferEncoding): Double = js.native
    
    @JSImport("mz", "fs.writev")
    @js.native
    def writev(fd: Double, buffers: js.Array[ArrayBufferView]): js.Promise[js.Tuple2[Double, js.Array[ArrayBufferView]]] = js.native
    @JSImport("mz", "fs.writev")
    @js.native
    def writev(
      fd: Double,
      buffers: js.Array[ArrayBufferView],
      cb: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesWritten */ Double, 
          /* buffers */ js.Array[ArrayBufferView], 
          Unit
        ]
    ): Unit = js.native
    @JSImport("mz", "fs.writev")
    @js.native
    def writev(fd: Double, buffers: js.Array[ArrayBufferView], position: Double): js.Promise[js.Tuple2[Double, js.Array[ArrayBufferView]]] = js.native
    @JSImport("mz", "fs.writev")
    @js.native
    def writev(
      fd: Double,
      buffers: js.Array[ArrayBufferView],
      position: Double,
      cb: js.Function3[
          /* err */ ErrnoException | Null, 
          /* bytesWritten */ Double, 
          /* buffers */ js.Array[ArrayBufferView], 
          Unit
        ]
    ): Unit = js.native
    
    @JSImport("mz", "fs.writevSync")
    @js.native
    def writevSync(fd: Double, buffers: js.Array[ArrayBufferView]): Double = js.native
    @JSImport("mz", "fs.writevSync")
    @js.native
    def writevSync(fd: Double, buffers: js.Array[ArrayBufferView], position: Double): Double = js.native
  }
  
  object readline {
    
    @JSImport("mz", "readline.Interface")
    @js.native
    class Interface protected ()
      extends typings.mz.readlineMod.Interface {
      /**
        * NOTE: According to the documentation:
        *
        * > Instances of the `readline.Interface` class are constructed using the
        * > `readline.createInterface()` method.
        *
        * @see https://nodejs.org/dist/latest-v10.x/docs/api/readline.html#readline_class_interface
        */
      protected def this(input: ReadableStream) = this()
      /**
        * NOTE: According to the documentation:
        *
        * > Instances of the `readline.Interface` class are constructed using the
        * > `readline.createInterface()` method.
        *
        * @see https://nodejs.org/dist/latest-v10.x/docs/api/readline.html#readline_class_interface
        */
      protected def this(options: ReadLineOptions) = this()
      protected def this(input: ReadableStream, output: WritableStream) = this()
      protected def this(input: ReadableStream, output: js.UndefOr[scala.Nothing], completer: AsyncCompleter) = this()
      protected def this(input: ReadableStream, output: js.UndefOr[scala.Nothing], completer: Completer) = this()
      protected def this(input: ReadableStream, output: WritableStream, completer: AsyncCompleter) = this()
      protected def this(input: ReadableStream, output: WritableStream, completer: Completer) = this()
      protected def this(
        input: ReadableStream,
        output: js.UndefOr[scala.Nothing],
        completer: js.UndefOr[scala.Nothing],
        terminal: Boolean
      ) = this()
      protected def this(
        input: ReadableStream,
        output: js.UndefOr[scala.Nothing],
        completer: AsyncCompleter,
        terminal: Boolean
      ) = this()
      protected def this(input: ReadableStream, output: js.UndefOr[scala.Nothing], completer: Completer, terminal: Boolean) = this()
      protected def this(
        input: ReadableStream,
        output: WritableStream,
        completer: js.UndefOr[scala.Nothing],
        terminal: Boolean
      ) = this()
      protected def this(input: ReadableStream, output: WritableStream, completer: AsyncCompleter, terminal: Boolean) = this()
      protected def this(input: ReadableStream, output: WritableStream, completer: Completer, terminal: Boolean) = this()
    }
    
    /**
      * Clears the current line of this WriteStream in a direction identified by `dir`.
      */
    @JSImport("mz", "readline.clearLine")
    @js.native
    def clearLine(stream: WritableStream, dir: Direction): Boolean = js.native
    @JSImport("mz", "readline.clearLine")
    @js.native
    def clearLine(stream: WritableStream, dir: Direction, callback: js.Function0[Unit]): Boolean = js.native
    
    /**
      * Clears this `WriteStream` from the current cursor down.
      */
    @JSImport("mz", "readline.clearScreenDown")
    @js.native
    def clearScreenDown(stream: WritableStream): Boolean = js.native
    @JSImport("mz", "readline.clearScreenDown")
    @js.native
    def clearScreenDown(stream: WritableStream, callback: js.Function0[Unit]): Boolean = js.native
    
    @JSImport("mz", "readline.createInterface")
    @js.native
    def createInterface(input: ReadableStream): typings.mz.readlineMod.Interface = js.native
    @JSImport("mz", "readline.createInterface")
    @js.native
    def createInterface(
      input: ReadableStream,
      output: js.UndefOr[scala.Nothing],
      completer: js.UndefOr[typings.mz.readlineMod.Completer],
      terminal: Boolean
    ): typings.mz.readlineMod.Interface = js.native
    @JSImport("mz", "readline.createInterface")
    @js.native
    def createInterface(
      input: ReadableStream,
      output: js.UndefOr[scala.Nothing],
      completer: typings.mz.readlineMod.Completer
    ): typings.mz.readlineMod.Interface = js.native
    @JSImport("mz", "readline.createInterface")
    @js.native
    def createInterface(input: ReadableStream, output: WritableStream): typings.mz.readlineMod.Interface = js.native
    @JSImport("mz", "readline.createInterface")
    @js.native
    def createInterface(
      input: ReadableStream,
      output: WritableStream,
      completer: js.UndefOr[typings.mz.readlineMod.Completer],
      terminal: Boolean
    ): typings.mz.readlineMod.Interface = js.native
    @JSImport("mz", "readline.createInterface")
    @js.native
    def createInterface(input: ReadableStream, output: WritableStream, completer: typings.mz.readlineMod.Completer): typings.mz.readlineMod.Interface = js.native
    @JSImport("mz", "readline.createInterface")
    @js.native
    def createInterface(options: typings.mz.readlineMod.ReadLineOptions): typings.mz.readlineMod.Interface = js.native
    
    /**
      * Moves this WriteStream's cursor to the specified position.
      */
    @JSImport("mz", "readline.cursorTo")
    @js.native
    def cursorTo(stream: WritableStream, x: Double): Boolean = js.native
    @JSImport("mz", "readline.cursorTo")
    @js.native
    def cursorTo(stream: WritableStream, x: Double, y: js.UndefOr[scala.Nothing], callback: js.Function0[Unit]): Boolean = js.native
    @JSImport("mz", "readline.cursorTo")
    @js.native
    def cursorTo(stream: WritableStream, x: Double, y: Double): Boolean = js.native
    @JSImport("mz", "readline.cursorTo")
    @js.native
    def cursorTo(stream: WritableStream, x: Double, y: Double, callback: js.Function0[Unit]): Boolean = js.native
    
    @JSImport("mz", "readline.emitKeypressEvents")
    @js.native
    def emitKeypressEvents(stream: ReadableStream): Unit = js.native
    @JSImport("mz", "readline.emitKeypressEvents")
    @js.native
    def emitKeypressEvents(stream: ReadableStream, readlineInterface: typings.node.readlineMod.Interface): Unit = js.native
    
    /**
      * Moves this WriteStream's cursor relative to its current position.
      */
    @JSImport("mz", "readline.moveCursor")
    @js.native
    def moveCursor(stream: WritableStream, dx: Double, dy: Double): Boolean = js.native
    @JSImport("mz", "readline.moveCursor")
    @js.native
    def moveCursor(stream: WritableStream, dx: Double, dy: Double, callback: js.Function0[Unit]): Boolean = js.native
  }
  
  object zlib {
    
    /** @deprecated */
    @JSImport("mz", "zlib.Z_ASCII")
    @js.native
    val Z_ASCII: Double = js.native
    
    /** @deprecated Use `constants.Z_BEST_COMPRESSION` */
    @JSImport("mz", "zlib.Z_BEST_COMPRESSION")
    @js.native
    val Z_BEST_COMPRESSION: Double = js.native
    
    /** @deprecated Use `constants.Z_BEST_SPEED` */
    @JSImport("mz", "zlib.Z_BEST_SPEED")
    @js.native
    val Z_BEST_SPEED: Double = js.native
    
    /** @deprecated */
    @JSImport("mz", "zlib.Z_BINARY")
    @js.native
    val Z_BINARY: Double = js.native
    
    /** @deprecated Use `constants.Z_BLOCK` */
    @JSImport("mz", "zlib.Z_BLOCK")
    @js.native
    val Z_BLOCK: Double = js.native
    
    /** @deprecated Use `constants.Z_BUF_ERROR` */
    @JSImport("mz", "zlib.Z_BUF_ERROR")
    @js.native
    val Z_BUF_ERROR: Double = js.native
    
    /** @deprecated Use `constants.Z_DATA_ERROR` */
    @JSImport("mz", "zlib.Z_DATA_ERROR")
    @js.native
    val Z_DATA_ERROR: Double = js.native
    
    /** @deprecated Use `constants.Z_DEFAULT_COMPRESSION` */
    @JSImport("mz", "zlib.Z_DEFAULT_COMPRESSION")
    @js.native
    val Z_DEFAULT_COMPRESSION: Double = js.native
    
    /** @deprecated Use `constants.Z_DEFAULT_STRATEGY` */
    @JSImport("mz", "zlib.Z_DEFAULT_STRATEGY")
    @js.native
    val Z_DEFAULT_STRATEGY: Double = js.native
    
    /** @deprecated */
    @JSImport("mz", "zlib.Z_DEFLATED")
    @js.native
    val Z_DEFLATED: Double = js.native
    
    /** @deprecated Use `constants.Z_ERRNO` */
    @JSImport("mz", "zlib.Z_ERRNO")
    @js.native
    val Z_ERRNO: Double = js.native
    
    // Compression strategy.
    /** @deprecated Use `constants.Z_FILTERED` */
    @JSImport("mz", "zlib.Z_FILTERED")
    @js.native
    val Z_FILTERED: Double = js.native
    
    /** @deprecated Use `constants.Z_FINISH` */
    @JSImport("mz", "zlib.Z_FINISH")
    @js.native
    val Z_FINISH: Double = js.native
    
    /** @deprecated Use `constants.Z_FIXED` */
    @JSImport("mz", "zlib.Z_FIXED")
    @js.native
    val Z_FIXED: Double = js.native
    
    /** @deprecated Use `constants.Z_FULL_FLUSH` */
    @JSImport("mz", "zlib.Z_FULL_FLUSH")
    @js.native
    val Z_FULL_FLUSH: Double = js.native
    
    /** @deprecated Use `constants.Z_HUFFMAN_ONLY` */
    @JSImport("mz", "zlib.Z_HUFFMAN_ONLY")
    @js.native
    val Z_HUFFMAN_ONLY: Double = js.native
    
    /** @deprecated Use `constants.Z_MEM_ERROR` */
    @JSImport("mz", "zlib.Z_MEM_ERROR")
    @js.native
    val Z_MEM_ERROR: Double = js.native
    
    /** @deprecated Use `constants.Z_NEED_DICT` */
    @JSImport("mz", "zlib.Z_NEED_DICT")
    @js.native
    val Z_NEED_DICT: Double = js.native
    
    // Compression levels.
    /** @deprecated Use `constants.Z_NO_COMPRESSION` */
    @JSImport("mz", "zlib.Z_NO_COMPRESSION")
    @js.native
    val Z_NO_COMPRESSION: Double = js.native
    
    // Allowed flush values.
    /** @deprecated Use `constants.Z_NO_FLUSH` */
    @JSImport("mz", "zlib.Z_NO_FLUSH")
    @js.native
    val Z_NO_FLUSH: Double = js.native
    
    // Return codes for the compression/decompression functions.
    // Negative values are errors, positive values are used for special but normal events.
    /** @deprecated Use `constants.Z_OK` */
    @JSImport("mz", "zlib.Z_OK")
    @js.native
    val Z_OK: Double = js.native
    
    /** @deprecated Use `constants.Z_PARTIAL_FLUSH` */
    @JSImport("mz", "zlib.Z_PARTIAL_FLUSH")
    @js.native
    val Z_PARTIAL_FLUSH: Double = js.native
    
    /** @deprecated Use `constants.Z_RLE` */
    @JSImport("mz", "zlib.Z_RLE")
    @js.native
    val Z_RLE: Double = js.native
    
    /** @deprecated Use `constants.Z_STREAM_END` */
    @JSImport("mz", "zlib.Z_STREAM_END")
    @js.native
    val Z_STREAM_END: Double = js.native
    
    /** @deprecated Use `constants.Z_STREAM_ERROR` */
    @JSImport("mz", "zlib.Z_STREAM_ERROR")
    @js.native
    val Z_STREAM_ERROR: Double = js.native
    
    /** @deprecated Use `constants.Z_SYNC_FLUSH` */
    @JSImport("mz", "zlib.Z_SYNC_FLUSH")
    @js.native
    val Z_SYNC_FLUSH: Double = js.native
    
    /** @deprecated */
    @JSImport("mz", "zlib.Z_TEXT")
    @js.native
    val Z_TEXT: Double = js.native
    
    /** @deprecated Use `constants.Z_TREES` */
    @JSImport("mz", "zlib.Z_TREES")
    @js.native
    val Z_TREES: Double = js.native
    
    /** @deprecated  */
    @JSImport("mz", "zlib.Z_UNKNOWN")
    @js.native
    val Z_UNKNOWN: Double = js.native
    
    /** @deprecated Use `constants.Z_VERSION_ERROR` */
    @JSImport("mz", "zlib.Z_VERSION_ERROR")
    @js.native
    val Z_VERSION_ERROR: Double = js.native
    
    @JSImport("mz", "zlib.brotliCompress")
    @js.native
    def brotliCompress(buf: InputType): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.brotliCompress")
    @js.native
    def brotliCompress(buf: InputType, callback: CompressCallback): Unit = js.native
    @JSImport("mz", "zlib.brotliCompress")
    @js.native
    def brotliCompress(buf: InputType, options: BrotliOptions): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.brotliCompress")
    @js.native
    def brotliCompress(buf: InputType, options: BrotliOptions, callback: CompressCallback): Unit = js.native
    
    @JSImport("mz", "zlib.brotliCompressSync")
    @js.native
    def brotliCompressSync(buf: InputType): Buffer = js.native
    @JSImport("mz", "zlib.brotliCompressSync")
    @js.native
    def brotliCompressSync(buf: InputType, options: BrotliOptions): Buffer = js.native
    
    @JSImport("mz", "zlib.brotliDecompress")
    @js.native
    def brotliDecompress(buf: InputType): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.brotliDecompress")
    @js.native
    def brotliDecompress(buf: InputType, callback: CompressCallback): Unit = js.native
    @JSImport("mz", "zlib.brotliDecompress")
    @js.native
    def brotliDecompress(buf: InputType, options: BrotliOptions): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.brotliDecompress")
    @js.native
    def brotliDecompress(buf: InputType, options: BrotliOptions, callback: CompressCallback): Unit = js.native
    
    @JSImport("mz", "zlib.brotliDecompressSync")
    @js.native
    def brotliDecompressSync(buf: InputType): Buffer = js.native
    @JSImport("mz", "zlib.brotliDecompressSync")
    @js.native
    def brotliDecompressSync(buf: InputType, options: BrotliOptions): Buffer = js.native
    
    object constants {
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODE")
      @js.native
      val BROTLI_DECODE: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES")
      @js.native
      val BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP")
      @js.native
      val BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES")
      @js.native
      val BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1")
      @js.native
      val BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2")
      @js.native
      val BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS")
      @js.native
      val BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET")
      @js.native
      val BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_CL_SPACE")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_DICTIONARY")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_DISTANCE")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_DISTANCE: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_PADDING_1")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_PADDING_1: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_PADDING_2")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_PADDING_2: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_RESERVED")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_RESERVED: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_TRANSFORM")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS")
      @js.native
      val BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_INVALID_ARGUMENTS")
      @js.native
      val BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_ERROR_UNREACHABLE")
      @js.native
      val BROTLI_DECODER_ERROR_UNREACHABLE: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_NEEDS_MORE_INPUT")
      @js.native
      val BROTLI_DECODER_NEEDS_MORE_INPUT: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_NEEDS_MORE_OUTPUT")
      @js.native
      val BROTLI_DECODER_NEEDS_MORE_OUTPUT: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_NO_ERROR")
      @js.native
      val BROTLI_DECODER_NO_ERROR: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION")
      @js.native
      val BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_PARAM_LARGE_WINDOW")
      @js.native
      val BROTLI_DECODER_PARAM_LARGE_WINDOW: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_RESULT_ERROR")
      @js.native
      val BROTLI_DECODER_RESULT_ERROR: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT")
      @js.native
      val BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT")
      @js.native
      val BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_RESULT_SUCCESS")
      @js.native
      val BROTLI_DECODER_RESULT_SUCCESS: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DECODER_SUCCESS")
      @js.native
      val BROTLI_DECODER_SUCCESS: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DEFAULT_MODE")
      @js.native
      val BROTLI_DEFAULT_MODE: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DEFAULT_QUALITY")
      @js.native
      val BROTLI_DEFAULT_QUALITY: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_DEFAULT_WINDOW")
      @js.native
      val BROTLI_DEFAULT_WINDOW: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_ENCODE")
      @js.native
      val BROTLI_ENCODE: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_LARGE_MAX_WINDOW_BITS")
      @js.native
      val BROTLI_LARGE_MAX_WINDOW_BITS: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_MAX_INPUT_BLOCK_BITS")
      @js.native
      val BROTLI_MAX_INPUT_BLOCK_BITS: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_MAX_QUALITY")
      @js.native
      val BROTLI_MAX_QUALITY: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_MAX_WINDOW_BITS")
      @js.native
      val BROTLI_MAX_WINDOW_BITS: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_MIN_INPUT_BLOCK_BITS")
      @js.native
      val BROTLI_MIN_INPUT_BLOCK_BITS: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_MIN_QUALITY")
      @js.native
      val BROTLI_MIN_QUALITY: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_MIN_WINDOW_BITS")
      @js.native
      val BROTLI_MIN_WINDOW_BITS: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_MODE_FONT")
      @js.native
      val BROTLI_MODE_FONT: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_MODE_GENERIC")
      @js.native
      val BROTLI_MODE_GENERIC: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_MODE_TEXT")
      @js.native
      val BROTLI_MODE_TEXT: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_OPERATION_EMIT_METADATA")
      @js.native
      val BROTLI_OPERATION_EMIT_METADATA: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_OPERATION_FINISH")
      @js.native
      val BROTLI_OPERATION_FINISH: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_OPERATION_FLUSH")
      @js.native
      val BROTLI_OPERATION_FLUSH: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_OPERATION_PROCESS")
      @js.native
      val BROTLI_OPERATION_PROCESS: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING")
      @js.native
      val BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_PARAM_LARGE_WINDOW")
      @js.native
      val BROTLI_PARAM_LARGE_WINDOW: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_PARAM_LGBLOCK")
      @js.native
      val BROTLI_PARAM_LGBLOCK: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_PARAM_LGWIN")
      @js.native
      val BROTLI_PARAM_LGWIN: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_PARAM_MODE")
      @js.native
      val BROTLI_PARAM_MODE: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_PARAM_NDIRECT")
      @js.native
      val BROTLI_PARAM_NDIRECT: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_PARAM_NPOSTFIX")
      @js.native
      val BROTLI_PARAM_NPOSTFIX: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_PARAM_QUALITY")
      @js.native
      val BROTLI_PARAM_QUALITY: Double = js.native
      
      @JSImport("mz", "zlib.constants.BROTLI_PARAM_SIZE_HINT")
      @js.native
      val BROTLI_PARAM_SIZE_HINT: Double = js.native
      
      @JSImport("mz", "zlib.constants.DEFLATE")
      @js.native
      val DEFLATE: Double = js.native
      
      @JSImport("mz", "zlib.constants.DEFLATERAW")
      @js.native
      val DEFLATERAW: Double = js.native
      
      @JSImport("mz", "zlib.constants.GUNZIP")
      @js.native
      val GUNZIP: Double = js.native
      
      @JSImport("mz", "zlib.constants.GZIP")
      @js.native
      val GZIP: Double = js.native
      
      @JSImport("mz", "zlib.constants.INFLATE")
      @js.native
      val INFLATE: Double = js.native
      
      @JSImport("mz", "zlib.constants.INFLATERAW")
      @js.native
      val INFLATERAW: Double = js.native
      
      @JSImport("mz", "zlib.constants.UNZIP")
      @js.native
      val UNZIP: Double = js.native
      
      @JSImport("mz", "zlib.constants.ZLIB_VERNUM")
      @js.native
      val ZLIB_VERNUM: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_BEST_COMPRESSION")
      @js.native
      val Z_BEST_COMPRESSION: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_BEST_SPEED")
      @js.native
      val Z_BEST_SPEED: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_BLOCK")
      @js.native
      val Z_BLOCK: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_BUF_ERROR")
      @js.native
      val Z_BUF_ERROR: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_DATA_ERROR")
      @js.native
      val Z_DATA_ERROR: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_DEFAULT_CHUNK")
      @js.native
      val Z_DEFAULT_CHUNK: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_DEFAULT_COMPRESSION")
      @js.native
      val Z_DEFAULT_COMPRESSION: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_DEFAULT_LEVEL")
      @js.native
      val Z_DEFAULT_LEVEL: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_DEFAULT_MEMLEVEL")
      @js.native
      val Z_DEFAULT_MEMLEVEL: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_DEFAULT_STRATEGY")
      @js.native
      val Z_DEFAULT_STRATEGY: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_DEFAULT_WINDOWBITS")
      @js.native
      val Z_DEFAULT_WINDOWBITS: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_ERRNO")
      @js.native
      val Z_ERRNO: Double = js.native
      
      // Compression strategy.
      @JSImport("mz", "zlib.constants.Z_FILTERED")
      @js.native
      val Z_FILTERED: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_FINISH")
      @js.native
      val Z_FINISH: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_FIXED")
      @js.native
      val Z_FIXED: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_FULL_FLUSH")
      @js.native
      val Z_FULL_FLUSH: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_HUFFMAN_ONLY")
      @js.native
      val Z_HUFFMAN_ONLY: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_MAX_CHUNK")
      @js.native
      val Z_MAX_CHUNK: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_MAX_LEVEL")
      @js.native
      val Z_MAX_LEVEL: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_MAX_MEMLEVEL")
      @js.native
      val Z_MAX_MEMLEVEL: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_MAX_WINDOWBITS")
      @js.native
      val Z_MAX_WINDOWBITS: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_MEM_ERROR")
      @js.native
      val Z_MEM_ERROR: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_MIN_CHUNK")
      @js.native
      val Z_MIN_CHUNK: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_MIN_LEVEL")
      @js.native
      val Z_MIN_LEVEL: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_MIN_MEMLEVEL")
      @js.native
      val Z_MIN_MEMLEVEL: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_MIN_WINDOWBITS")
      @js.native
      val Z_MIN_WINDOWBITS: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_NEED_DICT")
      @js.native
      val Z_NEED_DICT: Double = js.native
      
      // Compression levels.
      @JSImport("mz", "zlib.constants.Z_NO_COMPRESSION")
      @js.native
      val Z_NO_COMPRESSION: Double = js.native
      
      // Allowed flush values.
      @JSImport("mz", "zlib.constants.Z_NO_FLUSH")
      @js.native
      val Z_NO_FLUSH: Double = js.native
      
      // Return codes for the compression/decompression functions.
      // Negative values are errors, positive values are used for special but normal events.
      @JSImport("mz", "zlib.constants.Z_OK")
      @js.native
      val Z_OK: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_PARTIAL_FLUSH")
      @js.native
      val Z_PARTIAL_FLUSH: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_RLE")
      @js.native
      val Z_RLE: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_STREAM_END")
      @js.native
      val Z_STREAM_END: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_STREAM_ERROR")
      @js.native
      val Z_STREAM_ERROR: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_SYNC_FLUSH")
      @js.native
      val Z_SYNC_FLUSH: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_TREES")
      @js.native
      val Z_TREES: Double = js.native
      
      @JSImport("mz", "zlib.constants.Z_VERSION_ERROR")
      @js.native
      val Z_VERSION_ERROR: Double = js.native
    }
    
    @JSImport("mz", "zlib.createBrotliCompress")
    @js.native
    def createBrotliCompress(): BrotliCompress_ = js.native
    @JSImport("mz", "zlib.createBrotliCompress")
    @js.native
    def createBrotliCompress(options: BrotliOptions): BrotliCompress_ = js.native
    
    @JSImport("mz", "zlib.createBrotliDecompress")
    @js.native
    def createBrotliDecompress(): BrotliDecompress_ = js.native
    @JSImport("mz", "zlib.createBrotliDecompress")
    @js.native
    def createBrotliDecompress(options: BrotliOptions): BrotliDecompress_ = js.native
    
    @JSImport("mz", "zlib.createDeflate")
    @js.native
    def createDeflate(): Deflate_ = js.native
    @JSImport("mz", "zlib.createDeflate")
    @js.native
    def createDeflate(options: ZlibOptions): Deflate_ = js.native
    
    @JSImport("mz", "zlib.createDeflateRaw")
    @js.native
    def createDeflateRaw(): DeflateRaw_ = js.native
    @JSImport("mz", "zlib.createDeflateRaw")
    @js.native
    def createDeflateRaw(options: ZlibOptions): DeflateRaw_ = js.native
    
    @JSImport("mz", "zlib.createGunzip")
    @js.native
    def createGunzip(): Gunzip_ = js.native
    @JSImport("mz", "zlib.createGunzip")
    @js.native
    def createGunzip(options: ZlibOptions): Gunzip_ = js.native
    
    @JSImport("mz", "zlib.createGzip")
    @js.native
    def createGzip(): Gzip_ = js.native
    @JSImport("mz", "zlib.createGzip")
    @js.native
    def createGzip(options: ZlibOptions): Gzip_ = js.native
    
    @JSImport("mz", "zlib.createInflate")
    @js.native
    def createInflate(): Inflate_ = js.native
    @JSImport("mz", "zlib.createInflate")
    @js.native
    def createInflate(options: ZlibOptions): Inflate_ = js.native
    
    @JSImport("mz", "zlib.createInflateRaw")
    @js.native
    def createInflateRaw(): InflateRaw_ = js.native
    @JSImport("mz", "zlib.createInflateRaw")
    @js.native
    def createInflateRaw(options: ZlibOptions): InflateRaw_ = js.native
    
    @JSImport("mz", "zlib.createUnzip")
    @js.native
    def createUnzip(): Unzip_ = js.native
    @JSImport("mz", "zlib.createUnzip")
    @js.native
    def createUnzip(options: ZlibOptions): Unzip_ = js.native
    
    @JSImport("mz", "zlib.deflate")
    @js.native
    def deflate(buf: InputType): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.deflate")
    @js.native
    def deflate(buf: InputType, callback: CompressCallback): Unit = js.native
    @JSImport("mz", "zlib.deflate")
    @js.native
    def deflate(buf: InputType, options: ZlibOptions): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.deflate")
    @js.native
    def deflate(buf: InputType, options: ZlibOptions, callback: CompressCallback): Unit = js.native
    
    @JSImport("mz", "zlib.deflateRaw")
    @js.native
    def deflateRaw(buf: InputType): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.deflateRaw")
    @js.native
    def deflateRaw(buf: InputType, callback: CompressCallback): Unit = js.native
    @JSImport("mz", "zlib.deflateRaw")
    @js.native
    def deflateRaw(buf: InputType, options: ZlibOptions): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.deflateRaw")
    @js.native
    def deflateRaw(buf: InputType, options: ZlibOptions, callback: CompressCallback): Unit = js.native
    
    @JSImport("mz", "zlib.deflateRawSync")
    @js.native
    def deflateRawSync(buf: InputType): Buffer = js.native
    @JSImport("mz", "zlib.deflateRawSync")
    @js.native
    def deflateRawSync(buf: InputType, options: ZlibOptions): Buffer = js.native
    
    @JSImport("mz", "zlib.deflateSync")
    @js.native
    def deflateSync(buf: InputType): Buffer = js.native
    @JSImport("mz", "zlib.deflateSync")
    @js.native
    def deflateSync(buf: InputType, options: ZlibOptions): Buffer = js.native
    
    @JSImport("mz", "zlib.gunzip")
    @js.native
    def gunzip(buf: InputType): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.gunzip")
    @js.native
    def gunzip(buf: InputType, callback: CompressCallback): Unit = js.native
    @JSImport("mz", "zlib.gunzip")
    @js.native
    def gunzip(buf: InputType, options: ZlibOptions): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.gunzip")
    @js.native
    def gunzip(buf: InputType, options: ZlibOptions, callback: CompressCallback): Unit = js.native
    
    @JSImport("mz", "zlib.gunzipSync")
    @js.native
    def gunzipSync(buf: InputType): Buffer = js.native
    @JSImport("mz", "zlib.gunzipSync")
    @js.native
    def gunzipSync(buf: InputType, options: ZlibOptions): Buffer = js.native
    
    @JSImport("mz", "zlib.gzip")
    @js.native
    def gzip(buf: InputType): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.gzip")
    @js.native
    def gzip(buf: InputType, callback: CompressCallback): Unit = js.native
    @JSImport("mz", "zlib.gzip")
    @js.native
    def gzip(buf: InputType, options: ZlibOptions): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.gzip")
    @js.native
    def gzip(buf: InputType, options: ZlibOptions, callback: CompressCallback): Unit = js.native
    
    @JSImport("mz", "zlib.gzipSync")
    @js.native
    def gzipSync(buf: InputType): Buffer = js.native
    @JSImport("mz", "zlib.gzipSync")
    @js.native
    def gzipSync(buf: InputType, options: ZlibOptions): Buffer = js.native
    
    @JSImport("mz", "zlib.inflate")
    @js.native
    def inflate(buf: InputType): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.inflate")
    @js.native
    def inflate(buf: InputType, callback: CompressCallback): Unit = js.native
    @JSImport("mz", "zlib.inflate")
    @js.native
    def inflate(buf: InputType, options: ZlibOptions): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.inflate")
    @js.native
    def inflate(buf: InputType, options: ZlibOptions, callback: CompressCallback): Unit = js.native
    
    @JSImport("mz", "zlib.inflateRaw")
    @js.native
    def inflateRaw(buf: InputType): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.inflateRaw")
    @js.native
    def inflateRaw(buf: InputType, callback: CompressCallback): Unit = js.native
    @JSImport("mz", "zlib.inflateRaw")
    @js.native
    def inflateRaw(buf: InputType, options: ZlibOptions): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.inflateRaw")
    @js.native
    def inflateRaw(buf: InputType, options: ZlibOptions, callback: CompressCallback): Unit = js.native
    
    @JSImport("mz", "zlib.inflateRawSync")
    @js.native
    def inflateRawSync(buf: InputType): Buffer = js.native
    @JSImport("mz", "zlib.inflateRawSync")
    @js.native
    def inflateRawSync(buf: InputType, options: ZlibOptions): Buffer = js.native
    
    @JSImport("mz", "zlib.inflateSync")
    @js.native
    def inflateSync(buf: InputType): Buffer = js.native
    @JSImport("mz", "zlib.inflateSync")
    @js.native
    def inflateSync(buf: InputType, options: ZlibOptions): Buffer = js.native
    
    @JSImport("mz", "zlib.unzip")
    @js.native
    def unzip(buf: InputType): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.unzip")
    @js.native
    def unzip(buf: InputType, callback: CompressCallback): Unit = js.native
    @JSImport("mz", "zlib.unzip")
    @js.native
    def unzip(buf: InputType, options: ZlibOptions): js.Promise[Buffer] = js.native
    @JSImport("mz", "zlib.unzip")
    @js.native
    def unzip(buf: InputType, options: ZlibOptions, callback: CompressCallback): Unit = js.native
    
    @JSImport("mz", "zlib.unzipSync")
    @js.native
    def unzipSync(buf: InputType): Buffer = js.native
    @JSImport("mz", "zlib.unzipSync")
    @js.native
    def unzipSync(buf: InputType, options: ZlibOptions): Buffer = js.native
  }
}
