package typings.mobx

import org.scalablytyped.runtime.Instantiable1
import org.scalablytyped.runtime.StringDictionary
import typings.mobx.anon.ComputedRequiresReaction
import typings.mobx.anon.Configurable
import typings.mobx.anon.Promisevoidcancelvoid
import typings.mobx.anon.Time
import typings.mobx.distApiActionMod.IActionFactory
import typings.mobx.distApiAnnotationMod.Annotation
import typings.mobx.distApiAnnotationMod.AnnotationsMap
import typings.mobx.distApiAutorunMod.IAutorunOptions
import typings.mobx.distApiAutorunMod.IReactionOptions
import typings.mobx.distApiComputedMod.IComputedFactory
import typings.mobx.distApiExtrasMod.IDependencyTree
import typings.mobx.distApiExtrasMod.IObserverTree
import typings.mobx.distApiFlowMod.Flow_
import typings.mobx.distApiInterceptReadMod.ReadInterceptor
import typings.mobx.distApiMakeObservableMod.NoInfer
import typings.mobx.distApiObservableMod.CreateObservableOptions
import typings.mobx.distApiObservableMod.IObservableFactory
import typings.mobx.distApiWhenMod.IWhenOptions
import typings.mobx.distCoreActionMod.IActionRunInfo
import typings.mobx.distCoreAtomMod.IAtom
import typings.mobx.distCoreComputedvalueMod.IComputedValue
import typings.mobx.distCoreComputedvalueMod.IComputedValueOptions
import typings.mobx.distCoreDerivationMod.IDerivation
import typings.mobx.distCoreObservableMod.IDepTreeNode
import typings.mobx.distCoreObservableMod.IObservable
import typings.mobx.distCoreReactionMod.IReactionDisposer
import typings.mobx.distCoreReactionMod.IReactionPublic
import typings.mobx.distCoreReactionMod.Reaction
import typings.mobx.distCoreSpyMod.PureSpyEvent
import typings.mobx.distCoreSpyMod.SpyEvent
import typings.mobx.distTypesInterceptUtilsMod.IInterceptable
import typings.mobx.distTypesInterceptUtilsMod.IInterceptor
import typings.mobx.distTypesListenUtilsMod.IListenable
import typings.mobx.distTypesModifiersMod.IEnhancer
import typings.mobx.distTypesObservablearrayMod.IArrayDidChange
import typings.mobx.distTypesObservablearrayMod.IArrayWillChange
import typings.mobx.distTypesObservablearrayMod.IArrayWillSplice
import typings.mobx.distTypesObservablearrayMod.IObservableArray
import typings.mobx.distTypesObservablemapMod.IMapDidChange
import typings.mobx.distTypesObservablemapMod.IMapWillChange
import typings.mobx.distTypesObservablemapMod.IObservableMapInitialValues
import typings.mobx.distTypesObservableobjectMod.IIsObservableObject
import typings.mobx.distTypesObservableobjectMod.IObjectDidChange
import typings.mobx.distTypesObservableobjectMod.IObjectWillChange
import typings.mobx.distTypesObservablesetMod.IObservableSetInitialValues
import typings.mobx.distTypesObservablesetMod.ISetDidChange
import typings.mobx.distTypesObservablesetMod.ISetWillChange
import typings.mobx.distTypesObservablevalueMod.IObservableValue
import typings.mobx.distTypesObservablevalueMod.IValueDidChange
import typings.mobx.distTypesObservablevalueMod.IValueWillChange
import typings.mobx.distUtilsComparerMod.IEqualsComparer
import typings.mobx.distUtilsUtilsMod.Lambda
import typings.mobx.mobxStrings.`0`
import typings.mobx.mobxStrings.`10`
import typings.mobx.mobxStrings.`11`
import typings.mobx.mobxStrings.`12`
import typings.mobx.mobxStrings.`13`
import typings.mobx.mobxStrings.`14`
import typings.mobx.mobxStrings.`15`
import typings.mobx.mobxStrings.`16`
import typings.mobx.mobxStrings.`17`
import typings.mobx.mobxStrings.`18`
import typings.mobx.mobxStrings.`19`
import typings.mobx.mobxStrings.`1`
import typings.mobx.mobxStrings.`20`
import typings.mobx.mobxStrings.`21`
import typings.mobx.mobxStrings.`22`
import typings.mobx.mobxStrings.`23`
import typings.mobx.mobxStrings.`24`
import typings.mobx.mobxStrings.`25`
import typings.mobx.mobxStrings.`26`
import typings.mobx.mobxStrings.`27`
import typings.mobx.mobxStrings.`28`
import typings.mobx.mobxStrings.`29`
import typings.mobx.mobxStrings.`30`
import typings.mobx.mobxStrings.`31`
import typings.mobx.mobxStrings.`32`
import typings.mobx.mobxStrings.`33`
import typings.mobx.mobxStrings.`34`
import typings.mobx.mobxStrings.`35`
import typings.mobx.mobxStrings.`36`
import typings.mobx.mobxStrings.`37`
import typings.mobx.mobxStrings.`38`
import typings.mobx.mobxStrings.`39`
import typings.mobx.mobxStrings.`5`
import typings.mobx.mobxStrings.`6`
import typings.mobx.mobxStrings.`7`
import typings.mobx.mobxStrings.`8`
import typings.mobx.mobxStrings.`9`
import typings.std.IArguments
import typings.std.IterableIterator
import typings.std.Map
import typings.std.PropertyDecorator
import typings.std.PropertyKey
import typings.std.Set
import typings.std.ThisType
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object distInternalMod {
  
  @JSImport("mobx/dist/internal", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  @JSImport("mobx/dist/internal", "ACTION")
  @js.native
  val ACTION_ : /* "action" */ String = js.native
  
  @JSImport("mobx/dist/internal", "ACTION_BOUND")
  @js.native
  val ACTION_BOUND: /* "action.bound" */ String = js.native
  
  @JSImport("mobx/dist/internal", "ADD")
  @js.native
  val ADD: /* "add" */ String = js.native
  
  @JSImport("mobx/dist/internal", "AUTOACTION")
  @js.native
  val AUTOACTION_ : /* "autoAction" */ String = js.native
  
  @JSImport("mobx/dist/internal", "AUTOACTION_BOUND")
  @js.native
  val AUTOACTION_BOUND: /* "autoAction.bound" */ String = js.native
  
  @JSImport("mobx/dist/internal", "Atom")
  @js.native
  /**
    * Create a new atom. For debugging purposes it is recommended to give it a name.
    * The onBecomeObserved and onBecomeUnobserved callbacks can be used for resource management.
    */
  open class Atom ()
    extends typings.mobx.distCoreAtomMod.Atom {
    def this(name_ : String) = this()
  }
  
  @JSImport("mobx/dist/internal", "COMPUTED")
  @js.native
  val COMPUTED_ : /* "computed" */ String = js.native
  
  @JSImport("mobx/dist/internal", "COMPUTED_STRUCT")
  @js.native
  val COMPUTED_STRUCT: /* "computed.struct" */ String = js.native
  
  @JSImport("mobx/dist/internal", "CaughtException")
  @js.native
  open class CaughtException protected ()
    extends typings.mobx.distCoreDerivationMod.CaughtException {
    def this(cause: Any) = this()
  }
  
  @JSImport("mobx/dist/internal", "ComputedValue")
  @js.native
  open class ComputedValue[T] protected ()
    extends typings.mobx.distCoreComputedvalueMod.ComputedValue[T] {
    /**
      * Create a new computed value based on a function expression.
      *
      * The `name` property is for debug purposes only.
      *
      * The `equals` property specifies the comparer function to use to determine if a newly produced
      * value differs from the previous value. Two comparers are provided in the library; `defaultComparer`
      * compares based on identity comparison (===), and `structuralComparer` deeply compares the structure.
      * Structural comparison can be convenient if you always produce a new aggregated object and
      * don't want to notify observers if it is structurally the same.
      * This is useful for working with vectors, mouse coordinates etc.
      */
    def this(options: IComputedValueOptions[T]) = this()
  }
  
  @JSImport("mobx/dist/internal", "DELETE")
  @js.native
  val DELETE: /* "delete" */ String = js.native
  
  @JSImport("mobx/dist/internal", "EMPTY_ARRAY")
  @js.native
  val EMPTY_ARRAY: js.Array[scala.Nothing] = js.native
  
  @JSImport("mobx/dist/internal", "FLOW")
  @js.native
  val FLOW_ : /* "flow" */ String = js.native
  
  object FlowCancellationError {
    
    inline def apply(): Unit = ^.asInstanceOf[js.Dynamic].apply().asInstanceOf[Unit]
    
    @JSImport("mobx/dist/internal", "FlowCancellationError")
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("mobx/dist/internal", "FlowCancellationError.prototype")
    @js.native
    def prototype: Any = js.native
    inline def prototype_=(x: Any): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("prototype")(x.asInstanceOf[js.Any])
  }
  
  @JSImport("mobx/dist/internal", "IDerivationState_")
  @js.native
  object IDerivationState extends StObject {
    
    @JSBracketAccess
    def apply(value: Double): js.UndefOr[typings.mobx.distCoreDerivationMod.IDerivationState & Double] = js.native
    
    /* -1 */ val NOT_TRACKING_ : typings.mobx.distCoreDerivationMod.IDerivationState.NOT_TRACKING_ & Double = js.native
    
    /* 1 */ val POSSIBLY_STALE_ : typings.mobx.distCoreDerivationMod.IDerivationState.POSSIBLY_STALE_ & Double = js.native
    
    /* 2 */ val STALE_ : typings.mobx.distCoreDerivationMod.IDerivationState.STALE_ & Double = js.native
    
    /* 0 */ val UP_TO_DATE_ : typings.mobx.distCoreDerivationMod.IDerivationState.UP_TO_DATE_ & Double = js.native
  }
  
  @JSImport("mobx/dist/internal", "MAX_SPLICE_SIZE")
  @js.native
  val MAX_SPLICE_SIZE: /* 10000 */ Double = js.native
  
  @JSImport("mobx/dist/internal", "MobXGlobals")
  @js.native
  open class MobXGlobals ()
    extends typings.mobx.distCoreGlobalstateMod.MobXGlobals
  
  @JSImport("mobx/dist/internal", "OBSERVABLE")
  @js.native
  val OBSERVABLE_ : /* "observable" */ String = js.native
  
  @JSImport("mobx/dist/internal", "OBSERVABLE_REF")
  @js.native
  val OBSERVABLE_REF: /* "observable.ref" */ String = js.native
  
  @JSImport("mobx/dist/internal", "OBSERVABLE_SHALLOW")
  @js.native
  val OBSERVABLE_SHALLOW: /* "observable.shallow" */ String = js.native
  
  @JSImport("mobx/dist/internal", "OBSERVABLE_STRUCT")
  @js.native
  val OBSERVABLE_STRUCT: /* "observable.struct" */ String = js.native
  
  @JSImport("mobx/dist/internal", "ObservableArrayAdministration")
  @js.native
  open class ObservableArrayAdministration protected ()
    extends typings.mobx.distTypesObservablearrayMod.ObservableArrayAdministration {
    def this(name: String, enhancer: IEnhancer[Any], owned_ : Boolean, legacyMode_ : Boolean) = this()
    def this(name: Unit, enhancer: IEnhancer[Any], owned_ : Boolean, legacyMode_ : Boolean) = this()
  }
  
  @JSImport("mobx/dist/internal", "ObservableMap")
  @js.native
  open class ObservableMap[K, V] ()
    extends typings.mobx.distTypesObservablemapMod.ObservableMap[K, V] {
    def this(initialData: IObservableMapInitialValues[K, V]) = this()
    def this(initialData: Unit, enhancer_ : IEnhancer[V]) = this()
    def this(initialData: IObservableMapInitialValues[K, V], enhancer_ : IEnhancer[V]) = this()
    def this(initialData: Unit, enhancer_ : Unit, name_ : String) = this()
    def this(initialData: Unit, enhancer_ : IEnhancer[V], name_ : String) = this()
    def this(initialData: IObservableMapInitialValues[K, V], enhancer_ : Unit, name_ : String) = this()
    def this(initialData: IObservableMapInitialValues[K, V], enhancer_ : IEnhancer[V], name_ : String) = this()
  }
  
  @JSImport("mobx/dist/internal", "ObservableObjectAdministration")
  @js.native
  open class ObservableObjectAdministration protected ()
    extends typings.mobx.distTypesObservableobjectMod.ObservableObjectAdministration {
    def this(
      target_ : Any,
      values_ : Map[PropertyKey, ObservableValue[Any] | ComputedValue[Any]],
      name_ : String
    ) = this()
    def this(
      target_ : Any,
      values_ : Map[PropertyKey, ObservableValue[Any] | ComputedValue[Any]],
      name_ : String,
      defaultAnnotation_ : Annotation
    ) = this()
  }
  
  @JSImport("mobx/dist/internal", "ObservableSet")
  @js.native
  open class ObservableSet[T] ()
    extends typings.mobx.distTypesObservablesetMod.ObservableSet[T] {
    def this(initialData: IObservableSetInitialValues[T]) = this()
    def this(initialData: Unit, enhancer: IEnhancer[T]) = this()
    def this(initialData: IObservableSetInitialValues[T], enhancer: IEnhancer[T]) = this()
    def this(initialData: Unit, enhancer: Unit, name_ : String) = this()
    def this(initialData: Unit, enhancer: IEnhancer[T], name_ : String) = this()
    def this(initialData: IObservableSetInitialValues[T], enhancer: Unit, name_ : String) = this()
    def this(initialData: IObservableSetInitialValues[T], enhancer: IEnhancer[T], name_ : String) = this()
  }
  
  @JSImport("mobx/dist/internal", "ObservableValue")
  @js.native
  open class ObservableValue[T] protected ()
    extends typings.mobx.distTypesObservablevalueMod.ObservableValue[T] {
    def this(value: T, enhancer: IEnhancer[T]) = this()
    def this(value: T, enhancer: IEnhancer[T], name_ : String) = this()
    def this(value: T, enhancer: IEnhancer[T], name_ : String, notifySpy: Boolean) = this()
    def this(value: T, enhancer: IEnhancer[T], name_ : Unit, notifySpy: Boolean) = this()
    def this(value: T, enhancer: IEnhancer[T], name_ : String, notifySpy: Boolean, equals: IEqualsComparer[Any]) = this()
    def this(value: T, enhancer: IEnhancer[T], name_ : String, notifySpy: Unit, equals: IEqualsComparer[Any]) = this()
    def this(value: T, enhancer: IEnhancer[T], name_ : Unit, notifySpy: Boolean, equals: IEqualsComparer[Any]) = this()
    def this(value: T, enhancer: IEnhancer[T], name_ : Unit, notifySpy: Unit, equals: IEqualsComparer[Any]) = this()
  }
  
  @JSImport("mobx/dist/internal", "Reaction")
  @js.native
  open class Reaction_ protected () extends Reaction {
    def this(name_ : String, onInvalidate_ : js.Function0[Unit]) = this()
    def this(
      name_ : String,
      onInvalidate_ : js.Function0[Unit],
      errorHandler_ : js.Function2[/* error */ Any, /* derivation */ IDerivation, Unit]
    ) = this()
    def this(
      name_ : String,
      onInvalidate_ : js.Function0[Unit],
      errorHandler_ : js.Function2[/* error */ Any, /* derivation */ IDerivation, Unit],
      requiresObservable_ : Any
    ) = this()
    def this(
      name_ : String,
      onInvalidate_ : js.Function0[Unit],
      errorHandler_ : Unit,
      requiresObservable_ : Any
    ) = this()
  }
  
  @JSImport("mobx/dist/internal", "TraceMode")
  @js.native
  object TraceMode extends StObject {
    
    @JSBracketAccess
    def apply(value: Double): js.UndefOr[typings.mobx.distCoreDerivationMod.TraceMode & Double] = js.native
    
    /* 2 */ val BREAK: typings.mobx.distCoreDerivationMod.TraceMode.BREAK & Double = js.native
    
    /* 1 */ val LOG: typings.mobx.distCoreDerivationMod.TraceMode.LOG & Double = js.native
    
    /* 0 */ val NONE: typings.mobx.distCoreDerivationMod.TraceMode.NONE & Double = js.native
  }
  
  @JSImport("mobx/dist/internal", "UPDATE")
  @js.native
  val UPDATE: /* "update" */ String = js.native
  
  inline def _isComputed(value: Any): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("_isComputed")(value.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  inline def _isComputed(value: Any, property: PropertyKey): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("_isComputed")(value.asInstanceOf[js.Any], property.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  
  @JSImport("mobx/dist/internal", "action")
  @js.native
  val action: IActionFactory = js.native
  
  inline def addHiddenFinalProp(`object`: Any, propName: PropertyKey, value: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("addHiddenFinalProp")(`object`.asInstanceOf[js.Any], propName.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def addHiddenProp(`object`: Any, propName: PropertyKey, value: Any): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("addHiddenProp")(`object`.asInstanceOf[js.Any], propName.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def addObserver(observable: IObservable, node: IDerivation): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("addObserver")(observable.asInstanceOf[js.Any], node.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def allowStateChanges[T](allowStateChanges: Boolean, func: js.Function0[T]): T = (^.asInstanceOf[js.Dynamic].applyDynamic("allowStateChanges")(allowStateChanges.asInstanceOf[js.Any], func.asInstanceOf[js.Any])).asInstanceOf[T]
  
  inline def allowStateChangesEnd(prev: Boolean): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("allowStateChangesEnd")(prev.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def allowStateChangesStart(allowStateChanges: Boolean): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("allowStateChangesStart")(allowStateChanges.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def allowStateReadsEnd(prev: Boolean): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("allowStateReadsEnd")(prev.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def allowStateReadsStart(allowStateReads: Boolean): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("allowStateReadsStart")(allowStateReads.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def apiDefineProperty(obj: js.Object, key: PropertyKey, descriptor: js.PropertyDescriptor): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("apiDefineProperty")(obj.asInstanceOf[js.Any], key.asInstanceOf[js.Any], descriptor.asInstanceOf[js.Any])).asInstanceOf[Any]
  
  inline def apiOwnKeys(obj: js.Object): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("apiOwnKeys")(obj.asInstanceOf[js.Any]).asInstanceOf[Any]
  
  object arrayExtensions {
    
    @JSImport("mobx/dist/internal", "arrayExtensions")
    @js.native
    val ^ : js.Any = js.native
    
    inline def clear(): js.Array[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("clear")().asInstanceOf[js.Array[Any]]
    
    inline def pop(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("pop")().asInstanceOf[Any]
    
    inline def push(items: Any*): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("push")(items.asInstanceOf[Seq[js.Any]]*).asInstanceOf[Double]
    
    inline def remove(value: Any): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("remove")(value.asInstanceOf[js.Any]).asInstanceOf[Boolean]
    
    inline def replace(newItems: js.Array[Any]): js.Array[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("replace")(newItems.asInstanceOf[js.Any]).asInstanceOf[js.Array[Any]]
    
    inline def reverse(): js.Array[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("reverse")().asInstanceOf[js.Array[Any]]
    
    inline def shift(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("shift")().asInstanceOf[Any]
    
    inline def sort(): js.Array[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("sort")().asInstanceOf[js.Array[Any]]
    
    inline def splice(index: Double, deleteCount: Double, newItems: Any*): js.Array[Any] = (^.asInstanceOf[js.Dynamic].applyDynamic("splice")((scala.List(index.asInstanceOf[js.Any], deleteCount.asInstanceOf[js.Any])).`++`(newItems.asInstanceOf[Seq[js.Any]])*)).asInstanceOf[js.Array[Any]]
    inline def splice(index: Double, deleteCount: Unit, newItems: Any*): js.Array[Any] = (^.asInstanceOf[js.Dynamic].applyDynamic("splice")((scala.List(index.asInstanceOf[js.Any], deleteCount.asInstanceOf[js.Any])).`++`(newItems.asInstanceOf[Seq[js.Any]])*)).asInstanceOf[js.Array[Any]]
    
    inline def spliceWithArray(index: Double): js.Array[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("spliceWithArray")(index.asInstanceOf[js.Any]).asInstanceOf[js.Array[Any]]
    inline def spliceWithArray(index: Double, deleteCount: Double): js.Array[Any] = (^.asInstanceOf[js.Dynamic].applyDynamic("spliceWithArray")(index.asInstanceOf[js.Any], deleteCount.asInstanceOf[js.Any])).asInstanceOf[js.Array[Any]]
    inline def spliceWithArray(index: Double, deleteCount: Double, newItems: js.Array[Any]): js.Array[Any] = (^.asInstanceOf[js.Dynamic].applyDynamic("spliceWithArray")(index.asInstanceOf[js.Any], deleteCount.asInstanceOf[js.Any], newItems.asInstanceOf[js.Any])).asInstanceOf[js.Array[Any]]
    inline def spliceWithArray(index: Double, deleteCount: Unit, newItems: js.Array[Any]): js.Array[Any] = (^.asInstanceOf[js.Dynamic].applyDynamic("spliceWithArray")(index.asInstanceOf[js.Any], deleteCount.asInstanceOf[js.Any], newItems.asInstanceOf[js.Any])).asInstanceOf[js.Array[Any]]
    
    inline def toJSON(): js.Array[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("toJSON")().asInstanceOf[js.Array[Any]]
    
    inline def unshift(items: Any*): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("unshift")(items.asInstanceOf[Seq[js.Any]]*).asInstanceOf[Double]
  }
  
  inline def asCreateObservableOptions(thing: Any): CreateObservableOptions = ^.asInstanceOf[js.Dynamic].applyDynamic("asCreateObservableOptions")(thing.asInstanceOf[js.Any]).asInstanceOf[CreateObservableOptions]
  
  inline def asDynamicObservableObject(target: Any): IIsObservableObject = ^.asInstanceOf[js.Dynamic].applyDynamic("asDynamicObservableObject")(target.asInstanceOf[js.Any]).asInstanceOf[IIsObservableObject]
  inline def asDynamicObservableObject(target: Any, options: CreateObservableOptions): IIsObservableObject = (^.asInstanceOf[js.Dynamic].applyDynamic("asDynamicObservableObject")(target.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[IIsObservableObject]
  
  inline def asObservableObject(target: Any): IIsObservableObject = ^.asInstanceOf[js.Dynamic].applyDynamic("asObservableObject")(target.asInstanceOf[js.Any]).asInstanceOf[IIsObservableObject]
  inline def asObservableObject(target: Any, options: CreateObservableOptions): IIsObservableObject = (^.asInstanceOf[js.Dynamic].applyDynamic("asObservableObject")(target.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[IIsObservableObject]
  
  inline def assertProxies(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("assertProxies")().asInstanceOf[Unit]
  
  inline def assign(target: js.Object, sources: Any*): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("assign")(scala.List(target.asInstanceOf[js.Any]).`++`(sources.asInstanceOf[Seq[js.Any]])*).asInstanceOf[Any]
  inline def assign[T, U](target: T, source: U): T & U = (^.asInstanceOf[js.Dynamic].applyDynamic("assign")(target.asInstanceOf[js.Any], source.asInstanceOf[js.Any])).asInstanceOf[T & U]
  inline def assign[T_1, U_1, V](target: T_1, source1: U_1, source2: V): T_1 & U_1 & V = (^.asInstanceOf[js.Dynamic].applyDynamic("assign")(target.asInstanceOf[js.Any], source1.asInstanceOf[js.Any], source2.asInstanceOf[js.Any])).asInstanceOf[T_1 & U_1 & V]
  inline def assign[T_2, U_2, V_1, W](target: T_2, source1: U_2, source2: V_1, source3: W): T_2 & U_2 & V_1 & W = (^.asInstanceOf[js.Dynamic].applyDynamic("assign")(target.asInstanceOf[js.Any], source1.asInstanceOf[js.Any], source2.asInstanceOf[js.Any], source3.asInstanceOf[js.Any])).asInstanceOf[T_2 & U_2 & V_1 & W]
  
  @JSImport("mobx/dist/internal", "autoAction")
  @js.native
  val autoAction: IActionFactory = js.native
  
  @JSImport("mobx/dist/internal", "autoAnnotation")
  @js.native
  val autoAnnotation: Annotation = js.native
  
  inline def autorun(view: js.Function1[/* r */ IReactionPublic, Any]): IReactionDisposer = ^.asInstanceOf[js.Dynamic].applyDynamic("autorun")(view.asInstanceOf[js.Any]).asInstanceOf[IReactionDisposer]
  inline def autorun(view: js.Function1[/* r */ IReactionPublic, Any], opts: IAutorunOptions): IReactionDisposer = (^.asInstanceOf[js.Dynamic].applyDynamic("autorun")(view.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[IReactionDisposer]
  
  inline def changeDependenciesStateTo0(derivation: IDerivation): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("changeDependenciesStateTo0")(derivation.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def checkIfStateModificationsAreAllowed(atom: IAtom): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("checkIfStateModificationsAreAllowed")(atom.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def checkIfStateReadsAreAllowed(observable: IObservable): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("checkIfStateReadsAreAllowed")(observable.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def clearObserving(derivation: IDerivation): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("clearObserving")(derivation.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def collectStoredAnnotations(target: Any): AnnotationsMap[Any, Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("collectStoredAnnotations")(target.asInstanceOf[js.Any]).asInstanceOf[AnnotationsMap[Any, Any]]
  
  object comparer {
    
    @JSImport("mobx/dist/internal", "comparer")
    @js.native
    val ^ : js.Any = js.native
    
    @JSImport("mobx/dist/internal", "comparer.default")
    @js.native
    def default: js.Function2[/* a */ Any, /* b */ Any, Boolean] = js.native
    inline def default(a: Any, b: Any): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("default")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    inline def default_=(x: js.Function2[/* a */ Any, /* b */ Any, Boolean]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("default")(x.asInstanceOf[js.Any])
    
    @JSImport("mobx/dist/internal", "comparer.identity")
    @js.native
    def identity: js.Function2[/* a */ Any, /* b */ Any, Boolean] = js.native
    inline def identity(a: Any, b: Any): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("identity")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    inline def identity_=(x: js.Function2[/* a */ Any, /* b */ Any, Boolean]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("identity")(x.asInstanceOf[js.Any])
    
    @JSImport("mobx/dist/internal", "comparer.shallow")
    @js.native
    def shallow: js.Function2[/* a */ Any, /* b */ Any, Boolean] = js.native
    inline def shallow(a: Any, b: Any): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("shallow")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    inline def shallow_=(x: js.Function2[/* a */ Any, /* b */ Any, Boolean]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("shallow")(x.asInstanceOf[js.Any])
    
    @JSImport("mobx/dist/internal", "comparer.structural")
    @js.native
    def structural: js.Function2[/* a */ Any, /* b */ Any, Boolean] = js.native
    inline def structural(a: Any, b: Any): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("structural")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
    inline def structural_=(x: js.Function2[/* a */ Any, /* b */ Any, Boolean]): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("structural")(x.asInstanceOf[js.Any])
  }
  
  @JSImport("mobx/dist/internal", "computed")
  @js.native
  val computed: IComputedFactory = js.native
  
  inline def configure(options: ComputedRequiresReaction): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("configure")(options.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def createAction(actionName: String, fn: js.Function): js.Function = (^.asInstanceOf[js.Dynamic].applyDynamic("createAction")(actionName.asInstanceOf[js.Any], fn.asInstanceOf[js.Any])).asInstanceOf[js.Function]
  inline def createAction(actionName: String, fn: js.Function, autoAction: Boolean): js.Function = (^.asInstanceOf[js.Dynamic].applyDynamic("createAction")(actionName.asInstanceOf[js.Any], fn.asInstanceOf[js.Any], autoAction.asInstanceOf[js.Any])).asInstanceOf[js.Function]
  inline def createAction(actionName: String, fn: js.Function, autoAction: Boolean, ref: js.Object): js.Function = (^.asInstanceOf[js.Dynamic].applyDynamic("createAction")(actionName.asInstanceOf[js.Any], fn.asInstanceOf[js.Any], autoAction.asInstanceOf[js.Any], ref.asInstanceOf[js.Any])).asInstanceOf[js.Function]
  inline def createAction(actionName: String, fn: js.Function, autoAction: Unit, ref: js.Object): js.Function = (^.asInstanceOf[js.Dynamic].applyDynamic("createAction")(actionName.asInstanceOf[js.Any], fn.asInstanceOf[js.Any], autoAction.asInstanceOf[js.Any], ref.asInstanceOf[js.Any])).asInstanceOf[js.Function]
  
  inline def createActionAnnotation(name: String): Annotation = ^.asInstanceOf[js.Dynamic].applyDynamic("createActionAnnotation")(name.asInstanceOf[js.Any]).asInstanceOf[Annotation]
  inline def createActionAnnotation(name: String, options: js.Object): Annotation = (^.asInstanceOf[js.Dynamic].applyDynamic("createActionAnnotation")(name.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[Annotation]
  
  inline def createActionDescriptor(
    adm: ObservableObjectAdministration,
    annotation: Annotation,
    key: PropertyKey,
    descriptor: js.PropertyDescriptor
  ): Configurable = (^.asInstanceOf[js.Dynamic].applyDynamic("createActionDescriptor")(adm.asInstanceOf[js.Any], annotation.asInstanceOf[js.Any], key.asInstanceOf[js.Any], descriptor.asInstanceOf[js.Any])).asInstanceOf[Configurable]
  inline def createActionDescriptor(
    adm: ObservableObjectAdministration,
    annotation: Annotation,
    key: PropertyKey,
    descriptor: js.PropertyDescriptor,
    safeDescriptors: Boolean
  ): Configurable = (^.asInstanceOf[js.Dynamic].applyDynamic("createActionDescriptor")(adm.asInstanceOf[js.Any], annotation.asInstanceOf[js.Any], key.asInstanceOf[js.Any], descriptor.asInstanceOf[js.Any], safeDescriptors.asInstanceOf[js.Any])).asInstanceOf[Configurable]
  
  inline def createAtom(name: String): IAtom = ^.asInstanceOf[js.Dynamic].applyDynamic("createAtom")(name.asInstanceOf[js.Any]).asInstanceOf[IAtom]
  inline def createAtom(name: String, onBecomeObservedHandler: js.Function0[Unit]): IAtom = (^.asInstanceOf[js.Dynamic].applyDynamic("createAtom")(name.asInstanceOf[js.Any], onBecomeObservedHandler.asInstanceOf[js.Any])).asInstanceOf[IAtom]
  inline def createAtom(
    name: String,
    onBecomeObservedHandler: js.Function0[Unit],
    onBecomeUnobservedHandler: js.Function0[Unit]
  ): IAtom = (^.asInstanceOf[js.Dynamic].applyDynamic("createAtom")(name.asInstanceOf[js.Any], onBecomeObservedHandler.asInstanceOf[js.Any], onBecomeUnobservedHandler.asInstanceOf[js.Any])).asInstanceOf[IAtom]
  inline def createAtom(name: String, onBecomeObservedHandler: Unit, onBecomeUnobservedHandler: js.Function0[Unit]): IAtom = (^.asInstanceOf[js.Dynamic].applyDynamic("createAtom")(name.asInstanceOf[js.Any], onBecomeObservedHandler.asInstanceOf[js.Any], onBecomeUnobservedHandler.asInstanceOf[js.Any])).asInstanceOf[IAtom]
  
  inline def createAutoAnnotation(): Annotation = ^.asInstanceOf[js.Dynamic].applyDynamic("createAutoAnnotation")().asInstanceOf[Annotation]
  inline def createAutoAnnotation(options: js.Object): Annotation = ^.asInstanceOf[js.Dynamic].applyDynamic("createAutoAnnotation")(options.asInstanceOf[js.Any]).asInstanceOf[Annotation]
  
  inline def createComputedAnnotation(name: String): Annotation = ^.asInstanceOf[js.Dynamic].applyDynamic("createComputedAnnotation")(name.asInstanceOf[js.Any]).asInstanceOf[Annotation]
  inline def createComputedAnnotation(name: String, options: js.Object): Annotation = (^.asInstanceOf[js.Dynamic].applyDynamic("createComputedAnnotation")(name.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[Annotation]
  
  inline def createDecoratorAnnotation(annotation: Annotation): PropertyDecorator & Annotation = ^.asInstanceOf[js.Dynamic].applyDynamic("createDecoratorAnnotation")(annotation.asInstanceOf[js.Any]).asInstanceOf[PropertyDecorator & Annotation]
  
  inline def createFlowAnnotation(name: String): Annotation = ^.asInstanceOf[js.Dynamic].applyDynamic("createFlowAnnotation")(name.asInstanceOf[js.Any]).asInstanceOf[Annotation]
  inline def createFlowAnnotation(name: String, options: js.Object): Annotation = (^.asInstanceOf[js.Dynamic].applyDynamic("createFlowAnnotation")(name.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[Annotation]
  
  inline def createInstanceofPredicate[T](name: String, theClass: Instantiable1[/* args (repeated) */ Any, T]): js.Function1[/* x */ Any, /* is T */ Boolean] = (^.asInstanceOf[js.Dynamic].applyDynamic("createInstanceofPredicate")(name.asInstanceOf[js.Any], theClass.asInstanceOf[js.Any])).asInstanceOf[js.Function1[/* x */ Any, /* is T */ Boolean]]
  
  inline def createLegacyArray[T](initialValues: js.Array[T], enhancer: IEnhancer[T]): IObservableArray[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("createLegacyArray")(initialValues.asInstanceOf[js.Any], enhancer.asInstanceOf[js.Any])).asInstanceOf[IObservableArray[T]]
  inline def createLegacyArray[T](initialValues: js.Array[T], enhancer: IEnhancer[T], name: String): IObservableArray[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("createLegacyArray")(initialValues.asInstanceOf[js.Any], enhancer.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[IObservableArray[T]]
  inline def createLegacyArray[T](initialValues: Unit, enhancer: IEnhancer[T]): IObservableArray[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("createLegacyArray")(initialValues.asInstanceOf[js.Any], enhancer.asInstanceOf[js.Any])).asInstanceOf[IObservableArray[T]]
  inline def createLegacyArray[T](initialValues: Unit, enhancer: IEnhancer[T], name: String): IObservableArray[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("createLegacyArray")(initialValues.asInstanceOf[js.Any], enhancer.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[IObservableArray[T]]
  
  inline def createObservableAnnotation(name: String): Annotation = ^.asInstanceOf[js.Dynamic].applyDynamic("createObservableAnnotation")(name.asInstanceOf[js.Any]).asInstanceOf[Annotation]
  inline def createObservableAnnotation(name: String, options: js.Object): Annotation = (^.asInstanceOf[js.Dynamic].applyDynamic("createObservableAnnotation")(name.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[Annotation]
  
  inline def createObservableArray[T](initialValues: js.Array[T], enhancer: IEnhancer[T]): IObservableArray[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("createObservableArray")(initialValues.asInstanceOf[js.Any], enhancer.asInstanceOf[js.Any])).asInstanceOf[IObservableArray[T]]
  inline def createObservableArray[T](initialValues: js.Array[T], enhancer: IEnhancer[T], name: String): IObservableArray[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("createObservableArray")(initialValues.asInstanceOf[js.Any], enhancer.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[IObservableArray[T]]
  inline def createObservableArray[T](initialValues: js.Array[T], enhancer: IEnhancer[T], name: String, owned: Boolean): IObservableArray[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("createObservableArray")(initialValues.asInstanceOf[js.Any], enhancer.asInstanceOf[js.Any], name.asInstanceOf[js.Any], owned.asInstanceOf[js.Any])).asInstanceOf[IObservableArray[T]]
  inline def createObservableArray[T](initialValues: js.Array[T], enhancer: IEnhancer[T], name: Unit, owned: Boolean): IObservableArray[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("createObservableArray")(initialValues.asInstanceOf[js.Any], enhancer.asInstanceOf[js.Any], name.asInstanceOf[js.Any], owned.asInstanceOf[js.Any])).asInstanceOf[IObservableArray[T]]
  inline def createObservableArray[T](initialValues: Unit, enhancer: IEnhancer[T]): IObservableArray[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("createObservableArray")(initialValues.asInstanceOf[js.Any], enhancer.asInstanceOf[js.Any])).asInstanceOf[IObservableArray[T]]
  inline def createObservableArray[T](initialValues: Unit, enhancer: IEnhancer[T], name: String): IObservableArray[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("createObservableArray")(initialValues.asInstanceOf[js.Any], enhancer.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[IObservableArray[T]]
  inline def createObservableArray[T](initialValues: Unit, enhancer: IEnhancer[T], name: String, owned: Boolean): IObservableArray[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("createObservableArray")(initialValues.asInstanceOf[js.Any], enhancer.asInstanceOf[js.Any], name.asInstanceOf[js.Any], owned.asInstanceOf[js.Any])).asInstanceOf[IObservableArray[T]]
  inline def createObservableArray[T](initialValues: Unit, enhancer: IEnhancer[T], name: Unit, owned: Boolean): IObservableArray[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("createObservableArray")(initialValues.asInstanceOf[js.Any], enhancer.asInstanceOf[js.Any], name.asInstanceOf[js.Any], owned.asInstanceOf[js.Any])).asInstanceOf[IObservableArray[T]]
  
  inline def deepEnhancer(v: Any, _underscore: Any, name: Any): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("deepEnhancer")(v.asInstanceOf[js.Any], _underscore.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[Any]
  
  inline def deepEqual(a: Any, b: Any): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("deepEqual")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  inline def deepEqual(a: Any, b: Any, depth: Double): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("deepEqual")(a.asInstanceOf[js.Any], b.asInstanceOf[js.Any], depth.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  
  @JSImport("mobx/dist/internal", "defaultCreateObservableOptions")
  @js.native
  val defaultCreateObservableOptions: CreateObservableOptions = js.native
  
  inline def defineProperty[T](o: T, p: PropertyKey, attributes: js.PropertyDescriptor & ThisType[Any]): T = (^.asInstanceOf[js.Dynamic].applyDynamic("defineProperty")(o.asInstanceOf[js.Any], p.asInstanceOf[js.Any], attributes.asInstanceOf[js.Any])).asInstanceOf[T]
  
  inline def die(
    error: /* keyof mobx.anon.0 */ `0` | `1` | `5` | `6` | `7` | `8` | `9` | `10` | `11` | `12` | `13` | `14` | `15` | `16` | `17` | `18` | `19` | `20` | `21` | `22` | `23` | `24` | `25` | `26` | `27` | `28` | `29` | `30` | `31` | `32` | `33` | `34` | `35` | `36` | `37` | `38` | `39`,
    args: Any*
  ): scala.Nothing = ^.asInstanceOf[js.Dynamic].applyDynamic("die")(scala.List(error.asInstanceOf[js.Any]).`++`(args.asInstanceOf[Seq[js.Any]])*).asInstanceOf[scala.Nothing]
  inline def die(error: String, args: Any*): scala.Nothing = ^.asInstanceOf[js.Dynamic].applyDynamic("die")(scala.List(error.asInstanceOf[js.Any]).`++`(args.asInstanceOf[Seq[js.Any]])*).asInstanceOf[scala.Nothing]
  
  inline def endAction(runInfo: IActionRunInfo): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("_endAction")(runInfo.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def endBatch(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("endBatch")().asInstanceOf[Unit]
  
  inline def entries[T](ar: IObservableArray[T]): js.Array[js.Tuple2[Double, T]] = ^.asInstanceOf[js.Dynamic].applyDynamic("entries")(ar.asInstanceOf[js.Any]).asInstanceOf[js.Array[js.Tuple2[Double, T]]]
  inline def entries[T](obj: T): js.Array[
    js.Tuple2[
      String, 
      /* import warning: importer.ImportType#apply Failed type conversion: T extends object ? T[keyof T] : any */ js.Any
    ]
  ] = ^.asInstanceOf[js.Dynamic].applyDynamic("entries")(obj.asInstanceOf[js.Any]).asInstanceOf[js.Array[
    js.Tuple2[
      String, 
      /* import warning: importer.ImportType#apply Failed type conversion: T extends object ? T[keyof T] : any */ js.Any
    ]
  ]]
  inline def entries[T](set: ObservableSet[T]): js.Array[js.Tuple2[T, T]] = ^.asInstanceOf[js.Dynamic].applyDynamic("entries")(set.asInstanceOf[js.Any]).asInstanceOf[js.Array[js.Tuple2[T, T]]]
  inline def entries[K, T](map: ObservableMap[K, T]): js.Array[js.Tuple2[K, T]] = ^.asInstanceOf[js.Dynamic].applyDynamic("entries")(map.asInstanceOf[js.Any]).asInstanceOf[js.Array[js.Tuple2[K, T]]]
  
  inline def executeAction(actionName: String, canRunAsDerivation: Boolean, fn: js.Function): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("executeAction")(actionName.asInstanceOf[js.Any], canRunAsDerivation.asInstanceOf[js.Any], fn.asInstanceOf[js.Any])).asInstanceOf[Any]
  inline def executeAction(actionName: String, canRunAsDerivation: Boolean, fn: js.Function, scope: Any): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("executeAction")(actionName.asInstanceOf[js.Any], canRunAsDerivation.asInstanceOf[js.Any], fn.asInstanceOf[js.Any], scope.asInstanceOf[js.Any])).asInstanceOf[Any]
  inline def executeAction(actionName: String, canRunAsDerivation: Boolean, fn: js.Function, scope: Any, args: IArguments): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("executeAction")(actionName.asInstanceOf[js.Any], canRunAsDerivation.asInstanceOf[js.Any], fn.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], args.asInstanceOf[js.Any])).asInstanceOf[Any]
  inline def executeAction(actionName: String, canRunAsDerivation: Boolean, fn: js.Function, scope: Unit, args: IArguments): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("executeAction")(actionName.asInstanceOf[js.Any], canRunAsDerivation.asInstanceOf[js.Any], fn.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], args.asInstanceOf[js.Any])).asInstanceOf[Any]
  
  inline def extendObservable[A /* <: js.Object */, B /* <: js.Object */](target: A, properties: B): A & B = (^.asInstanceOf[js.Dynamic].applyDynamic("extendObservable")(target.asInstanceOf[js.Any], properties.asInstanceOf[js.Any])).asInstanceOf[A & B]
  inline def extendObservable[A /* <: js.Object */, B /* <: js.Object */](target: A, properties: B, annotations: Unit, options: CreateObservableOptions): A & B = (^.asInstanceOf[js.Dynamic].applyDynamic("extendObservable")(target.asInstanceOf[js.Any], properties.asInstanceOf[js.Any], annotations.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[A & B]
  inline def extendObservable[A /* <: js.Object */, B /* <: js.Object */](target: A, properties: B, annotations: AnnotationsMap[B, scala.Nothing]): A & B = (^.asInstanceOf[js.Dynamic].applyDynamic("extendObservable")(target.asInstanceOf[js.Any], properties.asInstanceOf[js.Any], annotations.asInstanceOf[js.Any])).asInstanceOf[A & B]
  inline def extendObservable[A /* <: js.Object */, B /* <: js.Object */](
    target: A,
    properties: B,
    annotations: AnnotationsMap[B, scala.Nothing],
    options: CreateObservableOptions
  ): A & B = (^.asInstanceOf[js.Dynamic].applyDynamic("extendObservable")(target.asInstanceOf[js.Any], properties.asInstanceOf[js.Any], annotations.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[A & B]
  
  @JSImport("mobx/dist/internal", "flow")
  @js.native
  val flow: Flow_ = js.native
  
  inline def flowResult[T](result: T): /* import warning: importer.ImportType#apply Failed type conversion: T extends std.Generator<any, infer R, any> ? mobx.mobx/dist/api/flow.CancellablePromise<R> : T extends mobx.mobx/dist/api/flow.CancellablePromise<any> ? T : never */ js.Any = ^.asInstanceOf[js.Dynamic].applyDynamic("flowResult")(result.asInstanceOf[js.Any]).asInstanceOf[/* import warning: importer.ImportType#apply Failed type conversion: T extends std.Generator<any, infer R, any> ? mobx.mobx/dist/api/flow.CancellablePromise<R> : T extends mobx.mobx/dist/api/flow.CancellablePromise<any> ? T : never */ js.Any]
  
  inline def get[T /* <: js.Object */](obj: T, key: String): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("get")(obj.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[Any]
  inline def get[T](obj: IObservableArray[T], index: Double): js.UndefOr[T] = (^.asInstanceOf[js.Dynamic].applyDynamic("get")(obj.asInstanceOf[js.Any], index.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[T]]
  inline def get[K, V](obj: ObservableMap[K, V], key: K): js.UndefOr[V] = (^.asInstanceOf[js.Dynamic].applyDynamic("get")(obj.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[V]]
  
  inline def getAdministration(thing: Any): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getAdministration")(thing.asInstanceOf[js.Any]).asInstanceOf[Any]
  inline def getAdministration(thing: Any, property: String): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("getAdministration")(thing.asInstanceOf[js.Any], property.asInstanceOf[js.Any])).asInstanceOf[Any]
  
  inline def getAnnotationFromOptions(): js.UndefOr[Annotation] = ^.asInstanceOf[js.Dynamic].applyDynamic("getAnnotationFromOptions")().asInstanceOf[js.UndefOr[Annotation]]
  inline def getAnnotationFromOptions(options: CreateObservableOptions): js.UndefOr[Annotation] = ^.asInstanceOf[js.Dynamic].applyDynamic("getAnnotationFromOptions")(options.asInstanceOf[js.Any]).asInstanceOf[js.UndefOr[Annotation]]
  
  inline def getAtom(thing: Any): IDepTreeNode = ^.asInstanceOf[js.Dynamic].applyDynamic("getAtom")(thing.asInstanceOf[js.Any]).asInstanceOf[IDepTreeNode]
  inline def getAtom(thing: Any, property: PropertyKey): IDepTreeNode = (^.asInstanceOf[js.Dynamic].applyDynamic("getAtom")(thing.asInstanceOf[js.Any], property.asInstanceOf[js.Any])).asInstanceOf[IDepTreeNode]
  
  inline def getDebugName(thing: Any): String = ^.asInstanceOf[js.Dynamic].applyDynamic("getDebugName")(thing.asInstanceOf[js.Any]).asInstanceOf[String]
  inline def getDebugName(thing: Any, property: String): String = (^.asInstanceOf[js.Dynamic].applyDynamic("getDebugName")(thing.asInstanceOf[js.Any], property.asInstanceOf[js.Any])).asInstanceOf[String]
  
  inline def getDependencyTree(thing: Any): IDependencyTree = ^.asInstanceOf[js.Dynamic].applyDynamic("getDependencyTree")(thing.asInstanceOf[js.Any]).asInstanceOf[IDependencyTree]
  inline def getDependencyTree(thing: Any, property: String): IDependencyTree = (^.asInstanceOf[js.Dynamic].applyDynamic("getDependencyTree")(thing.asInstanceOf[js.Any], property.asInstanceOf[js.Any])).asInstanceOf[IDependencyTree]
  
  inline def getDescriptor(o: Any, p: PropertyKey): js.UndefOr[js.PropertyDescriptor] = (^.asInstanceOf[js.Dynamic].applyDynamic("getDescriptor")(o.asInstanceOf[js.Any], p.asInstanceOf[js.Any])).asInstanceOf[js.UndefOr[js.PropertyDescriptor]]
  
  inline def getEnhancerFromAnnotation(): IEnhancer[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("getEnhancerFromAnnotation")().asInstanceOf[IEnhancer[Any]]
  inline def getEnhancerFromAnnotation(annotation: Annotation): IEnhancer[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("getEnhancerFromAnnotation")(annotation.asInstanceOf[js.Any]).asInstanceOf[IEnhancer[Any]]
  
  inline def getEnhancerFromOptions(options: CreateObservableOptions): IEnhancer[Any] = ^.asInstanceOf[js.Dynamic].applyDynamic("getEnhancerFromOptions")(options.asInstanceOf[js.Any]).asInstanceOf[IEnhancer[Any]]
  
  inline def getGlobal(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getGlobal")().asInstanceOf[Any]
  
  inline def getGlobalState(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("getGlobalState")().asInstanceOf[Any]
  
  inline def getNextId(): Double = ^.asInstanceOf[js.Dynamic].applyDynamic("getNextId")().asInstanceOf[Double]
  
  inline def getObserverTree(thing: Any): IObserverTree = ^.asInstanceOf[js.Dynamic].applyDynamic("getObserverTree")(thing.asInstanceOf[js.Any]).asInstanceOf[IObserverTree]
  inline def getObserverTree(thing: Any, property: String): IObserverTree = (^.asInstanceOf[js.Dynamic].applyDynamic("getObserverTree")(thing.asInstanceOf[js.Any], property.asInstanceOf[js.Any])).asInstanceOf[IObserverTree]
  
  inline def getObservers(observable: IObservable): Set[IDerivation] = ^.asInstanceOf[js.Dynamic].applyDynamic("getObservers")(observable.asInstanceOf[js.Any]).asInstanceOf[Set[IDerivation]]
  
  inline def getOwnPropertyDescriptors[T](o: T): (/* import warning: importer.ImportType#apply Failed type conversion: {[ P in keyof T ]: std.TypedPropertyDescriptor<T[P]>} */ js.Any) & StringDictionary[js.PropertyDescriptor] = ^.asInstanceOf[js.Dynamic].applyDynamic("getOwnPropertyDescriptors")(o.asInstanceOf[js.Any]).asInstanceOf[(/* import warning: importer.ImportType#apply Failed type conversion: {[ P in keyof T ]: std.TypedPropertyDescriptor<T[P]>} */ js.Any) & StringDictionary[js.PropertyDescriptor]]
  
  inline def getPlainObjectKeys(`object`: Any): js.Array[String | js.Symbol] = ^.asInstanceOf[js.Dynamic].applyDynamic("getPlainObjectKeys")(`object`.asInstanceOf[js.Any]).asInstanceOf[js.Array[String | js.Symbol]]
  
  @JSImport("mobx/dist/internal", "globalState")
  @js.native
  def globalState: typings.mobx.distCoreGlobalstateMod.MobXGlobals = js.native
  inline def globalState_=(x: typings.mobx.distCoreGlobalstateMod.MobXGlobals): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("globalState")(x.asInstanceOf[js.Any])
  
  inline def has[T /* <: js.Object */](obj: T, key: String): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("has")(obj.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  inline def has[K](obj: ObservableMap[K, Any], key: K): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("has")(obj.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  inline def has[T](obj: ObservableSet[T], key: T): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("has")(obj.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  inline def has[T](obj: IObservableArray[T], index: Double): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("has")(obj.asInstanceOf[js.Any], index.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  
  inline def hasInterceptors(interceptable: IInterceptable[Any]): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("hasInterceptors")(interceptable.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def hasListeners(listenable: IListenable): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("hasListeners")(listenable.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def hasObservers(observable: IObservable): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("hasObservers")(observable.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def hasProp(target: js.Object, prop: PropertyKey): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("hasProp")(target.asInstanceOf[js.Any], prop.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  
  inline def intercept(`object`: js.Object, handler: IInterceptor[IObjectWillChange[Any]]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("intercept")(`object`.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def intercept[T](observableArray: js.Array[T], handler: IInterceptor[IArrayWillChange[T] | IArrayWillSplice[T]]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("intercept")(observableArray.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def intercept[T](
    observableArray: IObservableArray[T],
    handler: IInterceptor[IArrayWillChange[T] | IArrayWillSplice[T]]
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("intercept")(observableArray.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def intercept[V](observableSet: ObservableSet[V], handler: IInterceptor[ISetWillChange[V]]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("intercept")(observableSet.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def intercept[V](observableSet: Set[V], handler: IInterceptor[ISetWillChange[V]]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("intercept")(observableSet.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def intercept[T](value: IObservableValue[T], handler: IInterceptor[IValueWillChange[T]]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("intercept")(value.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def intercept[T /* <: js.Object */, K /* <: /* keyof T */ String */](
    `object`: T,
    property: K,
    handler: IInterceptor[
      IValueWillChange[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ]
    ]
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("intercept")(`object`.asInstanceOf[js.Any], property.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def intercept[K, V](observableMap: ObservableMap[K, V], handler: IInterceptor[IMapWillChange[K, V]]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("intercept")(observableMap.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def intercept[K, V](observableMap: ObservableMap[K, V], property: K, handler: IInterceptor[IValueWillChange[V]]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("intercept")(observableMap.asInstanceOf[js.Any], property.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def intercept[K, V](observableMap: Map[K, V], handler: IInterceptor[IMapWillChange[K, V]]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("intercept")(observableMap.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def intercept[K, V](observableMap: Map[K, V], property: K, handler: IInterceptor[IValueWillChange[V]]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("intercept")(observableMap.asInstanceOf[js.Any], property.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  
  inline def interceptChange[T](interceptable: IInterceptable[T | Null]): T | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("interceptChange")(interceptable.asInstanceOf[js.Any]).asInstanceOf[T | Null]
  inline def interceptChange[T](interceptable: IInterceptable[T | Null], change: T): T | Null = (^.asInstanceOf[js.Dynamic].applyDynamic("interceptChange")(interceptable.asInstanceOf[js.Any], change.asInstanceOf[js.Any])).asInstanceOf[T | Null]
  
  inline def interceptReads(`object`: js.Object, property: String, handler: ReadInterceptor[Any]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("interceptReads")(`object`.asInstanceOf[js.Any], property.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def interceptReads[T](observableArray: IObservableArray[T], handler: ReadInterceptor[T]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("interceptReads")(observableArray.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def interceptReads[V](observableSet: ObservableSet[V], handler: ReadInterceptor[V]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("interceptReads")(observableSet.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def interceptReads[T](value: IObservableValue[T], handler: ReadInterceptor[T]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("interceptReads")(value.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def interceptReads[K, V](observableMap: ObservableMap[K, V], handler: ReadInterceptor[V]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("interceptReads")(observableMap.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  
  inline def isAction(thing: Any): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isAction")(thing.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isAnnotation(thing: Any): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isAnnotation")(thing.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isAnnotationMapEntry(thing: Any): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isAnnotationMapEntry")(thing.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isAtom(x: Any): /* is mobx.mobx/dist/core/atom.Atom */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isAtom")(x.asInstanceOf[js.Any]).asInstanceOf[/* is mobx.mobx/dist/core/atom.Atom */ Boolean]
  
  inline def isCaughtException(e: Any): /* is mobx.mobx/dist/core/derivation.CaughtException */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isCaughtException")(e.asInstanceOf[js.Any]).asInstanceOf[/* is mobx.mobx/dist/core/derivation.CaughtException */ Boolean]
  
  inline def isComputed(value: Any): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isComputed")(value.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isComputedProp(value: Any, propName: PropertyKey): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("isComputedProp")(value.asInstanceOf[js.Any], propName.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  
  inline def isComputedValue(x: Any): /* is mobx.mobx/dist/core/computedvalue.ComputedValue<unknown> */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isComputedValue")(x.asInstanceOf[js.Any]).asInstanceOf[/* is mobx.mobx/dist/core/computedvalue.ComputedValue<unknown> */ Boolean]
  
  inline def isComputingDerivation(): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isComputingDerivation")().asInstanceOf[Boolean]
  
  inline def isES6Map(thing: Any): /* is std.Map<any, any> */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isES6Map")(thing.asInstanceOf[js.Any]).asInstanceOf[/* is std.Map<any, any> */ Boolean]
  
  inline def isES6Set(thing: Any): /* is std.Set<any> */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isES6Set")(thing.asInstanceOf[js.Any]).asInstanceOf[/* is std.Set<any> */ Boolean]
  
  inline def isFlow(fn: Any): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isFlow")(fn.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isFlowCancellationError(error: js.Error): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isFlowCancellationError")(error.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isFunction(fn: Any): /* is std.Function */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isFunction")(fn.asInstanceOf[js.Any]).asInstanceOf[/* is std.Function */ Boolean]
  
  inline def isGenerator(obj: Any): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isGenerator")(obj.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isObject(value: Any): /* is std.Object */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isObject")(value.asInstanceOf[js.Any]).asInstanceOf[/* is std.Object */ Boolean]
  
  inline def isObservable(value: Any): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isObservable")(value.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isObservableArray(thing: Any): /* is mobx.mobx/dist/types/observablearray.IObservableArray<any> */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isObservableArray")(thing.asInstanceOf[js.Any]).asInstanceOf[/* is mobx.mobx/dist/types/observablearray.IObservableArray<any> */ Boolean]
  
  @JSImport("mobx/dist/internal", "isObservableMap")
  @js.native
  def isObservableMap: js.Function1[
    /* thing */ Any, 
    /* is mobx.mobx/dist/types/observablemap.ObservableMap<any, any> */ Boolean
  ] = js.native
  inline def isObservableMap_=(
    x: js.Function1[
      /* thing */ Any, 
      /* is mobx.mobx/dist/types/observablemap.ObservableMap<any, any> */ Boolean
    ]
  ): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("isObservableMap")(x.asInstanceOf[js.Any])
  
  inline def isObservableObject(thing: Any): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isObservableObject")(thing.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isObservableProp(value: Any, propName: PropertyKey): Boolean = (^.asInstanceOf[js.Dynamic].applyDynamic("isObservableProp")(value.asInstanceOf[js.Any], propName.asInstanceOf[js.Any])).asInstanceOf[Boolean]
  
  @JSImport("mobx/dist/internal", "isObservableSet")
  @js.native
  def isObservableSet: js.Function1[
    /* thing */ Any, 
    /* is mobx.mobx/dist/types/observableset.ObservableSet<any> */ Boolean
  ] = js.native
  inline def isObservableSet_=(
    x: js.Function1[
      /* thing */ Any, 
      /* is mobx.mobx/dist/types/observableset.ObservableSet<any> */ Boolean
    ]
  ): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("isObservableSet")(x.asInstanceOf[js.Any])
  
  inline def isObservableValue(x: Any): /* is mobx.mobx/dist/types/observablevalue.IObservableValue<any> */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isObservableValue")(x.asInstanceOf[js.Any]).asInstanceOf[/* is mobx.mobx/dist/types/observablevalue.IObservableValue<any> */ Boolean]
  
  inline def isOverride(annotation: Annotation): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isOverride")(annotation.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isPlainObject(value: Any): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isPlainObject")(value.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isReaction(x: Any): /* is mobx.mobx/dist/core/reaction.Reaction */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isReaction")(x.asInstanceOf[js.Any]).asInstanceOf[/* is mobx.mobx/dist/core/reaction.Reaction */ Boolean]
  
  inline def isSpyEnabled(): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isSpyEnabled")().asInstanceOf[Boolean]
  
  inline def isString(value: Any): /* is string */ Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isString")(value.asInstanceOf[js.Any]).asInstanceOf[/* is string */ Boolean]
  
  inline def isStringish(value: Any): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("isStringish")(value.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def isolateGlobalState(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("isolateGlobalState")().asInstanceOf[Unit]
  
  inline def keys[T](ar: IObservableArray[T]): js.Array[Double] = ^.asInstanceOf[js.Dynamic].applyDynamic("keys")(ar.asInstanceOf[js.Any]).asInstanceOf[js.Array[Double]]
  inline def keys[K](map: ObservableMap[K, Any]): js.Array[K] = ^.asInstanceOf[js.Dynamic].applyDynamic("keys")(map.asInstanceOf[js.Any]).asInstanceOf[js.Array[K]]
  inline def keys[T /* <: js.Object */](obj: T): js.Array[PropertyKey] = ^.asInstanceOf[js.Dynamic].applyDynamic("keys")(obj.asInstanceOf[js.Any]).asInstanceOf[js.Array[PropertyKey]]
  inline def keys[T](set: ObservableSet[T]): js.Array[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("keys")(set.asInstanceOf[js.Any]).asInstanceOf[js.Array[T]]
  
  inline def makeAutoObservable[T /* <: js.Object */, AdditionalKeys /* <: PropertyKey */](target: T): T = ^.asInstanceOf[js.Dynamic].applyDynamic("makeAutoObservable")(target.asInstanceOf[js.Any]).asInstanceOf[T]
  inline def makeAutoObservable[T /* <: js.Object */, AdditionalKeys /* <: PropertyKey */](target: T, overrides: Unit, options: CreateObservableOptions): T = (^.asInstanceOf[js.Dynamic].applyDynamic("makeAutoObservable")(target.asInstanceOf[js.Any], overrides.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[T]
  inline def makeAutoObservable[T /* <: js.Object */, AdditionalKeys /* <: PropertyKey */](target: T, overrides: AnnotationsMap[T, NoInfer[AdditionalKeys]]): T = (^.asInstanceOf[js.Dynamic].applyDynamic("makeAutoObservable")(target.asInstanceOf[js.Any], overrides.asInstanceOf[js.Any])).asInstanceOf[T]
  inline def makeAutoObservable[T /* <: js.Object */, AdditionalKeys /* <: PropertyKey */](target: T, overrides: AnnotationsMap[T, NoInfer[AdditionalKeys]], options: CreateObservableOptions): T = (^.asInstanceOf[js.Dynamic].applyDynamic("makeAutoObservable")(target.asInstanceOf[js.Any], overrides.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[T]
  
  inline def makeIterable[T](iterator: js.Iterator[T]): IterableIterator[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("makeIterable")(iterator.asInstanceOf[js.Any]).asInstanceOf[IterableIterator[T]]
  
  inline def makeObservable[T /* <: js.Object */, AdditionalKeys /* <: PropertyKey */](target: T): T = ^.asInstanceOf[js.Dynamic].applyDynamic("makeObservable")(target.asInstanceOf[js.Any]).asInstanceOf[T]
  inline def makeObservable[T /* <: js.Object */, AdditionalKeys /* <: PropertyKey */](target: T, annotations: Unit, options: CreateObservableOptions): T = (^.asInstanceOf[js.Dynamic].applyDynamic("makeObservable")(target.asInstanceOf[js.Any], annotations.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[T]
  inline def makeObservable[T /* <: js.Object */, AdditionalKeys /* <: PropertyKey */](target: T, annotations: AnnotationsMap[T, NoInfer[AdditionalKeys]]): T = (^.asInstanceOf[js.Dynamic].applyDynamic("makeObservable")(target.asInstanceOf[js.Any], annotations.asInstanceOf[js.Any])).asInstanceOf[T]
  inline def makeObservable[T /* <: js.Object */, AdditionalKeys /* <: PropertyKey */](
    target: T,
    annotations: AnnotationsMap[T, NoInfer[AdditionalKeys]],
    options: CreateObservableOptions
  ): T = (^.asInstanceOf[js.Dynamic].applyDynamic("makeObservable")(target.asInstanceOf[js.Any], annotations.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[T]
  
  @JSImport("mobx/dist/internal", "$mobx")
  @js.native
  val mobx: js.Symbol = js.native
  
  inline def noop(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("noop")().asInstanceOf[Unit]
  
  inline def notifyListeners[T](listenable: IListenable, change: T): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("notifyListeners")(listenable.asInstanceOf[js.Any], change.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  @JSImport("mobx/dist/internal", "objectPrototype")
  @js.native
  val objectPrototype: js.Object = js.native
  
  @JSImport("mobx/dist/internal", "observable")
  @js.native
  def observable: IObservableFactory = js.native
  inline def observable_=(x: IObservableFactory): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("observable")(x.asInstanceOf[js.Any])
  
  inline def observe(`object`: js.Object, listener: js.Function1[/* change */ IObjectDidChange[Any], Unit]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(`object`.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe(
    `object`: js.Object,
    listener: js.Function1[/* change */ IObjectDidChange[Any], Unit],
    fireImmediately: Boolean
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(`object`.asInstanceOf[js.Any], listener.asInstanceOf[js.Any], fireImmediately.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[T](observableArray: js.Array[T], listener: js.Function1[/* change */ IArrayDidChange[T], Unit]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableArray.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[T](
    observableArray: js.Array[T],
    listener: js.Function1[/* change */ IArrayDidChange[T], Unit],
    fireImmediately: Boolean
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableArray.asInstanceOf[js.Any], listener.asInstanceOf[js.Any], fireImmediately.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[T](
    observableArray: IObservableArray[T],
    listener: js.Function1[/* change */ IArrayDidChange[T], Unit]
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableArray.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[T](
    observableArray: IObservableArray[T],
    listener: js.Function1[/* change */ IArrayDidChange[T], Unit],
    fireImmediately: Boolean
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableArray.asInstanceOf[js.Any], listener.asInstanceOf[js.Any], fireImmediately.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[V](observableSet: ObservableSet[V], listener: js.Function1[/* change */ ISetDidChange[V], Unit]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableSet.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[V](
    observableSet: ObservableSet[V],
    listener: js.Function1[/* change */ ISetDidChange[V], Unit],
    fireImmediately: Boolean
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableSet.asInstanceOf[js.Any], listener.asInstanceOf[js.Any], fireImmediately.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[V](observableSet: Set[V], listener: js.Function1[/* change */ ISetDidChange[V], Unit]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableSet.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[V](
    observableSet: Set[V],
    listener: js.Function1[/* change */ ISetDidChange[V], Unit],
    fireImmediately: Boolean
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableSet.asInstanceOf[js.Any], listener.asInstanceOf[js.Any], fireImmediately.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[T](value: IComputedValue[T], listener: js.Function1[/* change */ IValueDidChange[T], Unit]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[T](
    value: IComputedValue[T],
    listener: js.Function1[/* change */ IValueDidChange[T], Unit],
    fireImmediately: Boolean
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any], fireImmediately.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[T](value: IObservableValue[T], listener: js.Function1[/* change */ IValueDidChange[T], Unit]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[T](
    value: IObservableValue[T],
    listener: js.Function1[/* change */ IValueDidChange[T], Unit],
    fireImmediately: Boolean
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any], fireImmediately.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[T, K /* <: /* keyof T */ String */](
    `object`: T,
    property: K,
    listener: js.Function1[
      /* change */ IValueDidChange[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ], 
      Unit
    ]
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(`object`.asInstanceOf[js.Any], property.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[T, K /* <: /* keyof T */ String */](
    `object`: T,
    property: K,
    listener: js.Function1[
      /* change */ IValueDidChange[
        /* import warning: importer.ImportType#apply Failed type conversion: T[K] */ js.Any
      ], 
      Unit
    ],
    fireImmediately: Boolean
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(`object`.asInstanceOf[js.Any], property.asInstanceOf[js.Any], listener.asInstanceOf[js.Any], fireImmediately.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[K, V](observableMap: ObservableMap[K, V], listener: js.Function1[/* change */ IMapDidChange[K, V], Unit]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableMap.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[K, V](
    observableMap: ObservableMap[K, V],
    listener: js.Function1[/* change */ IMapDidChange[K, V], Unit],
    fireImmediately: Boolean
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableMap.asInstanceOf[js.Any], listener.asInstanceOf[js.Any], fireImmediately.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[K, V](
    observableMap: ObservableMap[K, V],
    property: K,
    listener: js.Function1[/* change */ IValueDidChange[V], Unit]
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableMap.asInstanceOf[js.Any], property.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[K, V](
    observableMap: ObservableMap[K, V],
    property: K,
    listener: js.Function1[/* change */ IValueDidChange[V], Unit],
    fireImmediately: Boolean
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableMap.asInstanceOf[js.Any], property.asInstanceOf[js.Any], listener.asInstanceOf[js.Any], fireImmediately.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[K, V](observableMap: Map[K, V], listener: js.Function1[/* change */ IMapDidChange[K, V], Unit]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableMap.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[K, V](
    observableMap: Map[K, V],
    listener: js.Function1[/* change */ IMapDidChange[K, V], Unit],
    fireImmediately: Boolean
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableMap.asInstanceOf[js.Any], listener.asInstanceOf[js.Any], fireImmediately.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[K, V](
    observableMap: Map[K, V],
    property: K,
    listener: js.Function1[/* change */ IValueDidChange[V], Unit]
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableMap.asInstanceOf[js.Any], property.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def observe[K, V](
    observableMap: Map[K, V],
    property: K,
    listener: js.Function1[/* change */ IValueDidChange[V], Unit],
    fireImmediately: Boolean
  ): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("observe")(observableMap.asInstanceOf[js.Any], property.asInstanceOf[js.Any], listener.asInstanceOf[js.Any], fireImmediately.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  
  inline def onBecomeObserved(value: IComputedValue[Any], listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeObserved")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeObserved(value: IObservable, listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeObserved")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeObserved(value: ObservableMap[Any, Any], listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeObserved")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeObserved(value: ObservableSet[Any], listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeObserved")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeObserved(value: IObservableArray[Any], listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeObserved")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeObserved(value: IObservableValue[Any], listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeObserved")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeObserved[K, V](value: js.Object, property: K, listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeObserved")(value.asInstanceOf[js.Any], property.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeObserved[K, V](value: ObservableMap[K, V], property: K, listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeObserved")(value.asInstanceOf[js.Any], property.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  
  inline def onBecomeUnobserved(value: IComputedValue[Any], listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeUnobserved")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeUnobserved(value: IObservable, listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeUnobserved")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeUnobserved(value: ObservableMap[Any, Any], listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeUnobserved")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeUnobserved(value: ObservableSet[Any], listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeUnobserved")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeUnobserved(value: IObservableArray[Any], listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeUnobserved")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeUnobserved(value: IObservableValue[Any], listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeUnobserved")(value.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeUnobserved[K, V](value: js.Object, property: K, listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeUnobserved")(value.asInstanceOf[js.Any], property.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  inline def onBecomeUnobserved[K, V](value: ObservableMap[K, V], property: K, listener: Lambda): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("onBecomeUnobserved")(value.asInstanceOf[js.Any], property.asInstanceOf[js.Any], listener.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  
  inline def onReactionError(handler: js.Function2[/* error */ Any, /* derivation */ IDerivation, Unit]): Lambda = ^.asInstanceOf[js.Dynamic].applyDynamic("onReactionError")(handler.asInstanceOf[js.Any]).asInstanceOf[Lambda]
  
  inline def once(func: Lambda): Lambda = ^.asInstanceOf[js.Dynamic].applyDynamic("once")(func.asInstanceOf[js.Any]).asInstanceOf[Lambda]
  
  @JSImport("mobx/dist/internal", "override")
  @js.native
  val `override`: Annotation & PropertyDecorator = js.native
  
  inline def ownKeys(target: Any): js.Array[String | js.Symbol] = ^.asInstanceOf[js.Dynamic].applyDynamic("ownKeys")(target.asInstanceOf[js.Any]).asInstanceOf[js.Array[String | js.Symbol]]
  
  inline def propagateChangeConfirmed(observable: IObservable): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("propagateChangeConfirmed")(observable.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def propagateChanged(observable: IObservable): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("propagateChanged")(observable.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def propagateMaybeChanged(observable: IObservable): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("propagateMaybeChanged")(observable.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def queueForUnobservation(observable: IObservable): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("queueForUnobservation")(observable.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def reaction_true[T, FireImmediately /* <: Boolean */](
    expression: js.Function1[/* r */ IReactionPublic, T],
    effect: js.Function3[
      /* arg */ T, 
      /* import warning: importer.ImportType#apply Failed type conversion: FireImmediately extends true ? T | undefined : T */ /* prev */ js.Any, 
      /* r */ IReactionPublic, 
      Unit
    ]
  ): IReactionDisposer = (^.asInstanceOf[js.Dynamic].applyDynamic("reaction")(expression.asInstanceOf[js.Any], effect.asInstanceOf[js.Any])).asInstanceOf[IReactionDisposer]
  inline def reaction_true[T, FireImmediately /* <: Boolean */](
    expression: js.Function1[/* r */ IReactionPublic, T],
    effect: js.Function3[
      /* arg */ T, 
      /* import warning: importer.ImportType#apply Failed type conversion: FireImmediately extends true ? T | undefined : T */ /* prev */ js.Any, 
      /* r */ IReactionPublic, 
      Unit
    ],
    opts: IReactionOptions[T, FireImmediately]
  ): IReactionDisposer = (^.asInstanceOf[js.Dynamic].applyDynamic("reaction")(expression.asInstanceOf[js.Any], effect.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[IReactionDisposer]
  
  inline def recordAnnotationApplied(
    adm: typings.mobx.distTypesObservableobjectMod.ObservableObjectAdministration,
    annotation: Annotation,
    key: PropertyKey
  ): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("recordAnnotationApplied")(adm.asInstanceOf[js.Any], annotation.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def refStructEnhancer(v: Any, oldValue: Any): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("refStructEnhancer")(v.asInstanceOf[js.Any], oldValue.asInstanceOf[js.Any])).asInstanceOf[Any]
  
  inline def referenceEnhancer(): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("referenceEnhancer")().asInstanceOf[Any]
  inline def referenceEnhancer(newValue: Any): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("referenceEnhancer")(newValue.asInstanceOf[js.Any]).asInstanceOf[Any]
  
  inline def registerInterceptor[T](interceptable: IInterceptable[T], handler: IInterceptor[T]): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("registerInterceptor")(interceptable.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  
  inline def registerListener(listenable: IListenable, handler: js.Function): Lambda = (^.asInstanceOf[js.Dynamic].applyDynamic("registerListener")(listenable.asInstanceOf[js.Any], handler.asInstanceOf[js.Any])).asInstanceOf[Lambda]
  
  inline def remove[T /* <: js.Object */](obj: T, key: String): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("remove")(obj.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[Any]
  inline def remove[T](obj: ObservableSet[T], key: T): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("remove")(obj.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[Any]
  inline def remove[T](obj: IObservableArray[T], index: Double): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("remove")(obj.asInstanceOf[js.Any], index.asInstanceOf[js.Any])).asInstanceOf[Any]
  inline def remove[K, V](obj: ObservableMap[K, V], key: K): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("remove")(obj.asInstanceOf[js.Any], key.asInstanceOf[js.Any])).asInstanceOf[Any]
  
  inline def removeObserver(observable: IObservable, node: IDerivation): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("removeObserver")(observable.asInstanceOf[js.Any], node.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def reportObserved(observable: IObservable): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("reportObserved")(observable.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def reserveArrayBuffer(max: Double): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("reserveArrayBuffer")(max.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def resetGlobalState(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("resetGlobalState")().asInstanceOf[Unit]
  
  inline def runInAction[T](fn: js.Function0[T]): T = ^.asInstanceOf[js.Dynamic].applyDynamic("runInAction")(fn.asInstanceOf[js.Any]).asInstanceOf[T]
  
  inline def runReactions(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("runReactions")().asInstanceOf[Unit]
  
  inline def set[T /* <: js.Object */](obj: T, key: PropertyKey, value: Any): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("set")(obj.asInstanceOf[js.Any], key.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[Any]
  inline def set[T /* <: js.Object */](obj: T, values: StringDictionary[Any]): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("set")(obj.asInstanceOf[js.Any], values.asInstanceOf[js.Any])).asInstanceOf[Any]
  inline def set[V](obj: ObservableMap[PropertyKey, V], values: StringDictionary[V]): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("set")(obj.asInstanceOf[js.Any], values.asInstanceOf[js.Any])).asInstanceOf[Any]
  inline def set[T](obj: ObservableSet[T], value: T): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("set")(obj.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[Any]
  inline def set[T](obj: IObservableArray[T], index: Double, value: T): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("set")(obj.asInstanceOf[js.Any], index.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[Any]
  inline def set[K, V](obj: ObservableMap[K, V], key: K, value: V): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("set")(obj.asInstanceOf[js.Any], key.asInstanceOf[js.Any], value.asInstanceOf[js.Any])).asInstanceOf[Any]
  
  inline def setReactionScheduler(fn: js.Function1[/* f */ js.Function0[Unit], Unit]): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("setReactionScheduler")(fn.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def shallowEnhancer(v: Any, _underscore: Any, name: Any): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("shallowEnhancer")(v.asInstanceOf[js.Any], _underscore.asInstanceOf[js.Any], name.asInstanceOf[js.Any])).asInstanceOf[Any]
  
  inline def shouldCompute(derivation: IDerivation): Boolean = ^.asInstanceOf[js.Dynamic].applyDynamic("shouldCompute")(derivation.asInstanceOf[js.Any]).asInstanceOf[Boolean]
  
  inline def spy(listener: js.Function1[/* change */ SpyEvent, Unit]): Lambda = ^.asInstanceOf[js.Dynamic].applyDynamic("spy")(listener.asInstanceOf[js.Any]).asInstanceOf[Lambda]
  
  inline def spyReport(event: SpyEvent): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("spyReport")(event.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def spyReportEnd(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("spyReportEnd")().asInstanceOf[Unit]
  inline def spyReportEnd(change: Time): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("spyReportEnd")(change.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def spyReportStart(event: PureSpyEvent): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("spyReportStart")(event.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def startAction(actionName: String, canRunAsDerivation: Boolean, // true for autoAction
  scope: Any): IActionRunInfo = (^.asInstanceOf[js.Dynamic].applyDynamic("_startAction")(actionName.asInstanceOf[js.Any], canRunAsDerivation.asInstanceOf[js.Any], scope.asInstanceOf[js.Any])).asInstanceOf[IActionRunInfo]
  inline def startAction(
    actionName: String,
    canRunAsDerivation: Boolean,
    // true for autoAction
  scope: Any,
    args: IArguments
  ): IActionRunInfo = (^.asInstanceOf[js.Dynamic].applyDynamic("_startAction")(actionName.asInstanceOf[js.Any], canRunAsDerivation.asInstanceOf[js.Any], scope.asInstanceOf[js.Any], args.asInstanceOf[js.Any])).asInstanceOf[IActionRunInfo]
  
  inline def startBatch(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("startBatch")().asInstanceOf[Unit]
  
  inline def storeAnnotation(prototype: Any, key: PropertyKey, annotation: Annotation): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("storeAnnotation")(prototype.asInstanceOf[js.Any], key.asInstanceOf[js.Any], annotation.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  @JSImport("mobx/dist/internal", "storedAnnotationsSymbol")
  @js.native
  val storedAnnotationsSymbol: js.Symbol = js.native
  
  inline def stringifyKey(key: Any): String = ^.asInstanceOf[js.Dynamic].applyDynamic("stringifyKey")(key.asInstanceOf[js.Any]).asInstanceOf[String]
  
  inline def toJS[T](source: T): T = ^.asInstanceOf[js.Dynamic].applyDynamic("toJS")(source.asInstanceOf[js.Any]).asInstanceOf[T]
  inline def toJS[T](source: T, options: Any): T = (^.asInstanceOf[js.Dynamic].applyDynamic("toJS")(source.asInstanceOf[js.Any], options.asInstanceOf[js.Any])).asInstanceOf[T]
  
  inline def toPrimitive(value: Any): Any = ^.asInstanceOf[js.Dynamic].applyDynamic("toPrimitive")(value.asInstanceOf[js.Any]).asInstanceOf[Any]
  
  inline def trace(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("trace")().asInstanceOf[Unit]
  inline def trace(enterBreakPoint: Boolean): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("trace")(enterBreakPoint.asInstanceOf[js.Any]).asInstanceOf[Unit]
  inline def trace(thing: Any): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("trace")(thing.asInstanceOf[js.Any]).asInstanceOf[Unit]
  inline def trace(thing: Any, enterBreakPoint: Boolean): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("trace")(thing.asInstanceOf[js.Any], enterBreakPoint.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def trace(thing: Any, prop: String): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("trace")(thing.asInstanceOf[js.Any], prop.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def trace(thing: Any, prop: String, enterBreakPoint: Boolean): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("trace")(thing.asInstanceOf[js.Any], prop.asInstanceOf[js.Any], enterBreakPoint.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def trace(thing: Any, prop: Unit, enterBreakPoint: Boolean): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("trace")(thing.asInstanceOf[js.Any], prop.asInstanceOf[js.Any], enterBreakPoint.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def trace(thing: Unit, enterBreakPoint: Boolean): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("trace")(thing.asInstanceOf[js.Any], enterBreakPoint.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def trace(thing: Unit, prop: String): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("trace")(thing.asInstanceOf[js.Any], prop.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def trace(thing: Unit, prop: String, enterBreakPoint: Boolean): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("trace")(thing.asInstanceOf[js.Any], prop.asInstanceOf[js.Any], enterBreakPoint.asInstanceOf[js.Any])).asInstanceOf[Unit]
  inline def trace(thing: Unit, prop: Unit, enterBreakPoint: Boolean): Unit = (^.asInstanceOf[js.Dynamic].applyDynamic("trace")(thing.asInstanceOf[js.Any], prop.asInstanceOf[js.Any], enterBreakPoint.asInstanceOf[js.Any])).asInstanceOf[Unit]
  
  inline def trackDerivedFunction[T](derivation: IDerivation, f: js.Function0[T], context: Any): Any = (^.asInstanceOf[js.Dynamic].applyDynamic("trackDerivedFunction")(derivation.asInstanceOf[js.Any], f.asInstanceOf[js.Any], context.asInstanceOf[js.Any])).asInstanceOf[Any]
  
  inline def transaction[T](action: js.Function0[T], thisArg: Unit): T = (^.asInstanceOf[js.Dynamic].applyDynamic("transaction")(action.asInstanceOf[js.Any], thisArg.asInstanceOf[js.Any])).asInstanceOf[T]
  
  inline def untracked[T](action: js.Function0[T]): T = ^.asInstanceOf[js.Dynamic].applyDynamic("untracked")(action.asInstanceOf[js.Any]).asInstanceOf[T]
  
  inline def untrackedEnd(): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("untrackedEnd")().asInstanceOf[Unit]
  inline def untrackedEnd(prev: IDerivation): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("untrackedEnd")(prev.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def untrackedStart(): IDerivation | Null = ^.asInstanceOf[js.Dynamic].applyDynamic("untrackedStart")().asInstanceOf[IDerivation | Null]
  
  inline def values[T](ar: IObservableArray[T]): js.Array[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("values")(ar.asInstanceOf[js.Any]).asInstanceOf[js.Array[T]]
  inline def values[T](obj: T): js.Array[
    /* import warning: importer.ImportType#apply Failed type conversion: T extends object ? T[keyof T] : any */ js.Any
  ] = ^.asInstanceOf[js.Dynamic].applyDynamic("values")(obj.asInstanceOf[js.Any]).asInstanceOf[js.Array[
    /* import warning: importer.ImportType#apply Failed type conversion: T extends object ? T[keyof T] : any */ js.Any
  ]]
  inline def values[T](set: ObservableSet[T]): js.Array[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("values")(set.asInstanceOf[js.Any]).asInstanceOf[js.Array[T]]
  inline def values[K, T](map: ObservableMap[K, T]): js.Array[T] = ^.asInstanceOf[js.Dynamic].applyDynamic("values")(map.asInstanceOf[js.Any]).asInstanceOf[js.Array[T]]
  
  inline def warnAboutProxyRequirement(msg: String): Unit = ^.asInstanceOf[js.Dynamic].applyDynamic("warnAboutProxyRequirement")(msg.asInstanceOf[js.Any]).asInstanceOf[Unit]
  
  inline def when(predicate: js.Function0[Boolean]): Promisevoidcancelvoid = ^.asInstanceOf[js.Dynamic].applyDynamic("when")(predicate.asInstanceOf[js.Any]).asInstanceOf[Promisevoidcancelvoid]
  inline def when(predicate: js.Function0[Boolean], effect: Lambda): IReactionDisposer = (^.asInstanceOf[js.Dynamic].applyDynamic("when")(predicate.asInstanceOf[js.Any], effect.asInstanceOf[js.Any])).asInstanceOf[IReactionDisposer]
  inline def when(predicate: js.Function0[Boolean], effect: Lambda, opts: IWhenOptions): IReactionDisposer = (^.asInstanceOf[js.Dynamic].applyDynamic("when")(predicate.asInstanceOf[js.Any], effect.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[IReactionDisposer]
  inline def when(predicate: js.Function0[Boolean], opts: IWhenOptions): Promisevoidcancelvoid = (^.asInstanceOf[js.Dynamic].applyDynamic("when")(predicate.asInstanceOf[js.Any], opts.asInstanceOf[js.Any])).asInstanceOf[Promisevoidcancelvoid]
}
