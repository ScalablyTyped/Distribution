package typings.telnetlib.mod

import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object constants {
  
  @JSImport("telnetlib", "constants")
  @js.native
  val ^ : js.Any = js.native
  
  @JSImport("telnetlib", "constants.commands")
  @js.native
  def commands: Commands = js.native
  inline def commands_=(x: Commands): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("commands")(x.asInstanceOf[js.Any])
  
  @JSImport("telnetlib", "constants.optionState")
  @js.native
  def optionState: OptionState = js.native
  inline def optionState_=(x: OptionState): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("optionState")(x.asInstanceOf[js.Any])
  
  @JSImport("telnetlib", "constants.q")
  @js.native
  def q: Q = js.native
  inline def q_=(x: Q): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("q")(x.asInstanceOf[js.Any])
  
  @JSImport("telnetlib", "constants.reason")
  @js.native
  def reason: Reason = js.native
  inline def reason_=(x: Reason): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("reason")(x.asInstanceOf[js.Any])
  
  @JSImport("telnetlib", "constants.state")
  @js.native
  def state: State = js.native
  inline def state_=(x: State): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("state")(x.asInstanceOf[js.Any])
  
  @JSImport("telnetlib", "constants.where")
  @js.native
  def where: Where = js.native
  inline def where_=(x: Where): Unit = ^.asInstanceOf[js.Dynamic].updateDynamic("where")(x.asInstanceOf[js.Any])
}
