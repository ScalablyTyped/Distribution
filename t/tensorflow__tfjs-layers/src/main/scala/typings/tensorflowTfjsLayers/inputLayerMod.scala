package typings.tensorflowTfjsLayers

import typings.tensorflowTfjsCore.distTypesMod.DataType
import typings.tensorflowTfjsLayers.kerasFormatCommonMod.Shape
import typings.tensorflowTfjsLayers.topologyMod.Layer
import typings.tensorflowTfjsLayers.topologyMod.SymbolicTensor
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object inputLayerMod {
  
  @JSImport("@tensorflow/tfjs-layers/dist/engine/input_layer", JSImport.Namespace)
  @js.native
  val ^ : js.Any = js.native
  
  inline def Input(config: InputConfig): SymbolicTensor = ^.asInstanceOf[js.Dynamic].applyDynamic("Input")(config.asInstanceOf[js.Any]).asInstanceOf[SymbolicTensor]
  
  @JSImport("@tensorflow/tfjs-layers/dist/engine/input_layer", "InputLayer")
  @js.native
  class InputLayer protected () extends Layer {
    def this(args: InputLayerArgs) = this()
    
    var sparse: Boolean = js.native
  }
  /* static members */
  object InputLayer {
    
    /** @nocollapse */
    @JSImport("@tensorflow/tfjs-layers/dist/engine/input_layer", "InputLayer.className")
    @js.native
    val className: /* "InputLayer" */ String = js.native
  }
  
  trait InputConfig extends StObject {
    
    /**
      * A shape tuple (integer), including the batch size. For instance,
      * `batchShape=[10, 32]` indicates that the expected input will be batches of
      * 10 32-dimensional vectors. `batchShape=[null, 32]` indicates batches of an
      * arbitrary number of 32-dimensional vectors.
      */
    var batchShape: js.UndefOr[Shape] = js.undefined
    
    var dtype: js.UndefOr[DataType] = js.undefined
    
    /**
      * An optional name string for the layer. Should be unique in a model (do not
      * reuse the same name twice). It will be autogenerated if it isn't provided.
      */
    var name: js.UndefOr[String] = js.undefined
    
    /**
      * A shape, not including the batch size. For instance, `shape=[32]`
      * indicates that the expected input will be batches of 32-dimensional
      * vectors.
      */
    var shape: js.UndefOr[Shape] = js.undefined
    
    /**
      * A boolean specifying whether the placeholder to be created is sparse.
      */
    var sparse: js.UndefOr[Boolean] = js.undefined
  }
  object InputConfig {
    
    inline def apply(): InputConfig = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[InputConfig]
    }
    
    extension [Self <: InputConfig](x: Self) {
      
      inline def setBatchShape(value: Shape): Self = StObject.set(x, "batchShape", value.asInstanceOf[js.Any])
      
      inline def setBatchShapeUndefined: Self = StObject.set(x, "batchShape", js.undefined)
      
      inline def setBatchShapeVarargs(value: (Null | Double)*): Self = StObject.set(x, "batchShape", js.Array(value :_*))
      
      inline def setDtype(value: DataType): Self = StObject.set(x, "dtype", value.asInstanceOf[js.Any])
      
      inline def setDtypeUndefined: Self = StObject.set(x, "dtype", js.undefined)
      
      inline def setName(value: String): Self = StObject.set(x, "name", value.asInstanceOf[js.Any])
      
      inline def setNameUndefined: Self = StObject.set(x, "name", js.undefined)
      
      inline def setShape(value: Shape): Self = StObject.set(x, "shape", value.asInstanceOf[js.Any])
      
      inline def setShapeUndefined: Self = StObject.set(x, "shape", js.undefined)
      
      inline def setShapeVarargs(value: (Null | Double)*): Self = StObject.set(x, "shape", js.Array(value :_*))
      
      inline def setSparse(value: Boolean): Self = StObject.set(x, "sparse", value.asInstanceOf[js.Any])
      
      inline def setSparseUndefined: Self = StObject.set(x, "sparse", js.undefined)
    }
  }
  
  trait InputLayerArgs extends StObject {
    
    /** Batch input shape, including the batch axis. */
    var batchInputShape: js.UndefOr[Shape] = js.undefined
    
    /** Optional input batch size (integer or null). */
    var batchSize: js.UndefOr[Double] = js.undefined
    
    /** Datatype of the input.  */
    var dtype: js.UndefOr[DataType] = js.undefined
    
    /** Input shape, not including the batch axis. */
    var inputShape: js.UndefOr[Shape] = js.undefined
    
    /** Name of the layer. */
    var name: js.UndefOr[String] = js.undefined
    
    /**
      * Whether the placeholder created is meant to be sparse.
      */
    var sparse: js.UndefOr[Boolean] = js.undefined
  }
  object InputLayerArgs {
    
    inline def apply(): InputLayerArgs = {
      val __obj = js.Dynamic.literal()
      __obj.asInstanceOf[InputLayerArgs]
    }
    
    extension [Self <: InputLayerArgs](x: Self) {
      
      inline def setBatchInputShape(value: Shape): Self = StObject.set(x, "batchInputShape", value.asInstanceOf[js.Any])
      
      inline def setBatchInputShapeUndefined: Self = StObject.set(x, "batchInputShape", js.undefined)
      
      inline def setBatchInputShapeVarargs(value: (Null | Double)*): Self = StObject.set(x, "batchInputShape", js.Array(value :_*))
      
      inline def setBatchSize(value: Double): Self = StObject.set(x, "batchSize", value.asInstanceOf[js.Any])
      
      inline def setBatchSizeUndefined: Self = StObject.set(x, "batchSize", js.undefined)
      
      inline def setDtype(value: DataType): Self = StObject.set(x, "dtype", value.asInstanceOf[js.Any])
      
      inline def setDtypeUndefined: Self = StObject.set(x, "dtype", js.undefined)
      
      inline def setInputShape(value: Shape): Self = StObject.set(x, "inputShape", value.asInstanceOf[js.Any])
      
      inline def setInputShapeUndefined: Self = StObject.set(x, "inputShape", js.undefined)
      
      inline def setInputShapeVarargs(value: (Null | Double)*): Self = StObject.set(x, "inputShape", js.Array(value :_*))
      
      inline def setName(value: String): Self = StObject.set(x, "name", value.asInstanceOf[js.Any])
      
      inline def setNameUndefined: Self = StObject.set(x, "name", js.undefined)
      
      inline def setSparse(value: Boolean): Self = StObject.set(x, "sparse", value.asInstanceOf[js.Any])
      
      inline def setSparseUndefined: Self = StObject.set(x, "sparse", js.undefined)
    }
  }
}
