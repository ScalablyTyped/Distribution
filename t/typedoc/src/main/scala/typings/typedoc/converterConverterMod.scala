package typings.typedoc

import typings.std.Record
import typings.typedoc.applicationMod.Application
import typings.typedoc.commentMod.CommentDisplayPart
import typings.typedoc.commentsMod.CommentParserConfig
import typings.typedoc.componentMod.ChildableComponent
import typings.typedoc.componentsMod.ConverterComponent
import typings.typedoc.contextMod.Context
import typings.typedoc.declarationReferenceMod.DeclarationReference
import typings.typedoc.entryPointMod.DocumentationEntryPoint
import typings.typedoc.libUtilsMod.MinimalSourceFile
import typings.typedoc.modelsMod.Comment
import typings.typedoc.modelsMod.ProjectReflection
import typings.typedoc.modelsMod.Reflection
import typings.typedoc.modelsTypesMod.SomeType
import typings.typedoc.optionsDeclarationMod.CommentStyle
import typings.typedoc.optionsDeclarationMod.ValidationOptions
import typings.typedoc.typedocStrings.begin
import typings.typedoc.typedocStrings.createDeclaration
import typings.typedoc.typedocStrings.createParameter
import typings.typedoc.typedocStrings.createSignature
import typings.typedoc.typedocStrings.createTypeParameter
import typings.typedoc.typedocStrings.end
import typings.typedoc.typedocStrings.resolveBegin
import typings.typedoc.typedocStrings.resolveEnd
import typings.typedoc.typedocStrings.resolveReflection
import typings.typescript.mod.Symbol
import typings.typescript.mod.Type
import typings.typescript.mod.TypeNode
import org.scalablytyped.runtime.StObject
import scala.scalajs.js
import scala.scalajs.js.annotation.{JSGlobalScope, JSGlobal, JSImport, JSName, JSBracketAccess}

object converterConverterMod {
  
  @JSImport("typedoc/dist/lib/converter/converter", "Converter")
  @js.native
  open class Converter protected () extends ChildableComponent[Application, ConverterComponent] {
    def this(owner: Application) = this()
    
    /* private */ var _buildCommentParserConfig: Any = js.native
    
    /* private */ var _config: Any = js.native
    
    /* private */ var _externalSymbolResolvers: Any = js.native
    
    /**
      * Adds a new resolver that the theme can use to try to figure out how to link to a symbol declared
      * by a third-party library which is not included in the documentation.
      *
      * The resolver function will be passed a declaration reference which it can attempt to resolve. If
      * resolution fails, the function should return undefined.
      *
      * Note: This will be used for both references to types declared in node_modules (in which case the
      * reference passed will have the `moduleSource` set and the `symbolReference` will navigate via `.`)
      * and user defined \{\@link\} tags which cannot be resolved.
      * @since 0.22.14
      */
    def addUnknownSymbolResolver(resolver: js.Function1[/* ref */ DeclarationReference, js.UndefOr[String]]): Unit = js.native
    
    /** @internal */
    var commentStyle: CommentStyle = js.native
    
    /**
      * Compile the files within the given context and convert the compiler symbols to reflections.
      *
      * @param context  The context object describing the current state the converter is in.
      * @returns An array containing all errors generated by the TypeScript compiler.
      */
    /* private */ var compile: Any = js.native
    
    def config: CommentParserConfig = js.native
    
    /**
      * Compile the given source files and create a project reflection for them.
      */
    def convert(entryPoints: js.Array[DocumentationEntryPoint]): ProjectReflection = js.native
    
    /* private */ var convertExports: Any = js.native
    
    /* private */ var convertReExports: Any = js.native
    
    /** @internal */
    def convertSymbol(context: Context, symbol: Symbol): Unit = js.native
    def convertSymbol(context: Context, symbol: Symbol, exportSymbol: Symbol): Unit = js.native
    
    /**
      * Convert the given TypeScript type into its TypeDoc type reflection.
      *
      * @param context  The context object describing the current state the converter is in.
      * @param referenceTarget The target to be used to attempt to resolve reference types
      * @returns The TypeDoc type reflection representing the given node and type.
      * @internal
      */
    def convertType(context: Context): SomeType = js.native
    def convertType(context: Context, node: Type): SomeType = js.native
    def convertType(context: Context, node: TypeNode): SomeType = js.native
    
    /* private */ var excludeCache: Any = js.native
    
    /** @internal */
    var excludeExternals: Boolean = js.native
    
    /** @internal */
    var excludeNotDocumented: Boolean = js.native
    
    /** @internal */
    var excludePrivate: Boolean = js.native
    
    /** @internal */
    var excludeProtected: Boolean = js.native
    
    /** @internal */
    var externalPattern: js.Array[String] = js.native
    
    /* private */ var externalPatternCache: Any = js.native
    
    /** @internal */
    var externalSymbolLinkMappings: Record[String, Record[String, String]] = js.native
    
    /* private */ var isExcluded: Any = js.native
    
    /** @internal */
    def isExternal(symbol: Symbol): Boolean = js.native
    
    /**
      * Parse the given file into a comment. Intended to be used with markdown files.
      */
    def parseRawComment(file: MinimalSourceFile): Comment = js.native
    
    /**
      * Resolve the project within the given context.
      *
      * @param context  The context object describing the current state the converter is in.
      * @returns The final project reflection.
      */
    /* private */ var resolve: Any = js.native
    
    /** @internal */
    def resolveExternalLink(ref: DeclarationReference): js.UndefOr[String] = js.native
    
    def resolveLinks(comment: Comment, owner: Reflection): Unit = js.native
    def resolveLinks(parts: js.Array[CommentDisplayPart], owner: Reflection): js.Array[CommentDisplayPart] = js.native
    
    /**
      * Used to determine if we should immediately bail when creating a reflection.
      * Note: This should not be used for excludeNotDocumented because we don't have enough
      * information at this point since comment discovery hasn't happened.
      * @internal
      */
    def shouldIgnore(symbol: Symbol): Boolean = js.native
    
    /** @internal */
    var validation: ValidationOptions = js.native
  }
  /* static members */
  object Converter {
    
    /**
      * General events
      */
    /**
      * Triggered when the converter begins converting a project.
      * The listener will be given a {@link Context} object.
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_BEGIN")
    @js.native
    val EVENT_BEGIN: begin = js.native
    
    /**
      * Factory events
      */
    /**
      * Triggered when the converter has created a declaration reflection.
      * The listener will be given {@link Context} and a {@link DeclarationReflection}.
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_CREATE_DECLARATION")
    @js.native
    val EVENT_CREATE_DECLARATION: createDeclaration = js.native
    
    /**
      * Triggered when the converter has created a parameter reflection.
      * The listener will be given {@link Context}, {@link ParameterReflection} and a `ts.Node?`
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_CREATE_PARAMETER")
    @js.native
    val EVENT_CREATE_PARAMETER: createParameter = js.native
    
    /**
      * Triggered when the converter has created a signature reflection.
      * The listener will be given {@link Context}, {@link SignatureReflection} | {@link ProjectReflection} and
      * `ts.SignatureDeclaration | ts.IndexSignatureDeclaration | ts.JSDocSignature | undefined`
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_CREATE_SIGNATURE")
    @js.native
    val EVENT_CREATE_SIGNATURE: createSignature = js.native
    
    /**
      * Triggered when the converter has created a type parameter reflection.
      * The listener will be given {@link Context} and a {@link TypeParameterReflection}
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_CREATE_TYPE_PARAMETER")
    @js.native
    val EVENT_CREATE_TYPE_PARAMETER: createTypeParameter = js.native
    
    /**
      * Triggered when the converter has finished converting a project.
      * The listener will be given a {@link Context} object.
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_END")
    @js.native
    val EVENT_END: end = js.native
    
    /**
      * Triggered when the converter resolves a reflection.
      * The listener will be given {@link Context} and a {@link Reflection}.
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_RESOLVE")
    @js.native
    val EVENT_RESOLVE: resolveReflection = js.native
    
    /**
      * Resolve events
      */
    /**
      * Triggered when the converter begins resolving a project.
      * The listener will be given {@link Context}.
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_RESOLVE_BEGIN")
    @js.native
    val EVENT_RESOLVE_BEGIN: resolveBegin = js.native
    
    /**
      * Triggered when the converter has finished resolving a project.
      * The listener will be given {@link Context}.
      * @event
      */
    @JSImport("typedoc/dist/lib/converter/converter", "Converter.EVENT_RESOLVE_END")
    @js.native
    val EVENT_RESOLVE_END: resolveEnd = js.native
  }
}
